<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
    <?dbhtml filename="macros/index.html" ?>
    <d:title>Preprocessing Directives</d:title>
    <d:para>The following comes from section 6.10 of specification. It will
    terminate when you see code starting. :-)</d:para>
    <d:para>A <d:emphasis role="italic">preprocessing directive</d:emphasis>
    consists of a sequence of preprocessing tokens that begins with a
    <d:code>#</d:code> preprocessing token that (at the start of translation
    phase 4) is either the first character in the source file (optionally after
    white space containing no new-line characters) or that follows white space
    containing at least one new-line character, and is ended by the next
    new-line character.<d:footnote><d:para>Thus, preprocessing directives are
    commonly called “lines”. These “lines” have no other syntactic
    significance, as all white space is equivalent except in certain situations
    during preprocessing (see the # character string literal creation operator
    in 12.3.2, for example).</d:para></d:footnote> A new-line character ends
    the preprocessing directive even if it occurs within what would otherwise
    be an invocation of a function-like macro.</d:para>
    <d:para>A text line shall not begin with a <d:code>#</d:code> preprocessing
    token. A non-directive shall not begin with any of the directive names
    appearing in the syntax.</d:para>
    <d:para>When in a group that is skipped (12.1), the directive syntax is
    relaxed to allow any sequence of preprocessing tokens to occur between the
    directive name and the following new-line character.</d:para>
    <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
    <d:para>The only white-space characters that shall appear between
    preprocessing tokens within a preprocessing directive (from just after the
    introducing # preprocessing token through just before the terminating
    new-line character) are space and horizontal-tab (including spaces that
    have replaced comments or possibly other white-space characters in
    translation phase 3).</d:para>
    <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
    <d:para>The implementation can process and skip sections of source files
    conditionally, include other source files, and replace macros. These
    capabilities are called preprocessing, because conceptually they occur
    before translation of the resulting translation unit.</d:para>
    <d:para>The preprocessing tokens within a preprocessing directive are not
    subject to macro expansion unless otherwise stated.</d:para>
    <d:para>EXAMPLE In:</d:para>
    <d:programlisting role="CLexer">#define EMPTY
EMPTY # include &lt;file.h></d:programlisting>
<d:para>the sequence of preprocessing tokens on the second line is not a
preprocessing directive, because it does not begin with a <d:code>#</d:code> at
the start of translation phase 4, even though it will do so after the macro
<d:code>EMPTY</d:code> has been replaced.</d:para>
<d:sect1>
  <d:title>Conditional Inclusion</d:title>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>The expression that controls conditional inclusion shall be an
  integer constant expression except that: it shall not contain a cast;
  identifiers (including those lexically identical to keywords) are interpreted
  as described below; <d:footnote><d:para>Because the controlling constant
  expression is evaluated during translation phase 4, all identifiers either
  are or are not macro names - there simply are no keywords, enumeration
  constants, etc.</d:para></d:footnote> and it may contain unary operator
  expressions of the form:</d:para>
  <d:screen>defined identifier</d:screen>
  <d:para>or:</d:para>
  <d:screen>defined (identifier)</d:screen>
  <d:para>which evaluate to 1 if the identifier is currently defined as a macro
  name (that is, if it is predefined or if it has been the subject of a
  <d:code>#define</d:code> preprocessing directive without an intervening
  <d:code>#undef</d:code> directive with the same subject identifier), 0 if it
  is not.</d:para>
  <d:para><d:emphasis role="bold">Sematics</d:emphasis></d:para>
  <d:para>Preprocessing directives of the forms:</d:para>
  <d:programlisting role="CLexer"># if constant-expression new-line group_opt
# elif constant-expression new-line group_opt</d:programlisting>
<d:para>check whether the controlling constant expression evaluates to
nonzero.</d:para>
<d:para>Prior to evaluation, macro invocations in the list of preprocessing
tokens that will become the controlling constant expression are replaced
(except for those macro names modified by the defined unary operator), just as
in normal text. If the token defined is generated as a result of this
replacement process or use of the defined unary operator does not match one of
the two specified forms prior to macro replacement, the behavior is
undefined. After all replacements due to macro expansion and the defined unary
operator have been performed, all remaining identifiers are replaced with the
pp-number 0, and then each preprocessing token is converted into a token. The
resulting tokens compose the controlling constant expression which is evaluated
according to the rules of constant expressions. For the purposes of this token
conversion and evaluation, all signed integer types and all unsigned integer
types act as if they hav e the same representation as, respectively, the types
<d:code>intmax_t</d:code> and <d:code>uintmax_t</d:code> defined in the header
<d:code>&lt;stdint.h></d:code>.<d:footnote><d:para>Thus, on an implementation
where <d:code>INT_MAX</d:code> is <d:code></d:code> and
<d:code>UINT_MAX</d:code> is <d:code>0xFFFF</d:code>, the constant
<d:code>0x8000</d:code> is signed and positive within a <d:code>#if</d:code>
expression even though it would be unsigned in translation phase
7.</d:para></d:footnote> This includes interpreting character constants, which
may involve converting escape sequences into execution character set
members. Whether the numeric value for these character constants matches the
value obtained when an identical character constant occurs in an expression
(other than within a <d:code>#if</d:code> or <d:code>#elif</d:code> directive)
is implementation-defined.<d:footnote><d:para>Thus, the constant expression in
the following <d:code>#if</d:code> directive and if statement is not guaranteed
to evaluate to the same value in these two contexts.
<d:programlisting role="CLexer">#if 'z' - 'a' == 25

if ('z' - 'a' == 25)</d:programlisting></d:para></d:footnote> Also, whether a
single-character character constant may have a negative value is
implementation-defined.</d:para>
<d:para>Preprocessing directives of the forms:</d:para>
<d:programlisting role="CLexer"># ifdef identifier new-line group_opt
# ifndef identifier new-line group_opt</d:programlisting>
<d:para>check whether the identifier is or is not currently defined as a macro
name. Their conditions are equivalent to <d:code>#if</d:code> defined
identifier and <d:code>#if !defined</d:code> identifier respectively.</d:para>
<d:para>Each directive’s condition is checked in order. If it evaluates to
false (zero), the group that it controls is skipped: directives are processed
only through the name that determines the directive in order to keep track of
the level of nested conditionals; the rest of the directives’ preprocessing
tokens are ignored, as are the other preprocessing tokens in the group. Only
the first group whose control condition evaluates to true (nonzero) is
processed. If none of the conditions evaluates to true, and there is a #else
directive, the group controlled by the #else is processed; lacking a #else
directive, all the groups until the #endif are skipped.<d:footnote><d:para>As
indicated by the syntax, a preprocessing token shall not follow a #else or
#endif directive before the terminating new-line character. However, comments
may appear anywhere in a source file, including within a preprocessing
directive.</d:para></d:footnote></d:para>
</d:sect1>
<d:sect1>
  <d:title>Source File Inclusion</d:title>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>A <d:code>#include</d:code> directive shall identify a header or
  source file that can be processed by the implementation.</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># include &lt;h-char-sequence>  new-line</d:programlisting>
  <d:para>searches a sequence of implementation-defined places for a header
  identified uniquely by the specified sequence between the &lt; and >
  delimiters, and causes the replacement of that directive by the entire
  contents of the header. How the places are specified or the header identified
  is implementation-defined.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
<d:programlisting role="CLexer"># include "q-char-sequence" new-line</d:programlisting>
<d:para>causes the replacement of that directive by the entire contents of the
source file identified by the specified sequence between the ” delimiters. The
named source file is searched for in an implementation-defined manner. If this
search is not supported, or if the search fails, the directive is reprocessed
as if it read:</d:para>
<d:programlisting role="CLexer"># include &lt;h-char-sequence> new-line</d:programlisting>
<d:para>with the identical contained sequence (including > characters, if any)
from the original directive.</d:para>
<d:para>A preprocessing directive of the form:</d:para>
<d:programlisting role="CLexer"># include pp-tokens new-line</d:programlisting>
<d:para>(that does not match one of the two previous forms) is permitted. The
preprocessing tokens after include in the directive are processed just as in
normal text. (Each identifier currently defined as a macro name is replaced by
its replacement list of preprocessing tokens.) The directive resulting after
all replacements shall match one of the two previous
forms.<d:footnote><d:para>Note that adjacent string literals are not
concatenated into a single string literal; thus, an expansion that results in
two string literals is an invalid directive.</d:para></d:footnote> The method
by which a sequence of preprocessing tokens between a &lt; and a >
preprocessing token pair or a pair of ” characters is combined into a single
header name preprocessing token is implementation-defined.</d:para> 
<d:para>The implementation shall provide unique mappings for sequences
consisting of one or more letters or digits followed by a period (.) and a
single letter. The first character shall be a letter. The implementation may
ignore the distinctions of alphabetical case and restrict the mapping to eight
significant characters before the period.</d:para>
<d:para>A <d:code>#include</d:code> preprocessing directive may appear in a
source file that has been read because of a <d:code>#include</d:code> directive
in another file, up to an implementation-defined nesting limit.</d:para>
<d:para><d:emphasis role="bold">Forward References</d:emphasis>: macro
replacement (12.3).</d:para>
</d:sect1>
<d:sect1>
  <d:title>Macro Replacement</d:title>
<d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>Two replacement lists are identical if and only if the preprocessing
  tokens in both have the same number, ordering, spelling, and white-space
  separation, where all white-space separations are considered
  identical.</d:para>
  <d:para>An identifier currently defined as an object-like macro shall not be
  redefined by another #define preprocessing directive unless the second
  definition is an object-like macro definition and the two replacement lists
  are identical. Likewise, an identifier currently defined as a function-like
  macro shall not be redefined by another <d:code>#define</d:code>
  preprocessing directive unless the second definition is a function-like macro
  definition that has the same number and spelling of parameters, and the two
  replacement lists are identical.</d:para>
  <d:para>There shall be white-space between the identifier and the replacement
  list in the definition of an object-like macro.</d:para>
  <d:para>If the identifier-list in the macro definition does not end with an
  ellipsis, the number of arguments (including those arguments consisting of no
  preprocessing tokens) in an invocation of a function-like macro shall equal
  the number of parameters in the macro definition. Otherwise, there shall be
  more arguments in the invocation than there are parameters in the macro
  definition (excluding the ...). There shall exist a ) preprocessing token
  that terminates the invocation.</d:para>
  <d:para>The identifier <d:code>__VA_ARGS__</d:code> shall occur only in the
  replacement-list of a function-like macro that uses the ellipsis notation in
  the parameters.</d:para>
  <d:para>A parameter identifier in a function-like macro shall be uniquely
  declared within its scope.</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>The identifier immediately following the define is called the macro
  name. There is one name space for macro names. Any white-space characters
  preceding or following the replacement list of preprocessing tokens are not
  considered part of the replacement list for either form of macro.</d:para>
  <d:para>If a <d:code>#</d:code> preprocessing token, followed by an
  identifier, occurs lexically at the point at which a preprocessing directive
  could begin, the identifier is not subject to macro replacement.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># define identifier replacement-list new-line</d:programlisting>
  <d:para>defines an object-like macro that causes each subsequent instance of
  the macro name<d:footnote><d:para>Since, by macro-replacement time, all
  character constants and string literals are preprocessing tokens, not
  sequences possibly containing identifier-like subsequences, they are never
  scanned for macro names or parameters.</d:para></d:footnote> to be replaced
  by the replacement list of preprocessing tokens that constitute the remainder
  of the directive.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># define identifier lparen identifier-listopt ) replacement-list new-line
# define identifier lparen ... ) replacement-list new-line
# define identifier lparen identifier-list , ... ) replacement-list new-line</d:programlisting>
<d:para>defines a function-like macro with arguments, similar syntactically to
a function call. The parameters are specified by the optional list of
identifiers, whose scope extends from their declaration in the identifier list
until the new-line character that terminates the <d:para>#define</d:para>
preprocessing directive. Each subsequent instance of the function-like macro
name followed by a ( as the next preprocessing token introduces the sequence of
preprocessing tokens that is replaced by the replacement list in the definition
(an invocation of the macro). The replaced sequence of preprocessing tokens is
terminated by the matching ) preprocessing token, skipping intervening matched
pairs of left and right parenthesis preprocessing tokens. Within the sequence
of preprocessing tokens making up an invocation of a function-like macro,
new-line is considered a normal white-space character.</d:para>
<d:para>The sequence of preprocessing tokens bounded by the outside-most
matching parentheses forms the list of arguments for the function-like
macro. The individual arguments within the list are separated by comma
preprocessing tokens, but comma preprocessing tokens between matching inner
parentheses do not separate arguments. If there are sequences of preprocessing
tokens within the list of arguments that would otherwise act as preprocessing
directives,<d:footnote><d:para>Despite the name, a non-directive is a
preprocessing directive.</d:para></d:footnote> the behavior is
undefined.</d:para>
<d:para>If there is a ... in the identifier-list in the macro definition, then
the trailing arguments, including any separating comma preprocessing tokens,
are merged to form a single item: the variable arguments. The number of
arguments combined is such that, following merger, the number of arguments is
one more than the number of parameters in the macro definition (excluding the
...).</d:para>
<d:sect2>
  <d:title>Argument Substitution</d:title>
  <d:para>After the arguments for the invocation of a function-like macro have
  been identified, argument substitution takes place. A parameter in the
  replacement list, unless preceded by a <d:code>#</d:code> or
  <d:code>##</d:code> preprocessing token or followed by a <d:code>##</d:code>
  preprocessing token (see below), is replaced by the corresponding argument
  after all macros contained therein have been expanded. Before being
  substituted, each argument’s preprocessing tokens are completely macro
  replaced as if they formed the rest of the preprocessing file; no other
  preprocessing tokens are available.</d:para>
  <d:para>An identifier <d:code>__VA_ARGS__</d:code> that occurs in the
  replacement list shall be treated as if it were a parameter, and the variable
  arguments shall form the preprocessing tokens used to replace it.</d:para>
</d:sect2>
<d:sect2>
  <d:title>The # operator</d:title>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>Each <d:code>#</d:code> preprocessing token in the replacement list
  for a function-like macro shall be followed by a parameter as the next
  preprocessing token in the replacement list.</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>If, in the replacement list, a parameter is immediately preceded by a
  <d:code>#</d:code> preprocessing token, both are replaced by a single
  character string literal preprocessing token that contains the spelling of
  the preprocessing token sequence for the corresponding argument. Each
  occurrence of white space between the argument's preprocessing tokens becomes
  a single space character in the character string literal. White space before
  the first preprocessing token and after the last preprocessing token
  composing the argument is deleted. Otherwise, the original spelling of each
  preprocessing token in the argument is retained in the character string
  literal, except for special handling for producing the spelling of string
  literals and character constants: a \ character is inserted before each " and
  \ character of a character constant or string literal (including the
  delimiting " characters), except that it is implementation-defined whether a
  \ character is inserted before the \ character beginning a universal
  character name. If the replacement that results is not a valid character
  string literal, the behavior is undefined. The character string literal
  corresponding to an empty argument is "". The order of evaluation of
  <d:code>#</d:code> and <d:code>##</d:code> operators is unspecified.</d:para>
</d:sect2>
</d:sect1>
</d:chapter>
