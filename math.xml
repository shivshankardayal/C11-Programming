<?xml version="1.0" encoding="UTF-8"?>
<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
    <?dbhtml filename="math/index.html" ?>
    <d:title>Mathematics &amp;lt;math.h></d:title>
    <d:para>The header <d:code>&amp;lt;math.h></d:code> declares two types and
    many mathematical functions and defines several macros. Most synopses
    specify a family of functions consisting of a principal function with one
    or more double parameters, a <d:code>double</d:code> return value, or both;
    and other functions with the same name but with <d:code>f</d:code> and
    <d:code>l</d:code> suffixes, which are corresponding functions with
    <d:code>float</d:code> and <d:code>long double</d:code> parameters, return
    values, or both.<d:footnote><d:para>Particularly on systems with wide
    expression evaluation, a <d:code>&amp;lt;math.h></d:code> function might
    pass arguments and return values in wider format than the synopsis
    prototype indicates.</d:para></d:footnote> Integer arithmetic functions and
    conversion functions are discussed later.</d:para>
    <d:para>The types</d:para>
    <d:blockquote>
      <d:para><d:code>float_t</d:code></d:para>
      <d:para><d:code>double_t</d:code></d:para>
    </d:blockquote>
    <d:para>are floating types at least as wide as <d:code>float</d:code> and
    <d:code>double</d:code>, respectively, and such that
    <d:code>double_t</d:code> is at least as wide as
    <d:code>float_t</d:code>. If <d:code>FLT_EVAL_METHOD</d:code> equals 0,
    <d:code>float_t</d:code> and <d:code>double_t</d:code> are
    <d:code>float</d:code> and <d:code>double</d:code>, respectively; if
    <d:code>FLT_EVAL_METHOD</d:code> equals 1, they are both
    <d:code>double</d:code>; if <d:code>FLT_EVAL_METHOD</d:code> equals 2, they
    are both <d:code>long double</d:code>; and for other values of
    <d:code>FLT_EVAL_METHOD</d:code>, they are otherwise
    implementation-defined.<d:footnote><d:para>The types
    <d:code>float_t</d:code> and <d:code>double_t</d:code> are intended to be
    the implementation's most efficient types at least as wide as
    <d:code>float</d:code> and <d:code>double</d:code>, respectively. For
    <d:code>FLT_EVAL_METHOD</d:code> equal 0, 1 or 2, the type
    <d:code>float_t</d:code> is the narrowest type used by the implementation
    to evaluate floating expressions.</d:para></d:footnote></d:para>
    <d:para>The macro</d:para>
    <d:blockquote><d:para>HUGE_VAL</d:para></d:blockquote>
    <d:para>expands to a positive <d:code>double</d:code> constant expression,
    not necessarily representable as a <d:code>float</d:code>. The
    macros</d:para>
    <d:blockquote>
      <d:para><d:code>HUGE_VALF</d:code></d:para>
      <d:para><d:code>HUGE_VALL</d:code></d:para>
    </d:blockquote>
    <d:para>are respectively <d:code>float</d:code> and <d:code>long
    double</d:code> analogs of
    <d:code>HUGE_VAL</d:code>.<d:footnote><d:para><d:code>HUGE_VAL,
    HUGE_VALF</d:code> and <d:code>HUGE_VALL</d:code> can be positive
    infinities in an implementation that supports
    infinities.</d:para></d:footnote></d:para>
    <d:para>The macro</d:para>
    <d:blockquote><d:para><d:code>INFINITY</d:code></d:para></d:blockquote>
    <d:para>expands to a constant expression of type <d:code>float</d:code>
    representing positive or unsigned infinity, if available; else to a
    positive constant of type <d:code>float</d:code> that overflows at
    translation time.<d:footnote><d:para>In this case, using
    <d:code>INFINITY</d:code> will violate the constraint in Constants and thus
    require a diagnostic.</d:para></d:footnote></d:para>
    <d:para>The macro</d:para>
    <d:blockquote><d:para><d:code>NAN</d:code></d:para></d:blockquote>
    <d:para>is defined if and only if the implementation supports quiet NaNs
    for the <d:code>float</d:code> type. It expands to a constant expression of
    type float representing a quiet NaN.</d:para>
    <d:para>The <d:emphasis role="italic">number classification
    macros</d:emphasis></d:para>
    <d:blockquote>
      <d:para><d:code>FP_INFINITE</d:code></d:para>
      <d:para><d:code>FP_NAN</d:code></d:para>
      <d:para><d:code>FP_NORMAL</d:code></d:para>
      <d:para><d:code>FP_SUBNORMAL</d:code></d:para>
      <d:para><d:code>FP_ZERO</d:code></d:para>
    </d:blockquote>
    <d:para>represent the mutually exclusive kinds of floating-point
    values. They expand to integer constant expressions with distinct
    values. Additional implementation-defined floatingpoint classifications,
    with macro definitions beginning with <d:code>FP_1</d:code> and an
    uppercase letter, may also be specified by the implementation.</d:para>
    <d:para>The macro</d:para>
    <d:blockquote><d:para>FP_FAST_FMA</d:para></d:blockquote>
    <d:para>is optionally defined. If defined, it indicates that the fma
    function generally executes about as fast as, or faster than, a multiply
    and an add of double operands.<d:footnote><d:para>Typically, the
    <d:code>FP_FAST_FMA</d:code> macro is defined if and only if the
    <d:code>fma</d:code> function is implemented directly with a hardware
    multiply-add instruction. Software implementations are expected to be
    substantially slower.</d:para></d:footnote> The macros</d:para>
    <d:blockquote>
      <d:para><d:code>FP_FAST_FMAF</d:code></d:para>
      <d:para><d:code>FP_FAST_FMAL</d:code></d:para>
    </d:blockquote>
    <d:para>are, respectively, <d:code>float</d:code> and <d:code>long
    double</d:code> analogs of <d:code>FP_FAST_FMA</d:code>. If defined, these
    macros expand to the integer constant 1.</d:para>
    <d:para>The macros</d:para>
    <d:blockquote><d:para><d:code>FP_ILOGB0</d:code></d:para>
    <d:para><d:code>FP_ILOGBNAN</d:code></d:para>
    </d:blockquote>
    <d:para>expand to integer constant expressions whose values are returned by
    <d:code>ilogb(x)</d:code> if <d:code>x</d:code> is zero or NaN,
    respectively. The value of <d:code>FP_ILOGB0</d:code> shall be either
    <d:code>INT_MIN</d:code> or <d:code>-INT_MAX</d:code>. The value of
    <d:code>FP_ILOGBNAN</d:code> shall be either <d:code>INT_MAX</d:code> or
    <d:code>INT_MIN</d:code>.</d:para>
    <d:para>The macros</d:para>
    <d:blockquote><d:para><d:code>MATH_ERRNO</d:code></d:para>
    <d:para><d:code>MATH_ERREXCEPT</d:code></d:para></d:blockquote>
    <d:para>expand to the integer constants 1 and 2, respectively; the
    macro</d:para>
    <d:blockquote><d:para><d:code>
    math_errhandling
    </d:code></d:para></d:blockquote>
    <d:para>expands to an expression that has type int and the value
    <d:code>MATH_ERRNO, MATH_ERREXCEPT</d:code> or the bitwise OR of both. The
    value of <d:code>math_errhandling</d:code> is constant for the duration of
    the program. It is unspecified whether <d:code>math_errhandling</d:code> is
    a macro or an identifier with external linkage. If a macro definition is
    suppressed or a program defines an identifier with the name
    <d:code>math_errhandling</d:code>, the behavior is undefined. If the
    expression math_errhandling &amp; <d:code>MATH_ERREXCEPT</d:code> can be
    nonzero, the implementation shall define the macros <d:code>FE_DIVBYZERO,
    FE_INVALID</d:code> and <d:code></d:code> in &amp;lt;fenv.h>.</d:para>
    <d:sect1>
      <d:title>Treatment of error conditions</d:title>
      <d:para>The behavior of each of the functions in &amp;lt;math.h> is
      specified for all representable values of its input arguments, except
      where stated otherwise. Each function shall execute as if it were a
      single operation without generating any externally visible exceptional
      conditions.</d:para>
      <d:para>For all functions, a domain error occurs if an input argument is
      outside the domain over which the mathematical function is defined. The
      description of each function lists any required domain errors; an
      implementation may define additional domain errors, provided that such
      errors are consistent with the mathematical definition of the
      function.<d:footnote><d:para>In an implementation that supports
      infinities, this allows an infinity as an argument to be a domain error
      if the mathematical domain of the function does not include the
      infinity.</d:para></d:footnote> On a domain error, the function returns
      an implementation-defined value; if the integer expression
      <d:code>math_errhandling &amp; MATH_ERRNO</d:code> is nonzero, the
      integer expression errno acquires the value <d:code>EDOM</d:code>; if the
      integer expression <d:code>math_errhandling &amp; MATH_ERREXCEPT</d:code>
      is nonzero, the "invalid" floating-point exception is raised.</d:para>
      <d:para>Similarly, a range error occurs if the mathematical result of the
      function cannot be represented in an object of the specified type, due to
      extreme magnitude.</d:para>
      <d:para>A floating result overflows if the magnitude of the mathematical
      result is finite but so large that the mathematical result cannot be
      represented without extraordinary roundoff error in an object of the
      specified type. If a floating result overflows and default rounding is in
      effect, or if the mathematical result is an exact infinity (for example
      <d:code>log(0.0)</d:code>), then the function returns the value of the
      macro <d:code>HUGE_VAL, HUGE_VALF</d:code> or <d:code>HUGE_VALL</d:code>
      according to the return type, with the same sign as the correct value of
      the function; if the integer expression <d:code>math_errhandling &amp;
      MATH_ERRNO</d:code> is nonzero, the integer expression errno acquires the
      value <d:code>ERANGE</d:code>; if the integer expression
      <d:code>math_errhandling &amp; MATH_ERREXCEPT</d:code> is nonzero, the
      "divide-by-zero" floating-point exception is raised if the mathematical
      result is an exact infinity and the "overflow" floating-point exception
      is raised otherwise.</d:para>
      <d:para>The result underflows if the magnitude of the mathematical result
      is so small that the mathematical result cannot be represented, without
      extraordinary roundoff error, in an object of the specified
      type.<d:footnote><d:para>The term underflow here is intended to encompass
      both "gradual underflow" as in IEC 60559 and also "flush-to-zero"
      underflow.</d:para></d:footnote> If the result underflows, the function
      returns an implementation-defined value whose magnitude is no greater
      than the smallest normalized positive number in the specified type; if
      the integer expression <d:code>math_errhandling &amp; MATH_ERRNO</d:code>
      is nonzero, whether errno acquires the value <d:code>ERANGE</d:code> is
      implementation-defined; if the integer expression
      <d:code>math_errhandling &amp; MATH_ERREXCEPT</d:code> is nonzero,
      whether the "underflow" floating-point exception is raised is
      implementation-defined.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>The FP_CONTRACT pragma</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;math.h>
#pragma STDC FP_CONTRACT on-off-switch</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>FP_CONTRACT</d:code> pragma can be used to allow (if the
state is "on") or disallow (if the state is "off") the implementation to
contract expressions (Expressions). Each pragma can occur either outside
external declarations or preceding all explicit declarations and statements
inside a compound statement. When outside external declarations, the pragma
takes effect from its occurrence until another <d:code>FP_CONTRACT</d:code>
pragma is encountered, or until the end of the translation unit. When inside a
compound statement, the pragma takes effect from its occurrence until another
<d:code>FP_CONTRACT</d:code> pragma is encountered (including within a nested
compound statement), or until the end of the compound statement; at the end of
a compound statement the state for the pragma is restored to its condition just
before the compound statement. If this pragma is used in any other context, the
behavior is undefined. The default state ("on" or "off") for the pragma is
implementation-defined.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>Classification macros</d:title>
      <d:para>In the synopses in this subclause, real-floating indicates that
      the argument shall be an expression of real floating type.</d:para>
      <d:sect2>
	<d:title>The fpclassify macro</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
int fpclassify(real-floating x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>fpclassify</d:code> macro classifies its argument value as
NaN, infinite, normal, subnormal, zero, or into another implementation-defined
category. First, an argument represented in a format wider than its semantic
type is converted to its semantic type. Then classification is based on the
type of the argument.<d:footnote><d:para>Since an expression can be evaluated
with more range and precision than its type has, it is important to know the
type that classification is based on. For example, a normal <d:code>long
double</d:code> value might become subnormal when converted to
<d:code>double</d:code>, and zero when converted to
<d:code>float</d:code>.</d:para></d:footnote></d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>fpclassify</d:code> macro returns the value of the number
classification macro appropriate to the value of its argument.</d:para>
<d:para>EXAMPLE The <d:code>fpclassify</d:code> macro might be implemented in
terms of ordinary functions as</d:para>
<d:programlisting role="CLexer">#define fpclassify(x) \
        ((sizeof (x) == sizeof (float)) ? _ _fpclassifyf(x) : \
        (sizeof (x) == sizeof (double)) ? _ _fpclassifyd(x) : \
        _ _fpclassifyl(x))</d:programlisting>
      </d:sect2>
      <d:sect2>
	<d:title>The isfinite macro</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
int isfinite(real-floating x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>isfinite</d:code> macro determines whether its argument has
a finite value (zero, subnormal, or normal, and not infinite or NaN). First, an
argument represented in a format wider than its semantic type is converted to
its semantic type. Then determination is based on the type of the
argument.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>isfinite</d:code> macro returns a nonzero value if and only
if its argument has a finite value.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The isinf macro</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
int isinf(real-floating x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>isinf</d:code> macro determines whether its argument value
is an infinity (positive or negative). First, an argument represented in a
format wider than its semantic type is converted to its semantic type. Then
determination is based on the type of the argument.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>isinf</d:code> macro returns a nonzero value if and only if
its argument has an infinite value.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The isnan macro</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
int isnan(real-floating x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>isnan</d:code> macro determines whether its argument value
is a NaN. First, an argument represented in a format wider than its semantic
type is converted to its semantic type. Then determination is based on the type
of the argument.<d:footnote><d:para>For the isnan macro, the type for
determination does not matter unless the implementation supports NaNs in the
evaluation type but not in the semantic type.</d:para></d:footnote></d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>isnan</d:code> macro returns a nonzero value if and only if
its argument has a NaN value.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The isnormal macro</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
int isnormal(real-floating x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>isnormal</d:code> macro determines whether its argument
value is normal (neither zero, subnormal, infinite, nor NaN). First, an
argument represented in a format wider than its semantic type is converted to
its semantic type. Then determination is based on the type of the
argument.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>isnormal</d:code> macro returns a nonzero value if and only
if its argument has a normal value.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The signbit macro</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
int signbit(real-floating x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>signbit</d:code> macro determines whether the sign of its
argument value is negative.<d:footnote><d:para>The <d:code>signbit</d:code>
macro reports the sign of all values, including infinities, zeros, and NaNs. If
zero is unsigned, it is treated as positive.</d:para></d:footnote></d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>signbit</d:code> macro returns a nonzero value if and only
if the sign of its argument value is negative.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Trigonometric functions</d:title>
      <d:sect2>
	<d:title>The acos functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double acos(double x);
float acosf(float x);
long double acosl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>acos</d:code> functions compute the principal value of the
arc cosine of <d:code>x</d:code>. A domain error occurs for arguments not in
the interval [-1, +1].</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The acos functions return arccos x in the interval
[<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mn>0</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>] radians.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The asin functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double asin(double x);
float asinf(float x);
long double asinl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>asin</d:code> functions compute the principal value of the
arc sine of <d:code>x</d:code>. A domain error occurs for arguments not in the
interval [-1, +1].</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>asin</d:code> functions return arcsin <d:code>x</d:code> in
the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] radians.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The atan functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double atan(double x);
float atanf(float x);
long double atanl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>atan</d:code> functions compute the principal value of the
arc tangent of <d:code>x</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>atan</d:code> functions return arctan <d:code>x</d:code> in
the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] radians.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The atan2 functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>atan2</d:code> functions compute the value of the arc
tangent of <d:code>y/x</d:code>, using the signs of both arguments to determine
the quadrant of the return value. A domain error may occur if both arguments
are zero.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>atan2</d:code> functions return arctan <d:code>y/x</d:code>
in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>] radians.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The cos functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double cos(double x);
float cosf(float x);
long double cosl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cos</d:code> functions compute the cosine of
<d:code>x</d:code> (measured in radians).</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cos</d:code> functions return cos
<d:code>x</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The sin functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double sin(double x);
float sinf(float x);
long double sinl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>sin</d:code> functions compute the sine of
<d:code>x</d:code> (measured in radians).</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>sin</d:code> functions return sin
<d:code>x</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The tan functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double tan(double x);
float tanf(float x);
long double tanl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>tan</d:code> functions return the tangent of
<d:code>x</d:code> (measured in radians).</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>tan</d:code> functions return tan
<d:code>x</d:code>.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Hyperbolic functions</d:title>
      <d:sect2>
	<d:title>The acosh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double acosh(double x);
float acoshf(float x);
long double acoshl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>acosh</d:code> functions compute the (nonnegative) arc
hyperbolic cosine of <d:code>x</d:code>. A domain error occurs for arguments
less than 1.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The acosh functions return arcosh <d:code>x</d:code> in the interval
[<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mn>0</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi mathvariant="normal">&#x221E;<!-- ∞ --></mml:mi>
</mml:math></d:inlineequation>].</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The asinh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double asinh(double x);
float asinhf(float x);
long double asinhl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>asinh</d:code> functions compute the arc hyperbolic sine of
<d:code>x</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>asinh</d:code> functions return arsinh
<d:code>x</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The atanh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double atanh(double x);
float atanhf(float x);
long double atanhl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>atanh</d:code> functions compute the arc hyperbolic tangent
of <d:code>x</d:code>. A domain error occurs for arguments not in the interval
[-1, +1]. A range error may occur if the argument equals -1 or +1.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>atanh</d:code> functions return atanh
<d:code>x</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The cosh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double cosh(double x);
float coshf(float x);
long double coshl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cosh</d:code> functions compute the hyperbolic cosine of
<d:code>x</d:code>. A range error occurs if the magnitude of <d:code>x</d:code>
is too large.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cosh</d:code> functions return cosh
<d:code>x</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The sinh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double sinh(double x);
float sinhf(float x);
long double sinhl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>sinh</d:code> functions compute the hyperbolic sine of
<d:code>x</d:code>. A range error occurs if the magnitude of <d:code>x</d:code>
is too large.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>sinh</d:code> functions return sinh
<d:code>x</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The tanh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double tanh(double x);
float tanhf(float x);
long double tanhl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>tanh</d:code> functions compute the hyperbolic tangent of
<d:code>x</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>tanh</d:code> functions return tanh
<d:code>x</d:code>.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Exponential and logrithmic functions</d:title>
      <d:sect2>
	<d:title>The exp functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double exp(double x);
float expf(float x);
long double expl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>exp</d:code> functions compute the base-e exponential of
<d:code>x</d:code>. A range error occurs if the magnitude of <d:code>x</d:code>
is too large.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>exp</d:code> functions return <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML"> 
  <mml:msup>
    <mml:mi>e</mml:mi>
    <mml:mi>x</mml:mi>
  </mml:msup>
</mml:math></d:inlineequation>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The exp2 functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double exp2(double x);
float exp2f(float x);
long double exp2l(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>exp2</d:code> functions compute the base-2 exponential of
<d:code>x</d:code>. A range error occurs if the magnitude of <d:code>x</d:code>
is too large.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The exp2 functions return <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML"> 
  <mml:msup>
    <mml:mn>2</mml:mn>
    <mml:mi>x</mml:mi>
  </mml:msup>
</mml:math></d:inlineequation>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The expml functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double expm1(double x);
float expm1f(float x);
long double expm1l(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>expm1</d:code> functions compute the base-e exponential of
the argument, minus 1. A range error occurs if <d:code>x</d:code> is too
large.<d:footnote><d:para>For small magnitude <d:code>x</d:code>,
<d:code>expm1(x)</d:code> is expected to be more accurate than <d:code>exp(x) -
1</d:code>.</d:para></d:footnote></d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The expm1 functions return <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:msup>
    <mml:mi>e</mml:mi>
    <mml:mi>x</mml:mi>
  </mml:msup>
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mn>1</mml:mn>
</mml:math></d:inlineequation></d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The frexp functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double frexp(double value, int *exp);
float frexpf(float value, int *exp);
long double frexpl(long double value, int *exp);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>frexp</d:code> functions break a floating-point number into
a normalized fraction and an integral power of 2. They store the integer in the
int object pointed to by <d:code>exp</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>If <d:code>value</d:code> is not a floating-point number, the results
are unspecified. Otherwise, the <d:code>frexp</d:code> functions return the
value <d:code>x</d:code>, such that <d:code>x</d:code> has a magnitude in the
interval [1/2, 1) or zero, and value equals <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>x</mml:mi>
  <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
  <mml:msup>
    <mml:mn>2</mml:mn>
    <mml:mrow class="MJX-TeXAtom-ORD">
      <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
      <mml:mi>e</mml:mi>
      <mml:mi>x</mml:mi>
      <mml:mi>p</mml:mi>
    </mml:mrow>
  </mml:msup>
</mml:math></d:inlineequation>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The ilogb functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
int ilogb(double x);
int ilogbf(float x);
int ilogbl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ilogb</d:code> functions extract the exponent of
<d:code>x</d:code> as a signed int value. If <d:code>x</d:code> is zero they
compute the value <d:code>FP_ILOGB0</d:code>; if <d:code>x</d:code> is infinite
they compute the value <d:code>INT_MAX</d:code>; if <d:code>x</d:code> is a NaN
they compute the value <d:code>FP_ILOGBNAN</d:code>; otherwise, they are
equivalent to calling the corresponding <d:code>logb</d:code> function and
casting the returned value to type <d:code>int</d:code>. A domain error or
range error may occur if <d:code>x</d:code> is zero, infinite, or NaN. If the
correct value is outside the range of the return type, the numeric result is
unspecified.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ilogb</d:code> functions return the exponent of
<d:code>x</d:code> as a signed int value.</d:para>
<d:para><d:emphasis role="bold">Forward references:</d:emphasis> the
<d:code>logb</d:code> functions (The logb functions).</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The ldexp functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double ldexp(double x, int exp);
float ldexpf(float x, int exp);
long double ldexpl(long double x, int exp);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ldexp</d:code> functions multiply a floating-point number
by an integral power of 2. A range error may occur.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The ldexp functions return <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>x</mml:mi>
  <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
  <mml:msup>
    <mml:mn>2</mml:mn>
    <mml:mrow class="MJX-TeXAtom-ORD">
      <mml:mi>e</mml:mi>
      <mml:mi>x</mml:mi>
      <mml:mi>p</mml:mi>
    </mml:mrow>
  </mml:msup>
</mml:math></d:inlineequation>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The log functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double log(double x);
float logf(float x);
long double logl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>log</d:code> functions compute the base-e (natural)
logarithm of <d:code>x</d:code>. A domain error occurs if the argument is
negative. A range error may occur if the argument is zero.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The log functions return <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>l</mml:mi>
  <mml:mi>o</mml:mi>
  <mml:msub>
    <mml:mi>g</mml:mi>
    <mml:mi>e</mml:mi>
  </mml:msub>
  <mml:mi>x</mml:mi>
</mml:math></d:inlineequation>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The log10 functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double log10(double x);
float log10f(float x);
long double log10l(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>log10</d:code> functions compute the base-10 (natural)
logarithm of <d:code>x</d:code>. A domain error occurs if the argument is
negative. A range error may occur if the argument is zero.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The log10 functions return <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>l</mml:mi>
  <mml:mi>o</mml:mi>
  <mml:msub>
    <mml:mi>g</mml:mi>
    <mml:mn>10</mml:mn>
  </mml:msub>
  <mml:mi>x</mml:mi>
</mml:math></d:inlineequation>.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The log1p functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double log1p(double x);
float log1pf(float x);
long double log1pl(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>log1p</d:code> functions compute the base-e (natural)
logarithm of 1 plus the argument.<d:footnote><d:para>For small magnitude
<d:code></d:code>, <d:code>log1p(x)</d:code> is expected to be more accurate
than <d:code>log(1 + x)</d:code>.</d:para></d:footnote> A domain error occurs
if the argument is less than -1. A range error may occur if the argument equals
11.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The log1p functions return <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML"> 
  <mml:mi>l</mml:mi>
  <mml:mi>o</mml:mi>
  <mml:msub>
    <mml:mi>g</mml:mi>
    <mml:mi>e</mml:mi>
  </mml:msub>
  <mml:mo stretchy="false">(</mml:mo>
  <mml:mn>1</mml:mn>
  <mml:mo>+</mml:mo>
  <mml:mi>x</mml:mi>
  <mml:mo stretchy="false">)</mml:mo>
</mml:math></d:inlineequation></d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The log2 functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;math.h>
double log2(double x);
float log2f(float x);
long double log2l(long double x);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>log2</d:code> functions compute the base-2 logarithm of
<d:code>x</d:code>. A domain error occurs if the argument is less than zero. A
range error may occur if the argument is zero.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>log2</d:code> functions return <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>l</mml:mi>
  <mml:mi>o</mml:mi>
  <mml:msub>
    <mml:mi>g</mml:mi>
    <mml:mn>2</mml:mn>
  </mml:msub>
  <mml:mi>x</mml:mi>
</mml:math></d:inlineequation></d:para>
      </d:sect2>
    </d:sect1>
</d:chapter>
