<html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>Chapter 15. Complex arithmetic &lt;complex.h></title><link href="../../css/style.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL-NS Stylesheets V1.76.1" name="generator"/><link href="../index.html" rel="home" title="C Programming with C99"/><link href="../index.html" rel="up" title="C Programming with C99"/><link href="../assert/index.html" rel="prev" title="Chapter 14. Diagnostics &lt;assert.h>"/><link href="../ix01.html" rel="next" title="Index"/><script src="../css/analytics.js" type="text/javascript" xmlns:d="http://docbook.org/ns/docbook" xmlns:exsl="http://exslt.org/common" xmlns:fo="http://www.w3.org/1999/XSL/Format"></script></head><body alink="#0000FF" bgcolor="white" link="#0000FF" text="black" vlink="#840084"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Chapter 15. Complex arithmetic &lt;complex.h></th></tr><tr><td align="left" width="20%"><a accesskey="p" href="../assert/index.html">Prev</a> </td><th align="center" width="60%"> </th><td align="right" width="20%"> <a accesskey="n" href="../ix01.html">Next</a></td></tr></table><hr/></div><div class="chapter" title="Chapter 15. Complex arithmetic &lt;complex.h>"><div class="titlepage"><div><div><h2 class="title"><a name="idp1388720"></a>Chapter 15. Complex arithmetic &lt;complex.h></h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="index.html#idp1430944">15.1. Introduction</a></span></dt><dt><span class="sect1"><a href="index.html#idp1445952">15.2. Conventions</a></span></dt><dt><span class="sect1"><a href="index.html#idp1250032">15.3. Branch Cuts</a></span></dt><dt><span class="sect1"><a href="index.html#idp1253120">15.4. The CX_LIMITED_RANGE Pragma</a></span></dt><dt><span class="sect1"><a href="index.html#idp1259744">15.5. Trigonometric functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp1260480">15.5.1. The cscos functions</a></span></dt><dt><span class="sect2"><a href="index.html#idp2781184">15.5.2. The casin functions</a></span></dt><dt><span class="sect2"><a href="index.html#idp2331552">15.5.3. The cstan functions</a></span></dt><dt><span class="sect2"><a href="index.html#idp2360384">15.5.4. The ccos functions</a></span></dt><dt><span class="sect2"><a href="index.html#idp2373600">15.5.5. The csin functions</a></span></dt><dt><span class="sect2"><a href="index.html#idp2386240">15.5.6. The ctan functions</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp2399440">15.6. Hyperbolic functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp2538448">15.6.1. The cscosh functions</a></span></dt><dt><span class="sect2"><a href="index.html#idp2561392">15.6.2. The casinh function</a></span></dt></dl></dd></dl></div><div class="sect1" title="15.1. Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1430944"></a>15.1. Introduction</h2></div></div></div><p>The header <code class="code">&lt;complex.h></code> defines macros and
      declares functions that support complex arithmetic. Each synopsis
      specifies a family of functions consisting of a principal function with
      one or more <code class="code">double complex</code> parameters and a
      <code class="code">double complex</code> or <code class="code">double</code> 
      return value; and other functions with the same name but with f and l
      suffixes which are corresponding functions with <code class="code">float</code>
      and <code class="code">long double</code> parameters and return values.</p><p>The macro complex expands to <code class="code">_Complex</code>; the macro
      <code class="code">_Complex_I</code> expands to a constant expression of type
      <code class="code">const float _Complex</code>, with the value of the imaginary
      unit.<sup>[<a class="footnote" href="#ftn.idp1436816" name="idp1436816">147</a>]</sup>.</p><p>The macro <code class="code">I</code> expands to
<code class="code">_Complex_I</code>.</p><p>Notwithstanding the provisions of reserved identifiers, a program may
undefine and perhaps then redefine the macros <code class="code">complex</code> and
<code class="code">I</code>.</p><p><span class="bold"><strong>Forward references:</strong></span> IEC
60559-compatible complex arithmetic (annex G).</p></div><div class="sect1" title="15.2. Conventions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1445952"></a>15.2. Conventions</h2></div></div></div><p>Values are interpreted as radians, not degrees. An implementation
      may set errno but is not required to.</p></div><div class="sect1" title="15.3. Branch Cuts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1250032"></a>15.3. Branch Cuts</h2></div></div></div><p>Some of the functions below have branch cuts, across which the
      function is discontinuous. For implementations with a signed zero
      (including all IEC 60559 implementations) that follow the specifications
      of annex G, the sign of zero distinguishes one side of a cut from another
      so the function is continuous (except for format limitations) as the cut
      is approached from either side. For example, for the square root
      function, which has a branch cut along the negative real axis, the top of
      the cut, with imaginary part +0, maps to the positive imaginary axis, and
      the bottom of the cut, with imaginary part -0, maps to the negative
      imaginary axis.</p><p>Implementations that do not support a signed zero (see annex F)
      cannot distinguish the sides of branch cuts. These implementations shall
      map a cut so the function is continuous as the cut is approached coming
      around the finite endpoint of the cut in a counter clockwise
      direction. (Branch cuts for the functions specified here have just one
      finite endpoint.) For example, for the square root function, coming
      counter clockwise around the finite endpoint of the cut along the
      negative real axis approaches the cut from above, so the cut maps to the
      positive imaginary axis.</p></div><div class="sect1" title="15.4. The CX_LIMITED_RANGE Pragma"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1253120"></a>15.4. The CX_LIMITED_RANGE Pragma</h2></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="cp">#pragma STDC CX_LIMITED_RANGE on-off-switch</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The usual mathematical formulas for complex multiply, divide, and
absolute value are problematic because of their treatment of infinities and
because of undue overflow and underflow. The <code class="code">CX_LIMITED_RANGE</code>
pragma can be used to inform the implementation that (where the state is “on”)
the usual mathematical formulas are acceptable.<sup>[<a class="footnote" href="#ftn.idp1257280" name="idp1257280">148</a>]</sup> The pragma can occur either outside external
declarations or preceding all explicit declarations and statements inside a
compound statement. When outside external declarations, the pragma takes effect
from its occurrence until another <code class="code">CX_LIMITED_RANGE</code> pragma is
encountered, or until the end of the translation unit. When inside a compound
statement, the pragma takes effect from its occurrence until another
<code class="code">CX_LIMITED_RANGE</code> pragma is encountered (including within a
nested compound statement), or until the end of the compound statement; at the
end of a compound statement the state for the pragma is restored to its
condition just before the compound statement. If this pragma is used in any
other context, the behavior is undefined. The default state for the pragma is
“off”.</p></div><div class="sect1" title="15.5. Trigonometric functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1259744"></a>15.5. Trigonometric functions</h2></div></div></div><div class="sect2" title="15.5.1. The cscos functions"><div class="titlepage"><div><div><h3 class="title"><a name="idp1260480"></a>15.5.1. The cscos functions</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">cacos</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">cacosf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">cacosl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Descriptiotn</strong></span></p><p>The <code class="code">cacos</code> functions compute the complex arc cosine of
<code class="code">z</code>, with branch cuts outside the interval <code class="code">[-1,
+1]</code> along the real axis.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">cacos</code> functions return the complex arc cosine value, in the range
of a strip mathematically unbounded along the imaginary axis and in the
interval [0, <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>π</mi>
</math>] along the real axis.</p><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">cacos</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">cacosf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">cacosl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p>Link with <code class="code">-lm</code>.</p><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">cacos()</code> function calculates the complex arc cosine
of <code class="code">z</code>. If <code class="code">y = cacos(z)</code>, then <code class="code">z =
ccos(y)</code>. The real part of <code class="code">y</code> is chosen in the interval
[0, <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>π</mi>
</math>].</p><p>One has:</p><pre class="screen">cacos(z) = -i * clog(z + i * csqrt(1 - z * z))</pre><p><span class="bold"><strong>Example</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;complex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">4.0</span><span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Re[cacos(z)]=%lf and Im[cacos(z)]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creal</span><span class="p">(</span><span class="n">cacos</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span> <span class="n">cimag</span><span class="p">(</span><span class="n">cacos</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>Compile like <code class="code">clang filename.c -lm</code>. Execution gives
following output:</p><pre class="screen">Re[cacos(z)]=0.936812 and Im[cacos(z)]=-2.305509</pre></div><div class="sect2" title="15.5.2. The casin functions"><div class="titlepage"><div><div><h3 class="title"><a name="idp2781184"></a>15.5.2. The casin functions</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">casin</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">casinf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">casinl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">casin</code> functions compute the complex arc sine of
<code class="code">z</code>, with branch cuts outside the interval [-1, +1] along the
real axis.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code"></code> functions return the complex arc sine value, in
the range of a strip mathematically unbounded along the imaginary axis and in
the interval [<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>−</mo>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo>,</mo>
<mo>+</mo>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
</math>] along the real axis.</p><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">casin</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">casinf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">casinl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><pre class="screen">csin(z) = (exp(i * z) - exp(-i * z)) / (2 * i)</pre><p><span class="bold"><strong>Example</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;complex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">4.0</span><span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Re[cacsin(z)]=%lf and Im[cacsin(z)]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creal</span><span class="p">(</span><span class="n">casin</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span> <span class="n">cimag</span><span class="p">(</span><span class="n">casin</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>Compile like <code class="code">clang filename.c -lm</code>. Execution gives
following output:</p><pre class="screen">Re[cacsin(z)]=0.633984 and Im[cacsin(z)]=2.305509</pre></div><div class="sect2" title="15.5.3. The cstan functions"><div class="titlepage"><div><div><h3 class="title"><a name="idp2331552"></a>15.5.3. The cstan functions</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">catan</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">catanf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">catanl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">catan</code> functions compute the complex arc tangent of
<code class="code">z</code>, with branch cuts outside the interval [-i, +i] along the
imaginary axis.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">catan</code> functions return the complex arc tangent
value, in the range 
of a strip mathematically unbounded along the imaginary axis and in the
interval [<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>−</mo>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo>,</mo>
<mo>+</mo>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
</math>] along the real axis.</p><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">catan</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">catanf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">catanl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p>Link with <code class="code">-lm</code>.</p><p>The <code class="code">catan()</code> function calculates the complex arc tangent of <code class="code">z</code>. If <code class="code">y = catan(z)</code>, then <code class="code">z = ctan(y)</code>. The real part of <code class="code">y</code> is chosen in the interval [<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>−</mo>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo>,</mo>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
</math>].</p><p>One has:</p><pre class="screen">catan(z) = (clog(1 + i * z) - clog(1 - i * z)) / (2 * i)</pre><p><span class="bold"><strong>Example</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;complex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">4.0</span><span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Re[cactan(z)]=%lf and Im[cactan(z)]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creal</span><span class="p">(</span><span class="n">catan</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span> <span class="n">cimag</span><span class="p">(</span><span class="n">catan</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>Compile like . Execution<code class="code">clang filename.c -lm</code> gives
following output:</p><pre class="screen">Re[cactan(z)]=1.448307 and Im[cactan(z)]=0.158997</pre></div><div class="sect2" title="15.5.4. The ccos functions"><div class="titlepage"><div><div><h3 class="title"><a name="idp2360384"></a>15.5.4. The ccos functions</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">ccos</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">ccosf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">ccosl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">ccos</code> functions compute the complex cosine of
<code class="code">z</code>.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">ccos</code> functions return the complex cosine
value.</p><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">ccos</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">ccosf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">ccosl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p>Link with <code class="code">-lm</code>.</p><p><span class="bold"><strong>Description</strong></span></p><p>The complex cosine function is defined as:</p><pre class="screen">ccos(z) = (exp(i * z) + exp(-i * z)) / 2</pre><p><span class="bold"><strong>Example</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;complex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">4.0</span><span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Re[ccos(z)]=%lf and Im[ccos(z)]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creal</span><span class="p">(</span><span class="n">ccos</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span> <span class="n">cimag</span><span class="p">(</span><span class="n">ccos</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre>
and the output is:
<pre class="screen">Re[ccos(z)]=-27.034946 and Im[ccos(z)]=-3.851153</pre></div><div class="sect2" title="15.5.5. The csin functions"><div class="titlepage"><div><div><h3 class="title"><a name="idp2373600"></a>15.5.5. The csin functions</h3></div></div></div><p>Synopsis</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">csin</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">csinf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">csinl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code"></code> functions compute the complex sine of
<code class="code">z</code>.</p><p><span class="bold"><strong>Desciption</strong></span></p><p>The <code class="code">csin</code> functions return the complex sine
value.</p><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">csin</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">csinf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">csinl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p>Link with <code class="code">-lm</code>.</p><p><span class="bold"><strong>Description</strong></span></p><p>The complex sine function is defined as:</p><pre class="screen">csin(z) = (exp(i * z) - exp(-i * z)) / (2 * i)</pre><p><span class="bold"><strong>Example</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;complex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">4.0</span><span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Re[csin(z)]=%lf and Im[csin(z)]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creal</span><span class="p">(</span><span class="n">csin</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span> <span class="n">cimag</span><span class="p">(</span><span class="n">csin</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre>
and the output is:
<pre class="screen">Re[csin(z)]=3.853738 and Im[csin(z)]=-27.01681</pre></div><div class="sect2" title="15.5.6. The ctan functions"><div class="titlepage"><div><div><h3 class="title"><a name="idp2386240"></a>15.5.6. The ctan functions</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">ctan</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">ctanf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">ctanl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">ctan</code> functions compute the complex tangent of
<code class="code">z</code>.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">ctan</code> functions return the complex tangent
value.</p><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">ctan</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">ctanf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">ctanl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p>Link with <code class="code">-lm.</code></p><p><span class="bold"><strong>Description</strong></span></p><p>The complex tangent function is defined as:</p><pre class="screen">ctan(z) = csin(z) / ccos(z)</pre><p><span class="bold"><strong>Example</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;complex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">4.0</span><span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Re[ctann(z)]=%lf and Im[ctan(z)]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creal</span><span class="p">(</span><span class="n">ctan</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span> <span class="n">cimag</span><span class="p">(</span><span class="n">ctan</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre>
and the output is:
<pre class="screen">Re[ctann(z)]=-0.000187 and Im[ctan(z)]=0.999356</pre></div></div><div class="sect1" title="15.6. Hyperbolic functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp2399440"></a>15.6. Hyperbolic functions</h2></div></div></div><div class="sect2" title="15.6.1. The cscosh functions"><div class="titlepage"><div><div><h3 class="title"><a name="idp2538448"></a>15.6.1. The cscosh functions</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">cacosh</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">cacoshf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">cacoshl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">cacosh</code> functions compute the complex arc
hyperbolic cosine of <code class="code">z</code>, with a branch cut at values less than
1 along the real axis.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">cacosh</code> functions return the complex arc hyperbolic
cosine value, in the range of a half-strip of non-negative values along the
real axis and in the interval [<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>−</mo>
<mi>i</mi>
<mi>π</mi>
<mo>,</mo>
<mo>+</mo>
<mi>i</mi>
<mi>π</mi>
</math>] along the imaginary axis.</p><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">cacosh</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">cacoshf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">cacoshl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">cacosh()</code> function calculates the complex arc
hyperpolic cosine of <code class="code">z</code>. If <code class="code">y = cacosh(z)</code>,
then <code class="code">z = ccosh(y)</code>. The imaginary part of <code class="code">y</code> is
chosen in the interval [<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>−</mo>
<mi>π</mi>
<mo>,</mo>
<mi>π</mi>
</math>]. The real part of <code class="code">y</code> is chosen
nonnegative.</p><p>One has:</p><pre class="screen">cacosh(z) = 2 * clog(csqrt((z + 1) / 2) + csqrt((z - 1) /
2))</pre><p><span class="bold"><strong>Example</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;complex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">4.0</span><span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Re[cacosh(z)]=%lf and Im[cacosh(z)]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creal</span><span class="p">(</span><span class="n">cacosh</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span> <span class="n">cimag</span><span class="p">(</span><span class="n">cacosh</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre>
and the output is:
<pre class="screen">Re[cacosh(z)]=2.305509 and Im[cacosh(z)]=0.93681</pre></div><div class="sect2" title="15.6.2. The casinh function"><div class="titlepage"><div><div><h3 class="title"><a name="idp2561392"></a>15.6.2. The casinh function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">casinh</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">casinhf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">casinhl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">casinh</code> functions compute the complex arc
hyperbolic sine of <code class="code"></code>, with branch cuts outside the interval
[-i, +i] along the imaginary axis.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">casinh</code> functions return the complex arc hyperbolic
sine value, in the range of a strip mathematically unbounded along the real
axis and in the interval [<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>−</mo>
<mi>i</mi>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo>,</mo>
<mo>+</mo>
<mi>i</mi>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
</math>] along the imaginary axis.</p><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;complex.h&gt;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="nf">casinh</span><span class="p">(</span><span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">complex</span> <span class="nf">casinhf</span><span class="p">(</span><span class="kt">float</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="nf">casinhl</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</pre><p>Link with <code class="code">-lm.</code></p><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">casinh()</code> function calculates the complex arc
hyperbolic sine of <code class="code">z</code>. If <code class="code"></code>, then <code class="code">z =
csinh(y)</code>. The imaginary part of <code class="code">y</code> is chosen in the
interval [<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>−</mo>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo>,</mo>
<mo>+</mo>
<mi>π</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
</math>].</p><p>One has:</p><pre class="screen">casinh(z) = clog(z + csqrt(z * z + 1))</pre><p><span class="bold"><strong>Example</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;complex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">4.0</span><span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Re[casinh(z)]=%lf and Im[casinh(z)]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">creal</span><span class="p">(</span><span class="n">casinh</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span> <span class="n">cimag</span><span class="p">(</span><span class="n">casinh</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre>
and the output is:
<pre class="screen">Re[casinh(z)]=2.299914 and Im[casinh(z)]=0.917617</pre></div></div><div class="footnotes"><br/><hr align="left" width="100"/><div class="footnote"><p><sup>[<a class="para" href="#idp1436816" id="ftn.idp1436816">147</a>] </sup>The imaginary unit is a number
      <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>i</mi>
</math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<msup>
<mi>i</mi>
<mn>2</mn>
</msup>
<mo>=</mo>
<mo>−</mo>
<mn>1</mn>
</math></p></div><div class="footnote"><p><sup>[<a class="para" href="#idp1257280" id="ftn.idp1257280">148</a>] </sup>The purpose
of the pragma is to allow the implementation to use the
formulas.</p></div></div></div><div class="navfooter"><hr/><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="../assert/index.html">Prev</a> </td><td align="center" width="20%"> </td><td align="right" width="40%"> <a accesskey="n" href="../ix01.html">Next</a></td></tr><tr><td align="left" valign="top" width="40%">Chapter 14. Diagnostics &lt;assert.h> </td><td align="center" width="20%"><a accesskey="h" href="../index.html">Home</a></td><td align="right" valign="top" width="40%"> Index</td></tr></table></div><p style="text-align: center;" xmlns:d="http://docbook.org/ns/docbook" xmlns:exsl="http://exslt.org/common" xmlns:fo="http://www.w3.org/1999/XSL/Format">© 2010, 2013 Shiv S. Dayal. <a href="http://libreprogramming.org">libreprogramming.org</a>.
   GNU FDL license is applicable where not stated.</p></body></html>