<html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>Chapter 12. Preprocessing Directives</title><link href="../../css/style.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL-NS Stylesheets V1.76.1" name="generator"/><link href="../index.html" rel="home" title="C Programming with C99"/><link href="../index.html" rel="up" title="C Programming with C99"/><link href="../su/index.html" rel="prev" title="Chapter 11. Structures and Unions"/><link href="../std/index.html" rel="next" title="Chapter 13. The C Standard Library"/><script src="../css/analytics.js" type="text/javascript" xmlns:d="http://docbook.org/ns/docbook" xmlns:exsl="http://exslt.org/common" xmlns:fo="http://www.w3.org/1999/XSL/Format"></script></head><body alink="#0000FF" bgcolor="white" link="#0000FF" text="black" vlink="#840084"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Chapter 12. Preprocessing Directives</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="../su/index.html">Prev</a> </td><th align="center" width="60%"> </th><td align="right" width="20%"> <a accesskey="n" href="../std/index.html">Next</a></td></tr></table><hr/></div><div class="chapter" title="Chapter 12. Preprocessing Directives"><div class="titlepage"><div><div><h2 class="title"><a name="idp2242128"></a>Chapter 12. Preprocessing Directives</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="index.html#idp863936">12.1. Conditional Inclusion</a></span></dt><dt><span class="sect1"><a href="index.html#idp2360272">12.2. Source File Inclusion</a></span></dt><dt><span class="sect1"><a href="index.html#idp2375008">12.3. Macro Replacement</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp592096">12.3.1. Argument Substitution</a></span></dt><dt><span class="sect2"><a href="index.html#idp596320">12.3.2. The # Operator</a></span></dt><dt><span class="sect2"><a href="index.html#idp602992">12.3.3. The ## Operator</a></span></dt><dt><span class="sect2"><a href="index.html#idp610496">12.3.4. Rescanning and Further Replacement</a></span></dt><dt><span class="sect2"><a href="index.html#idp614688">12.3.5. Scope of Macro Definitions</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp618672">12.4. Line Control</a></span></dt><dt><span class="sect1"><a href="index.html#idp1905264">12.5. Error Directive</a></span></dt><dt><span class="sect1"><a href="index.html#idp1908048">12.6. Pragma Directive</a></span></dt><dt><span class="sect1"><a href="index.html#idp1917344">12.7. Null Directive</a></span></dt><dt><span class="sect1"><a href="index.html#idp1920720">12.8. Predefined Macro Names</a></span></dt><dt><span class="sect1"><a href="index.html#idp1938800">12.9. Pragma Operator</a></span></dt><dt><span class="sect1"><a href="index.html#idp1943264">12.10. Usage</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp1945888">12.10.1. #include</a></span></dt><dt><span class="sect2"><a href="index.html#idp1959056">12.10.2. Why we need headers?</a></span></dt><dt><span class="sect2"><a href="index.html#idp1962640">12.10.3. #define</a></span></dt><dt><span class="sect2"><a href="index.html#idp1975008">12.10.4. #undef</a></span></dt><dt><span class="sect2"><a href="index.html#idp2467104">12.10.5. # and ##</a></span></dt><dt><span class="sect2"><a href="index.html#idp2469488">12.10.6. #error</a></span></dt><dt><span class="sect2"><a href="index.html#idp2474032">12.10.7. #pragma</a></span></dt><dt><span class="sect2"><a href="index.html#idp2475856">12.10.8. Miscellaneous</a></span></dt></dl></dd></dl></div><p>The following comes from section 6.10 of specification. It will
    terminate when you see code starting. :-)</p><p>A <span class="italic">preprocessing directive</span>
    consists of a sequence of preprocessing tokens that begins with a
    <code class="code">#</code> preprocessing token that (at the start of translation
    phase 4) is either the first character in the source file (optionally after
    white space containing no new-line characters) or that follows white space
    containing at least one new-line character, and is ended by the next
    new-line character.<sup>[<a class="footnote" href="#ftn.idp722736" name="idp722736">128</a>]</sup> A new-line character ends
    the preprocessing directive even if it occurs within what would otherwise
    be an invocation of a function-like macro.</p><p>A text line shall not begin with a <code class="code">#</code> preprocessing
    token. A non-directive shall not begin with any of the directive names
    appearing in the syntax.</p><p>When in a group that is skipped (12.1), the directive syntax is
    relaxed to allow any sequence of preprocessing tokens to occur between the
    directive name and the following new-line character.</p><p><span class="bold"><strong>Constraints</strong></span></p><p>The only white-space characters that shall appear between
    preprocessing tokens within a preprocessing directive (from just after the
    introducing # preprocessing token through just before the terminating
    new-line character) are space and horizontal-tab (including spaces that
    have replaced comments or possibly other white-space characters in
    translation phase 3).</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The implementation can process and skip sections of source files
    conditionally, include other source files, and replace macros. These
    capabilities are called preprocessing, because conceptually they occur
    before translation of the resulting translation unit.</p><p>The preprocessing tokens within a preprocessing directive are not
    subject to macro expansion unless otherwise stated.</p><p>EXAMPLE In:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#define EMPTY</span>
<span class="n">EMPTY</span> <span class="err">#</span> <span class="n">include</span> <span class="o">&lt;</span><span class="n">file</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</pre></div>
</pre><p>the sequence of preprocessing tokens on the second line is not a
preprocessing directive, because it does not begin with a <code class="code">#</code> at
the start of translation phase 4, even though it will do so after the macro
<code class="code">EMPTY</code> has been replaced.</p><div class="sect1" title="12.1. Conditional Inclusion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp863936"></a>12.1. Conditional Inclusion</h2></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The expression that controls conditional inclusion shall be an
  integer constant expression except that: it shall not contain a cast;
  identifiers (including those lexically identical to keywords) are interpreted
  as described below; <sup>[<a class="footnote" href="#ftn.idp866032" name="idp866032">129</a>]</sup> and it may contain unary operator
  expressions of the form:</p><pre class="screen">defined identifier</pre><p>or:</p><pre class="screen">defined (identifier)</pre><p>which evaluate to 1 if the identifier is currently defined as a macro
  name (that is, if it is predefined or if it has been the subject of a
  <code class="code">#define</code> preprocessing directive without an intervening
  <code class="code">#undef</code> directive with the same subject identifier), 0 if it
  is not.</p><p><span class="bold"><strong>Sematics</strong></span></p><p>Preprocessing directives of the forms:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># if constant-expression new-line group_opt</span>
<span class="cp"># elif constant-expression new-line group_opt</span>
</pre></div>
</pre><p>check whether the controlling constant expression evaluates to
nonzero.</p><p>Prior to evaluation, macro invocations in the list of preprocessing
tokens that will become the controlling constant expression are replaced
(except for those macro names modified by the defined unary operator), just as
in normal text. If the token defined is generated as a result of this
replacement process or use of the defined unary operator does not match one of
the two specified forms prior to macro replacement, the behavior is
undefined. After all replacements due to macro expansion and the defined unary
operator have been performed, all remaining identifiers are replaced with the
pp-number 0, and then each preprocessing token is converted into a token. The
resulting tokens compose the controlling constant expression which is evaluated
according to the rules of constant expressions. For the purposes of this token
conversion and evaluation, all signed integer types and all unsigned integer
types act as if they hav e the same representation as, respectively, the types
<code class="code">intmax_t</code> and <code class="code">uintmax_t</code> defined in the header
<code class="code">&lt;stdint.h></code>.<sup>[<a class="footnote" href="#ftn.idp2349392" name="idp2349392">130</a>]</sup> This includes interpreting character constants, which
may involve converting escape sequences into execution character set
members. Whether the numeric value for these character constants matches the
value obtained when an identical character constant occurs in an expression
(other than within a <code class="code">#if</code> or <code class="code">#elif</code> directive)
is implementation-defined.<sup>[<a class="footnote" href="#ftn.idp2353776" name="idp2353776">131</a>]</sup> Also, whether a
single-character character constant may have a negative value is
implementation-defined.</p><p>Preprocessing directives of the forms:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># ifdef identifier new-line group_opt</span>
<span class="cp"># ifndef identifier new-line group_opt</span>
</pre></div>
</pre><p>check whether the identifier is or is not currently defined as a macro
name. Their conditions are equivalent to <code class="code">#if</code> defined
identifier and <code class="code">#if !defined</code> identifier respectively.</p><p>Each directive’s condition is checked in order. If it evaluates to
false (zero), the group that it controls is skipped: directives are processed
only through the name that determines the directive in order to keep track of
the level of nested conditionals; the rest of the directives’ preprocessing
tokens are ignored, as are the other preprocessing tokens in the group. Only
the first group whose control condition evaluates to true (nonzero) is
processed. If none of the conditions evaluates to true, and there is a #else
directive, the group controlled by the #else is processed; lacking a #else
directive, all the groups until the #endif are skipped.<sup>[<a class="footnote" href="#ftn.idp2359312" name="idp2359312">132</a>]</sup></p></div><div class="sect1" title="12.2. Source File Inclusion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp2360272"></a>12.2. Source File Inclusion</h2></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A <code class="code">#include</code> directive shall identify a header or
  source file that can be processed by the implementation.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># include &lt;h-char-sequence&gt;  new-line</span>
</pre></div>
</pre><p>searches a sequence of implementation-defined places for a header
  identified uniquely by the specified sequence between the &lt; and >
  delimiters, and causes the replacement of that directive by the entire
  contents of the header. How the places are specified or the header identified
  is implementation-defined.</p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># include &quot;q-char-sequence&quot; new-line</span>
</pre></div>
</pre><p>causes the replacement of that directive by the entire contents of the
source file identified by the specified sequence between the ” delimiters. The
named source file is searched for in an implementation-defined manner. If this
search is not supported, or if the search fails, the directive is reprocessed
as if it read:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># include &lt;h-char-sequence&gt; new-line</span>
</pre></div>
</pre><p>with the identical contained sequence (including > characters, if any)
from the original directive.</p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># include pp-tokens new-line</span>
</pre></div>
</pre><p>(that does not match one of the two previous forms) is permitted. The
preprocessing tokens after include in the directive are processed just as in
normal text. (Each identifier currently defined as a macro name is replaced by
its replacement list of preprocessing tokens.) The directive resulting after
all replacements shall match one of the two previous
forms.<sup>[<a class="footnote" href="#ftn.idp2370688" name="idp2370688">133</a>]</sup> The method
by which a sequence of preprocessing tokens between a &lt; and a >
preprocessing token pair or a pair of ” characters is combined into a single
header name preprocessing token is implementation-defined.</p><p>The implementation shall provide unique mappings for sequences
consisting of one or more letters or digits followed by a period (.) and a
single letter. The first character shall be a letter. The implementation may
ignore the distinctions of alphabetical case and restrict the mapping to eight
significant characters before the period.</p><p>A <code class="code">#include</code> preprocessing directive may appear in a
source file that has been read because of a <code class="code">#include</code> directive
in another file, up to an implementation-defined nesting limit.</p><p><span class="bold"><strong>Forward References</strong></span>: macro
replacement (12.3).</p></div><div class="sect1" title="12.3. Macro Replacement"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp2375008"></a>12.3. Macro Replacement</h2></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Two replacement lists are identical if and only if the preprocessing
  tokens in both have the same number, ordering, spelling, and white-space
  separation, where all white-space separations are considered
  identical.</p><p>An identifier currently defined as an object-like macro shall not be
  redefined by another #define preprocessing directive unless the second
  definition is an object-like macro definition and the two replacement lists
  are identical. Likewise, an identifier currently defined as a function-like
  macro shall not be redefined by another <code class="code">#define</code>
  preprocessing directive unless the second definition is a function-like macro
  definition that has the same number and spelling of parameters, and the two
  replacement lists are identical.</p><p>There shall be white-space between the identifier and the replacement
  list in the definition of an object-like macro.</p><p>If the identifier-list in the macro definition does not end with an
  ellipsis, the number of arguments (including those arguments consisting of no
  preprocessing tokens) in an invocation of a function-like macro shall equal
  the number of parameters in the macro definition. Otherwise, there shall be
  more arguments in the invocation than there are parameters in the macro
  definition (excluding the ...). There shall exist a ) preprocessing token
  that terminates the invocation.</p><p>The identifier <code class="code">__VA_ARGS__</code> shall occur only in the
  replacement-list of a function-like macro that uses the ellipsis notation in
  the parameters.</p><p>A parameter identifier in a function-like macro shall be uniquely
  declared within its scope.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The identifier immediately following the define is called the macro
  name. There is one name space for macro names. Any white-space characters
  preceding or following the replacement list of preprocessing tokens are not
  considered part of the replacement list for either form of macro.</p><p>If a <code class="code">#</code> preprocessing token, followed by an
  identifier, occurs lexically at the point at which a preprocessing directive
  could begin, the identifier is not subject to macro replacement.</p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># define identifier replacement-list new-line</span>
</pre></div>
</pre><p>defines an object-like macro that causes each subsequent instance of
  the macro name<sup>[<a class="footnote" href="#ftn.idp585600" name="idp585600">134</a>]</sup> to be replaced
  by the replacement list of preprocessing tokens that constitute the remainder
  of the directive.</p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># define identifier lparen identifier-listopt ) replacement-list new-line</span>
<span class="cp"># define identifier lparen ... ) replacement-list new-line</span>
<span class="cp"># define identifier lparen identifier-list , ... ) replacement-list new-line</span>
</pre></div>
</pre><p>defines a function-like macro with arguments, similar syntactically to
a function call. The parameters are specified by the optional list of
identifiers, whose scope extends from their declaration in the identifier list
until the new-line character that terminates the </p><p>#define</p><p>
preprocessing directive. Each subsequent instance of the function-like macro
name followed by a ( as the next preprocessing token introduces the sequence of
preprocessing tokens that is replaced by the replacement list in the definition
(an invocation of the macro). The replaced sequence of preprocessing tokens is
terminated by the matching ) preprocessing token, skipping intervening matched
pairs of left and right parenthesis preprocessing tokens. Within the sequence
of preprocessing tokens making up an invocation of a function-like macro,
new-line is considered a normal white-space character.</p><p>The sequence of preprocessing tokens bounded by the outside-most
matching parentheses forms the list of arguments for the function-like
macro. The individual arguments within the list are separated by comma
preprocessing tokens, but comma preprocessing tokens between matching inner
parentheses do not separate arguments. If there are sequences of preprocessing
tokens within the list of arguments that would otherwise act as preprocessing
directives,<sup>[<a class="footnote" href="#ftn.idp590480" name="idp590480">135</a>]</sup> the behavior is
undefined.</p><p>If there is a ... in the identifier-list in the macro definition, then
the trailing arguments, including any separating comma preprocessing tokens,
are merged to form a single item: the variable arguments. The number of
arguments combined is such that, following merger, the number of arguments is
one more than the number of parameters in the macro definition (excluding the
...).</p><div class="sect2" title="12.3.1. Argument Substitution"><div class="titlepage"><div><div><h3 class="title"><a name="idp592096"></a>12.3.1. Argument Substitution</h3></div></div></div><p>After the arguments for the invocation of a function-like macro have
  been identified, argument substitution takes place. A parameter in the
  replacement list, unless preceded by a <code class="code">#</code> or
  <code class="code">##</code> preprocessing token or followed by a <code class="code">##</code>
  preprocessing token (see below), is replaced by the corresponding argument
  after all macros contained therein have been expanded. Before being
  substituted, each argument’s preprocessing tokens are completely macro
  replaced as if they formed the rest of the preprocessing file; no other
  preprocessing tokens are available.</p><p>An identifier <code class="code">__VA_ARGS__</code> that occurs in the
  replacement list shall be treated as if it were a parameter, and the variable
  arguments shall form the preprocessing tokens used to replace it.</p></div><div class="sect2" title="12.3.2. The # Operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp596320"></a>12.3.2. The # Operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Each <code class="code">#</code> preprocessing token in the replacement list
  for a function-like macro shall be followed by a parameter as the next
  preprocessing token in the replacement list.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>If, in the replacement list, a parameter is immediately preceded by a
  <code class="code">#</code> preprocessing token, both are replaced by a single
  character string literal preprocessing token that contains the spelling of
  the preprocessing token sequence for the corresponding argument. Each
  occurrence of white space between the argument's preprocessing tokens becomes
  a single space character in the character string literal. White space before
  the first preprocessing token and after the last preprocessing token
  composing the argument is deleted. Otherwise, the original spelling of each
  preprocessing token in the argument is retained in the character string
  literal, except for special handling for producing the spelling of string
  literals and character constants: a \ character is inserted before each " and
  \ character of a character constant or string literal (including the
  delimiting " characters), except that it is implementation-defined whether a
  \ character is inserted before the \ character beginning a universal
  character name. If the replacement that results is not a valid character
  string literal, the behavior is undefined. The character string literal
  corresponding to an empty argument is "". The order of evaluation of
  <code class="code">#</code> and <code class="code">##</code> operators is unspecified.</p></div><div class="sect2" title="12.3.3. The ## Operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp602992"></a>12.3.3. The ## Operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A <code class="code">##</code> preprocessing token shall not occur at the
  beginning or at the end of a replacement list for either form of macro
  definition.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>If, in the replacement list of a function-like macro, a parameter is
  immediately preceded or followed by a <code class="code">##</code> preprocessing
  token, the parameter is replaced by the corresponding argument’s
  preprocessing token sequence; however, if an argument consists of no
  preprocessing tokens, the parameter is replaced by a placemarker
  preprocessing token instead.<sup>[<a class="footnote" href="#ftn.idp607504" name="idp607504">136</a>]</sup></p><p>For both object-like and function-like macro invocations, before the
  replacement list is reexamined for more macro names to replace, each instance
  of a <code class="code">##</code> preprocessing token in the replacement list (not
  from an argument) is deleted and the preceding preprocessing token is
  concatenated with the following preprocessing token. Placemarker
  preprocessing tokens are handled specially: concatenation of two placemarkers
  results in a single placemarker preprocessing token, and concatenation of a
  placemarker with a non-placemarker preprocessing token results in the
  non-placemarker preprocessing token. If the result is not a valid
  preprocessing token, the behavior is undefined. The resulting token is
  available for further macro replacement. The order of evaluation of
  <code class="code">##</code> operators is unspecified.</p></div><div class="sect2" title="12.3.4. Rescanning and Further Replacement"><div class="titlepage"><div><div><h3 class="title"><a name="idp610496"></a>12.3.4. Rescanning and Further Replacement</h3></div></div></div><p>After all parameters in the replacement list have been substituted
  and <code class="code">#</code> and <code class="code">##</code> processing has taken place,
  all placemarker preprocessing tokens are removed. Then, the resulting
  preprocessing token sequence is rescanned, along with all subsequent
  preprocessing tokens of the source file, for more macro names to
  replace.</p><p>If the name of the macro being replaced is found during this scan of
  the replacement list (not including the rest of the source file’s
  preprocessing tokens), it is not replaced. Furthermore, if any nested
  replacements encounter the name of the macro being replaced, it is not
  replaced. These nonreplaced macro name preprocessing tokens are no longer
  available for further replacement even if they are later (re)examined in
  contexts in which that macro name preprocessing token would otherwise have
  been replaced.</p><p>The resulting completely macro-replaced preprocessing token sequence
  is not processed as a preprocessing directive even if it resembles one, but
  all pragma unary operator expressions within it are then processed as
  specified in 12.9 below.</p></div><div class="sect2" title="12.3.5. Scope of Macro Definitions"><div class="titlepage"><div><div><h3 class="title"><a name="idp614688"></a>12.3.5. Scope of Macro Definitions</h3></div></div></div><p>A macro definition lasts (independent of block structure) until a
  corresponding <code class="code">#undef</code> directive is encountered or (if none is
  encountered) until the end of the preprocessing translation unit. Macro
  definitions have no significance after translation phase 4.</p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># undef identifier new-line</span>
</pre></div>
</pre><p>causes the specified identifier no longer to be defined as a macro
  name. It is ignored if the specified identifier is not currently defined as a
  macro name.</p></div></div><div class="sect1" title="12.4. Line Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp618672"></a>12.4. Line Control</h2></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The string literal of a <code class="code">#line</code> directive, if present,
  shall be a character string literal.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The line number of the current source line is one greater than the
  number of new-line characters read or introduced in translation phase 1 while
  processing the source file to the current token.</p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># line digit-sequence new-line</span>
</pre></div>
</pre><p>causes the implementation to behave as if the following sequence of
  source lines begins with a source line that has a line number as specified by
  the digit sequence (interpreted as a decimal integer). The digit sequence
  shall not specify zero, nor a number greater than 2147483647.</p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># line digit-sequence &quot;s-char-sequenceopt&quot; new-line</span>
</pre></div>
</pre><p>sets the presumed line number similarly and changes the presumed name
  of the source file to be the contents of the character string
  literal.</p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># line pp-tokens new-line</span>
</pre></div>
</pre><p>(that does not match one of the two previous forms) is permitted. The
  preprocessing tokens after line on the directive are processed just as in
  normal text (each identifier currently defined as a macro name is replaced by
  its replacement list of preprocessing tokens). The directive resulting after
  all replacements shall match one of the two previous forms and is then
  processed as appropriate.</p></div><div class="sect1" title="12.5. Error Directive"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1905264"></a>12.5. Error Directive</h2></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A preprocessing directive of the form <code class="code"># error
  pp-tokensopt new-line</code> causes the implementation to produce a
  diagnostic message that includes the specified sequence of preprocessing
  tokens.</p></div><div class="sect1" title="12.6. Pragma Directive"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1908048"></a>12.6. Pragma Directive</h2></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># pragma pp-tokensopt new-line</span>
</pre></div>
</pre><p>where the preprocessing token STDC does not immediately follow pragma
  in the directive (prior to any macro replacement)<sup>[<a class="footnote" href="#ftn.idp1911232" name="idp1911232">137</a>]</sup>
  causes the implementation to behave in an implementation-defined manner. The
  behavior might cause translation to fail or cause the translator or the
  resulting program to behave in a non-conforming manner. Any such pragma that
  is not recognized by the implementation is ignored.</p><p>If the preprocessing token STDC does immediately follow pragma in the
  directive (prior to any macro replacement), then no macro replacement is
  performed on the directive, and the directive shall have one of the following
  forms whose meanings are described elsewhere:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#pragma STDC FP_CONTRACT on-off-switch</span>
<span class="cp">#pragma STDC FENV_ACCESS on-off-switch</span>
<span class="cp">#pragma STDC CX_LIMITED_RANGE on-off-switch</span>
</pre></div>
</pre><p><span class="italic">on-off-switch: </span> on of</p><p>ON OFF DEFAULT</p><p><span class="bold"><strong>Forward references:</strong></span> the
FP_CONTRACT pragma (13.12.2), the FENV_ACCESS pragma (13.6.1), the
CX_LIMITED_RANGE pragma (13.3.4). 149).</p></div><div class="sect1" title="12.7. Null Directive"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1917344"></a>12.7. Null Directive</h2></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A preprocessing directive of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># new-line</span>
</pre></div>
</pre><p>has no effect.</p></div><div class="sect1" title="12.8. Predefined Macro Names"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1920720"></a>12.8. Predefined Macro Names</h2></div></div></div><p>The following macro names shall be defined by the
  implementation:</p><p><code class="code">__DATE__</code> The date of translation of the
  preprocessing translation unit: a character string literal of the form "Mmm
  dd yyyy", where the names of the months are the same as those generated by
  the asctime function, and the first character of dd is a space character if
  the value is less than 10. If the date of translation is not available, an
  implementation-defined valid date shall be supplied.</p><p><code class="code">__FILE__</code> The presumed name of the current source
  file (a character string literal)<sup>[<a class="footnote" href="#ftn.idp1923712" name="idp1923712">138</a>]</sup></p><p><code class="code">__LINE__</code> The presumed line number (within the
  current source file) of the current source line (an integer
  constant).<sup>[<a class="footnote" href="#ftn.line" name="line">139</a>]</sup></p><p><code class="code">__STDC__</code> The integer constant 1, intended to
  indicate a conforming implementation. <code class="code">__STDC_HOSTED__</code> The
  integer constant 1 if the implementation is a hosted implementation or the
  integer constant 0 if it is not.</p><p><code class="code">__STDC_VERSION__</code> The integer constant
  199901L.<sup>[<a class="footnoteref" href="index.html#ftn.line">139</a>]</sup></p><p><code class="code">__TIME__</code> The time of translation of the
  preprocessing translation unit: a character string literal of the form
  "hh:mm:ss" as in the time generated by the asctime function. If the time of
  translation is not available, an implementation-defined valid time shall be
  supplied.</p><p>The following macro names are conditionally defined by the
  implementation: <code class="code">__STDC_IEC_559__</code> The integer constant 1,
  intended to indicate conformance to the specifications in annex F (IEC 60559
  floating-point arithmetic).</p><p><code class="code">__STDC_IEC_559_COMPLEX__</code> The integer constant 1,
  intended to indicate adherence to the specifications in informative annex G
  (IEC 60559 compatible complex arithmetic).</p><p>__STDC_ISO_10646__</p><p> An integer constant of the form
  yyyymmL (for example, 199712L). If this symbol is defined, then every
  character in the Unicode required set, when stored in an object of type
  <code class="code">wchar_t</code>, has the same value as the short identifier of that
  character. The Unicode required set consists of all the characters that are
  defined by ISO/IEC 10646, along with all amendments and technical corrigenda,
  as of the specified year and month.</p><p>The values of the predefined macros (except for
  <code class="code">__FILE__</code> and <code class="code">__LINE__</code>) remain constant
  throughout the translation unit.</p><p>None of these macro names, nor the identifier defined, shall be the
  subject of a <code class="code">#define</code> or a <code class="code">#undef</code>
  preprocessing directive. Any other predefined macro names shall begin with a
  leading underscore followed by an uppercase letter or a second
  underscore.</p><p>The implementation shall not predefine the macro
  <code class="code">__cplusplus</code>, nor shall it define it in any standard
  header.</p><p><span class="bold"><strong>Forward references:</strong></span> the asctime
  function (13.23.3.1), standard headers (13.1.2).</p></div><div class="sect1" title="12.9. Pragma Operator"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1938800"></a>12.9. Pragma Operator</h2></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A unary operator expression of the form:</p><pre class="CLexer"><div class="highlight"><pre><span class="n">_Pragma</span> <span class="p">(</span> <span class="n">string</span><span class="o">-</span><span class="n">literal</span> <span class="p">)</span>
</pre></div>
</pre><p>is processed as follows: The string literal is destringized by
  deleting the L prefix, if present, deleting the leading and trailing
  double-quotes, replacing each escape sequence \" by a double-quote, and
  replacing each escape sequence \\ by a single backslash. The resulting
  sequence of characters is processed through translation phase 3 to produce
  preprocessing tokens that are executed as if they were the pp-tokens in a
  pragma directive. The original four preprocessing tokens in the unary
  operator expression are removed.</p><p>At this point specification material ends here and now we will see
  usage of above discussed macros.</p></div><div class="sect1" title="12.10. Usage"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp1943264"></a>12.10. Usage</h2></div></div></div><p>Note that for this part the compilation command should be
  <code class="code">clang -E filename.c</code>. Let us create two files
  <code class="code">test.c</code> and <code class="code">test1.c</code> and their contents are
  given below respectively.</p><div class="sect2" title="12.10.1. #include"><div class="titlepage"><div><div><h3 class="title"><a name="idp1945888"></a>12.10.1. #include</h3></div></div></div><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &quot;test1.c&quot;</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">test</span><span class="p">.</span>
</pre></div>
</pre><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &quot;test.c&quot;</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">test1</span><span class="p">.</span>
</pre></div>
</pre><p>Keep both the files in same directory and execute <code class="code">clang -E
test.c</code> you will see following:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp"># 1 &quot;test.c&quot;</span>
<span class="cp"># 1 &quot;test.c&quot; 1</span>
<span class="cp"># 1 &quot;&lt;built-in&gt;&quot; 1</span>
<span class="cp"># 1 &quot;&lt;built-in&gt;&quot; 3</span>
<span class="cp"># 143 &quot;&lt;built-in&gt;&quot; 3</span>
<span class="cp"># 1 &quot;&lt;command line&gt;&quot; 1</span>
<span class="cp"># 1 &quot;&lt;built-in&gt;&quot; 2</span>
<span class="cp"># 1 &quot;test.c&quot; 2</span>
<span class="cp"># 1 &quot;./test1.c&quot; 1</span>
<span class="p">...</span>
<span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="n">from</span> <span class="n">test</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span>
<span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="n">from</span> <span class="p">.</span><span class="o">/</span><span class="n">test1</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span>
<span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="n">from</span> <span class="n">test</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span>
<span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="n">from</span> <span class="p">.</span><span class="o">/</span><span class="n">test1</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span>
<span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="n">from</span> <span class="n">test</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span>
<span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="n">from</span> <span class="p">.</span><span class="o">/</span><span class="n">test1</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span>
<span class="p">...</span>
<span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="n">from</span> <span class="n">test</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span>
<span class="p">.</span><span class="o">/</span><span class="n">test1</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> <span class="n">nested</span> <span class="n">too</span> <span class="n">deeply</span>
<span class="cp">#include &quot;test.c&quot;</span>

<span class="n">I</span> <span class="n">am</span> <span class="n">test1</span><span class="p">.</span>
<span class="cp"># 2 &quot;test.c&quot; 2</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">test</span>
<span class="cp"># 2 &quot;./test1.c&quot; 2</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">test1</span><span class="p">.</span>
<span class="cp"># 2 &quot;test.c&quot; 2</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">test</span>
<span class="cp"># 2 &quot;./test1.c&quot; 2</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">test1</span><span class="p">.</span>
<span class="cp"># 2 &quot;test.c&quot; 2</span>
</pre></div>
</pre><p>As you can see <code class="code">test.c</code> includes
<code class="code">test1.c</code> and <code class="code">test1.c</code> includes
<code class="code">test.c</code>. So they are including each other which is causing
nested includes. After processesing for some time preprocessor’s head starts
spinning as if it has drunk a full bottle of rum and it bails out. As you know
headers are included in all meaningful C programs and headers include each
other as well. This inclusion of each other can easily lead to nested inclusion
so how do header authors circumvent this problem. Well, a technique has been
devised known popularly as header guard. The lines which have the form
<code class="code">#</code> number text is actually <code class="code"># line</code>
directive.</p><p>Consider following code:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#ifndef ANYTHING</span>
<span class="cp">#define ANYTHING</span>

<span class="cp">#include &quot;test1.c&quot;</span>

<span class="n">I</span> <span class="n">am</span> <span class="n">test</span><span class="p">.</span>

<span class="cp">#endif</span>
</pre></div>
</pre><pre class="CLexer"><div class="highlight"><pre><span class="cp">#ifndef ANYTHING_ELSE</span>
<span class="cp">#define ANYTHING_ELSE</span>

<span class="cp">#include &quot;test.c&quot;</span>

<span class="n">I</span> <span class="n">am</span> <span class="n">test1</span><span class="p">.</span>

<span class="cp">#endif</span>
</pre></div>
</pre><p>Now what will happen that when <code class="code">test.c</code> is included
<code class="code">ANYTHING</code> is defined and when <code class="code">test1.c</code> is
included via it <code class="code">ANYTHING_ELSE</code> will be defined. After first
round of inclusion no more inclusion can happen as governed by the
directives. Please see headers of standard library to see the conventions for
<code class="code">ANYTHING</code>.</p></div><div class="sect2" title="12.10.2. Why we need headers?"><div class="titlepage"><div><div><h3 class="title"><a name="idp1959056"></a>12.10.2. Why we need headers?</h3></div></div></div><p>Now that we have seen the <code class="code">#include</code> directive I
    would like to tell that why we even need header files. Header files contain
    several elements of libraries which come with C. For example, function
    prototypes, structure/type, declarations, macros, global variable
    declaration etc. Actual code resides inside <code class="code">*.a</code> or
    <code class="code">*.so</code> library files on GNU/Linux or UNIX OSes. Now let us
    consider a case that we want to access a C function of standard
    library. The compilation phase requires that prototype of function should
    be known at compilation time. If we do not have headers we have no way to
    provide this function prototype at compile time. Same stands true for
    global variables. The declaration of these must be known at compilation
    time. You take any language there has to be a mechanism to include code
    from other files. Be it use directive of Perl or import of Python or any
    other mechanism of any other language.</p></div><div class="sect2" title="12.10.3. #define"><div class="titlepage"><div><div><h3 class="title"><a name="idp1962640"></a>12.10.3. #define</h3></div></div></div><p><code class="code">#define</code> and <code class="code">#include</code> are probably
    the most encountered macro in all C files. There are many usage of it. We
    will first see the text replacement and function like usage which can be
    avoided and should be replaced by global constants and inline
    functions. First let us see what text replacement functionality we get
    using <code class="code">#define</code>. Consider the following code
    fragment:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#define MAX 5</span>

<span class="n">MAX</span>

<span class="n">I</span> <span class="n">am</span> <span class="n">MAX</span>
</pre></div>
</pre><p>Now run it though <code class="code">clang -E filename.c</code> and you will get
following output:</p><pre class="screen"># 1 "test.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "test.c"


5

I am 5</pre><p>So as you see both the occurrences are replaced by the text 5. This is
the simplest form of text replacement which people use to handle many
things. Most common are array sizes and symbolic constants. Another form is the
form like functions which has been shown in 10.4.</p><p>The bad part of these two is that both do not enter symbol table and
make code hard to debug. The former can be replaced by const variables and
latter by inline functions.</p><p>The other usage of it is to define names. For example, we revisit our
old example headers. Header guards usually declare something like
this:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#ifndef SOMETHING</span>
<span class="cp">#define SOMETHING</span>

<span class="cm">/* header code */</span>
<span class="cp">#endif</span>
</pre></div>
</pre><p>As you can see <code class="code">#define</code> is used to define
<code class="code">SOMETHING</code> so second time the conditional inclusion
<code class="code">#ifndef</code> will fail. It can also be tested by defiend like
<code class="code">if(defined(SOMETHING)</code>. Now if <code class="code">SOMETHING</code> has
been defined if test will pass successfully. Similarly <code class="code">#ifdef</code>
can be used to test it as a shortcut i.e. <code class="code">#ifdef
SOMETHING</code>. The normal if-else statements are replaced in preprocessing
directives using <code class="code">#if, #elif</code> and
<code class="code">#endif</code>.</p></div><div class="sect2" title="12.10.4. #undef"><div class="titlepage"><div><div><h3 class="title"><a name="idp1975008"></a>12.10.4. #undef</h3></div></div></div><p>Anything defined by <code class="code">#define</code> can be undefined by
    <code class="code">#undef</code>. For example consider the following code:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#define test</span>
<span class="cp">#ifdef test</span>

<span class="c1">//do something</span>

<span class="cp">#undef test</span>
<span class="cp">#ifdef test</span>

<span class="c1">//do something else</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</pre><p>If you do this then first something else will be executed while the
second will not be.</p></div><div class="sect2" title="12.10.5. # and ##"><div class="titlepage"><div><div><h3 class="title"><a name="idp2467104"></a>12.10.5. # and ##</h3></div></div></div><p>You can use following two examples and description given above to
    understand both of these:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#define hash_hash # ## #</span>
<span class="cp">#define mkstr(a) # a</span>
<span class="cp">#define in_between(a) mkstr(a)</span>
<span class="cp">#define join(c, d) in_between(c hash_hash d)</span>

<span class="kt">char</span> <span class="n">p</span><span class="p">[]</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">//char p[]=&quot;x ## y&quot;</span>

<span class="cp">#define FIRST a # b</span>
<span class="cp">#define SECOND a ## b</span>

<span class="kt">char</span> <span class="n">first</span><span class="p">[]</span> <span class="o">=</span> <span class="n">FIRST</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">second</span><span class="p">[]</span> <span class="o">=</span> <span class="n">SECOND</span><span class="p">;</span>
</pre></div>
</pre></div><div class="sect2" title="12.10.6. #error"><div class="titlepage"><div><div><h3 class="title"><a name="idp2469488"></a>12.10.6. #error</h3></div></div></div><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="err">#</span> <span class="n">error</span> <span class="n">MAX</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>If you try to compile this like <code class="code">clang filename.c</code> then
you will get following:</p><pre class="screen">clang test.c
test.c:5:5: error: #error MAX
  # error MAX
  ^
1 error generated.</pre><p>You can combine <code class="code"># error</code> with <code class="code">#if</code> but
I have yet to see purposeful code written that way. Non-preprocessing
constructs are better for handling such situations. Only if you want to test a
preprocessing token then it should be used.</p></div><div class="sect2" title="12.10.7. #pragma"><div class="titlepage"><div><div><h3 class="title"><a name="idp2474032"></a>12.10.7. #pragma</h3></div></div></div><p><code class="code">#pragma</code> is dependent on what follows it. You
    should consult compiler documentation as it is mostly
    implementation-defined. It is a way to tell compiler to do things which are
    not governed by specification.</p></div><div class="sect2" title="12.10.8. Miscellaneous"><div class="titlepage"><div><div><h3 class="title"><a name="idp2475856"></a>12.10.8. Miscellaneous</h3></div></div></div><p>Usage of <code class="code">__LINE__, __FILE__, __DATE__</code> and
    <code class="code">__TIME__</code> is simple and shown in following
    example:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s:%d:%s:%s&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">__DATE__</span><span class="p">,</span> <span class="n">__TIME__</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre>
and the output is:
<pre class="screen">test.c:5:Jun 24 2012:11:24:57</pre><p>This concluded our discussion on macros. Rest of the book will describe
the standard library.</p></div></div><div class="footnotes"><br/><hr align="left" width="100"/><div class="footnote"><p><sup>[<a class="para" href="#idp722736" id="ftn.idp722736">128</a>] </sup>Thus, preprocessing directives are
    commonly called “lines”. These “lines” have no other syntactic
    significance, as all white space is equivalent except in certain situations
    during preprocessing (see the # character string literal creation operator
    in 12.3.2, for example).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp866032" id="ftn.idp866032">129</a>] </sup>Because the controlling constant
  expression is evaluated during translation phase 4, all identifiers either
  are or are not macro names - there simply are no keywords, enumeration
  constants, etc.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp2349392" id="ftn.idp2349392">130</a>] </sup>Thus, on an implementation
where <code class="code">INT_MAX</code> is <code class="code"></code> and
<code class="code">UINT_MAX</code> is <code class="code">0xFFFF</code>, the constant
<code class="code">0x8000</code> is signed and positive within a <code class="code">#if</code>
expression even though it would be unsigned in translation phase
7.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp2353776" id="ftn.idp2353776">131</a>] </sup>Thus, the constant expression in
the following <code class="code">#if</code> directive and if statement is not guaranteed
to evaluate to the same value in these two contexts.
</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#if &#39;z&#39; - &#39;a&#39; == 25</span>

<span class="k">if</span> <span class="p">(</span><span class="sc">&#39;z&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">==</span> <span class="mi">25</span><span class="p">)</span>
</pre></div>
</pre></div><div class="footnote"><p><sup>[<a class="para" href="#idp2359312" id="ftn.idp2359312">132</a>] </sup>As
indicated by the syntax, a preprocessing token shall not follow a #else or
#endif directive before the terminating new-line character. However, comments
may appear anywhere in a source file, including within a preprocessing
directive.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp2370688" id="ftn.idp2370688">133</a>] </sup>Note that adjacent string literals are not
concatenated into a single string literal; thus, an expansion that results in
two string literals is an invalid directive.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp585600" id="ftn.idp585600">134</a>] </sup>Since, by macro-replacement time, all
  character constants and string literals are preprocessing tokens, not
  sequences possibly containing identifier-like subsequences, they are never
  scanned for macro names or parameters.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp590480" id="ftn.idp590480">135</a>] </sup>Despite the name, a non-directive is a
preprocessing directive.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp607504" id="ftn.idp607504">136</a>] </sup>Placemarker preprocessing
  tokens do not appear in the syntax because they are temporary entities that
  exist only within translation phase 4.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp1911232" id="ftn.idp1911232">137</a>] </sup>An
  implementation is not required to perform macro replacement in pragmas, but
  it is permitted except for in standard pragmas (where <code class="code">STDC</code>
  immediately follows pragma). If the result of macro replacement in a
  non-standard pragma has the same form as a standard pragma, the behavior is
  still implementation-defined; an implementation is permitted to behave as if
  it were the standard pragma, but is not required to.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp1923712" id="ftn.idp1923712">138</a>] </sup>The presumed source file
  name and line number can be changed by the <code class="code">#line</code>
  directive.</p></div><div class="footnote"><p><sup>[<a class="para" href="#line" id="ftn.line">139</a>] </sup>This macro was not specified in
  ISO/IEC 9899:1990 and was specified as 199409L in ISO/IEC 9899/AMD1:1995. The
  intention is that this will remain an integer constant of type long int that
  is increased with each revision of International
  Standard.</p></div></div></div><div class="navfooter"><hr/><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="../su/index.html">Prev</a> </td><td align="center" width="20%"> </td><td align="right" width="40%"> <a accesskey="n" href="../std/index.html">Next</a></td></tr><tr><td align="left" valign="top" width="40%">Chapter 11. Structures and Unions </td><td align="center" width="20%"><a accesskey="h" href="../index.html">Home</a></td><td align="right" valign="top" width="40%"> Chapter 13. The C Standard Library</td></tr></table></div><p style="text-align: center;" xmlns:d="http://docbook.org/ns/docbook" xmlns:exsl="http://exslt.org/common" xmlns:fo="http://www.w3.org/1999/XSL/Format">© 2010, 2013 Shiv S. Dayal. <a href="http://libreprogramming.org">libreprogramming.org</a>.
   GNU FDL license is applicable where not stated.</p></body></html>