<?xml version="1.0" encoding="UTF-8"?>
<d:book version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
  <d:info>
    <d:title>C Programming with C99</d:title>
    <d:author>
      <d:personname>
        <d:firstname>Shiv</d:firstname>
        <d:surname>Dayal</d:surname>
      </d:personname>
    </d:author>
    <d:copyright>
      <d:year>2011, 2013</d:year>
      <d:holder>Shiv S. Dayal</d:holder>
    </d:copyright>
  </d:info>
  <xi:include href="preface.xml"/>
  <xi:include href="introduction.xml"/>
  <xi:include href="fs.xml" />
  <xi:include href="env.xml" />
  <xi:include href="lang.xml" />
  <xi:include href="basics.xml" />
    <d:chapter><?dbhtml filename="io/index.html" ?>
    <d:title>Console I/O</d:title>
    <d:para>What is I/O? I know you may be wondering what rubbish question? It is input/output.
      Well, yes you are right. However, i/o can be further categorized in several categories. First
      of them is console i/o, which is what we are concerned with. In console i/o your keyboard is
      input device or <d:code>stdin</d:code> file stream and display device or monitor is output
      device or <d:code>stdout</d:code> file stream. There is also also something called
        <d:code>stderr</d:code> which is standard error file stream. For historical reasons these
      are known as <d:code>FILE</d:code>, which, happens to be the data type for handling these
      streams. Then there are more different kind of i/o. In everyday usage you use mouse to handle
      GUI. Standard C99 does not have anything for mouse. For your hard disk i/o that is real files
      like our source code files and executable file same FILE stream is used. Network i/o is also
      there. There is an opengroup which specifies functions for network related functions. Some
      operating system like GNU/Linux are POSIX compatible which defines how network i/o will be
      used. Even a printer is a special output device, a camera input, speakers output, microphone
      input and so on. However, before we go on with i/o I would like to present C’s memory model
      which will be needed by our discussion of i/o related functions. However, if things do not
      make sense even then please go through it and come later to understand more.</d:para>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">C's Memory Model</title>
      <d:para>C programs use <d:hardware>RAM</d:hardware> as primary memory except when you use
        register keyword to request compiler to store variables in cpu register. C’s memory model is
        split into three area at a higher level. Data, Stack and Code Segment. Date is further split
        in three parts; initialized data segment, uninitialized data segment or BSS which is name
        after an ancient assembler Block Started by Symbol and heap. Initialized data segment
        contains initialized global variables and static variables. Here both global and local
        static variables are counted. For uninitialized data segment it is same as above just that
        the variables are not initialized explicitly but implicitly to zero. Next is heap. Heap is
        the largest area of memory used for dynamic memory allocation. As you will see later that
        you can manage heap using <d:code>malloc(), calloc(), realloc(),</d:code> and
          <d:code>free()</d:code>. Note that compiler does not manage memory allocated for you. You,
        the programmer, are responsible for allocating and freeing up memory in area. If heap gets
        full os will use virtual memory or swap space on hard disk. Objects allocated on heap
        persist across function calls. However, there are some very nasty problems, which, come in
        picture when you use heap. There are several of them. You may forget to allocate memory and
        want to dereference unallocated pointer. You may have initialized it to
          <d:code>NULL</d:code> and try to dereference that. You may allocate and free twice. You
        forgot to set pointer to <d:code>NULL</d:code> after freeing it. And last but not the least
        you loose all pointers to the memory area before you can free. The nature with this
        particular problem is that if your program is going to run for long time then it is going to
        consume more and more memory. Because of its nature it is known as memory leak. It is very
        difficult to detect such problems in code which does not run for long periods of time. Our
        friend valgrind will come to help up with this problem. When a memory leak happens it eats
        up <d:hardware>RAM</d:hardware> slowly and then operating system has to use virtual memory
        as explained above. In a nutshell, I will say that heap means you have to handle
        it.</d:para>
      <d:para>Stack is relatively simple. All non-static and non-register variables go on stack.
        Stack variables do not retain there value across function calls unless they are passed as
        pointers. Also, when they go out of scope, that is the scope in which they were declared
        ends, they will be kind of lost. The way in which stack frame moves the same area will be
        used for new variables. However, stack is very limited (compared to heap) and in deeply
        nested function calls or recursion (you will see these in Functions chapter) stack may get
        full and program may crash. The reason for crashing is that operating system will not use
        virtual memory but will do a segmentation fault in its place. GNU/Linux allow its users to
        modify the stack size by ulimit command. Note that stack and heap are adjacent in memory and
        grow in opposite direction.</d:para>
      <d:para>Code segment or text segment is an area where the executable instructions of program
        reside. It is typically constant and read-only area unless your system allows self-modifying
        code. Following diagram shows the memory layout.</d:para>
      <d:figure>
        <d:title>C's Memory Model</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="images/memmod.png"/>
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
      <d:para>In this chapter we will look at only those functions, which, allow us to do console
        i/o. We will begin with our familiar friends. Can you guess who are they? Yes! They are
          <d:code>printf</d:code> and <d:code>scanf</d:code>.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>printf</d:title>
      <d:para><d:code>printf</d:code> is a string based output function that is It writes character
        strings to <d:code>stdout</d:code>. The data which has to be written is formatted by format
        string as shown previously. After the format specifier it expects as many arguments as
        specified in format string. The characters which are not like, say <d:code>%d</d:code> for
        example, arecalled ordinary characters. These are simply copied to output stream, which, is
          <d:code>stdout</d:code> for <d:code>printf</d:code>. The <d:code>%d</d:code> like
        conversion charcaters are known as conversion specification or format specifiers. Each
        conversion specification should be augmented with one one argument. The results are
        undefined if there are insufficient arguments for the format. If extra arguments are given
        the excess arguments will be evaluated but are otherwise ignored. However, there is a big
        problem here! There is no type-safety.:-( In general compiler will warn you about it and
        you, the programmer, are responsible for giving correct format string, correct no. of
        correct type of arguments. Consider the following program for
        example:<d:programlisting role="CLexer">// printf demo
// Author: Shiv Shankar Dayal
// Description: printf demo

#include &lt;stdio.h>

int main()
{
  printf("%d %d\n", 3, 8);

  //do not mess it. undefined behavior
  printf("%d %d\n", 5);

  //extra arguments ignored
  printf("%d %d\n", 3, 5, "hello");

  //legal because char is integer type
  printf("%d\n", 's');

  //wrap around of integer as char
  printf("%c\n", 836);

  //do not mess with type-safety
  int i = printf("%d\n", "hello");
  prinf("%d\n", i);

  return 0;
}</d:programlisting>
        now that if you give the command like <d:code>clang printf.c</d:code> then you will be shown
        following warnings:
        <d:screen>printf.c:12:14: warning: more '%' conversions than data arguments [-Wformat]
        printf("%d %d\n", 5);
                 ~^
printf.c:15:26: warning: data argument not used by format string [-Wformat-extra-args]
        printf("%d %d\n", 3, 5, "hello");
             ~~~~~~~~~        ^
printf.c:24:19: warning: conversion specifies type 'int' but the argument has type
'char *' [-Wformat]
      int i = printf("%d\n", "hello");
                      ~^     ~~~~~~~
                      %s
3 warnings generated.</d:screen>
        Clearly this is not a good sign for any program. A program should compile cleanly. In our
        case compiler is generating binary even though there are warnings. You can make compiler
        generate more warnings by issuing a <d:code>-Wall</d:code> flag. You can also treat all
        warnings as errors by passing <d:code>-Werror</d:code> to compiler. These two options will
        ensure that your code has no warnings. Now let us move to output and try to understand it.
        The output on my system is as given below. It may differ on your system:
        <d:screen>3 8
5 8
3 5
115
D
134514119
10</d:screen> First
          <d:code>printf</d:code> is correct as expected. The second line causes undefined behavior.
        You may think it is the previous 8 but rest assured it is not guaranteed that it will always
        the case. Ii is <d:emphasis role="bold">UNDEFINED</d:emphasis>. Third printf is also fine in
        the sense that extra argument is ignored. Fourth and fifth are normal. Sixth is again a big
        problem. You are trying to print a decimal integer while argument is a character string.
        There is no way for compiler to determine that what should be printed which will fit on
        standards. Now we will have to take a look at all possible format specifier and their
        meanings. You have seen most of them so this is more for a reference. I have taken following
        from <d:link xlink:href="http://www3.opengroup.org">http://www3.opengroup.org</d:link> and
        modified to suit the book. In particular, I have omitted facts related to XSI specification. </d:para>
      <d:para>Each conversion specification starts with '<d:code>%</d:code>' character. After this
        following appear in sequence:</d:para>
      <d:itemizedlist>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">Zero or more flags, in any order, which modify
            the meaning of the conversion specification.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional minimum field width. If the
            converted value from argument has fewer characters (bytes) than the field width, it will
            be padded with spaces by default on left; it will be padded on right if the
            left-adjustment flag (‘-‘) is given to the field width. The field width takes the form
            of an asterisk or a decimal integer.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional precision that gives the minimum
            number of digits to appear for the <code>d, i, o, u, x</code> and <code>X</code>
            conversion specifiers; the number of digits to appear for radix character for the
              <code>a, A, e, E, f</code> and <code>F</code> conversion specifiers; the maximum
            number of significant digits for the <code>g</code> and <code>G</code> conversion
            specifiers; or the maximum number of bytes to be printed from a string in the s
            conversion specifiers. The precision takes form of a period (‘.’) followed either by an
            asterisk (‘*’), described below, or an optional decimal digit string, where a null digit
            string is treated as zero. If a precision appears with any other conversion specifier,
            the behavior is undefined.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional length modifier that specifies the
            size of the argument.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">A conversion specifier character that
            indicates the type of conversion to be applied.</para>
        </d:listitem>
      </d:itemizedlist>
      <d:para>A field width, or precision, or both, may be indicated by an asterisk(‘*’). In this
        case an argument of type int supplies the field width or precision. You, the programmer,
        will have to ensure that arguments specifying field, width or precision, or both appear in
        that order before the argument, if any to be converted. A negative field width is taken as a
        ‘-‘ flag followed a positive field width. A negative precision is taken as if the precision
        were omitted.</d:para>
      <d:para>The flag characters and their meanings are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">-</emphasis> The result of
        the conversion will be left-justified within the field. The conversion is right-justified if
        the flag is not specified.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">+</emphasis> The result of
        a signed conversion will always begin with a sign (‘+’ or ‘-‘). The conversion will begin
        with a sign only when a negative value is converted if this value is not specified.</d:para>
      <d:para>If the first character of a signed conversion is not a sign or if a signed conversion
        results in no characters, a will be prefixed to the result. This means that if the and ‘+’
        flags both appear, the flag will be ignored.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">#</emphasis> Specifies
        that the value is to be converted to an alternative form. For o conversion, it increases the
        precision (if necessary) to force the first digit of the result to be zero. For
          <d:code>x</d:code> or <d:code>X</d:code> conversion specifiers, a non-zero result will
        have <d:code>0x (0X)</d:code> prefixed to it. For <d:code>a, A, e, E, f, F, g</d:code> and
          <d:code>G</d:code> conversion specifiers, the result will always contain a radix
        character, even if no digits follow the radix character. Without this flag, a radix
        character appears in the result of these conversions only if a digit follows it.</d:para>
      <d:para>For 0 and <d:code>G</d:code> conversion specifiers, trailing zeros will not be removed
        from the result as they normally are. For other conversion specifiers the, the behavior is
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">UNDEFINED</emphasis>.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">0</emphasis> For
          <d:code>d, i, o, x, X, a, A, e, E, f, F, g</d:code> and <d:code>G</d:code> conversion
        specifiers, leading zeros (following any indication of sign or base) are used to pad to the
        field width; no space padding is performed. If the ‘0’ and ‘-‘ flags both appear, the ‘0’
        flag is ignored. For <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion
        specifiers, if a precision is specified, the ‘0’ flag is ignored.</d:para>
      <d:para>The length and their meanings are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">hh</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifiers
        applies to a <d:code>signed char</d:code> or <d:code>unsigned char</d:code> argument (the
        argument will have been promoted according to integer promotions, but its value will be
        converted to <d:code>signed char</d:code> or <d:code>unsigned char</d:code> before printing;
        or that a following n conversion specifier applies to a pointer to a <d:code>signed
          char</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">h</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>short</d:code> or <d:code>unsigned short</d:code> argument (the
        argument will have been promoted according to the integer promotions, but its value will be
        converted to <d:code>short</d:code> or <d:code>unsigned short</d:code> before printing); or
        that a following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>short</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">l</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>long</d:code> or <d:code>unsigned long</d:code> argument; that a
        following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>long</d:code> argument; that a following <d:code>c</d:code> conversion specifier
        applies to a <d:code>win_t</d:code> argument; that a following <d:code>s</d:code> conversion
        specifier applies to a <d:code>wchar_t</d:code> argument; or has not effect on a following
          <d:code>a, A, e, R, f, F, g</d:code> or <d:code>G</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">ll</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>long long</d:code> or <d:code>unsigned long long</d:code> argument;
        that a following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>long long</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">j</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to an <d:code>intmax_t</d:code> or <d:code>uintmax_t</d:code> argument; or that a
        following <d:code>n</d:code> conversion specifier applies to an <d:code>intmax_t</d:code>
        argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">z</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>size_t</d:code> or the corresponding signed integer type argument; or
        that a following <d:code>n</d:code> conversion specifier applies to a signed integer type
        corresponding to a <d:code>size_t</d:code> argument.</d:para>
      <d:para><d:code>t</d:code> Specifies that a following <d:code>d, i, o, u, x</d:code> and
          <d:code>X</d:code> conversion specifier applies to a <d:code>ptrdiff_t</d:code> or the
        corresponding <d:code>unsigned int</d:code> type argument; or that a following
          <d:code>n</d:code> conversion specifier applies to a unsigned integer type corresponding
        to a <d:code>ptrdiff_t</d:code> argument.</d:para>
      <d:para><d:code>L</d:code> Specifies that a following <d:code>a, A, e, E, f, F, g</d:code> and
          <d:code>G</d:code> conversion specifier applies to a <d:code>long double</d:code>
        argument.</d:para>
      <d:para>If a length modifier appears with any conversion specfier other than as specified
        above, the behavior is <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >UNDEFINED</emphasis>. You may have noted data types like <d:code>intmax_t,
          size_t</d:code> and <d:code>ptrdiff_t</d:code>, which you may not know and I have not told
        you about them. But do not worry in due course of time we will see them.</d:para>
      <d:para>The conversion specifiers and their meaning are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">d, i</emphasis> The
          <d:code>int</d:code> argument will be converted to a signed decimal in the style
          “[-]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be converted in fewer digits, it will be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">o</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned octal format in the style
          “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be represented in fewer digits, it will be expanded with leading zeros. The default
        precision is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">u</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned decimal format in the
        style “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be represented in fewer digits, it will be expanded with leading zeros. The default
        precision is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">x</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned decimal format in the
        style “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”; the
        letters “abcdef” are used. The precision specifiers specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer digits, it will be
        expanded with leading zeros. The default precision is 1. The result of converting zero with
        an explicit precision of zero will be no characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">X</emphasis> Equivalent to
        the x conversion specifier, except that letters "<d:code>ABCDEF</d:code>" are used instead
        of "<d:code>abcdef</d:code>".</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">f, F</emphasis> The
          <d:code>double</d:code> argument will be converted to decimal notation in the style
          “[-]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">ddd.ddd</emphasis>”,
        where the number of digits after the radix character is equal to the precision
        specification. If the precision is missing, it will be taken as 6; if the precision is
        explicitly zero and no ‘#’ flag is present, no radix character will appear. If a radix
        character appears, at least one digit appears before it. The low-order digit will be rounded
        in an implementation-defined manner.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity will be converted in one
        of the styles “[-]<d:code>inf</d:code>” or “[-]<d:code>infinity</d:code>” ; which style is
        implementation-defined. A double argument representing a NaN will be converted in one of the
        styles “[-]<d:code>nan</d:code>(<emphasis xmlns="http://docbook.org/ns/docbook"
          role="italic">n-char-sequence</emphasis>)” or “[-]<d:code>nan</d:code>”; which style, and
        the meaning of any n-char-sequence, is implementation-defined. The F conversion specifier
        produces "<d:code>INF</d:code>", "<d:code>INFINITY</d:code>" or "<d:code>NAN</d:code>"
        instead of "<d:code>inf</d:code>", "<d:code>infinity</d:code>" or "<d:code>nan</d:code>",
        respectively.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">e, E</emphasis> The
          <d:code>double</d:code> argument will be converted in the style “[-]<emphasis
          xmlns="http://docbook.org/ns/docbook" role="italic">d.ddde</emphasis>[<d:inlineequation>
          <mml:math>
            <mml:mo>±</mml:mo>
          </mml:math>
        </d:inlineequation>]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
          >dd</emphasis>”, where there is one digit before the radix character (which is non-zero if
        the argument is non-zero) and the number of digits after it is equal to the precision; if
        the precision is missing, it will be taken as 6; if the precision is zero and no ‘#’ flag is
        present, no radix character will appear. The low-order digit will be rounded in an
        implementation-defined manner. The E conversion specifier will produce a number with ‘E’
        instead of ‘e’ introducing the exponent. The exponent will always contain at least two
        digits. If the value is zero, the exponent will be zero.</d:para>
      <d:para>A double argument representing an infinity or NaN will be converted in the style of an
          <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">g, G</emphasis> The double
        argument will be converted in the style <d:code>f</d:code> or <d:code>e</d:code> (or in the
        style <d:code>F</d:code> or <d:code>E</d:code> in the case of a <d:code>G</d:code>
        conversion specifier), with the precision specifying the number of significant digits. If an
        explicit precision is zero, it will be taken as 1. The style used depends on the value
        converted; style <d:code>e</d:code> (or <d:code>E</d:code> ) will be used only if the
        exponent resulting from such a conversion is less than -4 or greater than or equal to the
        precision. Trailing zeros will be removed from the fractional portion of the result; a radix
        character will appear only if it is followed by a digit or a ‘<d:code>#</d:code>’ flag is
        present.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity or NaN will be converted
        in the style of an <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><d:code>a, A</d:code> A <d:code>double</d:code> argument representing a floating-point
        number will be converted in the style “[-]<emphasis xmlns="http://docbook.org/ns/docbook"
          role="italic">0xh.hhhhp</emphasis>(<d:inlineequation>
          <mml:math>
            <mml:mo>±</mml:mo>
          </mml:math>
        </d:inlineequation>)<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
          >d</emphasis>”, where there is one hexadecimal digit (which will be non-zero if the
        argument is a normalized floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is equal to the
        precision; if the precision is missing and <d:code>FLT_RADIX</d:code> is a power of 2, then
        the precision will be sufficient for an exact representation of the value; if the precision
        is missing and <d:code>FLT_RADIX</d:code> is not a power of 2, then the precision will be
        sufficient to distinguish values of type <d:code>double</d:code>, except that trailing zeros
        may be omitted; if the precision is zero and the ‘<d:code>#</d:code>’ flag is not specified,
        no decimal-point character will appear. The letters "<d:code>abcdef</d:code>" will be used
        for a conversion and the letters "<d:code>ABCDEF</d:code>" for A conversion. The
          <d:code>A</d:code> conversion specifier produces a number with ‘<d:code>X</d:code>’ and
          ‘<d:code>P</d:code>’ instead of ‘<d:code>x</d:code>’ and ‘<d:code>p</d:code>’. The
        exponent will always contain at least one digit, and only as many more digits as necessary
        to represent the decimal exponent of 2. If the value is zero, the exponent will be
        zero.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity or NaN will be converted
        in the style of an <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">c</emphasis> The <emphasis
          xmlns="http://docbook.org/ns/docbook" role="bold">int</emphasis> argument will be
        converted to an <d:code>unsigned char</d:code>, and the resulting byte will be written. If
        an <d:code>l</d:code> qualifier is present, the <d:code>wint_t</d:code> argument will be
        converted as if by an <d:code>ls</d:code> conversion specification with no precision and an
        argument that points to a two-element array of type <d:code>wchar_t</d:code>, the first
        element of which contains the <d:code>wint_t</d:code> argument to the <d:code>ls</d:code>
        conversion specification and the second element contains a null wide character.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">s</emphasis> The argument
        will be a pointer to an array of <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >char</emphasis>. Bytes from the array will be written up to (but not including) any
        terminating null byte. If the precision is specified, no more than that many bytes will be
        written. If the precision is not specified or is greater than the size of the array, the
        programmer will ensure that the array contains a null byte. Note that it is a big problem
        which causes <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">strcpy</emphasis>
        to be insecure. What is the char array does not have this null terminating character? We
        will see a safe implementation of <d:code>strcpy</d:code> later. Also,
          <d:code>strlen</d:code> suffers from this problem. Any function relying on null character
        will suffer from this. If an <d:code>l</d:code> qualifier is present, the argument will be a
        pointer to an array of type <d:code>wchar_t</d:code>. Wide characters from the array will be
        converted to characters (each as if by a call to the <d:code>wcrtomb()</d:code> function,
        with the conversion state described by an <d:code>mbstate_t</d:code> object initialized to
        zero before the first wide character is converted) up to and including a terminating null
        wide character. The resulting characters will be written up to (but not including) the
        terminating null character (byte). If no precision is specified, the programmer will ensure
        that the array contains a null wide character. If a precision is specified, no more than
        that many characters (bytes) will be written (including shift sequences, if any), and the
        array will contain a null wide character if, to equal the character sequence length given by
        the precision, the function would need to access a wide character one past the end of the
        array. In no case will a partial character be written.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">p</emphasis> The argument
        will be a pointer to <d:code>void</d:code>. The value of the pointer is converted to a
        sequence of printable characters, in an implementation-defined manner.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">n</emphasis> The argument
        will be a pointer to an <d:code>int</d:code> into which is written the number of bytes
        written to the output so far by this call to one of the fprintf() functions. No argument is
        converted.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">%</emphasis> Print a
          ‘<d:code>%</d:code>’ character; no argument is converted. The complete conversion
        specification will be <d:code>%%</d:code>.</d:para>
      <d:para>If a conversion specification does not match one of the above forms, the behavior is
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">UNDEFINED</emphasis>. If any
        argument is not the correct type for the corresponding conversion specification, the
        behavior is undefined. This is what happened to out string in <d:code>printf.c</d:code>
        shown above. In no case will a nonexistent or small field width cause truncation of a field;
        if the result of a conversion is wider than the field width, the field will be expanded to
        contain the conversion result. Characters generated by <d:code>fprintf()</d:code> and
          <d:code>printf()</d:code> are printed as if <d:code>fputc()</d:code> had been
        called.</d:para>
      <d:para>For the <d:code>a</d:code> and <d:code>A</d:code> conversion specifiers, if
          <d:code>FLT_RADIX</d:code> is a power of 2, the value will be correctly rounded to a
        hexadecimal floating number with the given precision. For <d:code>a</d:code> and
          <d:code>A</d:code> conversions, if <d:code>FLT_RADIX</d:code> is not a power of 2 and the
        result is not exactly representable in the given precision, the result should be one of the
        two adjacent numbers in hexadecimal floating style with the given precision, with the extra
        stipulation that the error should have a correct sign for the current rounding
        direction.</d:para>
      <d:para>For the <d:code>e, E, f, F, g</d:code> and <d:code>G</d:code> conversion specifiers,
        if the number of significant decimal digits is at most <d:code>DECIMAL_DIG</d:code>, then
        the result should be correctly rounded. If the number of significant decimal digits is more
        than <d:code>DECIMAL_DIG</d:code> but the source value is exactly representable with
          <d:code>DECIMAL_DIG</d:code> digits, then the result should be an exact representation
        with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
          <d:code>L &lt; U</d:code>, both having <d:code>DECIMAL_DIG</d:code> significant digits;
        the value of the resultant decimal string <d:code>D</d:code> should satisfy <d:code>L &lt;=
          D &lt;= U</d:code>, with the extra stipulation that the error should have a correct sign
        for the current rounding direction.</d:para>
      <d:para>Some of the capitalized words like <d:code>DECIMAL_DIG, FLT_RADIX</d:code> etc are
        macros defined in <d:code>float.h</d:code>. You should have a look at it. Now we will have
        one example and I will show you output but not explain it. Understanding the output is left
        as an exercise to you, the reader.</d:para>
      <d:programlisting role="CLexer">// Format Specifiers
// Author: Shiv S. Dayal
//Desciption: It is a demo of several format specifiers

#include&lt;stdio.h>

int main()
{
  int i   = 343456;
  float f = 123;
  long double ld = 78939.9347;

  printf("% d\n", i);
  printf("%+d\n", i);
  printf("%#o\n", i);
  printf("%#f\n", f);
  printf("%-08i\n", i);
  printf("%08i\n", i);
  printf("%8i\n", i);
  printf("%hhi\n", i);
  printf("%hi\n", i);
  printf("%li\n", i);
  printf("%lli\n", i);
  printf("%ji\n", i);
  printf("%zi\n", i);
  printf("%ti\n", i);
  printf("%8.8f\n", f);
  printf("%8.8Lf\n", ld);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen> 343456
+343456
01236640
123.000000
343456
00343456
  343456
-96
15776
343456
4638355772471066016
4638355772471066016
343456
343456
123.00000000
78939.93470000</d:screen>
<d:para>I suggest you to read the desciption of conversion specifiers
and experiment with various parameters to get different kind of
output.</d:para>
    </d:sect1>
    <d:sect1><d:title>scanf</d:title>
    <d:para><d:code>scanf()</d:code> is sister of
    <d:code>printf()</d:code>. They work in tandem. As its
    name says scan function it scans <d:code>stdin</d:code> or
    keyboard for input. Its signature is same as that of printf(). It
    raeds bytes from keyboard input, interprets them according to
    format string. It also expects a set of pointer arguments as
    opposed to values for <d:code>printf()</d:code>. The 
    pointers indicate where the interpreted data from the input will
    be stored. The result is <d:emphasis
    role="bold">UNDEFINED</d:emphasis>
    if there are less number of pointer arguments than the number of
    conversion specifers in format string. Excess arguments will be
    evaluated but ignored. The format string can have only white-space
    characters or an ordinary character (neither ‘<d:code>%</d:code>’
    nor a white-space character) or a conversion specification. Each
    conversion specification is introduced by ‘<d:code>%</d:code>’,
    after which the following appear in sequence.</d:para>
    <d:itemizedlist>
      <d:listitem>
	<d:para>An optoinal assignment suppressing character
	‘<d:code>*</d:code>’.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>An optional non-zero decimal integer that specifies
	the maximum field width</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>An option length modifier that specifies the size of
	the receiving object.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>A conversion specifier character that specifies the
	type of conversion to be applied. The valid conversion
	specifiers are described below.</d:para>
      </d:listitem>
    </d:itemizedlist>
    <d:para>A directive composed of one or more white-space characters
    will be executed by reading input until no more valid input can be
    read, or up to the first byte which is not a white-space character,
    which remains unread.</d:para>
    <d:para>A directive that is an ordinary character will be executed
    as follows: the next byte will be read from the input and compared
    with the byte that comprises the directive; if the comparison
    shows that they are not equivalent, the directive will fail, and
    the differing and subsequent bytes will remain unread. Similarly,
    if end-of-file, an encoding error, or a read error prevents a
    character from being read, the directive will fail.</d:para>
    <d:para>A directive that is a conversion specification defines a set
    of matching input sequences, as described below for each conversion
    character. A conversion specification will be executed in the
    following steps.</d:para>
    <d:para>Input white-space characters (as specified by
    <d:code>isspace()</d:code>) will be skipped, unless the conversion
    specification includes a <d:code>[, c, C</d:code> or
    <d:code>n</d:code> conversion specifier.</d:para>
    <d:para>An item will be read from the input, unless the conversion
    specification includes an n conversion specifier. An input item
    will be defined as the longest sequence of input bytes (up to any
    specified maximum field width, which may be measured in characters
    or bytes dependent on the conversion specifier) which is an
    initial subsequence of a matching sequence. The first byte, if
    any, after the input item will remain unread. If the length of the
    input item is 0, the execution of the conversion specification
    will fail; this condition is a matching failure, unless
    end-of-file, an encoding error, or a read error prevented input
    from the stream, in which case it is an input failure.</d:para>
    <d:para>Except in the case of a <d:code>%n</d:code> conversion
    specifier, the input item (or, in the case of a
    <d:code>%n</d:code> conversion specification, the count 
    of input bytes) will be converted to a type appropriate to the
    conversion character. If the input item is not a matching
    sequence, the execution of the conversion specification fails;
    this condition is a matching failure. Unless assignment
    suppression was indicated by a '<d:code>*</d:code>', the result of
    the conversion will be placed in the object pointed to by the
    first argument following the format argument that has not already
    received a conversion result if the conversion specification is
    introduced by <d:code>%</d:code>. If this object does not have an
    appropriate type, or if the result of the conversion cannot be
    represented in the space provided, the behavior is
    undefined.</d:para>
    <d:para>The length modifiers and their meanings are:</d:para>
    <d:para><d:emphasis role="bold">hh</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>signed char</d:code> or <d:code>unsigned
    char</d:code>.</d:para>
    <d:para><d:emphasis role="bold">h</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>short</d:code> or <d:code>unsigned
    short</d:code>.</d:para>
    <d:para><d:emphasis role="bold">l</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>long</d:code> or <d:code>unsigned long</d:code>; that a
    following <d:code>a, A, e, E, f, F, g</d:code> or
    <d:code>G</d:code> conversion specifier applies to an argument
    with type pointer to <d:code>double</d:code>; or that a following
    <d:code>c, s</d:code> or <d:code>[ conversion</d:code> specifier
    applies to an argument with type pointer to
    <d:code>wchar_t</d:code>.</d:para>
    <d:para><d:emphasis role="bold">j</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>intmax_t</d:code> or <d:code>uintmax_t</d:code>.</d:para>
    <d:para><d:emphasis role="bold">z</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to
    <d:code>size_t</d:code> or the corresponding <d:code>signed int</d:code>
    type.</d:para>
    <d:para><d:emphasis role="bold">t</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to
    <d:code>ptrdiff_t</d:code> or the corresponding <d:code>unsigned
    type</d:code>.</d:para>
    <d:para><d:emphasis role="bold">L</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to <d:code>long
    double</d:code>.</d:para>
    <d:para>If a length modifier appears with any conversion specifier other
    than as specified above, the bahavior is undefined. The following
    conversion specifiers are valid:</d:para>
    <d:para><d:emphasis role="bold">d</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 10 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">i</d:emphasis> Matches an optionally signed
    integer, whose format is the same as expected for the subject sequence of
    <d:code>strtol() with</d:code> 0 for the base argument. In the absence of a
    size modifier, the programmer will ensure that the corresponding argument
    is a pointer to <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">code</d:emphasis> Matches an optionally
    signed octal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 8 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to unsigned.</d:para>
    <d:para><d:emphasis role="bold">u</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 10 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">x</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 16 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">a, e, f, g</d:emphasis> Matches an
    optionally signed floating-point number, infinity, or NaN, whose format is
    the same as expected for the subject sequence of
    <d:code>strtod(). In</d:code> the absence of a size modifier, the
    programmer will ensure that the corresponding argument is a pointer to
    float.</d:para>
    <d:para>If the <d:code>printf() family</d:code> of functions generates
    character string representations for infinity and NaN (a symbolic entity
    encoded in floating-point format) to support IEEE Std 754-1985, the
    <d:code>scanf() family</d:code> of functions will recognize them as
    input.</d:para>
    <d:para><d:emphasis role="bold">s</d:emphasis> Matches a sequence of bytes
    that are not white-space characters. The programmer will ensure that the
    corresponding argument is a pointer to the initial byte of an array (will
    see them later) of <d:code>char, signed char</d:code> or <d:code>unsigned
    char</d:code> large enough to accept the sequence and a terminating null
    character code, which will be added automatically.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character will be converted to a wide character as if by a call to the
    <d:code>mbrtowc() function</d:code>, with the conversion state described by
    an <d:code>mbstate_t</d:code> object initialized to zero 
    before the first character is converted. The programmer will ensure that
    the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the sequence and the
    terminating null wide character, which will be added
    automatically.</d:para>
    <d:para><d:emphasis role="bold">c</d:emphasis> Matches a sequence of bytes
    of the number specified by the field width (1 if no field width is present
    in the conversion specification). The programmer will ensure that the
    corresponding argument is a pointer to the initial byte of an array of
    <d:code>char, signed char</d:code> or <d:code>unsigned char</d:code> large
    enough to accept the sequence. No null byte is added. The normal skip over
    white-space characters will be suppressed in this case.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character will be converted to a wide character as if by a call to the
    <d:code>mbrtowc() function</d:code>, with the conversion state described by
    an <d:code>mbstate_t</d:code> object initialized to zero 
    before the first character is converted. The programmer will ensure that
    the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the resulting sequence of
    wide characters. No null wide character is added.</d:para>
    <d:para><d:emphasis role="bold">p</d:emphasis> Matches an
    implementation-defined set of sequences, which shall be the same as the set
    of sequences that is produced by the %p conversion specification of the
    corresponding <d:code>printf() functions</d:code>. The application shall
    ensure that the corresponding argument is a pointer to a pointer to
    void. The interpretation of the input item is implementation-defined. If
    the input item is a value converted earlier during the same program
    execution, the pointer that results will compare equal to that value;
    otherwise, the behavior of the <d:code>%p</d:code> conversion specification
    is undefined.</d:para>
    <d:para><d:emphasis role="bold">[ </d:emphasis>Matches a non-empty sequence
    of bytes from a set of expected bytes (the scanset). The normal skip over
    white-space characters shall be suppressed in this case. The programmer
    will ensure that the corresponding argument is a pointer to the initial
    byte of an array of <d:code>char, signed char</d:code> or <d:code>unsigned
    char</d:code> large enough to accept the sequence and a terminating null
    byte, which shall be added automatically.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character in the sequence will be converted to a wide character as if by a
    call to the <d:code>mbrtowc() function</d:code>, 
    with the conversion state described by an <d:code>mbstate_t</d:code> object
    initialized to zero before the first character is converted. The programmer
    will ensure that the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the sequence and the
    terminating null wide character, which will be added
    automatically.</d:para>
    <d:para>The conversion specification includes all subsequent bytes in the format string up to
        and including the matching right square bracket ( '<d:code>]</d:code>' ). The bytes between
        the square brackets (the scanlist) comprise the scanset, unless the byte after the left
        square bracket is a circumflex ( '<d:code>^</d:code>^ ), in which case the scanset contains
        all bytes that do not appear in the scanlist between the circumflex and the right square
        bracket. If the conversion specification begins with "<d:code>[]</d:code>" or
          <d:code>"[^]"</d:code>, the right square bracket is included in the scanlist and the next
        right square bracket is the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that ends the conversion
        specification. If a '-' is in the scanlist and is not the first character, nor the second
        where the first character is a '<d:code>^</d:code>', nor the last character, the behavior is
        implementation-defined.</d:para>
      <d:para>The conversion specifiers <d:code>A, E, F, G</d:code> and <d:code>X</d:code> are also
        valid and shall be equivalent to <d:code>a, e, f, g</d:code> and <d:code>x</d:code>
        respectively.</d:para>
      <d:para>If end-of-file is encountered during input, conversion shall be terminated. If
        end-of-file occurs before any bytes matching the current conversion specification (except
        for <d:code>%n</d:code>) have been read (other than leading white-space characters, where
        permitted), execution of the current conversion specification will terminate with an input
        failure. Otherwise, unless execution of the current conversion specification is terminated
        with a matching failure, execution of the following conversion specification (if any) will
        be terminated with an input failure.</d:para>
      <d:para>Reaching the end of the string in <d:code>sscanf()</d:code> shall be equivalent to
        encountering end-of-file for <d:code>scanf()</d:code>. If conversion terminates on a
        conflicting input, the offending input is left unread in the input. Any trailing white space
        (including newlines) shall be left unread unless matched by a conversion specification. The
        success of literal matches and suppressed assignments is only directly determinable via the
          <d:code>%n</d:code> conversion specification.</d:para>
      <d:para>Time for some code. You have already seen many examples of <d:code>scanf</d:code> so I
        will just explain some concepts here. Consider the following program:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of string input

#include &lt;stdio.h>

int main()
{
  char str[128] = {0};

  scanf("%s", str);
  printf("You entered:\n%s\n", str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv.
You entered:
Hi!</d:screen>
      <d:para>It is certainly not the corect output. We had expected to see like: “Hi! My name is
        Shiv.”. What happend to input string after “Hi!”. Well, in a form given above for
          <d:code>scanf()</d:code> it will stop taking input after white-space for character
        strings. For numerics it does not matter as it does not match the format. For characters it
        is character-by-character so no confusion either. So what if you want to have the entire
        string including white-spaces. Use <d:code>[^n]</d:code> as given below:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Corrected demo of string input

#include &lt;stdio.h>

int main()
{
  char str[128] = {0};

  scanf("%[^\n]s", str);
  printf("You entered:\n%s\n", str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv.
You entered:
Hi! My name is Shiv.</d:screen>
      <d:para>What if you want to filter a string based on certain patterns. For example, a
        charcater string does not contain more that a single space, English alphabets, period and
        digits. To scan such a string you can define a pttern as program given below shows:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv. S Dayal
// Description: Demo of []

#include &lt;stdio.h>

int main()
{
  char c[100]={0};

  scanf("%[ A-Za-z0-9!.]", c);
  printf("%s\n", c);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv! My phone no. is 1234. %^$&amp;*
Hi! My name is Shiv! My phone no. is 1234.</d:screen>
      <d:para>There is also a major problem associated with input and that comes when you have
        characters involved. Consider the following program:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of scanf() function

#include &lt;stdio.h>

int main()
{
  int   i = 0;
  float f = 0.0;
  char  c1 = '\0';
  char  c2 = '\0';
  char  c3 = '\0';

  printf("Enter an integer, a float and three character one by one:\n");

  scanf("%d", &amp;i);
  scanf("%f", &amp;f);
  scanf("%c", &amp;c1);
  scanf("%c", &amp;c2);
  scanf("%c", &amp;c3);

  printf("You entered\n");
  printf("%d\n", i);
  printf("%f\n", f);
  printf("%c\n", c1);
  printf("%c\n", c2);
  printf("%c\n", c3);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>2
3.4
s
You entered
2
3.400000


s</d:screen>
      <d:para>What is happening here is that newline entered by our <d:code>RET</d:code> key is
        getting assigned to <d:code>c1</d:code> and <d:code>c3</d:code>. That is why the program
        accepted only second character. The enter after <d:code>float f;</d:code> was assigned to
          <d:code>c1</d:code> and the character entered to <d:code>c2</d:code> and then the RET
        newline to <d:code>c3</d:code>. There is a very simple way to recover from this:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of scanf() function

#include &lt;stdio.h>

int main()
{
  int   i = 0;
  float f = 0.0;
  char  c1 = '\0';
  char  c2 = '\0';
  char  c3 = '\0';

  printf("Enter an integer, a float and three character one by one:\n");
  scanf("%d", &amp;i);
  scanf("%f", &amp;f);
  scanf(" %c", &amp;c1);
  scanf(" %c", &amp;c2);
  scanf(" %c", &amp;c3);

  printf("%d\n", i);
  printf("%f\n", f);
  printf("%c\n", c1);
  printf("%c\n", c2);
  printf("%c\n", c3);

  return 0;
}</d:programlisting>
      <d:para>The whitespace character shown will eat up all the white-space given after the
        previous input. This concludes our discussion on <d:code>printf()</d:code> and
          <d:code>scanf()</d:code>. Now we will move to another set of i/o functions which take
        character string without filtering and print it to screen without filtering. What I am going
        to discuss are <d:code>gets(), fgets(), puts()</d:code> and
        <d:code>fputs()</d:code>.</d:para> 
  </d:sect1>
  <d:sect1>
    <d:title>Character String I/O Functions</d:title>
    <d:para>These functions are very simple compared to
    <d:code>printf()</d:code> and <d:code>scanf()</d:code>. They take a pointer
    to a character array or a character pointer and fill it with input or print
    it to monitor. Note that <d:code>gets()</d:code> and
    <d:code>puts()</d:code> work only with stdin and stdout respectively while
    <d:code>fgets()</d:code> and <d:code>fputs()</d:code> work with
    <d:code>FILE</d:code> streams. They can read and write to file streams that
    is. Here is a sample program:</d:para>
<d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description : Demo of string i/o
#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  char cStack[1024] = "";
  char *cHeap = (char*)malloc(sizeof(1024));

  gets(cStack);
  puts(cStack);

  cHeap = fgets(cHeap, 1024, stdin);
  fputs(cHeap, stdout);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>Hi!
Hi!
Hello!
Hello!</d:screen>
<d:para>First <d:code>"Hi!"</d:code> and <d:code>"Hello!"</d:code> are keyboard
inputs. Do not worry about array and pointer syntax at the moment. Just see the
difference between function calls. Their is a problem with
<d:code>gets()</d:code> that it can cause buffer overflow. If input is bigger
than 1024 bytes including the null terminator then buffer overflow will
happen. Note how you can prevent it with fgets() by specifying the number of
characters you want to read. Rest of input will be ignored by
<d:code>fgets()</d:code>. This is a security hole and therefore you should
never ever use <d:code>gets()</d:code>.</d:para>
<d:para>Time for single character input/output.</d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Single Character I/O</d:title>
    <d:para>There are several functions for single character i/o. They are
    <d:code>getc(), putc(), getchar(), putchar(), fgetc()</d:code> and
    <d:code>fputc()</d:code>. Apart from <d:code>getchar()</d:code> and
    <d:code>putchar()</d:code> rest can do any FILE stream-based i/o. Let us
    see them as they are mostly trivial.</d:para>
    <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Single character funciton demo
#include &lt;stdio.h>

int main()
{
  char c ='';

  c = getchar();
  putchar(c);

  c = getchar();
  putchar(c);

  c = fgetc(stdin);
  fputc(c, stdout);

  c = getchar();
  putchar(c);

  c = getc(stdin);
  putc(c, stdout);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>4
4
5
5
6
6</d:screen>
<d:para>The first 4, 5 and 6 were keyboard inputs. Note the use of extra
<d:code>getchar()</d:code> and <d:code>putchar()</d:code> to handle the
situation we faced during <d:code>scanf()</d:code>.</d:para>
<d:para>So we have seen many functions and programs for console i/o. File i/o
is still there and will be covered later. This chapter ends here. See you in
the next chapter with operators and expressions.:-)</d:para>
  </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="oae/index.html" ?>
      <d:title>Operators and Expressions</d:title>
      <d:para>Operators and expressions are in the core of every programming
      language. They form the major part of BNF grammar. They also decide how
      the syntax will look like. You as a programmer will spend considerable
      time using C operators. C has sevral type of operators like arithmetic
      operators, relational operators, bitwise operators, unary operators,
      logical operators to name some of them. Since C was first of very
      poopular structured general-pupose lnguages therefore many modern
      language use almost all the operators and supplement with their own. It
      is needless to say that to become a good programmar you must know all the
      operators of C and know where to use which one as it may decide
      performance, readability, simplicity of your code. Whenever you see array
      and pointer in following sections just plow through them. All will be
      clear soon.</d:para>
      <d:para>Whenever operators and expressions come in picture you may have a
      set of mixed data then to perform opration data is converted from one
      type to another. This is known as “Usual Arithmetic Conversion”, which I
      am going to tell you next.</d:para>
      <d:sect1>
	<d:title>Basic Operators</d:title>
	<d:para>There are five here. +, -, *, / and %. Please refer to chapter
	4 for their behavior. Let us see a simple example:</d:para>
	<d:programlisting role="CLexer">// Arithmetic operators
// Author: Shiv S. Dayal
// Description: Demo of arithmetic operators

#include &lt;stdio.h>

int main()
{
  int i = 10;
  float f= 6.45;
  char c = 'A';
  int iResult = 0;
  float fResult = 0.0;
  char cResult = '\0';

  cResult = c + i;
  printf("cResult = %c\n", cResult);
  cResult = cResult - 5;
  printf("cResult = %c\n", cResult);

  iResult = i - 10;
  printf("iResult = %d\n", iResult);
  iResult = i * c;
  printf("iResult = %d\n", iResult);
  iResult = (i + c)/3;
  printf("Result = %d\n", iResult);
  iResult = (i + c)%2;
  printf("iesult = %d\n", iResult);

  fResult = f * 2.12;
  printf("fesult = %f\n", fResult);
  fResult = f - i;
  printf("fesult = %f\n", fResult);
  fResult = f / 1.12;
  printf("fesult = %f\n", fResult);
  fResult = 1 % 3;
  printf("fesult = %f\n", fResult);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>cResult = K
cResult = F
iResult = 0
iResult = 650
Result = 25
iesult = 1
fesult = 13.674000
fesult = -3.550000
fesult = 5.758928
fesult = 1.000000</d:screen>
<d:para>First <d:code>cResult</d:code> is sum of <d:code>'A' + i</d:code> which
is <d:code>'K'</d:code> as <d:code>'K'</d:code> comes ten positions after A in
ASCII table. Then we subtract five and go back to F.</d:para>
<d:para>First <d:code>iReasult</d:code> is 10 - <d:code>i</d:code> where value
of <d:code>i</d:code> is 10 hence result is 0. Next we multiply it with
<d:code>i</d:code> which contains <d:code>'A'</d:code> who has got ASCII value
of 65 and result becomes 650. Then We take sum of <d:code>'A'</d:code> and
<d:code>i</d:code> and divide by 3 so the result is 25 as it is a division of
75 by 3. Next we use modulus operator and remainder is 1. Note that in case of
/ and % if denominator is zero the behavior is undefined.</d:para>
<d:para>Same way you can udnerstand floating-point operations. Note that you
cannot use modulus operator if either of the operands are floating-point
numbers as it will make no sense because of data type promotion rules. Here
data type promotion rule says smaller data types will be converted to bigger
data types. Also, if there is a data type on left side of assignment the result
of applying the operator to operands will be converted to the type of
that. chars are promoted to ints, ints are promoted to floats anf floats to
double. The point is that conversion will try to keep as much data as
possible.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Relational Operators</d:title>
	<d:para>There are four relational operators: &lt;, >, &lt;= and
	>=. Once again these are described in chapter 4. Let us see an
	example:</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of relational operator

#include &lt;stdio.h>
#include &lt;stdbool.h>

int main()
{
  int i = 4, j = 5;
  _Bool result = 0;

  result = i &lt; j;
  printf("%d\n", result);

  result = i > j;
  printf("%d\n", result);

  result = i &lt;= j;
  printf("%d\n", result);

  result = i >= j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>1
0
1
0</d:screen>
<d:para>Note that you should not apply these to floating-point data types as
they may not be represented correctly and two different entities have the same
internal representation.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Equality Operators</d:title>
	<d:para>There are two equlity operators == and !=. </d:para>
	<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of equality operator

#include &lt;stdio.h>
#include &lt;stdbool.h>
int main()
{
  int i = 4, j = 5;
  _Bool result = 0;

  result = i == j;
  printf("%d\n", result);

  result = i != j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>0
1</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Increment and Decrement Operators</d:title>
	<d:para>There is one increment and one decrement operator. ++ and
	--. Both come in two forms prefix and postfix. First we will see prefix
	versions then postfix ones. There is only one constraint on prefix
	operators of these and that is the operand of the prefix increment or
	decrement operator will have qualified or unqualified real or pointer
	type and will be a modifiable lvalue.</d:para>
	<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of increment decrement operators

#include &lt;stdio.h>

int main()
{
  float f = 7.123;

  printf("%f\n", ++f);
  printf("%f\n", --f);
  printf("%f\n", f++);
  printf("%f\n", f--);
  printf("%f\n", f);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>8.123000
7.123000
7.123000
8.123000
7.123000</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Logical Operators</d:title>
	<d:para>There are two such operators. &amp;&amp; logical AND and ||
	locical OR. Both the operators have the same constraints and it is that
	both the operands will have scalar type.</d:para>
	<d:para>The &amp;&amp; operator gives 1 if both the operands are
	non-zero else 0. The result type is int. It is different from bitwise
	&amp; operator in the sense that it guarantess left-to-right
	evaluation; if the second operand is evaluated, there is a sequence
	point between the evaluations of the first and second operands. If the
	first operand is 0 then the second operand is not evaluated. This is
	known as “short-circuit evaluation”.</d:para>
	<d:para>The || operator gives 1 if any of operands are non-zero else it
	gives 0. Same as logical AND operator and unlike bitwise | operator it
	guarantees left-to-right evaluation and same goes for sequence
	points. If first operand is non-zero, the second is not
	evaluated.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of logical AND &amp; OR operators

#include &lt;stdio.h>
#include &lt;stdbool.h>

int main()
{
  int i = 4, j = 5, k = 0;
  bool result;

  result = i&amp;&amp;j;
  printf("%d\n", result);

  result = i||j;
  printf("%d\n", result);

  result = k&amp;&amp;j;
  printf("%d\n", result);

  result = k||j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>1
1
0
1</d:screen>
<d:para>note the use of <d:code>bool</d:code> here instead of
<d:code>_Bool</d:code>.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Bitwise Operators</d:title>
	<d:para>There are three bitwise operators. &amp;, |, and ^. AND, OR and
	EX-OR respectively. OR is also called inclusive OR. These have the same
	contsraints and it is that operands should be integer types. The usual
	arithmetic conversions are performed on the operands.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of bitwise operators

#include &amp;stdio.h>
#include &amp;stdbool.h>

int main()
{
  int i = 4, j = 5;
  int result;

  result = i&amp;j;
  printf("%d\n", result);

  result = i|j;
  printf("%d\n", result);

  result = i^j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>4
5
1</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Bitwise Shift Operators</d:title>
	<d:para>The constraint is same as other bitwise operators that operands
	should be integers. The integer promotions are performed on each of the
	operands. The type of the result if that of the promoted left
	operand. If the value of the right operand is negative or is greater
	than or equal to the width of the promoted left operand, the behavior
	is undefined.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of shift operators

#include &lt;stdio.h>

int main()
{
  int i  = 4;
  char c ='A';
  int result;

  result = c&lt;&lt;i;
  printf("%d\n", result);

  result = c>>i;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
      </d:sect1>
      <d:sect1>
	<d:title>Assignment Operators</d:title>
	<d:para>These are = *= /= %= += -= &lt;&lt;= >>= &amp;= ^= and |= The only
	constraint is that left operand should be modifiable lvalue. An
	assignment operator stores a value in the object designated by the left
	operand. An assignment expression has the value of the left operand
	after the assignment, but is not an lvalue. The type of an assignment
	expression is the type of the left operand unless the left operand has
	qualified type, in which case it is the unqualified version of the type
	of the left operand. The side effect of updating the stored value of
	the left operand is sequenced after the value computations of the left
	and right operands. The evaluations of the operands are
	unsequenced.</d:para>
<d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of compound assignments.

#include &lt;stdio.h>

int main()
{
  int i   = 3;
  int j   = 3;
  float f = 4.7;
  float result=0.0;

  result += i+f;
  printf("%f\n", result);

  result -= f;
  printf("%f\n", result);

  j &lt;&lt;= i;
  printf("%d\n", j);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>7.700000
3.000000
24</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Conditional Operators</d:title>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of conditional operator

#include &lt;stdio.h>

int main()
{
  int i = (4 &lt; 5)? 7:10;

  printf("%d\n", i);

  return 0;
}</d:programlisting>
<d:para>output is 7 as 4 is less than 5 which is true.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Comma Operator</d:title>
	<d:para>It is a very simple operator. The left operand of a comma
	operator is evaluated as a void expression; there is a sequence point
	between its evaluation and that of the right operand. Then the right
	operand is evaluated; the result has its type and value. A comma
	operator does not give an lvalue.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>sizeof Operator</d:title>
	<d:para>You have already see sizeof operator in second chapter when we
	saw sizes of data types. However here is the constraint: the sizeof
	operator will not be applied to an expression that has function type or
	an incomplete type, to the parenthesized name of such a type, or to an
	expression that designates a bit-field member.</d:para>
	<d:para>The sizeof operator yields the size (in bytes) of its operand,
	which may be an expression or the parenthesized name of a type. The
	size is determined from the type of the operand. The result is an
	integer. If the type of the operand is a variable length array type,
	the operand is evaluated; otherwise, the operand is not evaluated and
	the result is an integer constant.</d:para>
	<d:para>When applied to an operand that has type char, unsigned char,
	or signed char, (or a qualified version thereof) the result is 1. When
	applied to an operand that has array type, the result is the total
	number of bytes in the array. When applied to an operand that has
	structure or union type, the result is the total number of bytes in
	such an object, including internal and trailing padding.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Unary Arithmetic Operators</d:title>
	<d:para>We will see casting, array subscripting, function parenthes,
	address and indirection operators later at appropriate time. For now I
	am going to tell you about operator precedence and associativity and
	then about grouping parenthes. Given below is the table for operator
	precedence and associativity, however, you may not be familiar with few
	of them but later you will be:</d:para>
	<d:table frame="border" class="leftcenter"
          border="1">
	  <d:colgroup width="0*"/>
	  <d:colgroup width="0*"/>
          <d:caption>Priority and assiciativity table</d:caption>
          <d:thead>
            <d:tr bgcolor="#aaa">
              <d:th>Operators</d:th>
              <d:th>Associativity</d:th>
            </d:tr>
          </d:thead>
	  <d:tr>
	    <d:td>() [] . -> ++ – (postfix)</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>++ – + - (unary) ! ~ (types) * &amp; sizeof</d:td>
	    <d:td>right-to-left</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>* / %</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>+ - (Addition/Subtraction)</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&lt;&lt; >></d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&lt; > &lt;= >=</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>== !=</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&amp;</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>^</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>|</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&amp;&amp;</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>||</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>Assignemnt operators</d:td>
	    <d:td>right-to-left</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>,</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	</d:table>
      </d:sect1>
      <d:sect1>
	<d:title>Grouping parentheses</d:title>
	<d:para>Grouping parentheses are used to override operator precedence
	and group expressions. NEVER EVER try to memorize and rely on
	precedence of operators. Always use grouping parentheses. Till now I
	have shown very simple examples of operators; here are some complex
	ones:</d:para>
	<d:programlisting role="CLexer">// Author: Shiv Shankar Dayal
// Description: Demo of grouping parentheses

#include &lt;stdio.h>

int main()
{
  printf("%f\n", 5.2*(3.7+2.3));
  printf("%d\n", ((4&lt;5)||(7^5)));

  return 0;
}</d:programlisting>
<d:para>This small program shows you what can go wrong if you rely on
memory. It allows you do addition first and then multiplcation. Inner
parentheses are evaluated first then inner ones. This concludes our chapter on
operators and expressions. Next we focus on control statements and flow
statements.</d:para> 
      </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="cf/index.html" ?>
      <d:title>Control Flow</d:title>
      <d:para>There are three things you will learn in this chapter. Switching
      the path of execution in program depending upon program variables or
      states using control statements. Repeating a set of instructions using
      loops. Bypassing certain set of instructions in a loop and jump
      around. Collectively, these elements of C allow or enable you to take
      driver’s seat over the control over a C program. You will spend much of
      your programming time even in future using these basic elements. Let us
      begin with if-else without spending much time over boring stuff. Before
      we proceed I would like to tell you about storage classes of array and
      their scope. I could have covered it in second chapter but I did not want
      to scare you with too many things in itself.</d:para>
      <d:sect1>
	<d:title>Storage Classes</d:title>
	<d:para>In C99 variables can be declared at any point in class without
	breaking an expression. This was not possible in older C and you could
	only declare at start of function. There is <d:code>auto, register,
	static</d:code> and <d:code>extern</d:code>.</d:para>
	<d:para><d:code>auto</d:code> is the default storage class for local
	variables. Local variables are those that are inside any function or
	any control-flow statement block. You will perhaps never use auto
	explicitly. For examle, <d:code>auto int i; register</d:code> is the
	storage class which tell the compiler that this variable will be stored
	in a CPU register instead of RAM. It is mostly used for loop counters
	and to store small 32-bit or 64-bit variables in CPU register. For
	example, <d:code>register int i;</d:code></d:para>
	<d:para><d:code>static</d:code> is the default storage class for global
	variables though local variables can also be made static. local static
	variables persist across function calls that is their values do not
	change.</d:para>
	<d:para><d:code>extern</d:code> keyword allows global variables to
	become visible in other modules than itself.</d:para>
	<d:para>There are two more modifiers: <d:code>const</d:code> and
	<d:code>volatile</d:code>. As their names specify const makes a
	variable constant. That is you cannot change value of a variable
	declared as <d:code>const</d:code>. <d:code>volatile</d:code> is kind
	of opposite but not really opposite. What it does is that the programs
	other than the program itself where it has been declared are allowed to
	change it. This means that a variable can be a <d:code>const</d:code>
	as well as <d:code>volatile</d:code> at the same time.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>if else Statement</d:title>
	<d:para>An if-else statement may consist of only <d:code>if</d:code> or
	both <d:code>if</d:code> and <d:code>else</d:code> or
	<d:code>if</d:code> and <d:code>else if</d:code> or <d:code>if, else
	if</d:code> and <d:code>else</d:code>. An if-else statement must have
	<d:code>if</d:code> at the beginning, zeor or more <d:code>else
	if</d:code> may come after <d:code>if</d:code> or before
	<d:code>else</d:code> and <d:code>else</d:code> must come at
	end. <d:code>else if</d:code> and <d:code>else</d:code> are optional
	and may not come. Consider the following program:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>

int main()
{
  int i = 0, j= 0;

  printf("Please enter two integers i and j:\n");
  scanf("%d%d", &amp;i , &amp;j);

  if(i==4)
    printf("you entered 4 for i.\n");

  if(i==7)
  {
    printf("you entered 7 for i.\n");
    printf("I am happy for you.\n");
  }
  else
  {
    printf("You did not enter 7 for i.\n");
  }
  if(i==7)
  {
    printf("you entered 7 for i.\n");
    printf("I am happy for you.\n");
  }
  else if(j==8)
    printf("You entered 8 for i.\n");

  if(i==7)
    printf("you entered my lucky number.\n");
  else if((i==7) &amp;&amp;(j==8))
    printf("May god bless you!\n");
  else
    printf("You entered bad number.\n");

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Please enter two integers i and j:
4
6
you entered 4 for i.
You did not enter 7 for i.
You entered bad number.</d:screen>
<d:para>As you can see from first if sttatement that if you enter the value of
i as 4 then the printf will be executed and you will be able to see it. Note
that if there are multiple lines below if which you want to execute then you
must put them in a block using curly braces. If you just want to execute one
line then these curly braces are optional. Note that how you must use curly
braces if you have more than one line and you want to execute them. Also, see
the syntax for missing else and missing else if. One if-else can be nested
inside another for example see the following code:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>
#include &lt;string.h>

int main()
{
  char fName[128]={0}, lName[128]={0};

  printf("Enter your first name and last name in that order:\n");
  gets(fName);
  gets(lName);

  if(strcmp(fName, "Shiv") == 0)
  {
    if(strcmp(lName, "Dayal") == 0)
      printf("Your name is Shiv Dayal.\n");
  }
  else
  {
    printf("Your name is %s %s.\n", fName, lName);
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Enter your first name and last name in that order:
Shiv
Dayal
Your name is Shiv Dayal.</d:screen>
<d:para>another run:</d:para>
<d:screen>Enter your first name and last name in that order:
Richard
Stallman
Your name is Richard Stallman.</d:screen>
<d:para>when first if matches but else does not:</d:para>
<d:screen>Enter your first name and last name in that order:
Shiv
Stallman</d:screen>
<d:para>Note the usage of nested if-else. Also, note how
<d:code>strcmp</d:code> has been used to compare two strings and
<d:code>gets</d:code> to read the input. <d:code>gets</d:code> is dangerous but
it is simple that is why has been used here. You can read about it at the link
of opengroup. We will see this in more detail towards the end when we deal with
chapter named C Standard Library.</d:para>
<d:warning>
  <d:title>Assignment in if/else-if</d:title>
  <d:para>Always remember the expression inside if evaluates to a boolean so
  you should never do an ASSIGNMENT inside if and else if as it will always
  evaluate to what is assigned. It can render all your logic meaningless. C is
  not Python, where assignment inside if is not allowed. However, if you assign
  0 to some variable it will evaluate to <d:code>false</d:code>.</d:para>
</d:warning>
<d:sect2>
  <d:title>Dangling else Problem</d:title>
  <d:para>The <d:code>else</d:code> part has a property that it will cling to
  closest if. So the following piece of code may give you surprise:</d:para>
<d:programlisting role="CLexer">if(x==1)
  if(y>2)
    printf("foo\n");
else
  printf("bar\n");</d:programlisting>
<d:para>Now consider <d:code>x!=1</d:code> then you may think that bar will be
printed. However, that will not be the case. The else part clings to inner
if. This can be fixed by using curly braces.</d:para>
</d:sect2>
      </d:sect1>
      <d:sect1>
	<d:title>switch Statement</d:title>
	<d:para><d:code>switch</d:code> statement is kind of if-else
	replacement to simplify it. Usage of switch statement is to compare one
	expression with others, and then execute a series of sub-statements
	inside case and default based on the result of the comparisons. Note
	that switch statement takes only integers or integreal type as its
	argument and same is valid for its cases. Consider the following
	example:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>

int main()
{
  int i  = 65;

  switch(i)
  {
    case 'A':
      printf("Value of i is 'A'.\n");
      break;
    case 'B':
      printf("Value of i is 'B'.\n");
      break;
    default:
      break;
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Value of i is 'A'.</d:screen>
<d:para>Notice the usage of <d:code>break</d:code>. It is used to terminate
execution once a match has been found for a particular case else what will
happen is shown below:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of switch statement.

#include &lt;stdio.h>

int main()
{
  int i  = 65;

  switch(i)
  {
    case 'A':
      printf("Value of i is 'A'.\n");
    case 'B':
      printf("Value of i is 'B'.\n");
    default:
      printf("Value of i is %c.\n", i);
      break;
    }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Value of i is 'A'.
Value of i is 'B'.
Value of i is A.</d:screen>
<d:para>This is also known as fall through of a <d:code>switch</d:code>
statement. Notice, the use of default that how it is analogous to
<d:code>else</d:code> statement. <d:code>switch</d:code> statements can also be
nested inside each other. However, node that lots of nesting is not good. At
most 2-3 levels are more than enough else you should look at alternative ways
of writing code.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>while Loop</d:title>
	<d:para>Of three loops I am first going to cover <d:code>while</d:code>
	loop. It is simplest of three. I will just give an example for you to
	understand.</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of while statement.

#include &lt;stdio.h>

int main()
{
  int i = 0;

  while(i &lt;= 10)
  {
    printf("%d * %2d = %4d\n", 2, i, 2*i);
    i++;
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>2 *  0 =    0
2 *  1 =    2
2 *  2 =    4
2 *  3 =    6
2 *  4 =    8
2 *  5 =   10
2 *  6 =   12
2 *  7 =   14
2 *  8 =   16
2 *  9 =   18
2 * 10 =   20</d:screen>
<d:para><d:code>while</d:code> loop just has one expression which is its
terminating condition. We have written <d:code>i&lt;=10</d:code> which is
terminating condition for our loop. The moment i will become greater than that
the loop will terminated. We are initializing our loop index to 0 and
incrementing within while loop. Note that you must use curly braces for body of
block of loop. If you have only one statement as body of loop then braces are
optional.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>do-while Loop</d:title>
	<d:para>It is very much similar to <d:code>while</d:code> loop but with
	a very subtle difference. Consider the following code:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of do while statement.

#include &lt;stdio.h>

int main()
{
  int i = 0;

  do {
    printf("I am Shiv.\n");
    i++;
  }while(i&lt;5);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>I am Shiv.
I am Shiv.
I am Shiv.
I am Shiv.
I am Shiv.</d:screen>
<d:para>Notice the semicolon at the end of while. Now time for that subtle
difference:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of do while statement.

#include &lt;stdio.h>

int main()
{
  int i = 10;

  do {
    printf("2 * 10 = 20\n");
    i++;
  }while(i&lt;5);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>2 * 10 = 20</d:screen>
<d:para>Notice how <d:code>do while</d:code> loop executes once even if the loop index is more than the terminating condition in the while part.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>for Loop</d:title>
	<d:para><d:code>for</d:code> loop is the last of loops and most
	versatile. It has three parts: initialization of loop counters,
	terminating condition, and loop index modification. If you declare a
	variable in the initialization part then that variable has just loop
	scope while for <d:code>while</d:code> and <d:code>do while</d:code>
	loop indices have at least outer block scope. This makes
	<d:code>for</d:code> loop better. Consider the following example for
	computing squares of numbers:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of for statement.

#include &lt;stdio.h>

int main()
{
  for(int i=1, j=1; (i&lt;=10)||(j&lt;=10); i++, j++)
    printf("%2d * %2d = %4d\n", i, j, i*j);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>1 *  1 =    1
2 *  2 =    4
3 *  3 =    9
4 *  4 =   16
5 *  5 =   25
6 *  6 =   36
7 *  7 =   49
8 *  8 =   64
9 *  9 =   81
10 * 10 =  100</d:screen>
<d:para>Notice how various things are coming in picture here: initialization,
terminating conditions loop counter incrementation and output formatting. Here
is how you can write an infinite for loop <d:code>for(;;)</d:code>. You can
write an infinite loop anywhere if your loop index counters are not getting
incremented/decremented properly or your termination condition is
incorrect. Also, always make sure that loop indices are initialized. As an
exercise you can try to implement this program using <d:code>while</d:code> and
<d:code>do while</d:code> loop. Last line of the above output is not having
first space properly.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>break and continue Statements</d:title>
	<d:para><d:code>break</d:code> statement breaks out of innermost
	<d:code>for, do, while</d:code> and <d:code>switch</d:code>
	statements. It terminates that loop. Consider for example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of break statement.

#include &lt;stdio.h>

int main()
{

  for(int i = 0;;i +=10)
  {
    if(i>100)
      break;
    printf("%d\n", i);
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>0
10
20
30
40
50
60
70
80
90
100</d:screen>
<d:para>Notice how the <d:code>for</d:code> loop is terminated once
<d:code>i</d:code> goes beyond 100 even though there is no terminating
condition. Try the same in <d:code>while</d:code> and <d:code>do-while</d:code>
loop and produce the same result.</d:para>
<d:para><d:code>continue</d:code> statement is slightly different than
<d:code>break</d:code> in the sense that it does not stop the execution of that
loop but simply does not execute remaining instructions of that block. Consider
for example:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of continue statement.

#include &lt;stdio.h>

int main()
{

  for(int i = 0;i&lt;=100;i +=10)
  {
    if(i==50)
      continue;
    printf("%d\n", i);
  }

  return 0;
}</d:programlisting>
and the output is:<d:screen>0
10
20
30
40
60
70
80
90
100</d:screen>
<d:para>Notice how 50 is missing from output.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>typedef and return Statements</d:title>
	<d:para><d:code>typedef</d:code> statement is used to define new types
	from existing types. For example:</d:para>
<d:programlisting role="CLexer">typedef char s8;
typedef unsigned char s8;
typedef short int s16;
typedef unsigned short int u16;</d:programlisting>
<d:para>You will be seeing its usage in function pointers, structures and
unions heavily.</d:para>
<d:para><d:code>return</d:code> statement is used to return from
function. Optionally you can return a value.</d:para>
      </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="ap/index.html" ?>
      <d:title>Arrays and Pointers</d:title>
      <d:para>In this chapter I am going to tell you about two very powerful
	constructs of C programming; arrays and pointers. Arrays are what they
	are; array of some data type. There can be an array of any complete
	type. You cannot create an array of any incomplete type, therefore, an
	array of type void is not allowed. There are fixed arrays and also
	variable length arrays. C99 inroduced variable length arrays before
	that arrays were only of fixed length. However, you can increase the
	capacity of a fixed sized array using <d:code>realloc()</d:code>
	function. There is single-dimensional array and then there is
	multi-dimensional array. We will first go through single-dimensional
	array then multi-dimensional.
      </d:para>
      <d:sect1>
	<d:title>Single-Dimensional Array</d:title>
	<d:para>Let us first create a basic array and then see how to access it
	elements:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of array.

#include &lt;stdio.h>

int main()
{
  const int MAX = 8;
  //An initialized array
  int a[8] = {0};
  //An initialized array to 0
  int b[MAX];

  for(int i=0; i&lt;8; i++)
  {
    b[i] = i;
    printf("b[%d]=%d\n", i, b[i]);
  }

  for(int i=0; i&lt;8; i++)
  {
    printf("a[%d]=%d\n", i, a[i]);
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>b[0]=0
b[1]=1
b[2]=2
b[3]=3
b[4]=4
b[5]=5
b[6]=6
b[7]=7
a[0]=0
a[1]=0
a[2]=0
a[3]=0
a[4]=0
a[5]=0
a[6]=0
a[7]=0</d:screen>
<d:para>Here you see array subscripting operator in action. I have not covered
this particular operator in fourth chapter so it becomes my duty to explain it
here. There are two parts here one outside subscript and another outside. The
expression which is outside will have type “const pointer to object type”. This
means that array’s base address is fixed and cannot be changes. The expression
which is inside will have integer type. The result of these two has type
“type”. We will see pointer arithmetic with binary + operator in the pointers
section which is equivalent to subscript expression.</d:para>
<d:para>As you can see array a is fixed length array while array b is a
variable length array. You are not allowed to initialize variable length arrays
at the time of declaration. Notice that array indices do not start from 1 but
0. Never ever make the mistake of thinking that array indices start from 1. You
can also initialize an array as <d:code>a[]={1, 2, 3}; or a[3]={1, 2,
3};</d:code>. The array elements would be <d:code>a[0], a[1]</d:code> and
<d:code>a[2]</d:code> in both the cases. Notice how assignment is done to
elements of second array inside for loop one by one using the bracket operator
or subscripting operator. The array elements are always in sequence in
memory. A conceptual diagram is given below for first three elements of above
array. Here 1 means first element.</d:para>
      <d:figure>
        <d:title>An Array's Memory Diagram</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="images/arraydia.png"/>
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
<d:para>Array elements are always(not always but most commonly. It is so coomon
that I have used always.) accessed using their indices so order of retrieval is
<mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mtext>O(1)</mml:mtext>
</mml:math>.(This is known as big-O notation. You can find it in any Data
Structure and Algorithm book. If you wait you can find in my book as well but
you should not. :-)) The above program will not compile using old compilers
which do not support C99 standard like Turbo C++. Also, you may require to pass
the flag <d:code>-std=c99</d:code> to some versions of gcc. For variable length
arrays it is not necessary to declare the size in advance. Even, input to
program from other sources will do.</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of array.

#include &lt;stdio.h>

int main()
{
  int i=0;

  printf("Enter the value of i:\n");
  scanf("%d\n", &amp;i);

  char c[i];

  printf("Enter a string which contains one less no. of chars than i:\n");
  gets(c);
  puts(c);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Enter the value of i:
6
shiv
Enter a string which contains one less no. of chars than i:
shiv
shiv</d:screen>
<d:para>As you can see variable length array should be declared after the size
is known otherwise you may see strange output even though it is not compilation
error. For example you could have declaraed array immediately after
<d:code>i</d:code> but you will get some garbage output. The reason for this is
that at that point of time i contains garbage value. Also, note that array
indices are integers. Floating-point numbers or variables cannot be
indices.</d:para>
<d:para>Let us say you are writing a big piece of code and array is declared
somewhere and you want to know how many elemnets you can fill in the array or
what is the maximum size of array then you can use the following
program:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of array.

#include &lt;stdio.h>

int main()
{
  float f[10]={0.0};

  printf("Size of array f is %d.\n", sizeof(f)/sizeof(float));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Size of array f is 10.</d:screen>
<d:para>Now an experienced programmer may ask that if we can know the size of
array then why we do not have something like out of bounds exception of Java in
C. My answer to that is C was written in 1970 and Java in 1990. For example,
there are certain compilers with flags which help you detect this at
runtime.</d:para>
<d:para>Feel free to experiment with arrays. Do whatever you like. Remember the
more you will experiment the more you will learn. There are various ways in
which you can define character arrays. For example, <d:code>char c[6]={'h',
'e', 'l', 'l', 'o', '\0'};</d:code>. Remember, you must terminate a character
array with a null terminator. Another way to define the same is: <d:code>char
str[6] = "hello";</d:code>. In this example you do not need to add
'<d:code>\0</d:code>' explicitly as it is added automatically. Also, 6 is
optional here if you want you can ommit that. Of course second example is more
preferable. Note that if you declare an array of size m and data type size of
array is n bytes then the array will consume m*n bytes no matter what; even
when you are not using those bytes. Note that all these arrays are on stack
memory area. We will see how to allocate array on heap memory area once we have
studied pointers.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Multi-Dimensional Array</d:title>
	<d:para>Arrays can be n-dmensional. There is no limit on
	dimensions. You can allocate as much as your memory allows. We will
	begin with two-dimensional array. A two-dimensional array looks like a
	matrix. Say a two-dimensional array has m as one dimension and n as
	second diemnsion. Then total no. of elements will be m*n and size
	occupied is m*m*size of data type of array. There are various ways to
	initialize a two-dimensional array. Consider the following
	example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of two-dimensional array.

#include &lt;stdio.h>

int main()
{
  int a[2][2] = {{1,2},{3,4}};
  int b[2][2] = {1,2,3,4};

  //iterating over array
  for(int i=0;i&lt;2;i++)
  {
    for(int j=0;j&lt;2;j++)
      printf("%d ", a[i][j]);
    printf("\n");
  }
  for(int i=0;i&lt;2;i++)
  {
    for(int j=0;j&lt;2;j++)
      printf("%d ", b[i][j]);
    printf("\n");
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>1 2
3 4
1 2
3 4</d:screen>
<d:para>Same way you can have multi-dimensional array. I leave it up to you to
find applications of different arrays. For now, try multiplying two matrices,
doing a transpose, inverse of a matrix and printing a yearly calenday for any
year for example. With the current information given to you, you should be able
to do all these easily. As shown for array a it is not really a single array
but an array of array. How we can read this is array a has two arrays each of
which have two integers.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Pointers</d:title>
	<d:para>A pointer can store an address. A pointer of some type can
	store address of that type and a pointer to void can store address of
	any type.</d:para>
	<d:para>These are very interesting; considered to be one of the most
	powerful in the hands of capable programmer and most dangerous tool in
	the hands of an ignorant programmer. There are four standard library
	functions associated with them. All these are declared in <d:emphasis
	role="bold">stdlib.h</d:emphasis> which is part of standard c
	library. The functions are: <d:code>malloc(), calloc(),
	realloc()</d:code> and <d:code>free()</d:code>. Following is the
	contents of man pages verbatim,later in the program you can go to
	opengroup links as well. First signatures:</d:para>
<d:programlisting role="CLexer">void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);</d:programlisting>
<d:para>here <d:code>size_t</d:code> is the unsigned integer type of the result
of the sizeof operator. It is defined in <d:code>stddef.h</d:code>. And now
descriptions:</d:para>
<d:para><d:code>calloc()</d:code> allocates memory for an array of
<d:code>nmemb</d:code> elements of <d:code>size</d:code> bytes each and returns
a pointer to the allocated memory. The memory is set to zero. If
<d:code>nmemb</d:code> or size is 0, then <d:code>calloc()</d:code> returns
either <d:code>NULL</d:code>, or a unique pointer value that can later be
successfully passed to <d:code>free()</d:code>.</d:para>
<d:para><d:code>malloc()</d:code> allocates <d:code>size</d:code> bytes and
returns a pointer to the allocated memory. The memory is not cleared. If size
is 0, then <d:code>malloc()</d:code> returns either <d:code>NULL</d:code>, or a
unique pointer value that can later be successfully passed to
<d:code>free()</d:code>.</d:para>
<d:para><d:code>free()</d:code> frees the memory space pointed to by
<d:code>ptr</d:code>, which must have been returned by a previous call to
<d:code>malloc(), calloc()</d:code> or <d:code>realloc()</d:code>. Otherwise,
or if <d:code>free(ptr)</d:code> has already been called before, undefined
behavior occurs. If <d:code>ptr</d:code> is <d:code>NULL</d:code>, no operation
is performed.</d:para>
<d:para><d:code>realloc()</d:code> changes the size of the memory block pointed
to by <d:code>ptr</d:code> to <d:code>size</d:code> bytes. The contents will be
unchanged to the minimum of the old and new sizes; newly allocated memory will
be uninitialized. If <d:code>ptr</d:code> is <d:code>NULL</d:code>, then the
call is equivalent to <d:code>malloc(size)</d:code>, for all values of
<d:code>size</d:code>; if <d:code>size</d:code> is equal to zero, and
<d:code>ptr</d:code> is not <d:code>NULL</d:code>, then the call is equivalent
to <d:code>free(ptr)</d:code>. Unless <d:code>ptr</d:code> is
<d:code>NULL</d:code>, it must have been returned by an earlier call to
<d:code>malloc(), calloc()</d:code> or <d:code>realloc()</d:code>. If the area
pointed to was moved, a <d:code>free(ptr)</d:code> is done.</d:para>
<d:para>Let us consider a program:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int *p = NULL;

  p = (int*)malloc(sizeof(int)*8);

  for(int i=0;i&lt;8;i++)
  {
    *(p+i)=i;
    printf("Content at %dth location is %d.\n", i, *(p+i));
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Content at 0th location is 0.
Content at 1th location is 1.
Content at 2th location is 2.
Content at 3th location is 3.
Content at 4th location is 4.
Content at 5th location is 5.
Content at 6th location is 6.
Content at 7th location is 7.</d:screen>
<d:para>There are various ways to declare a simple pointer and initialize
it. For example:</d:para>
<d:programlisting role="CLexer">char *c;                           //Only declaration no initialization
c = NULL;                          //Initialization
void *p = NULL;                    //declaration and initialization
void *q = malloc(sizeof(void)*10); //Declare and allocate memory for 10</d:programlisting>
<d:para>On line number 15 and 16 you are seeing pointer arithmetic in previous
program. Consider array a declared in the first example. We could have iterated
in that example like <d:code>*(a+i)</d:code>.</d:para>
<d:para>A postfix expression followed by an expression in square brackets
<d:code>[]</d:code> is a subscripted designation of an element of an array
object. The definition of the subscript operator <d:code>[]</d:code> is that
<d:code>E1[E2]</d:code> is identical to
<d:code>(*((E1)+(E2)))</d:code>. Because of the conversion rules that apply to
the binary <d:code>+</d:code> operator, if <d:code>E1</d:code> is an array
object (equivalently, a pointer to the initial element of an array object) and
<d:code>E2</d:code> is an integer, <d:code>E1[E2]</d:code> designates the
<d:code>E2</d:code>-th element of of <d:code>E1</d:code> (counting from
zero).</d:para>
<d:para>I had not covered some portion of additive operators in the chapter of
operators and expression deliberately as I wanted to discuss them here. When an
expression that has integer type is added to or subtracted from a pointer, the
result has the type of the pointer operand. If the pointer operand points to an
element of an array object, and the array is large enough, the result points to
an element offset from the original element such that the difference of the
subscripts of the resulting and original array elements equals the integer
expression. In other words, if the expression <d:code>P</d:code> points to the
<d:code>i</d:code>-th element of an array object, the expressions
<d:code>(P)+N</d:code> (equivalently, <d:code>N+(P)</d:code>) and
<d:code>(P)-N</d:code> (where <d:code>N</d:code> has the value
<d:code>n</d:code>) point to, respectively, the <d:code>i+n</d:code>-th and
<d:code>i-n</d:code>-th elements of the array object, provided they
exist. Moreover, if the expression <d:code>P</d:code> points to the last
element of an array object, the expression <d:code>(P)+1</d:code> points one
past the last element of the array object, and if the expression
<d:code>Q</d:code> points one past the last element of an array object, the
expression <d:code>(Q)-1</d:code> points to the last element of the array
object. If both the pointer operand and the result point to elements of the
same array object, or one past the last element of the array object, the
evaluation will not produce an overflow; otherwise, the behavior is
undefined. If the result points one past the last element of the array object,
it will not be used as the operand of a unary <d:code>*</d:code> operator that
is evaluated.</d:para>
<d:para>When two pointers are subtracted, both shall point to elements of the
same array object, or one past the last element of the array object; the result
is the difference of the subscripts of the two array elements. The size of the
result is implementation-defined, and its type (a signed integer type) is
<d:code>ptrdiff_t</d:code> defined in the &lt;stddef.h> header. If the result
is not representable in an object of that type, the behavior is undefined. In
other words, if the expressions <d:code>P</d:code> and <d:code>Q</d:code> point
to, respectively, the <d:code>i</d:code>-th and <d:code>j</d:code>-th elements
of an array object, the expression <d:code>(P)-(Q)</d:code> has the value
<d:code>i-j</d:code> provided the value fits in an object of type
<d:code>ptrdiff_t</d:code>. Moreover, if the expression <d:code>P</d:code>
points either to an element of an array object or one past the last element of
an array object, and the expression <d:code>Q</d:code> points to the last
element of the same array object, the expression <d:code>((Q)+1)-(P)</d:code>
has the same value as <d:code>((Q)-(P))+1</d:code> and as
<d:code>-((P)-((Q)+1))</d:code>, and has the value zero if the expression
<d:code>P</d:code> points one past the last element of the array object, even
though the expression <d:code>(Q)+1</d:code> does not point to an element of
the array object.</d:para>
<d:para>You can also apply increment and decrement operators on pointers. I
will show you a reimplementation of previos program using increment
operators:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int *p = NULL;

  p = (int*)malloc(sizeof(int)*8);
  int *q = p;

  for(int i=0;i&lt;8;i++)
  {
    *(p+i)=i;
    printf("Content at %dth location is %d.\n", i, *(q++));
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Content at 0th location is 0.
Content at 1th location is 1.
Content at 2th location is 2.
Content at 3th location is 3.
Content at 4th location is 4.
Content at 5th location is 5.
Content at 6th location is 6.
Content at 7th location is 7.</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Address and Indirection Operators</d:title>
	<d:para>As is the case with subscript operator and pointer arithmetic
	in the fourth chapter that I have delayed these two as well for I
	wanted to put them here. Whenever you declare a plain variable you have
	an address associated with it and that variable is an lvalue. Just to
	repeat an lvalue is a value whose address can be taken. To take the
	address of an lvalue you use the address operator which is &amp;. Now a
	pointer points to address of any value as we know so we can use address
	operator to get the address and use a pointer to store. There are
	several usage of storing an address. Most notable of those is
	pass-by-address which we will see in next chapter which will deal with
	functions. Let us say we take address of a variable and assign that to
	a pointer. Then if we change the value of the memory pointed to by the
	pointer then the variable whose address has been taken will get updated
	with this new value. Consider for example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int  i = 8;
  int *p = &amp;i;

  *p = 7;

  printf("i=%d *p=%d\n", i, *p);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>i=7 *p=7</d:screen>
<d:para>So you see the power of pointers that if you have an address you can
modify its contents. This is exacly what <d:code>scanf()</d:code> does. The
dereference operator or indirection operator or aterisk (<d:code>*</d:code>)
gives you value at address pointed to by pointer <d:code>o</d:code>. However,
if you want to change address of some varible like that ofi by doing something
like &amp;i=&amp;someOthervar; you cannot do that because address is not an
lvalue. However, you can pass address of a pointer variable to some other
function and use it using pointer to pointer notation which I will show you in
next chapter. As I have shown pointers are kind of equivalent to array except
the fact that they are on heap and sizeof operator will not work on
them. Consider this example:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int  a[4] = {1,2,3,4};
  int* p    = a;
  int* q    = (int*)calloc(10, 4);

  for(int i=0; i&lt;4; i++)
    printf("i=%d *p=%d\n", i, *(p+i));

  printf("Size of a=%d\n", sizeof(a));
  printf("Size of p=%d\n", sizeof(p));
  printf("Size of q=%d\n", sizeof(q));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>i=0 *p=1
i=1 *p=2
i=2 *p=3
i=3 *p=4
Size of a=16
Size of p=4
Size of q=4</d:screen>
<d:para>Here <d:code>p</d:code> acts as pointer to array. You can have a
pointer to any kind of array. You can point to any element of array because
array elements are lvalues whose addresses can be taken and to initialize a
pointer alll you need is an address.</d:para>
<d:caution><d:title>Advice</d:title><d:para>Complex pointer arithmetic is best avoided. Be very
thoughtful that if you really really need it. Use loops to iterate
arrays. Multiple levels of indirection is also bad. Typically I have not seen
more than pointers to pointers. Now we will see array of
pointers.</d:para></d:caution> 
      </d:sect1>
      <d:sect1>
	<d:title>Arrays of Pointers</d:title>
	<d:para>Pointers are just like ordinary variables so we can as well create
	array of pointers. Consider following for example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  char* strArray[2]={"Hello", "Universe!"};

  for(int i=0; i&lt;2; i++)
    printf("%s\n", strArray[i]);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Hello
Universe!</d:screen>
<d:para>Note how the length of two array elements are different as they are
pointers. Let us do a more complex example.</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int* intArray[2];

  intArray[0] = (int*)calloc(3, sizeof(int));
  intArray[1] = (int*)calloc(2, sizeof(int));

  *intArray[0]     = 4;
  *(intArray[0]+1) = 5;
  *(intArray[0]+2) = 6;


  *intArray[1]     = 1;
  *(intArray[1]+1) = 2;

  for(int i=0; i&lt;3; i++)
  {
    printf("Memory location=%p Content=%d\n", intArray[0]+i, *(intArray[0]+i));
  }

  for(int i=0; i&lt;2; i++)
  {
    printf("Memory location=%p Content=%d\n", intArray[1]+i, *(intArray[1]+i));
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Memory location=0x87d1008 Content=4
Memory location=0x87d100c Content=5
Memory location=0x87d1010 Content=6
Memory location=0x87d1018 Content=1
Memory location=0x87d101c Content=2</d:screen>
<d:para>Note missing four bytes between 6 and 1. Memory locations may be
different on your system. But see how messy pointer syntax can go even with
such simple code. Array to pointers are useful for containing variables of
dynamic size of same type.</d:para>
<d:para>Pointers to pointers are same as array of pointers. The only difference
is that you can dynamically modify the number of elements.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Pointers of Pointers</d:title>
	<d:para>Consider the following example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int** intPtr;

  intPtr = (int**)malloc(sizeof(sizeof(int*)*2));

  *intPtr = (int*)malloc(sizeof(int)*3);
  *(intPtr+1) = (int*)malloc(sizeof(int)*4);

  **intPtr     = 1;
  *(*intPtr+1) = 2;
  *(*intPtr+2) = 7;


  **(intPtr+1)      = 3;
  *(*(intPtr+1)+1)  = 5;
  *(*(intPtr+1)+2)  = 9;
  *(*(intPtr+1)+3)  = 11;

  for(int i=0; i&lt;3; i++)
    printf("Memory location=%p content=%d\n", *intPtr+i, *(*intPtr+i));

  for(int i=0; i&lt;4; i++)
    printf("Memory location=%p content=%d\n", *(intPtr+1)+i, *(*(intPtr+1)+i));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Memory location=0x9947018 content=1
Memory location=0x994701c content=2
Memory location=0x9947020 content=7
Memory location=0x9947028 content=3
Memory location=0x994702c content=5
Memory location=0x9947030 content=9
Memory location=0x9947034 content=11</d:screen>
<d:para>Again memory location may change on your system. As you can see how
things can get messy with pointers. Believe me you will hate this. Also, I do
not see any reason to use more than two levels of indirection. So you get the
idea. If you need dynamic no. of elements with dynamic content you are going to
use pointers to pointers.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>realloc() Function</d:title>
	<d:para>Once <d:code>malloc()</d:code> and <d:code>calloc()</d:code>
	allocate some memory you have that certain amount of memory available
	to you. When you have an array you have some memory but what if you
	want more later. <d:code>reallloc()</d:code> comes to rescue you. Here
	is a sample program:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int *p = (int*)malloc(sizeof(int)*2);

  *p     = 5;
  *(p+1) = 7;

  printf("Original 1st element=%d\n", *p);
  printf("Original 2nd element=%d\n", *(p+1));

  p = (int*)realloc(p, sizeof(int)*4);

  *(p+2) = 9;
  *(p+3) = 11;

  printf("New 1st element=%d\n", *p);
  printf("New 2nd element=%d\n", *(p+1));
  printf("New 3rd element=%d\n", *(p+2));
  printf("New 4th element=%d\n", *(p+3));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Original 1st element=5
Original 2nd element=7
New 1st element=5
New 2nd element=7
New 3rd element=9
New 4th element=11</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>free() Function</d:title>
	<d:para>Whatever program we have written in this chapter related to
	dynamic memory allocation using <d:code>malloc()</d:code> etc are very
	bad code just because we are not releasing memory properly. Any call to
	memory allocation functions have to be matched with a corresponding
	<d:code>free()</d:code> call. The reason for this is that when all
	pointers to a memory area are lost and that memory is not freed then
	operating system cannot recycle that memory. In case of servers or long
	running processes this may eat up all the physical RAM and virtual
	memory and eventually freeze the system. To guard against such events
	you must macth all allocation calls with deallocation calls so that
	operating system can reclaim the freed memmory.</d:para> 
	<d:para>You must heed this warning given here with all of your
	focus. You got to handle heap that is dynamically allocated memory
	yourself. You allocate and you free it. If you miss you have a memory
	leak.</d:para>
	<d:warning><d:title>Warning</d:title>
	<d:para>You must free all memory you allocate.</d:para></d:warning>
      </d:sect1>
      <d:sect1>
	<d:title>Constness</d:title>
	<d:para>To make anything constant you need to associate const keyword
	with it. For example, <d:code>const int i; const float
	f;</d:code>. However, with pointers in picture scenarios change
	compared to two simple previous examples. When pointers are made
	constant there are two elements. First is the pointer itself and second
	is the value pointed to. Consider for example:</d:para>
	<d:programlisting role="CLexer">const int* i;  //constant pointer data is not
int* const i;  //constant data pointer is not
const int* const i; //both are const</d:programlisting>
<d:para>The way to read it is you draw a vertical line where asterisk(*) is
there and the value associated with const is constant. Whenever you need use a
constant freely. Try to use constants more and more. Also, prefre them to
following:</d:para>
<d:programlisting role="CLexer">#define MAX 10</d:programlisting>
<d:para>As told and shown to you it will replace <d:code>MAX</d:code> with 10
in the file everywhere without any concern of type-safety. Also, it does not
enter in the symbol table so while debugging you will not see
<d:code>MAX</d:code> anywhere. So instead you should use something
like:</d:para>
<d:programlisting role="CLexer">const int MAX=10;</d:programlisting>
<d:para>I will also like to say something about volatile variables. Beginners
are usually convinced that volatile variables cannot be declraed as const. Let
me iterate the definitions once again. A const variable cannot be modifed by
the program itself. A volatile variable can be modified by sources other than
the program itself. Hence, a const volatile variable cannot be modified by the
program but other sources can still modify it.</d:para>
      </d:sect1>
    </d:chapter>
    <xi:include href="functions.xml"/>
    <xi:include href="su.xml"/>
    <xi:include href="macros.xml"/>
    <xi:include href="std.xml"/>
    <xi:include href="assert.xml"/>
    <d:index>
    <d:title>Index</d:title>
  </d:index>
</d:book>
