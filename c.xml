<?xml version="1.0" encoding="UTF-8"?>
<d:book version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
  <d:info>
    <d:title>C Programming with C99</d:title>
    <d:author>
      <d:personname>
        <d:firstname>Shiv</d:firstname>
        <d:surname>Dayal</d:surname>
      </d:personname>
    </d:author>
    <d:copyright>
      <d:year>2011, 2013</d:year>
      <d:holder>Shiv S. Dayal</d:holder>
    </d:copyright>
  </d:info>
  <xi:include href="preface.xml"/>
  <xi:include href="introduction.xml"/>
  <d:chapter>
    <?dbhtml filename="fs/index.html" ?>
    <d:title>Following Specification</d:title>
    <d:para>At this point of time I would like to look back and refer to C99 specification n1124.pdf
      located at <link xmlns="http://docbook.org/ns/docbook"
        xlink:href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"
        >http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf</link>, which, is the C99
      specification with me. Since my thoughts are random in nature I will try to follow the
      organization of content given in the specification. This treatment of C99 is very tightly
      coupled with compiler(clang) and specification. If someone says that a book can be written by
      ignoring any of these two then I will be the last person to believe that.:P However, note that
      I will not include all the contents of specification and will exclude some of very obvious and
      trivial sections/subsections. The following terms, definitions and symbols have come from
      specification, however, some are omitted for the sake of conciseness. When I will repeat the
      specification at times I will do a verbatim copy just for quick reference and then add an
      explanation to that. Believe me you can learn most of the language just by studying the
      specification itself. Chapter no. 2, 3 and 4 will have material which may have redundant
      material discussed elsewhere in the book. Note that specification is directed more at compiler
      writers rather than at developers. However, it still covers a lot of ground and is also
      helpful to understand the nature of different compilers as where they can go in different
      directions.</d:para>
    <d:sect1>
      <d:title>Terms, Definitions and Symbols</d:title>
      <d:orderedlist>
        <d:listitem>
          <d:para><d:emphasis role="bold">access:</d:emphasis> &lt;execution-time action&gt; to read
            or modify the value of an object.</d:para>
          <d:para>NOTE 1: Where only one of these two actions is meant, “read” or “modify” is
            used.</d:para>
          <d:para>NOTE 2: “Modify” includes the case where the new value being stored is the same as
            the previous value.</d:para>
          <d:para>NOTE 3: Expressions that are not evaluated do not access objects.</d:para>
          <d:para>There are two parts of any program. Data and instruction. Programs are stored in
            file on some non-volatile storage for example, hard disk drive, CD, DVD, tape drive.
            When they are executed from non-volatile storage they are transferred to some volatile
            storage typically RAM (Random Access Memory) of the computer. When a program is executed
            it becomes a living entity capable of doing something and sometimes also referred as
            process. So when the contents of RAM (henceforth referred as memory) is either read or
            written (it does not matter whether the value is same or new) to then it is defined as
            access. Here point to be noted is that the expressions which will not be evaluated do
            not access objects.</d:para>
          <d:para>There are certain issues wit the term read and modify. One can ask it it the case
            that multiplication or division of a number with 1 modifies it or addition or
            subtraction of a number with 0 modifies it. The answer is yes on all these accounts.
            Similarly, you can ask if a bit-field is accessed then is it the case that the
            bit-fields sharing the storage in memory are also accessed. My answer would be yes. The
            reason is there is no way to get address of an individual bit and we get at least
            32-bits in one fetch cycle on a 32-bit processor.</d:para>
          <d:para>There can be various reasons why an expression is not evaluated. For
            example:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <d:para>being part of a statement which is not executed probably because of
                conditional compilation,</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>being part of a sub-expression whose evaluation is conditional on other
                sub-expressions within a full expression; this means the above point, and</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>being an operand of the sizeof operator. sizeof operator never evaluates its
                operand or try to access them. It just computes their sizes and pass it
                along.</d:para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>Also, consider the following
            program:<d:programlisting role="CLexer">#include &lt;stdio.h&gt;

int main()
{
  int a=0, b=0, c=3, d=4;

  a = c + d;
  b = c + d;

  return 0;
}</d:programlisting></d:para>
          <d:para>In this code it is not necessary that data for c and d will be accessed for second
            addition.</d:para>
          <d:para>Also consider the following
            program:<d:programlisting role="CLexer">#include &lt;stdio.h&gt;

typedef struct {
  volatile int x1:3;
  volatile int x2:3;
  volatile int x3:4;
  volatile int x4:1;
} S;

int main()
{
  int i = 7;
  S s;

  i = s.x2;

  return 0;
}</d:programlisting></d:para>
          <d:para>Now depending on whether system is little-endian or big-endian the storage of x2
            and x3 will be in different bytes. Also, this will change the way bytes are accessed
            when x2 is referred in memory. Many combinations are possible depending on processor
            architecture.</d:para>
        </d:listitem>
        <d:listitem>
          <d:para><d:emphasis role="bold">alignment:</d:emphasis> requirement that objects of a
            particular type be located on storage boundaries with addresses that are particular
            multiples of a byte address.</d:para>
          <d:para>Say your program requires x bytes of memory then it will not be always given x
            bytes but something more. Say an object requires y bytes then it will be always greater
            or equal to y bytes. This is required so that objects are always located on storage
            boundaries that are particular multiples of byte address. The reason for this alignment
            lies in the efficiency of the operating system as a whole. As we know that on 32-bit
            systems data bus is 32 bits similarly on 64-bit systems it is 64 bits. This means in one
            fetch cycle (read up on this on some microprocessor or computer architecture book) only
            32-bits can be fetched. 32-bits means 4 bytes. Oops! I did not tell you about bits and
            bytes conversion. Not even nibble. However, since 4 bytes can be fetched in one cycle
            compiler tries to optimize the data in group of 4 bytes. Given below are some
            examples.<d:programlisting role="CLexer">/* Description: Demonstration of structure padding and memory alignment.*/

#include &lt;stdio.h&gt;

typedef struct
{
  char a;
  int b;
}A;

typedef struct
{
  char a;
  int b;
  char c;
  char d;
  char e;
  int f;
}B;

typedef struct
{
  char x;
  char y;
  int z;
}C;

typedef struct
{
  char x;
  int z;
  char y;
}D;

int main()
{
  A a;
  B b;
  C c;
  D d;
  printf("Size of structure %c is %d\n",'A', sizeof(a));
  printf("Size of structure %c is %d\n",'B', sizeof(b));
  printf("Size of structure %c is %d\n",'C', sizeof(c));
  printf("Size of structure %c is %d\n",'D', sizeof(d));

  return 0;
}</d:programlisting></d:para>
          <d:para>the output is:<d:screen>Size of structure A is 8
Size of structure B is 16
Size of structure C is 8
Size of structure D is 12</d:screen></d:para>
          <d:para>Now let me ask you a question that how come size of C is 8 while size of D is 12
            while both structures contain same no. of similar elements. The answer lies in the order
            of elements. Further let us consider the following
            program:<d:programlisting role="CLexer">#include &lt;stdio.h&gt;

typedef struct {
  char c;
  int j;
}t;

int main()
{
  t s1;

  s1.j = 4;
  s1.c = 5;

  printf("%p %p", &amp;s1.j, &amp;s1.c);

  return 0;
}</d:programlisting></d:para>
          <d:para>and the output
            is:<d:screen>0xbfc98f7c 0xbfc98f78</d:screen></d:para>
          <d:para>Now if you notice <d:code>0xbfc98f7c % 4</d:code> is 0 which is our alignment
            requirement. So, now you can see why structure C and D have different sizes.</d:para>
          <d:para>Another point worth noting is that certain processors allocate arrays on word
            boundaries which are power of 2. For example, a character array requiring x bytes will
            actually n bytes where x is not power of 2 and n is next power of 2 which is greater
            than x. Such optimizations are quite common in computers and you need to be aware of it
            to write efficient programs because you cannot make any assumptions about behavior of
            processor.</d:para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> argument:</emphasis>
          </para>
          <para xmlns="http://docbook.org/ns/docbook">actual argument</para>
          <para xmlns="http://docbook.org/ns/docbook">actual parameter (deprecated)</para>
          <para xmlns="http://docbook.org/ns/docbook">expression in the comma-separated list bounded
            by the parentheses in a function call expression, or a sequence of preprocessing tokens
            in the comma-separated list bounded by the parentheses in a function-like macro
            invocation.</para>
          <para xmlns="http://docbook.org/ns/docbook">Sometimes they are also called actual
            parameters(in function definition) but as you can see in specification ISO/IEC 9899:TC2
            Section 3.3 this term is being deprecated. A function can have zero or more actual
            arguments and if they are more than one then each of them will be separated by a comma.
            These also apply to macros that is preprocessor directives when invoked like a function.
          </para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> behavior:</emphasis>
            external appearance or action</para>
          <para xmlns="http://docbook.org/ns/docbook">By this term behavior the specification tries
            to categorize certain behavior which do not fall in other categories. For example, there
            are four more types of behaviors namely implementation-defined behavior, locale-specific
            behavior, undefined behavior and unspecified behavior. The term behavior categorizes
            external and those behaviors which do not fall under these four categories. External
            behavior includes mouse, keyboard and such.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">implementation-defined
              behavior:</emphasis> unspecified behavior where each implementation documents how the
            choice is made.</para>
          <para xmlns="http://docbook.org/ns/docbook">EXAMPLE An example of implementation-defined
            behavior is the propagation of the high-order bit when a signed integer is shifted
            right.</para>
          <para xmlns="http://docbook.org/ns/docbook">When specification does not specify how a
            particular element of language should be implemented then programs use their logic to
            implement these things and sometimes it depends on hardware as well. Behavior of such
            elements is called implementation-defined-behavior. A full list of such behaviors is
            typically provided by the compiler.</para>
          <para xmlns="http://docbook.org/ns/docbook">Consider the following example:</para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>

int main()
{
  printf("%d %d\n", -2>>1, -1>>1);

  return 0;
}</d:programlisting>
          <d:para>and the output is:</d:para>
          <d:programlisting>-1 -1</d:programlisting>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> locale-specific
              behavior:</emphasis> behavior that depends on local conventions of nationality,
            culture, and language that each implementation documents</para>
          <para xmlns="http://docbook.org/ns/docbook">EXAMPLE An example of locale-specific behavior
            is whether the islower function returns true for characters other than the 26 lowercase
            Latin letters.</para>
          <para xmlns="http://docbook.org/ns/docbook">Any behavior which changes when locale of the
            program changes will come under this category. The character e-acute is a lowercase
            letter in a Latin-1 locale, but not in the “C” locale. A full list of such behaviors is
            typically provided by the compiler.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> undefined
              behavior:</emphasis> behavior, upon use of a non-portable or erroneous program
            construct or of erroneous data, for which International Standard imposes no
            requirements.</para>
          <para xmlns="http://docbook.org/ns/docbook">NOTE: Possible undefined behavior ranges from
            ignoring the situation completely with unpredictable results, to behaving during
            translation or program execution in a documented manner characteristic of the
            environment (with or without the issuance of a diagnostic message), to terminating a
            translation or execution (with the issuance of a diagnostic message).</para>
          <para xmlns="http://docbook.org/ns/docbook">EXAMPLE An example of undefined behavior is
            the behavior on integer overflow.</para>
          <para xmlns="http://docbook.org/ns/docbook">We will see more examples of these undefined
            behaviors as we go through the specification.</para>
          <para xmlns="http://docbook.org/ns/docbook">It is very easy to say undefined behavior for
            specification but when a compiler programmer writes a compiler he cannot really say that
            our program is causing undefined behavior. Sometimes it will emit a warning but
            sometimes it will silently compile the program. However, then output of two compilers
            may not match. Even output of two different version of compilers may not match.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> unspecified
              behavior:</emphasis> use of an unspecified value, or other behavior where this
            International Standard provides two or more possibilities and imposes no further
            requirements on which is chosen in any instance.</para>
          <para xmlns="http://docbook.org/ns/docbook">EXAMPLE An example of unspecified behavior is
            the order in which the arguments to a function are evaluated.</para>
          <para xmlns="http://docbook.org/ns/docbook">We will more of these as we progress and list
            of all such behaviors is given in the appendix.</para>
          <para xmlns="http://docbook.org/ns/docbook">It is different than undefined behavior but
            compiler writers are still free to to implement as they see fit. </para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">
            <emphasis role="bold">bit:</emphasis> unit of data storage in the execution environment
            large enough to hold an object that may have one of two values.</para>
          <para xmlns="http://docbook.org/ns/docbook">NOTE It need not be possible to express the
            address of each individual bit of an object.</para>
          <para xmlns="http://docbook.org/ns/docbook">The term bit was first coined by John Wilder
            Tukey who also coined the term software, best known for his work on fast Fourier
            transform(FFT). Note that base-2 is not the most efficient way to store the numbers but
            it is base-e. You can read about more on it in. [Hayes] Those who are from electronics
            background know that transistors operate in cut-off(very low voltage, high current) and
            saturation(high voltage, low current). These two states consume very less power. The
            other two states are active and reverse-active. However, power consumption is more.
            Therefore, just to save power there is a trade-off between compactness and power
            consumption. Usually, popular compilers like gcc or clang do not provide mechanism to
            sequence of bits. However, there is a compiler which allows bit-level addressing in
            registers if not memory. [Wegner] There are processors where data is not byte-aligned
            and some bit-level addressing is available as shown in [Nie] . </para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">
            <emphasis role="bold">byte:</emphasis> addressable unit of data storage large enough to
            hold any member of the basic character set of the execution environment.</para>
          <para xmlns="http://docbook.org/ns/docbook">NOTE 1: It is possible to express the address
            of each individual byte of an object uniquely.</para>
          <para xmlns="http://docbook.org/ns/docbook">NOTE 2: A byte is composed of a contiguous
            sequence of bits, the number of which is implementation-defined. The least significant
            bit is called the low-order bit; the most significant bit is called the high-order
            bit.</para>
          <para xmlns="http://docbook.org/ns/docbook">As most of programmers will know that a byte
            is 8 bits. However, the term for 8 bits is octet as the term for 4 bits is nibble. This
            term is now so common for 8 bits that they are used interchangeably. Note that byte and
            char are different. byte is used to denote the storage while char is used to denote the
            type. We can say a 32-bit integer occupies 4 bytes but we cannot say the same in terms
            of char. [POSIX] defines a byte as an octet.</para>
          <para xmlns="http://docbook.org/ns/docbook">Considering an integer which is a multi-byte
            type can have its bytes individually addressed. Even though it says that numbers of bits
            is implementation-defined on most systems this number is governed by CHAR_BIT macro
            which has a value of 8. </para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">character:</emphasis>
            Member of a set of elements used for the organization, control, or representation of
            data.</para>
          <para xmlns="http://docbook.org/ns/docbook">There are many character sets each capable of
            representing one language in this world. Sometimes they fit in a single byte while
            sometimes they do not and then we need more bytes to represent that kind of
            language.</para>
          <d:orderedlist numeration="upperroman">
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">single-byte character: Bit representation
                that fits in a byte.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">multi-byte character: Sequence of one or
                more bytes representing a member of the extended character set of either the source
                or the execution environment.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">wide Character: Bit representation that
                fits in an object of type wchar_t, capable of representing any character in the
                current locale.</para>
            </d:listitem>
          </d:orderedlist>
          <d:para>A character is one the most primitive types of C programming language. On most
            machines its size is 1 byte. Even though void has also a size of 1 byte it is known as
            incomplete type and cannot be used to create an object.</d:para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> constraint:</emphasis>
            Restriction, either syntactic or semantic, by which the exposition of language elements
            is to be interpreted.</para>
          <para xmlns="http://docbook.org/ns/docbook">There are certain restrictions imposed by the
            language through the standard which programmers must adhere to. Violation of these
            restrictions may lead to diagnostic messages being issued from the compiler. We will see
            such constraints throughout the standard. </para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">correctly rounded
              result:</emphasis> Representation in the result format that is nearest in value,
            subject to the effective rounding mode, to what the result would be given unlimited
            range and precision.</para>
          <para xmlns="http://docbook.org/ns/docbook">This is something which is very much related
            to floating-point numbers. Consider two representable numbers a and b. Now there can be
            infinite numbers between these two. However, there will be exactly one number which will
            lie in between them. If this number is not representable as per floating-point
            specification then the rounding of this number will depend on the current rounding mode
            in effect. IEEE specifies four rounding modes for rounding floating-point numbers. They
            are: <code>rd_near</code> (for rounding to the nearest), <code>rd_zero</code> (for
            rounding to zero), <code>rd_minf</code> (for rounding to minus infinity) and
              <code>rd_pinf</code> (for rounding to plus infinity). Consider the following program
            which shows all four rounding modes in action.</para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;fenv.h>

int main (int argc, char **argv)
{
  float x, y, z1, z2;

  x = 1.0;
  y = 1.0e-20;

  fesetround(FE_TONEAREST);
  z1 = x - y; z2 = y - x; z1 = z1 - x; z2 = z2 + x;
  printf("near, z1 = %17.10e, z2 = %17.10e \n", z1, z2);

  fesetround(FE_UPWARD);
  z1 = x - y; z2 = y - x; z1 = z1 - x; z2 = z2 + x;
  printf("minf, z1 = %17.10e, z2 = %17.10e \n", z1, z2);

  fesetround(FE_DOWNWARD);
  z1 = x - y; z2 = y - x; z1 = z1 - x; z2 = z2 + x;
  printf("pinf, z1 = %17.10e, z2 = %17.10e \n", z1, z2);

  fesetround(FE_TOWARDZERO);
  z1 = x - y; z2 = y - x; z1 = z1 - x; z2 = z2 + x;
  printf("zero, z1 = %17.10e, z2 = %17.10e \n", z1, z2);


return 0;
}</d:programlisting>
          <d:para>and the output is:</d:para>
          <d:screen>near, z1 =  0.0000000000e+00, z2 =  0.0000000000e+00
minf, z1 =  0.0000000000e+00, z2 =  5.9604644775e-08
pinf, z1 = -5.9604644775e-08, z2 = -0.0000000000e+00
zero, z1 = -5.9604644775e-08, z2 =  5.9604644775e-08</d:screen>
          <d:para>Note that you need to link with <d:code>-lm</d:code> for compilation of the
            program, just in case.</d:para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> diagnostic
              message:</emphasis> message belonging to an implementation-defined subset of the
            implementation’s message output.</para>
          <para xmlns="http://docbook.org/ns/docbook">These refer to compilation-time warning or
            error messages produced by the compiler. Since the specification does not direct any
            particular way in which these diagnostic messages should be generated all compiler
            writers are free to do whatever suits their whim. For example, earlier gcc used to print
            only line numbers but now they also show column numbers where errors have occurred.
            clang goes one step further and produces colored output. </para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">forward
              reference:</emphasis> Reference to a later subclause of International Standard that
            contains additional information relevant to this subclause.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"
              >implementation:</emphasis> Particular set of software, running in a particular
            translation environment under particular control options, that performs translation of
            programs for, and supports execution of functions in, a particular execution
            environment.</para>
          <d:para>Here implementation means what we typically know as compiler. Note that it does
            not even say compiler. Even a C interpreter can be taken as an implementation. However,
            historically C has been a compiled language so we will mean implementation as compiler
            henceforth. Note that when you change compiler or even compiler options then you are
            changing the translation of code which means implementation has changed.</d:para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> implementation
              limit:</emphasis> Restriction imposed upon programs by the implementation.</para>
          <para xmlns="http://docbook.org/ns/docbook">In C all types have a range or limits
            partially for efficiency reasons. The specification also says that a strictly conforming
            program will remain below the lowest limits. Now what these limits do is that increase
            the portability of program just like being the lowest common denominator.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">object:</emphasis>
            region of data storage in the execution environment, the contents of which can represent
            values.When referenced, an object may be interpreted as having a particular type.</para>
          <para xmlns="http://docbook.org/ns/docbook">These are what we know as variables in common
            developer language. The region of data storage occupied by an object will be contiguous
            number of bytes. Note that the term object used in ISO standard of C has nothing to do
            with object in object-oriented programming paradigm.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">parameter:</emphasis>
            Also known as formal parameter or formal argument (deprecated). Object declared as part
            of a function declaration or definition that acquires a value on entry to the function,
            or an identifier from the comma-separated list bounded by the parentheses immediately
            following the macro name in a function-like macro definition.</para>
          <para xmlns="http://docbook.org/ns/docbook">For example:</para>
          <d:programlisting role="CLexer">#define FUNC(X, Y) //two parameters

int f(int x);  //one parameter
void y(int y, int z); //two parameters</d:programlisting>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold"> recommended
              practice:</emphasis> Specification that is strongly recommended as being in keeping
            with the intent of the standard, but that may be impractical for some
            implementations.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">value:</emphasis>
            Precise meaning of the contents of an object when interpreted as having a specific
            type.</para>
          <para xmlns="http://docbook.org/ns/docbook">This at times will depend on the type of
            machine. For example, a union containing an integer and two characters will have
            different values for characters on big-endian and little-endian machines. But on the
            same machine the meaning must be accurate for contents of an object.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">implementation-defined
              value:</emphasis> Unspecified value where each implementation documents how the choice
            is made.</para>
          <para xmlns="http://docbook.org/ns/docbook">There are certain values defined by the
            implementation. For example, in the table for defining numerical limits in chapter 3
            specification defines <code>INT_MAX</code> in a fashion as if integers are 16-bit. But
            all modern 32-bit compilers do not follow this limit and they treat integer as 32-bit
            entity. indeterminate value: Either an unspecified value or a trap
            representation.</para>
          <para xmlns="http://docbook.org/ns/docbook">Consider a variable declaration int i;. What
            value does this integer i contain? We do not know. The value contained is unspecified as
            per specification nomenclature. Developers also know this as garbage value. Behavior
            caused by usage of such variables will be known as unspecified behavior. However,
            behavior caused by a trap representation will be undefined behavior.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><emphasis role="bold">unspecified
              value:</emphasis> Valid value of the relevant type where International Standard
            imposes no requirements on which value is chosen in any instance. NOTE: An unspecified
            value cannot be a trap representation. As we have seen in last example the value of the
            variable will be unspecified value. </para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><inlineequation>
              <mml:math>
                <mml:mrow>
                  <mml:mo>⌈</mml:mo>
                  <mml:mtext> x</mml:mtext>
                  <mml:mo>⌉</mml:mo>
                </mml:mrow>
              </mml:math>
            </inlineequation> : ceiling of x: the least integer greater than or equal to x.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook"><inlineequation>
              <mml:math>
                <mml:mrow>
                  <mml:mo>⌊</mml:mo>
                  <mml:mtext> x </mml:mtext>
                  <mml:mo>⌋</mml:mo>
                </mml:mrow>
              </mml:math>
            </inlineequation> : floor of x: the greatest integer less than or equal to x.</para>
        </d:listitem>
      </d:orderedlist>
      <d:para>You can also read the conformance part of this chapter which is chapter 3 in
        specification.</d:para>
    </d:sect1>
  </d:chapter>
  <d:chapter>
    <?dbhtml filename="env/index.html" ?>
    <d:title>Environment</d:title>
    <d:para>As last chapter was mapped to chapter 3 of specification similarly this chapter is
      mapped to chapter 5 of specification. Please refer to these sections simultaneously.</d:para>
    <d:para>We store source code in two different files with two different extensions. One regular
      expression for source code is *.c and the other is *.h. These files are stored in hard disk.
      When compiled it may produce *.o files optionally. Your program may also produce *.a, *.so,
      a.out (this name may be different for you if you provide -o switch to gcc. At least one *.a or
      *.so or a.out or its equivalent will be produced on unix systems. On Windows systems you may
      produce *.lib, *.dll or *.exe. *.lib, *.dll and *.exe map directly to their counterparts in
      Unix as *.a, *.so and a.out. These files are called static library, dynamic library, and
      executables respectively.</d:para>
    <d:para>An implementation translates C source files and executes C programs in two
      data-processing system environments, which will be called the <d:emphasis>translation
        environment</d:emphasis> and the <d:emphasis>execution environment</d:emphasis> in this
      International Standard. Their characteristics define and constrain the results of executing
      conforming C programs constructed according to the syntactic and semantic rules for conforming
      implementations.</d:para>
    <d:para>Just to ease the words translation environment is the machine where the program is being
      compiled and execution environment is the machine where the executables are/will be
      executed.</d:para>
    <d:sect1>
      <d:title>Conceptual Model</d:title>
      <d:sect2>
        <d:title>Translation Environment</d:title>
        <d:sect3>
          <d:title>Program Structure</d:title>
          <d:para>A C program need not all be translated at the same time. The text of the program
            is kept in units called <d:emphasis>source files</d:emphasis>, (or
              <d:emphasis>preprocessing files</d:emphasis>) in International Standard. A source file
            together with all the headers and source files included via the preprocessing directive
              <d:code>#include</d:code> is known as a <d:emphasis>preprocessing translation
              unit</d:emphasis>. After preprocessing, a preprocessing translation unit is called a
              <d:emphasis>translation unit</d:emphasis>. Previously translated translation units may
            be preserved individually or in libraries. The separate translation units of a program
            communicate by (for example) calls to functions whose identifiers have external linkage,
            manipulation of objects whose identifiers have external linkage, or manipulation of data
            files. Translation units may be separately translated and then later linked to produce
            an executable program.</d:para>
          <d:para>A normal C file is preprocessing <d:emphasis>translation unit</d:emphasis> while a
            file produced by output of <d:code>gcc -E filename.c</d:code> is a
              <d:emphasis>translation unit</d:emphasis>. For example, you can have two source files
            and three headers. <d:code>par1.c, part2.c, part1.h, part2.h</d:code> and
              <d:code>common.h</d:code>. Now these may be individually compiled to
              <d:code>part1.o</d:code> and <d:code>part2.o</d:code> and then linked to have a final
            program <d:code>output</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> linkages of identifiers (Linkages of identifiers), external
            definitions (External definitions), preprocessing directives (Preprocessing
            Directives).</d:para>
        </d:sect3>
        <d:sect3>
          <d:title>Translation Phases</d:title>
          <d:para>The precedence among the syntax rules of translation is specified by the following phases.<d:footnote>
              <d:para>Implementations behave as if these separate phases occur, even though many are
                typically folded together in practice.</d:para>
            </d:footnote></d:para>
          <d:orderedlist>
            <d:listitem>
              <d:para>Physical source file multibyte characters are mapped, in an
                implementation-defined-manner, to the source character set (introducing newline
                characters for end-of-line indicators) if necessary. Trigraph sequences are replaced
                by corresponding single-character internal representations.</d:para>
              <d:para>Typically source file reside on HDD in source character set described in
                Character Sets{xref}. Sometimes they may also reside in other storage mediums also
                for example, floppy disk, USB drive etc. Implementation defines how multibyte
                characters will map to source character set. Different operating systems typically
                stored end-of-line in different ways. All these are converted to newline characters.
                Trigraph sequences are converted to their equivalents. For example, consider
                following:<d:programlisting role="CLexer">printf("??&lt;\n");</d:programlisting></d:para>
              <d:para>process it with command <d:code>gcc -E -trigraphs test.c</d:code> to get
                following:<d:programlisting role="CLexer"># 1 "test.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 1 "test.c"
printf("{\n");</d:programlisting></d:para>
            </d:listitem>
            <d:listitem>
              <d:para>Each instance of a backslash character (\) immediately followed by a new-line
                character is deleted, splicing physical source lines to form logical source lines.
                Only the last backslash on any physical source line shall be eligible for being part
                of such a splice. A source file that is not empty shall end in a new-line character,
                which shall not be immediately preceded by a backslash character before any such
                splicing takes place.</d:para>
              <d:para>Consider
                following:<d:programlisting role="CLexer">printf("line 1 \
line 2");</d:programlisting></d:para>
              <d:para>processing it though preprocessor like <d:code>gcc -E test.c</d:code> will
                yield<d:programlisting role="CLexer"># 1 "test.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 1 "test.c"
printf("line 1 line 2");</d:programlisting></d:para>
              <d:para>
                <d:programlisting role="CLexer">printf("line 1" \</d:programlisting>
              </d:para>
              <d:para>and<d:programlisting role="CLexer">#include "test1.c"
"line 2 \
line 3");</d:programlisting></d:para>
              <d:para>process <d:code>test2.c</d:code> to get
                following:<d:programlisting role="CLexer"># 1 "test1.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 1 "test1.c"
# 1 "test.c" 1
printf("line 1"
# 2 "test1.c" 2
"line 2 line 3");</d:programlisting>If
                you omit newline at end of file then gcc will issue you a warning.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The source file is decomposed into preprocessing tokens <d:footnote>
                  <d:para>the process of dividing a source file's characters into preprocessing
                    tokens is context-dependent. For example, see the handling of
                      <d:code>&lt;</d:code> within a <d:code>#include</d:code> preprocessing
                    directive.</d:para>
                </d:footnote> and sequences of white-space characters (including comments). A source
                file shall not end in a partial preprocessing token or in a partial comment. Each
                comment is replaced by one space character. New-line characters are retained.
                Whether each nonempty sequence of white-space characters other than new-line is
                retained or replaced by one space character is implementation-defined.</d:para>
              <d:para>Modifying above example like:</d:para>
              <d:programlisting role="CLexer">#include "test1.c" // a comment
"line 2 \
line 3");</d:programlisting>
              <d:para>will yield:</d:para>
              <d:programlisting role="CLexer"># 1 "test1.c"
# 1 "&lt;built-in>"
# 1 "&lt;command-line>"
# 1 "test1.c"
# 1 "test.c" 1
printf("line 1"
# 2 "test1.c" 2
"line 2 line 3");</d:programlisting>
              <d:para>Two important points to note here are that new-lines are retained which is
                important for next step and comments are replaced by one space character. new-lines
                are needed to separate preprocessing directives and comments are needed to be
                replaced by one character else strange things may happen. Consider <d:code>int/*a
                  comment*/main()</d:code> being rendered as <d:code>intmain()</d:code> for example.
                For understanding the meaning of last sentence consider the following
                program:</d:para>
              <d:programlisting role="CLexer">#include &lt;stdio.h>

int main()  
{
  #define makestr(a) #a

  char *p = makestr(x          y);

  puts(p);
}</d:programlisting>
              <d:para>and the output is:</d:para>
              <d:programlisting role="CLexer">x y</d:programlisting>
              <d:para>so we can clearly say that <d:code>gcc</d:code> replaces multiple whitespace
                characters by one.</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Preprocessing directives are executed,
                macro invocations are expanded, and <code>_Pragma</code> unary operator expressions
                are executed. If a character sequence that matches the syntax of a universal
                character name is produced by token concatenation, the behavior is undefined. A
                  <code>#include</code> preprocessing directive causes the named header or source
                file to be processed from phase 1 through phase 4, recursively. All preprocessing
                directives are then deleted.</para>
              <d:para>For example:</d:para>
              <d:programlisting role="CLexer">#define MAX 5

#define MIN(a,b) ((a)&lt;(b)?(a):(b))

printf("%d", MAX)

printf(%d, MIN(5,7));</d:programlisting>
              <d:para>will become:</d:para>
              <d:programlisting role="CLexer"># 1 "test.c"
# 1 "&lt;built-in>"
# 1 "&lt;command-line>"
# 1 "test.c"




printf("%d", 5)

printf(%d, ((5)&lt;(7)?(5):(7)));</d:programlisting>
              <d:para>The #include preprocessing directives are processed in-depth first order. Once
                a header has been fully processed, processing resumes in the file that included it.
                15 levels of nesting can be done for header files(Translation limits) Before
                processing the header, the macros <d:code>__FILE__</d:code> and
                  <d:code>__LINE__</d:code> are set (and they are reset when processing resumes in
                the file containing the header).</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Each source character set member and
                escape sequence in character constants and string literals is converted to the
                corresponding member of the execution character set; if there is no corresponding
                member, it is converted to an implementation-defined member other than the null
                (wide) character.<footnote>
                  <para>An implementation need not convert all non-corresponding source characters
                    to the same execution character.</para>
                </footnote></para>
              <d:para>For most of the machines both source and execution characters sets are ASCII
                while some mainframes use EBCDIC as their character set.</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Adjacent string literal tokens are
                concatenated.</para>
              <para xmlns="http://docbook.org/ns/docbook">For example, consider:</para>
              <d:programlisting role="CLexer">#include &lt;stdio.h>

#define STR1 "hello "
#define STR2 "world"
int main()
{
  puts(STR1 STR2);
}</d:programlisting>
              <d:para>and the output is:</d:para>
              <d:programlisting>hello world</d:programlisting>
              <d:para>Note that this rule only applies to string literals not to character array or
                pointers because they contain null terminating character.</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">White-space characters separating tokens
                are no longer significant. Each preprocessing token is converted into a token. The
                resulting tokens are syntactically and semantically analyzed and translated as a
                translation unit.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">All external object and function
                references are resolved. Library components are linked to satisfy external
                references to functions and objects not defined in the current translation. All such
                translator output is collected into a program image which contains information
                needed for execution in its execution environment.</para>
              <para xmlns="http://docbook.org/ns/docbook">These steps are typically carried out by
                the linker <code>ld</code>. </para>
            </d:listitem>
          </d:orderedlist>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> universal character names (Universal character names), lexical
            elements (Universal character names), preprocessing directives (Preprocessing
            Directives), trigraph sequences (Trigraph sequences), external definitions (External
            definitions).</d:para>
        </d:sect3>
        <d:sect3>
          <d:title>Dignostics</d:title>
          <d:para>A conforming implementation shall produce at least one diagnostic message
            (identified in an implementation-defined manner) if a preprocessing translation unit or
            translation unit contains a violation of any syntax rule or constraint, even if the
            behavior is also explicitly specified as undefined or implementation-defined. Diagnostic
            messages need not be produced in other circumstances.<d:footnote>
              <d:para>The intent is that an implementation should identify the nature of, and where
                possible localize, each violation. Of course, an implementation is free to produce
                any number of diagnostics as long as a valid program is still correctly translated.
                It may also successfully translate an invalid program.</d:para>
            </d:footnote></d:para>
          <d:para>Note that it is a requirement imposed on implementation. Nothing about what these
            messages will contain. Implementations are also free to provide more than one message to
            assist the programmer locate the source of error and by other means as well like
            pointing out the line number and column number in program text.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <d:title>Execution Environment</d:title>
        <d:para>Two execution environments are defined: <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">freestanding</emphasis> and
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">hosted</emphasis>. In both
          cases, <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">program
            startup</emphasis> occurs when a designated C function is called by the execution
          environment. All objects with static storage duration shall be <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">initialized</emphasis> (set to their
          initial values) before program startup. The manner and timing of such initialization are
          otherwise unspecified. <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >Program termination</emphasis> returns control to the execution environment.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >freestanding</emphasis> typically means embedded systems though not in
          standard.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> storage durations of objects (4.2.4), initialization
          (4.7.8).</d:para>
        <d:sect3>
          <d:title>Freestanding Environment</d:title>
          <d:para>In a freestanding environment (in which C program execution may take place without
            any benefit of an operating system), the name and type of the function called at program
            startup are implementation-defined. Any library facilities available to a freestanding
            program, other than the minimal set required by clause 4, are
            implementation-defined.</d:para>
          <d:para>The effect of program termination in a freestanding environment is
            implementation-defined.</d:para>
          <d:para>For example, consider the BIOS of PC which runs without an operating system. The
            startup function name need not be main. Since, such freestanding systems have scarce
            resources the requirement for conformance is only limited to a minimal set of library
            facilities. Sometimes it may not be even possible to stop the program running in a
            freestanding environment. Consider a PC without an operating system. BIOS will take over
            and how will it terminate. You will need to power off the system manually.</d:para>
        </d:sect3>
        <d:sect3>
          <d:title>Hosted Environment</d:title>
          <d:para>A hosted environment need not be provided, but shall conform to the following
            specifications if present.</d:para>
          <d:sect4>
            <d:title>Program Startup</d:title>
            <d:para>The function called at program startup is named main. The implementation
              declares no prototype for this function. It shall be defined with a return type of
                <d:code>int</d:code> and with no parameters:</d:para>
            <d:programlisting role="CLexer">int main(void) { /* ... */ }</d:programlisting>
            <d:para>or with two parameters (referred to here as argc and argv, though any names may
              be used, as they are local to the function in which they are declared):</d:para>
            <d:programlisting role="CLexer">int main(int argc, char *argv[]) { /* ... */ }</d:programlisting>
            <d:para>or equivalent;<d:footnote>
                <d:para>Thus, <d:code>int</d:code> can be replaced by a <d:code>typedef</d:code>
                  name defined as <d:code>int</d:code>, or the type of <d:code>argv</d:code> can be
                  written as <d:code>char ** argv</d:code>, and so on.</d:para>
              </d:footnote></d:para>
            <d:para>or in some other implementation defined manner. The function main must have
              external linkage. Also, the implementation or compiler should not have main function
              in any of the headers or libraries. Some implementations also provide a third argument
              called environment pointer or envp which contains environment variables of the
              systems.</d:para>
            <d:para>If they are declared, the parameters to the main function shall obey the
              following constraints:<d:itemizedlist>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">The value of <code>argc</code> shall
                    be nonnegative.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook"><code>argv[argc]</code> shall be a
                    null pointer.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">If the value of <code>argc</code> is
                    greater than zero, the array members <code>argv[0]</code> through
                      <code>argv[argc-1]</code> inclusive shall contain pointers to strings, which
                    are given implementation-defined values by the host environment prior to program
                    startup. The intent is to supply to the program information determined prior to
                    program startup from elsewhere in the hosted environment. If the host
                    environment is not capable of supplying strings with letters in both uppercase
                    and lowercase, the implementation shall ensure that the strings are received in
                    lowercase.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">If the value of <code>argc</code> is
                    greater than zero, the string pointed to by <code>argv[0]</code> represents the
                    program name; <code>argv[0][0]</code> shall be the null character if the program
                    name is not available from the host environment. If the value of
                      <code>argc</code> is greater than one, the strings pointed to by
                      <code>argv[1]</code> through <code>argv[argc-1]</code> represent the <emphasis
                      role="italic">program parameters</emphasis>.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">The parameters <code>argc</code> and
                      <code>argv</code> and the strings pointed to by the <code>argv</code> array
                    shall be modifiable by the program, and retain their last-stored values between
                    program startup and program termination.</para>
                </d:listitem>
              </d:itemizedlist></d:para>
            <d:para>Let us see a program to summarize this:</d:para>
            <d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(int argc, char *argv[])
{
  for(int i=0; i&lt;argc; i++)
    printf("%s\n", argv[i]);

  if(argv[argc]==NULL)
    printf("argv[argc] is NULL pointer.\n");

  return 0;
}</d:programlisting>
            <d:para>and if we run it like</d:para>
            <d:para><d:code>$</d:code><d:command>./a.out 1 2 3 4 5 6</d:command></d:para>
            <d:para>we will see following output:</d:para>
            <d:screen>./a.out
1
2
3
4
5
6
argv[argc] is NULL pointer.</d:screen>
          </d:sect4>
          <d:sect4>
            <d:title>Program Execution</d:title>
            <d:para>In a hosted environment, a program may use all the functions, macros, type
              definitions, and objects described in the library clause (clause 7).</d:para>
          </d:sect4>
          <d:sect4>
            <d:title>Program Termination</d:title>
            <d:para>If the return type of the main function is a type compatible with int, a return
              from the initial call to the main function is equivalent to calling the exit function
              with the value returned by the main function as its argument;<d:footnote>
                <d:para>the lifetimes of objects with automatic storage duration declared in main
                  will have ended in the former case, even where they would not have in the
                  latter.</d:para>
              </d:footnote> reaching the } that terminates the main function returns a value of 0.
              If the return type is not compatible with int, the termination status returned to the
              host environment is unspecified.</d:para>
            <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
                references:</emphasis> definition of terms (Definitions of terms), the exit function
              (The exit function).</d:para>
          </d:sect4>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Program Execution</title>
          <d:orderedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">The semantic descriptions in this
                International Standard describe the behavior of an abstract machine in which issues
                of optimization are irrelevant.</para>
              <para xmlns="http://docbook.org/ns/docbook">Optimization is very important from
                compilers aspect. However, it is of no concern for standard. The abstract machine in
                picture here has never been fully treated in the specification. There has been only
                one formally verified compiler with a subset of C. [Blazy] </para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Accessing a volatile object, modifying an
                object, modifying a file, or calling a function that does any of those operations
                are all <emphasis role="italic">side effects</emphasis>,<footnote>
                  <para>The IEC 60559 standard for binary floating-point arithmetic requires certain
                    user-accessible status flags and control modes. Floating-point operations
                    implicitly set the status flags; modes affect result values of floating-point
                    operations. Implementations that support such floating-point state are required
                    to regard changes to it as side effects - see appendix for details. The
                    floating-point environment library &lt;fenv.h> provides a programming facility
                    for indicating when these side effects matter, freeing the implementations in
                    other cases.</para>
                </footnote> which are changes in the state of the execution environment. Evaluation
                of an expression may produce side effects. At certain specified points in the
                execution sequence called sequence points, all side effects of previous evaluations
                shall be complete and no side effects of subsequent evaluations shall have taken
                place. (A summary of the sequence points is given in appendix C).</para>
              <d:para>There is hardly anything you can do without causing side effects. No useful
                program can be written without causing side effects. The C library treats all I/O as
                operations on files. The state of a program in execution includes information about
                current flow of control. Access of a volatile object does not guarantee a change in
                state, however, it has to be treated as side effect.</d:para>
              <d:para>Functional language like Lisp, Erlang, Haskell etc designed to be side effect
                free. This helps in proving mathematical properties of a program.</d:para>
              <d:para>Expressions may also be evaluated for its result value. Consider
                following:<d:programlisting role="CLexer">#include &lt;stdio.h>

int main(void)
{
  int i=0;

  printf("Enter an integer.\n");
  scanf("%d", &amp;i);

  if(i%2==0)
    printf("Number entered is intger.\n");

  return 0;
}</d:programlisting></d:para>
              <d:para>here you can see that the value of expression i%2 can alter the flow of
                program. The definition of sequence points is given here and possible sequence
                points are discussed later in appendix C.</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">In the abstract machine, all expressions
                are evaluated as specified by the semantics. An actual implementation need not
                evaluate part of an expression if it can deduce that its value is not used and that
                no needed side effects are produced (including any caused by calling a function or
                accessing a volatile object).</para>
              <d:para>The directions from specification here allow the implementation to optimize
                the machine code as they want. Note that this may result to certain items not
                discussed in specification. Any code which is translated and part of final machine
                code, but is never executed, is known as dead code. Similarly, a piece of code,
                which does not affect output of a program, is known as <emphasis
                  xmlns="http://docbook.org/ns/docbook" role="italic">redundant</emphasis>
                code.</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">When the processing of the abstract
                machine is interrupted by receipt of a signal, only the values of objects as of the
                previous sequence point may be relied on. Objects that may be modified between the
                previous sequence point and the next sequence point need not have received their
                correct values yet.</para>
              <para xmlns="http://docbook.org/ns/docbook">As you may know about modern processors
                have pipelines so before a signal is pipelined more sequence points may be
                pipelined, however, we cannot rely on that. </para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">The least requirements on a conforming
                implementation are:</para>
              <d:itemizedlist>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">At sequence points, volatile objects
                    are stable in the sense that previous accesses are complete and subsequent
                    accesses have not yet occurred.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">The input and output dynamics of
                    interactive devices shall take place as specified in Files. The intent of these
                    requirements is that unbuffered or line-buffered output appear as soon as
                    possible, to ensure that prompting messages actually appear prior to a program
                    waiting for input.</para>
                </d:listitem>
              </d:itemizedlist>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">What constitutes an interactive device is
                implementation-defined.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">More stringent correspondences between
                abstract and actual semantics may be defined by each implementation.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">EXAMPLE 1 An implementation might define a
                one-to-one correspondence between abstract and actual semantics: at every sequence
                point, the values of the actual objects would agree with those specified by the
                abstract semantics. The keyword <code>volatile </code>would then be
                redundant.</para>
              <para xmlns="http://docbook.org/ns/docbook"><code>volatile</code> can only be
                redundant if the implementation is able to tell the order of evaluation of an
                expression containing <code>volatile</code> objects. </para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Alternatively, an implementation might
                perform various optimizations within each translation unit, such that the actual
                semantics would agree with the abstract semantics only when making function calls
                across translation unit boundaries. In such an implementation, at the time of each
                function entry and function return where the calling function and the called
                function are in different translation units, the values of all externally linked
                objects and of all objects accessible via pointers therein would agree with the
                abstract semantics. Furthermore, at the time of each such function entry the values
                of the parameters of the called function and of all objects accessible via pointers
                therein would agree with the abstract semantics. In this type of implementation,
                objects referred to by interrupt service routines activated by the
                  <code>signal</code> function would require explicit specification of
                  <code>volatile</code> storage, as well as other implementation-defined
                restrictions.</para>
              <para xmlns="http://docbook.org/ns/docbook">Requirement that the code declare all
                object accessed by interrupt service routines as <code>volatile</code> is difficult
                to achieve in practice because such routines can be invoked in many ways. </para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">EXAMPLE 2 In executing the
                fragment<programlisting role="CLexer">char c1, c2;
/* ... */
c1 = c1 + c2;</programlisting></para>
              <d:para>the “integer promotions” require that the abstract machine promote the value
                of each variable to int size and then add the two ints and truncate the sum.
                Provided the addition of two chars can be done without overflow, or with overflow
                wrapping silently to produce the correct result, the actual execution need only
                produce the same result, possibly omitting the promotions.</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">EXAMPLE 3 Similarly, in the
                fragment<programlisting role="CLexer">float f1, f2;
double d;
/* ... */
f1 = f2 * d;</programlisting></para>
              <d:para>the multiplication may be executed using single-precision arithmetic if the
                implementation can ascertain that the result would be the same as if it were
                executed using double-precision arithmetic (for example, if d were replaced by the
                constant 2.0, which has type <d:code>double</d:code>).</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">EXAMPLE 4 Implementations employing wide
                registers have to take care to honor appropriate semantics. Values are independent
                of whether they are represented in a register or in memory. For example, an implicit
                spilling of a register is not permitted to alter the value. Also, an explicit store
                and load is required to round to the precision of the storage type. In particular,
                casts and assignments are required to perform their specified conversion. For the
                fragment<d:programlisting role="CLexer">double d1, d2;
float f;
d1 = f = expression;
d2 = (float) expression;</d:programlisting></para>
              <d:para>the values assigned to d1 and d2 are required to have been converted to
                float.</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">EXAMPLE 5 Rearrangement for floating-point
                expressions is often restricted because of limitations in precision as well as
                range. The implementation cannot generally apply the mathematical associative rules
                for addition or multiplication, nor the distributive rule, because of roundoff
                error, even in the absence of overflow and underflow. Likewise, implementations
                cannot generally replace decimal constants in order to rearrange expressions. In the
                following fragment, rearrangements suggested by mathematical rules for real numbers
                are often not valid (see F.8).</para>
              <d:programlisting role="CLexer">double x, y, z;
/* ... */
x = (x * y) * z; // not equivalent to x *= y * z;
z = (x - y) + y; // not equivalent to z = x;
z = x + x * y;   // not equivalent to z = x * (1.0 + y);
y = x / 5.0;     // not equivalent to y = x * 0.2;</d:programlisting>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">EXAMPLE 6 To illustrate the grouping
                behavior of expressions, in the following fragment</para>
              <d:programlisting role="CLexer">int a, b;
/* ... */
a = a + 32760 + b + 5;</d:programlisting>
              <d:para>the expression statement behaves exactly the same as:</d:para>
              <d:programlisting role="CLexer">a = (((a + 32760) + b) + 5);</d:programlisting>
              <d:para>due to the associativity and precedence of these operators. Thus, the result
                of the sum <d:code>(a + 32760)</d:code> is next added to <d:code>b</d:code>, and
                that result is then added to <d:code>5</d:code> which results in the value assigned
                to a. On a machine in which overflows produce an explicit trap and in which the
                range of values representable by an int is <d:code>[-32768, +32767]</d:code>, the
                implementation cannot rewrite this expression as <d:code>a = ((a + b) +
                  32765);</d:code> since if the values for <d:code>a</d:code> and <d:code>b</d:code>
                were, respectively, <d:code>-32754</d:code> and <d:code>-15</d:code>, the sum
                  <d:code>a + b</d:code> would produce a trap while the original expression would
                not; nor can the expression be rewritten either as:</d:para>
              <d:programlisting role="CLexer">a = ((a + 32765) + b);</d:programlisting>
              <d:para>or:</d:para>
              <d:programlisting role="CLexer">a = (a + (b + 32765));</d:programlisting>
              <d:para>since the values for a and b might have been, respectively, <d:code>4</d:code>
                and <d:code>-8</d:code> or <d:code>-17</d:code> and <d:code>12</d:code>. However, on
                a machine in which overflow silently generates some value and where positive and
                negative overflows cancel, the above expression statement can be rewritten by the
                implementation in any of the above ways because the same result will occur.</d:para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">EXAMPLE 7 The grouping of an expression
                does not completely determine its evaluation. In the following fragment</para>
              <d:programlisting role="CLexer">#include &lt;stdio.h>
int sum;
char *p;
/* ... */
sum = sum * 10 - '0' + (*p++ = getchar());</d:programlisting>
              <d:para>the expression statement is grouped as if it were written as:</d:para>
              <d:programlisting role="CLexer">sum = (((sum * 10) - '0') + ((*(p++)) = (getchar())));</d:programlisting>
              <d:para>but the actual increment of p can occur at any time between the previous
                sequence point and the next sequence point (the ;), and the call to getchar can
                occur at any point prior to the need of its returned value.</d:para>
            </d:listitem>
          </d:orderedlist>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> expressions (Expressions), type qualifiers (Type qualifiers),
            statements (Statements and blocks), the signal function (The signal function), files
            (Files).</d:para>
        </d:sect3>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Environmental Conditions</d:title>
      <d:sect2>
        <d:title>Character Sets</d:title>
        <d:orderedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">Two sets of characters and their associated
              collating sequences shall be defined: the set in which source files are written (the
              source character set), and the set interpreted in the execution environment (the
                <emphasis role="italic">execution character set</emphasis>). Each set is further
              divided into a basic character set, whose contents are given by this subclause, and a
              set of zero or more locale-specific members (which are not members of the basic
              character set) called extended characters. The combined set is also called the
              extended character set. The values of the members of the execution character set are
              implementation-defined.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">In a character constant or string literal,
              members of the execution character set shall be represented by corresponding members
              of the source character set or by escape sequences consisting of the backslash
              followed by one or more characters. A byte with all bits set to 0, called the null
              character, shall exist in the basic execution character set; it is used to terminate a
              character string.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">Both the basic source and basic execution
              character sets shall have the following members: the 26 uppercase letters of the Latin
              alphabet:</para>
            <d:programlisting>A B C D E F G H I J K L: M N O P Q R S T U V W X Y Z</d:programlisting>
            <d:para>the 26 lowercase letters of the Latin alphabet:</d:para>
            <d:programlisting>a b c d e f g h i j k l m n o p q r s t u v w x y z</d:programlisting>
            <d:para>the 10 decimal digits:</d:para>
            <d:programlisting>0 1 2 3 4 5 6 7 8 9</d:programlisting>
            <d:para>the following 29 graphic characters:</d:para>
            <d:programlisting>~ ! # % ^ &amp; * ( ) - _ = + \ | [ ] { } ; : ' " , &lt; . > / ?</d:programlisting>
            <d:para> the space character, and control characters representing horizontal tab,
              vertical tab, and form feed. The representation of each member of the source and
              execution basic character sets shall fit in a byte. In both the source and execution
              basic character sets, the value of each character after 0 in the above list of decimal
              digits shall be one greater than the value of the previous. In source files, there
              shall be some way of indicating the end of each line of text; this International
              Standard treats such an end-of-line indicator as if it were a single new-line
              character. In the basic execution character set, there shall be control characters
              representing alert, backspace, carriage return, and new line. If any other characters
              are encountered in a source file (except in an identifier, a character constant, a
              string literal, a header name, a comment, or a preprocessing token that is never
              converted to a token), the behavior is undefined.</d:para>
            <d:para>These character sets are also described in The C Character Set .</d:para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A <emphasis role="italic">letter</emphasis>
              is an uppercase letter or a lowercase letter as defined above; in this International
              Standard the term does not include other characters that are letters in other
              alphabets.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">The universal character name construct
              provides a way to name other characters.</para>
          </d:listitem>
        </d:orderedlist>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> universal character names (Universal character names), character
          constants (Character constants), preprocessing directives (Preprocessing Directives),
          string literals (String literals), comments (Comments), string (Introduction).</d:para>
        <d:sect3>
          <d:title>Trigraph Sequences</d:title>
          <d:para>All occurrences in a source file of the following sequences of three characters
            (called trigraph sequence<d:footnote>
              <d:para>The trigraph sequences enable the input of characters that are not defined in
                the Invariant Code Set as described in ISO/IEC 646, which is a subset of the
                seven-bit US ASCII code set.</d:para>
            </d:footnote>) are replaced with the corresponding single character.<table
              xmlns="http://docbook.org/ns/docbook" frame="border" border="1" class="centered">
              <caption>Trigraph Sequence</caption>
	      <colgroup width="0*" />
	      <colgroup width="0*" />
	      <colgroup width="0*" />
	      <colgroup width="0*" />
	      <colgroup width="0*" />
	      <colgroup width="0*" />
              <thead>
                <tr bgcolor="#aaa">
                  <th>Trigraph</th>
                  <th>Equivalent</th>
                  <th>Trigraph</th>
                  <th>Equivalent</th>
                  <th>Trigraph</th>
                  <th>Equivalent</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>??=</td>
                  <td>#</td>
                  <td>??'</td>
                  <td>^</td>
                  <td>??!</td>
                  <td>|</td>
                </tr>
                <tr>
                  <td>??(</td>
                  <td>[</td>
                  <td>??)</td>
                  <td>]</td>
                  <td>??&lt;</td>
                  <td>{</td>
                </tr>
                <tr>
                  <td>??></td>
                  <td>}</td>
                  <td>??/</td>
                  <td>\</td>
                  <td>??-</td>
                  <td>~</td>
                </tr>
              </tbody>
            </table></d:para>
          <d:para>This table is also given in The C Character Set . No other trigraph sequences
            exist. Each ? that does not begin one of the trigraphs listed above is not
            changed.</d:para>
          <d:para>EXAMPLE The following source line</d:para>
          <d:programlisting role="CLexer">printf("Eh???/n");</d:programlisting>
          <d:para>becomes (after replacement of the trigraph sequence <d:code>??/</d:code>)</d:para>
          <d:programlisting role="CLexer">printf("Eh?\n");</d:programlisting>
        </d:sect3>
        <d:sect3>
          <d:title>Multibyte Characters</d:title>
          <d:para>The source character set may contain multibyte characters, used to represent
            members of the extended character set. The execution character set may also contain
            multibyte characters, which need not have the same encoding as for the source character
            set. For both character sets, the following shall hold:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook"> The basic character set shall be present
                and each character shall be encoded as a single byte.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">A multibyte character set may have a
                  <emphasis role="italic">state-dependent encoding</emphasis>, wherein each sequence
                of multibyte characters begins in an <emphasis role="italic">initial shift
                  state</emphasis> and enters other locale-specific shift states when specific
                multibyte characters are encountered in the sequence. While in the initial shift
                state, all single-byte characters retain their usual interpretation and do not alter
                the shift state. The interpretation for subsequent bytes in the sequence is a
                function of the current shift state.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">A byte with all bits zero shall be
                interpreted as a null character independent of shift state. Such a byte shall not
                occur as part of any other multibyte character. </para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>For source files, the following shall hold:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook"> An identifier, comment, string literal,
                character constant, or header name shall begin and end in the initial shift
                state.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">An identifier, comment, string literal,
                character constant, or header name shall consist of a sequence of valid multibyte
                characters.</para>
              <para xmlns="http://docbook.org/ns/docbook">For example, accented characters fall in
                this category. </para>
            </d:listitem>
          </d:itemizedlist>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Character Display Semantics</title>
        <d:para>The <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">active
            position</emphasis> is that location on a display device where the next character output
          by the <d:code>fputc</d:code> function would appear. The intent of writing a printing
          character (as defined by the <d:code>isprint</d:code> function) to a display device is to
          display a graphic representation of that character at the active position and then advance
          the active position to the next position on the current line. The direction of writing is
          locale-specific. If the active position is at the final position of a line (if there is
          one), the behavior of the display device is unspecified. Following escape sequences are
          also treated in <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">Escape
            Sequences</emphasis>.</d:para>
        <d:para>Alphabetic escape sequences representing nongraphic characters in the execution
          character set are intended to produce actions on display devices as follows:</d:para>
        <d:para>\a (<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">alert</emphasis>)
          Produces an audible or visible alert without changing the active position.</d:para>
        <d:para>\b (<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >backspace</emphasis>) Moves the active position to the previous position on the current
          line. If the active position is at the initial position of a line, the behavior of the
          display device is unspecified.</d:para>
        <d:para>\f (<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">form
            feed</emphasis>) Moves the active position to the initial position at the start of the
          next logical page.</d:para>
        <d:para>\n (<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">new
            line</emphasis>) Moves the active position to the initial position of the next
          line.</d:para>
        <d:para>\r (<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">carriage
            return</emphasis>) Moves the active position to the initial position of the current
          line.</d:para>
        <d:para>\t (<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">horizontal
            tab</emphasis>) Moves the active position to the next horizontal tabulation position on
          the current line. If the active position is at or past the last defined horizontal
          tabulation position, the behavior of the display device is unspecified.</d:para>
        <d:para>\v (<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">vertical
            tab</emphasis>) Moves the active position to the initial position of the next vertical
          tabulation position. If the active position is at or past the last defined vertical
          tabulation position, the behavior of the display device is unspecified.</d:para>
        <d:para>Each of these escape sequences shall produce a unique implementation-defined value
          which can be stored in a single char object. The external representations in a text file
          need not be identical to the internal representations, and are outside the scope of this
          International Standard.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> the isprint function (The isprint function), the fputc function
          (The fputc function).</d:para>
      </d:sect2>
      <d:sect2>
        <d:title>Signals and Iterrupts</d:title>
        <d:para>Functions shall be implemented such that they may be interrupted at any time by a
          signal, or may be called by a signal handler, or both, with no alteration to earlier, but
          still active, invocations’ control flow (after the interruption), function return values,
          or objects with automatic storage duration. All such objects shall be maintained outside
          the function image (the instructions that compose the executable representation of a
          function) on a per-invocation basis.</d:para>
      </d:sect2>
      <d:sect2>
        <d:title>Environmental Limits</d:title>
        <d:para>Both the translation and execution environments constrain the implementation of
          language translators and libraries. The following summarizes the language-related
          environmental limits on a conforming implementation; the library-related limits are
          discussed in chapter 13 onwards.</d:para>
        <d:sect3>
          <d:title>Translation limits</d:title>
          <d:para>The implementation shall be able to translate and execute at least one program
            that contains at least one instance of every one of the following limits:<d:footnote>
              <d:para>Implementations should avoid imposing fixed translation limits whenever
                possible.</d:para>
            </d:footnote></d:para>
          <d:itemizedlist>
            <d:listitem>
              <d:para>127 nesting levels of blocks</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>63 nesting levels of conditional inclusion</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>12 pointer, array, and function declarators (in any combinations) modifying an
                arithmetic, structure, union, or incomplete type in a declaration</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>63 nesting levels of parenthesized declarators within a full
                declarator</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>63 nesting levels of parenthesized expressions within a full
                expression</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>63 significant initial characters in an internal identifier or a macro name
                (each universal character name or extended source character is considered a single
                character)</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>31 significant initial characters in an external identifier (each universal
                character name specifying a short identifier of 0000FFFF or less is considered 6
                characters, each universal character name specifying a short identifier of 00010000
                or more is considered 10 characters, and each extended source character is
                considered the same number of characters as the corresponding universal character
                name, if any)</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>4095 external identifiers in one translation unit</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>511 identifiers with block scope declared in one block</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>4095 macro identifiers simultaneously defined in one preprocessing translation
                unit</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>127 parameters in one function definition</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>127 arguments in one function call</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>127 parameters in one macro definition</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>127 arguments in one macro invocation</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>4095 characters in a logical source line</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>4095 characters in a character string literal or wide string literal (after
                concatenation)</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>65535 bytes in an object (in a hosted environment only)</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>15 nesting levels for <d:code>#include</d:code> files</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>1023 case labels for a <d:code>switch</d:code> statement (excluding those for
                any nested <d:code>switch</d:code> statements)</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>1023 members in a single structure or union</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>1023 enumeration constants in a single enumeration</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>63 levels of nested structure or union definitions in a single
                struct-declaration-list</d:para>
            </d:listitem>
          </d:itemizedlist>
        </d:sect3>
        <d:sect3>
          <d:title>Numerical Limits</d:title>
          <d:para>An implementation is required to document all the limits specified in this
            subclause, which are specified in the headers <d:code>&lt;limits.h></d:code> and
              <d:code>&lt;float.h></d:code>. Additional limits are specified in
              <d:code>&lt;stdint.h></d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> integer types <d:code>&lt;stdint.h></d:code> (Integer types
              <d:code>&lt;stdint.h></d:code>).</d:para>
          <d:sect4>
            <d:title>Sizes of integer types &lt;limits.h></d:title>
            <d:para>The values given below shall be replaced by constant expressions suitable for
              use in <d:code>#if</d:code> preprocessing directives. Moreover, except for
                <d:code>CHAR_BIT</d:code> and <d:code>MB_LEN_MAX</d:code>, the following shall be
              replaced by expressions that have the same type as would an expression that is an
              object of the corresponding type converted according to the integer promotions. Their
              implementation-defined values shall be equal or greater in magnitude (absolute value)
              to those shown, with the same sign.</d:para>
            <d:itemizedlist>
              <d:listitem>
                <d:para>number of bits for smallest object that is not a bit-field (byte)</d:para>
                <d:para><d:code>CHAR_BIT 8</d:code></d:para>
              </d:listitem>
              <d:listitem>
                <d:para>minimum value for an object of type <d:code>signed char</d:code></d:para>
                <d:para><d:code>SCHAR_MIN -127 </d:code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:mo>-</mml:mo>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>7</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation>
                </d:para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>signed char</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>SCHAR_MAX 127 </code><inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>7</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>unsigned char</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>UCHAR_MAX 255 </code><inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>8</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">minimum value for an object of type
                    <code>char</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>CHAR_MIN</code>
                  <emphasis role="italic">see below</emphasis></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>char</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>CHAR_MAX</code>
                  <emphasis role="italic">see below</emphasis></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum number of bytes in a multibyte
                  character, for any supported locale</para>
                <para xmlns="http://docbook.org/ns/docbook"><code>MB_LEN_MAX 1</code></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">minimum value for an object of type
                    <code>short int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>SHRT_MIN -32767 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:mo>-</mml:mo>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>15</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>short int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>SHRT_MAX +32767 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>15</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>unsigned short int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>USHRT_MAX 65535 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>16</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">minimum value for an object of type
                    <code>int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>INT_MIN -32767 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:mo>-</mml:mo>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>15</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>INT_MAX +32767 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>15</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>unsigned int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>UINT_MAX 65535 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>16</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">minimum value for an object of type
                    <code>long int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>LONG_MIN -2147483647 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:mo>-</mml:mo>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>31</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>long int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>LONG_MAX +2147483647 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>31</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>unsigned long int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>ULONG_MAX 4294967295 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>32</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">minimum value for an object of type
                    <code>long long int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>LLONG_MIN -9223372036854775807 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:mo>-</mml:mo>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>63</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>long long int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>LLONG_MAX +9223372036854775807 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>63</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">maximum value for an object of type
                    <code>unsigned long long int</code></para>
                <para xmlns="http://docbook.org/ns/docbook"><code>ULLONG_MAX 18446744073709551615 </code><d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mn>2</mml:mn>
                          <mml:mn>64</mml:mn>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>-</mml:mo>
                        <mml:mtext> 1</mml:mtext>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation></para>
              </d:listitem>
            </d:itemizedlist>
            <d:para>If the value of an object of type char is treated as a signed integer when used
              in an expression, the value of <d:code>CHAR_MIN</d:code> shall be the same as that of
                <d:code>SCHAR_MIN</d:code> and the value of <d:code>CHAR_MAX</d:code> shall be the
              same as that of <d:code>SCHAR_MAX</d:code>. Otherwise, the value of
                <d:code>CHAR_MIN</d:code> shall be 0 and the value of <d:code>CHAR_MAX</d:code>
              shall be the same as that of <d:code>UCHAR_MAX</d:code>.<d:footnote>
                <d:para>See Types.</d:para>
              </d:footnote> The value <d:code>UCHAR_MAX</d:code> shall equal <d:inlineequation>
                <mml:math>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mn>2</mml:mn>
                      <mml:mtext>CHAR_BIT</mml:mtext>
                    </mml:msup>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>-</mml:mo>
                    <mml:mtext> 1</mml:mtext>
                  </mml:mrow>
                </mml:math>
              </d:inlineequation>.</d:para>
          </d:sect4>
          <d:sect4>
            <d:title>Characteristics of floating types &lt;float.h></d:title>
            <d:para>The characteristics of floating types are defined in terms of a model that
              describes a representation of floating-point numbers and values that provide
              information about an implementation’s floating-point arithmetic.<d:footnote>
                <d:para>The floating-point model is intended to clarify the description of each
                  floating-point characteristic and does not require the floating-point arithmetic
                  of the implementation to be identical.</d:para>
              </d:footnote> The following parameters are used to define the model for each
              floating-point type<table xmlns="http://docbook.org/ns/docbook" frame="void"
                class="leftcenter">
	      <colgroup width="0*"/>
	      <colgroup width="0*"/>
                <tbody>
                  <tr>
                    <td><inlineequation>
                        <mml:math>
                          <mml:mtext>s</mml:mtext>
                        </mml:math>
                      </inlineequation></td>
                    <td>sign</td>
                  </tr>
                  <tr>
                    <td><inlineequation>
                        <mml:math>
                          <mml:mtext>b</mml:mtext>
                        </mml:math>
                      </inlineequation></td>
                    <td>base or radix of exponent representation (an integer > 1)</td>
                  </tr>
                  <tr>
                    <td><inlineequation>
                        <mml:math>
                          <mml:mtext>e</mml:mtext>
                        </mml:math>
                      </inlineequation></td>
                    <td>exponent (an integer between a minimum emin and a maximum emax )</td>
                  </tr>
                  <tr>
                    <td><inlineequation>
                        <mml:math>
                          <mml:mtext>p</mml:mtext>
                        </mml:math>
                      </inlineequation></td>
                    <td>precision (the number of base-b digits in the significand)</td>
                  </tr>
                  <tr>
                    <td><inlineequation>
                        <mml:math>
                          <mml:msub>
                            <mml:mtext>f</mml:mtext>
                            <mml:mtext>k</mml:mtext>
                          </mml:msub>
                        </mml:math>
                      </inlineequation></td>
                    <td>nonnegative integers less than b (the significand digits)</td>
                  </tr>
                </tbody>
              </table></d:para>
            <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">floating-point
                number (x)</emphasis> is defined by the following model:<d:equation>
                <mml:math mathvariant="italic">
                  <mml:mrow>
                    <mml:mtext>x</mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext>s</mml:mtext>
                    <mml:msup>
                      <mml:mtext>b</mml:mtext>
                      <mml:mtext>e</mml:mtext>
                    </mml:msup>
                    <mml:munderover>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mtext>k</mml:mtext>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mtext>p</mml:mtext>
                    </mml:munderover>
                    <mml:msub>
                      <mml:mtext>f</mml:mtext>
                      <mml:mtext>k</mml:mtext>
                    </mml:msub>
                    <mml:msup>
                      <mml:mtext>b</mml:mtext>
                      <mml:mrow>
                        <mml:mo>-</mml:mo>
                        <mml:mtext>k</mml:mtext>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mtext>,</mml:mtext>
                    <mml:msub>
                      <mml:mtext>e</mml:mtext>
                      <mml:mtext mathvariant="normal">min</mml:mtext>
                    </mml:msub>
                    <mml:mo>≤</mml:mo>
                    <mml:mtext>e</mml:mtext>
                    <mml:mo>≤</mml:mo>
                    <mml:msub>
                      <mml:mtext>e</mml:mtext>
                      <mml:mtext mathvariant="normal">max</mml:mtext>
                    </mml:msub>
                  </mml:mrow>
                </mml:math>
              </d:equation></d:para>
            <d:para>In addition to normalized floating-point numbers <d:inlineequation>
                <mml:math>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mtext>f</mml:mtext>
                      <mml:mn>1</mml:mn>
                    </mml:msub>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>></mml:mo>
                    <mml:mtext> 0</mml:mtext>
                  </mml:mrow>
                </mml:math>
              </d:inlineequation> if <d:inlineequation>
                <mml:math>
                  <mml:mrow>
                    <mml:mtext>x </mml:mtext>
                    <mml:mo>≠</mml:mo>
                    <mml:mtext>0</mml:mtext>
                  </mml:mrow>
                </mml:math>
              </d:inlineequation>, floating types may be able to contain other kinds of
              floating-point numbers, such as subnormal floating-point numbers <d:inlineequation>
                <mml:math>
                  <mml:mrow>
                    <mml:mtext>x </mml:mtext>
                    <mml:mo>≠</mml:mo>
                    <mml:mtext>0, e </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:msub>
                      <mml:mtext>e</mml:mtext>
                      <mml:mtext>min</mml:mtext>
                    </mml:msub>
                    <mml:mtext>, </mml:mtext>
                    <mml:msub>
                      <mml:mtext>f</mml:mtext>
                      <mml:mn>1</mml:mn>
                    </mml:msub>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> 0</mml:mtext>
                  </mml:mrow>
                </mml:math>
              </d:inlineequation> and unnormalized floating-point numbers <d:inlineequation>
                <mml:math>
                  <mml:mrow>
                    <mml:mtext>x </mml:mtext>
                    <mml:mo>≠</mml:mo>
                    <mml:mtext>0, e </mml:mtext>
                    <mml:mo>> </mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:msub>
                      <mml:mtext>e</mml:mtext>
                      <mml:mtext>min</mml:mtext>
                    </mml:msub>
                    <mml:mtext>, </mml:mtext>
                    <mml:msub>
                      <mml:mtext>f</mml:mtext>
                      <mml:mn>1</mml:mn>
                    </mml:msub>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> 0</mml:mtext>
                  </mml:mrow>
                </mml:math>
              </d:inlineequation> and values that are not floating-point numbers, such as infinities
              and NaNs. A NaN is an encoding signifying Not-a-Number. A quiet NaN propagates through
              almost every arithmetic operation without raising a floating-point exception; a
              signaling NaN generally raises a floating-point exception when occurring as an
              arithmetic operand.<d:footnote>
                <d:para>IEC 60559:1989 specifies quiet and signaling NaNs. For implementations that
                  do not support IEC 60559:1989, the terms quiet NaN and signaling NaN are intended
                  to apply to encodings with similar behavior.</d:para>
              </d:footnote></d:para>
            <d:para>An implementation may give zero and non-numeric values (such as infinities and
              NaNs) a sign or may leave them unsigned. Wherever such values are unsigned, any
              requirement in this International Standard to retrieve the sign shall produce an
              unspecified sign, and any requirement to set the sign shall be ignored.</d:para>
            <d:para>The accuracy of the floating-point operations (<d:code>+, -, *, /</d:code>) and
              of the library functions in <d:code>&lt;math.h></d:code> and
                <d:code>&lt;complex.h></d:code> that return floating-point results is
              implementation-defined, as is the accuracy of the conversion between floating-point
              internal representations and string representations performed by the library functions
              in <d:code>&lt;stdio.h>, &lt;stdlib.h></d:code> and <d:code>&lt;wchar.h></d:code>. The
              implementation may state that the accuracy is unknown.</d:para>
            <d:para>All integer values in the <d:code>&lt;float.h></d:code> header, except
                <d:code>FLT_ROUNDS</d:code>, shall be constant expressions suitable for use in
                <d:code>#if</d:code> preprocessing directives; all floating values shall be constant
              expressions. All except <d:code>DECIMAL_DIG, FLT_EVAL_METHOD, FLT_RADIX</d:code> and
                <d:code>FLT_ROUNDS</d:code> have separate names for all three floating-point types.
              The floating- point model representation is provided for all values except
                <d:code>FLT_EVAL_METHOD</d:code> and <d:code>FLT_ROUNDS</d:code>.</d:para>
            <d:para>The rounding mode for floating-point addition is characterized by the
              implementation- defined value of <d:code>FLT_ROUNDS</d:code>:<d:footnote>
                <d:para>Evaluation of <d:code>FLT_ROUNDS</d:code> correctly reflects any
                  execution-time change of rounding mode through the function fesetround in
                    <d:code>&lt;fenv.h></d:code>.</d:para>
              </d:footnote></d:para>
            <table xmlns="http://docbook.org/ns/docbook" frame="void" class="leftcenter">
	      <colgroup width="0*"/>
	      <colgroup width="0*"/>
              <tbody>
                <tr>
                  <td>-1</td>
                  <td>indeterminate</td>
                </tr>
                <tr>
                  <td>0</td>
                  <td>toward zero</td>
                </tr>
                <tr>
                  <td>1</td>
                  <td>to nearest</td>
                </tr>
                <tr>
                  <td>2</td>
                  <td>toward positive infinity</td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>toward negative infinity</td>
                </tr>
              </tbody>
            </table>
            <d:para>All other values for <d:code>FLT_ROUNDS</d:code> characterize
              implementation-defined rounding behavior. The four rounding methods were also
              described in Terms, Definitions and Symbols. The values of operations with floating
              operands and values subject to the usual arithmetic conversions and of floating
              constants are evaluated to a format whose range and precision may be greater than
              required by the type. The use of evaluation formats is characterized by the
              implementation-defined value of <d:code>FLT_EVAL_METHOD</d:code>:<d:footnote>
                <d:para>The evaluation method determines evaluation formats of expressions involving
                  all floating types, not just real types. For example, if
                    <d:code>FLT_EVAL_METHOD</d:code> is 1, then the product of two <d:code>float
                    _Complex</d:code> operands is represented in the <d:code>double
                    _Complex</d:code> format, and its parts are evaluated to
                  <d:code>double</d:code>.</d:para>
              </d:footnote><table xmlns="http://docbook.org/ns/docbook" frame="void"
	      class="leftcenter">
	      <colgroup width="0*" />
	      <colgroup width="0*" />
	      <tbody>
		<tr>
		  <td>-1</td>
		  <td>indeterminate</td>
		</tr>
                  <tr>
                    <td>0</td>
                    <td>evaluate all operations and constants just to the range and precision of the
                      type;</td>
                  </tr>
                  <tr>
                    <td>1</td>
                    <td>evaluate operations and constants of type <code>float</code> and
                        <code>double</code> to the range and precision of the <code>double</code>
                      type, evaluate <code>long double</code> operations and constants to the range
                      and precision of the <code>long double</code> type;</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>evaluate all operations and constants to the range and precision of the
                        <code>long double</code> type.</td>
                  </tr>
                </tbody>
              </table></d:para>
            <d:para>All other negative values for <d:code>FLT_EVAL_METHOD</d:code> characterize
              implementation-defined behavior.</d:para>
            <d:para>The values given in the following list shall be replaced by constant expressions
              with implementation-defined values that are greater or equal in magnitude (absolute
              value) to those shown, with the same sign:</d:para>
            <d:itemizedlist>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">radix of exponent representation, <inlineequation>
                    <mml:math>
                      <mml:mtext>b</mml:mtext>
                    </mml:math>
                  </inlineequation></para>
                <para xmlns="http://docbook.org/ns/docbook">
                  <code> FLT_RADIX 2</code></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">number of base-<code>FLT_RADIX</code>
                  digits in the floating-point significand, <inlineequation>
                    <mml:math>
                      <mml:mtext>p</mml:mtext>
                    </mml:math>
                  </inlineequation><screen>    FLT_MANT_DIG
    DBL_MANT_DIG
    LDBL_MANT_DIG</screen></para>
              </d:listitem>
              <d:listitem>
                <para xmlns="http://docbook.org/ns/docbook">number of decimal digits, <inlineequation>
                    <mml:math>
                      <mml:mtext>n</mml:mtext>
                    </mml:math>
                  </inlineequation>, such that any floating-point number in the widest supported
                  floating type with <inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mtext>p</mml:mtext>
                          <mml:mtext>max</mml:mtext>
                        </mml:msub>
                      </mml:mrow>
                    </mml:math>
                  </inlineequation> radix <inlineequation>
                    <mml:math>
                      <mml:mtext>b</mml:mtext>
                    </mml:math>
                  </inlineequation> digits can be rounded to a floating-point number with <inlineequation>
                    <mml:math>
                      <mml:mtext>n</mml:mtext>
                    </mml:math>
                  </inlineequation> decimal digits and back again without change to the value, <informalequation>
                    <mml:math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                      <mml:mtable columnalign="right left" rowspacing="3pt" columnspacing="0.278em">
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mfenced open="{" close="">
                              <mml:mtable columnalign="left left" rowspacing="4pt"
                                columnspacing="1em">
                                <mml:mtr>
                                  <mml:mtd>
                                    <mml:msub>
                                      <mml:mi>p</mml:mi>
                                      <mml:mrow class="MJX-TeXAtom-ORD">
                                        <mml:mi>m</mml:mi>
                                        <mml:mi>a</mml:mi>
                                        <mml:mi>x</mml:mi>
                                      </mml:mrow>
                                    </mml:msub>
                                    <mml:msub>
                                      <mml:mi>log</mml:mi>
                                      <mml:mrow class="MJX-TeXAtom-ORD">
                                        <mml:mn>10</mml:mn>
                                      </mml:mrow>
                                    </mml:msub>
                                    <mml:mo>&#x2061;<!-- ⁡ --></mml:mo>
                                    <mml:mi>b</mml:mi>
                                  </mml:mtd>
                                  <mml:mtd>
                                    <mml:mspace width="1em"/>
                                    <mml:mtext>if&#xA0;</mml:mtext>
                                    <mml:mi>b</mml:mi>
                                    <mml:mtext>&#xA0;is a power of 10</mml:mtext>
                                  </mml:mtd>
                                </mml:mtr>
                                <mml:mtr>
                                  <mml:mtd>
                                    <mml:mo fence="false" stretchy="false"
                                      >&#x2308;<!-- ⌈ --></mml:mo>
                                    <mml:mn>1</mml:mn>
                                    <mml:mo>+</mml:mo>
                                    <mml:msub>
                                      <mml:mi>p</mml:mi>
                                      <mml:mrow class="MJX-TeXAtom-ORD">
                                        <mml:mi>m</mml:mi>
                                        <mml:mi>a</mml:mi>
                                        <mml:mi>x</mml:mi>
                                      </mml:mrow>
                                    </mml:msub>
                                    <mml:msub>
                                      <mml:mi>log</mml:mi>
                                      <mml:mrow class="MJX-TeXAtom-ORD">
                                        <mml:mn>10</mml:mn>
                                      </mml:mrow>
                                    </mml:msub>
                                    <mml:mo>&#x2061;<!-- ⁡ --></mml:mo>
                                    <mml:mi>b</mml:mi>
                                    <mml:mo fence="false" stretchy="false"
                                      >&#x2309;<!-- ⌉ --></mml:mo>
                                  </mml:mtd>
                                  <mml:mtd>
                                    <mml:mspace width="1em"/>
                                    <mml:mtext>otherwise</mml:mtext>
                                  </mml:mtd>
                                </mml:mtr>
                              </mml:mtable>
                            </mml:mfenced>
                          </mml:mtd>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:math>
                  </informalequation><screen>    DECIMAL_DIG 10
</screen></para>
              </d:listitem>
              <d:listitem>
                <d:para>number of decimal digits, <d:inlineequation>
                    <mml:math>
                      <mml:mtext>q</mml:mtext>
                    </mml:math>
                  </d:inlineequation>, such that any floating-point number with <d:inlineequation>
                    <mml:math>
                      <mml:mtext>q</mml:mtext>
                    </mml:math>
                  </d:inlineequation> decimal digits can be rounded into a floating-point number
                  with <d:inlineequation>
                    <mml:math>
                      <mml:mtext>p</mml:mtext>
                    </mml:math>
                  </d:inlineequation> radix <d:inlineequation>
                    <mml:math>
                      <mml:mtext>b</mml:mtext>
                    </mml:math>
                  </d:inlineequation> digits and back again without change to the <d:inlineequation>
                    <mml:math>
                      <mml:mtext>q</mml:mtext>
                    </mml:math>
                  </d:inlineequation> decimal digits,<d:informalequation>
                    <mml:math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                      <mml:mtable columnalign="right left" rowspacing="3pt" columnspacing="0.278em">
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mfenced open="{" close="">
                              <mml:mtable columnalign="left left" rowspacing="4pt"
                                columnspacing="1em">
                                <mml:mtr>
                                  <mml:mtd>
                                    <mml:mi>p</mml:mi>
                                    <mml:msub>
                                      <mml:mi>log</mml:mi>
                                      <mml:mrow class="MJX-TeXAtom-ORD">
                                        <mml:mn>10</mml:mn>
                                      </mml:mrow>
                                    </mml:msub>
                                    <mml:mo>&#x2061;<!-- ⁡ --></mml:mo>
                                    <mml:mi>b</mml:mi>
                                  </mml:mtd>
                                  <mml:mtd>
                                    <mml:mspace width="1em"/>
                                    <mml:mtext>if&#xA0;</mml:mtext>
                                    <mml:mi>b</mml:mi>
                                    <mml:mtext>&#xA0;is a power of 10</mml:mtext>
                                  </mml:mtd>
                                </mml:mtr>
                                <mml:mtr>
                                  <mml:mtd>
                                    <mml:mo fence="false" stretchy="false"
                                      >&#x230A;<!-- ⌊ --></mml:mo>
                                    <mml:mo stretchy="false">(</mml:mo>
                                    <mml:mi>p</mml:mi>
                                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                                    <mml:mn>1</mml:mn>
                                    <mml:mo stretchy="false">)</mml:mo>
                                    <mml:msub>
                                      <mml:mi>log</mml:mi>
                                      <mml:mrow class="MJX-TeXAtom-ORD">
                                        <mml:mn>10</mml:mn>
                                      </mml:mrow>
                                    </mml:msub>
                                    <mml:mo>&#x2061;<!-- ⁡ --></mml:mo>
                                    <mml:mi>b</mml:mi>
                                    <mml:mo fence="false" stretchy="false"
                                      >&#x230B;<!-- ⌋ --></mml:mo>
                                  </mml:mtd>
                                  <mml:mtd>
                                    <mml:mspace width="1em"/>
                                    <mml:mtext>otherwise</mml:mtext>
                                  </mml:mtd>
                                </mml:mtr>
                              </mml:mtable>
                            </mml:mfenced>
                          </mml:mtd>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:math>
                  </d:informalequation><d:screen>    FLT_DIG 6
    DBL_DIG 10
    LDBL_DIG 10</d:screen></d:para>
              </d:listitem>
              <d:listitem>
                <d:para>minimum negative integer such that <d:code>FLT_RADIX</d:code> raised to one
                  less than that power is a normalized floating-point number, <d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mtext>e</mml:mtext>
                          <mml:mtext>min</mml:mtext>
                        </mml:msub>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation><d:screen>    FLT_MIN_EXP
    DBL_MIN_EXP
    LDBL_MIN_EXP</d:screen></d:para>
              </d:listitem>
              <d:listitem>
                <d:para>minimum negative integer such that 10 raised to that power is in the range
                  of normalized floating-point numbers, <d:inlineequation>
                    <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mml:mo fence="false" stretchy="false">&#x2308;<!-- ⌈ --></mml:mo>
                      <mml:msub>
                        <mml:mi>log</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:mn>10</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>&#x2061;<!-- ⁡ --></mml:mo>
                      <mml:msup>
                        <mml:mi>b</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:msub>
                            <mml:mi>e</mml:mi>
                            <mml:mrow class="MJX-TeXAtom-ORD">
                              <mml:mi>m</mml:mi>
                              <mml:mi>i</mml:mi>
                              <mml:mi>n</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>&#x2212;<!-- − --></mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mo fence="false" stretchy="false">&#x2309;<!-- ⌉ --></mml:mo>
                    </mml:math>
                  </d:inlineequation><d:screen>    FLT_MIN_10_EXP -37
    DBL_MIN_10_EXP -37
    LDBL_MIN_10_EXP -37</d:screen></d:para>
              </d:listitem>
              <d:listitem>
                <d:para>maximum integer such that <d:code>FLT_RADIX</d:code> raised to one less than
                  that power is a representable finite floating-point number, <d:inlineequation>
                    <mml:math>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mtext>e</mml:mtext>
                          <mml:mtext>max</mml:mtext>
                        </mml:msub>
                      </mml:mrow>
                    </mml:math>
                  </d:inlineequation><d:screen>    FLT_MAX_EXP
    DBL_MAX_EXP
    LDBL_MAX_EXP</d:screen></d:para>
              </d:listitem>
              <d:listitem>
                <d:para>maximum integer such that 10 raised to that power is in the range of
                  representable finite floating-point numbers, <d:inlineequation>
                    <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mml:mo fence="false" stretchy="false">&#x230A;<!-- ⌊ --></mml:mo>
                      <mml:msub>
                        <mml:mi>log</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:mn>10</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>&#x2061;<!-- ⁡ --></mml:mo>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo>&#x2212;<!-- − --></mml:mo>
                      <mml:msup>
                        <mml:mi>b</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:mo>&#x2212;<!-- − --></mml:mo>
                          <mml:mi>p</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:msup>
                        <mml:mi>b</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:msub>
                            <mml:mi>e</mml:mi>
                            <mml:mrow class="MJX-TeXAtom-ORD">
                              <mml:mi>m</mml:mi>
                              <mml:mi>a</mml:mi>
                              <mml:mi>x</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo fence="false" stretchy="false">&#x230B;<!-- ⌋ --></mml:mo>
                    </mml:math>
                  </d:inlineequation>The values given in the following list shall be replaced by
                  constant expressions with implementation-defined values that are greater than or
                  equal to those shown:</d:para>
              </d:listitem>
              <d:listitem>
                <d:para>maximum representable finite floating-point number, <d:inlineequation>
                    <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo>&#x2212;<!-- − --></mml:mo>
                      <mml:msup>
                        <mml:mi>b</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:mo>&#x2212;<!-- − --></mml:mo>
                          <mml:mi>p</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:msup>
                        <mml:mi>b</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:msub>
                            <mml:mi>e</mml:mi>
                            <mml:mrow class="MJX-TeXAtom-ORD">
                              <mml:mi>m</mml:mi>
                              <mml:mi>a</mml:mi>
                              <mml:mi>x</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msup>
                    </mml:math>
                  </d:inlineequation><d:screen>    FLT_MAX 1E+37
    DBL_MAX 1E+37
    LDBL_MAX 1E+37</d:screen>The
                  values given in the following list shall be replaced by constant expressions with
                  implementation-defined (positive) values that are less than or equal to those
                  shown:</d:para>
              </d:listitem>
              <d:listitem>
                <d:para>the difference between 1 and the least value greater than 1 that is
                  representable in the given floating point type, <d:inlineequation>
                    <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mml:msup>
                        <mml:mi>b</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:mn>1</mml:mn>
                          <mml:mo>&#x2212;<!-- − --></mml:mo>
                          <mml:mi>p</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:math>
                  </d:inlineequation><d:screen>    FLT_EPSILON 1E-5
    DBL_EPSILON 1E-9
    LDBL_EPSILON 1E-9</d:screen></d:para>
              </d:listitem>
              <d:listitem>
                <d:para>minimum normalized positive floating-point number, <d:inlineequation>
                    <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mml:msup>
                        <mml:mi>b</mml:mi>
                        <mml:mrow class="MJX-TeXAtom-ORD">
                          <mml:msub>
                            <mml:mi>e</mml:mi>
                            <mml:mrow class="MJX-TeXAtom-ORD">
                              <mml:mi>m</mml:mi>
                              <mml:mi>i</mml:mi>
                              <mml:mi>n</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>&#x2212;<!-- − --></mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msup>
                    </mml:math>
                  </d:inlineequation></d:para>
              </d:listitem>
            </d:itemizedlist>
          </d:sect4>
          <d:sect4>
            <d:title>Recommended Practice</d:title>
            <d:para>Conversion from (at least) double to decimal with <d:code>DECIMAL_DIG</d:code>
              digits and back should be the identity function.</d:para>
            <d:para>EXAMPLE 1 The following describes an artificial floating-point representation
              that meets the minimum requirements of this International Standard, and the
              appropriate values in a <d:code>&lt;float.h&gt;</d:code> header for type
                <d:code>float</d:code>:<d:informalequation>
                <mml:math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <mml:mi>x</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:msup>
                    <mml:mn>16</mml:mn>
                    <mml:mi>e</mml:mi>
                  </mml:msup>
                  <mml:munderover>
                    <mml:mo>&#x2211;<!-- ∑ --></mml:mo>
                    <mml:mrow class="MJX-TeXAtom-ORD">
                      <mml:mi>k</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mn>6</mml:mn>
                  </mml:munderover>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                  <mml:msup>
                    <mml:mn>16</mml:mn>
                    <mml:mrow class="MJX-TeXAtom-ORD">
                      <mml:mo>&#x2212;<!-- − --></mml:mo>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>,</mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>&#x2212;<!-- − --></mml:mo>
                  <mml:mn>31</mml:mn>
                  <mml:mo>&#x2264;<!-- ≤ --></mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mi>e</mml:mi>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>&#x2264;<!-- ≤ --></mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>+</mml:mo>
                  <mml:mn>32</mml:mn>
                </mml:math>
              </d:informalequation><d:screen>    FLT_RADIX                   16
    FLT_MANT_DIG                 6
    FLT_EPSILON    9.53674316E-07F
    FLT_DIG                      6
    FLT_MIN_EXP                -31
    FLT_MIN        2.93873588E-39F
    FLT_MIN_10_EXP             -38
    FLT_MAX_EXP                +32
    FLT_MAX        3.40282347E+38F
    FLT_MAX_10_EXP             +38</d:screen></d:para>
            <d:para>EXAMPLE 2 The following describes floating-point representations that also meet
              the requirements for single-precision and double-precision normalized numbers in IEC
              60559, <d:footnote>
                <d:para>The floating-point model in that standard sums powers of b from zero, so the
                  values of the exponent limits are one less than shown here.</d:para>
              </d:footnote> and the appropriate values in a &lt;float.h&gt; header for types
                <d:code>float</d:code> and <d:code>double</d:code>:<d:informalequation>
                <mml:math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <mml:mi>x</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:msup>
                    <mml:mn>2</mml:mn>
                    <mml:mi>e</mml:mi>
                  </mml:msup>
                  <mml:munderover>
                    <mml:mo>&#x2211;<!-- ∑ --></mml:mo>
                    <mml:mrow class="MJX-TeXAtom-ORD">
                      <mml:mi>k</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mn>2</mml:mn>
                  </mml:munderover>
                  <mml:mn>4</mml:mn>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                  <mml:msup>
                    <mml:mn>2</mml:mn>
                    <mml:mrow class="MJX-TeXAtom-ORD">
                      <mml:mo>&#x2212;<!-- − --></mml:mo>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>,</mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>&#x2212;<!-- − --></mml:mo>
                  <mml:mn>125</mml:mn>
                  <mml:mo>&#x2264;<!-- ≤ --></mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mi>e</mml:mi>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>&#x2264;<!-- ≤ --></mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>+</mml:mo>
                  <mml:mn>128</mml:mn>
                </mml:math>
              </d:informalequation>
              <d:informalequation>
                <mml:math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <mml:mi>x</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:msup>
                    <mml:mn>2</mml:mn>
                    <mml:mi>e</mml:mi>
                  </mml:msup>
                  <mml:munderover>
                    <mml:mo>&#x2211;<!-- ∑ --></mml:mo>
                    <mml:mrow class="MJX-TeXAtom-ORD">
                      <mml:mi>k</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mn>5</mml:mn>
                  </mml:munderover>
                  <mml:mn>3</mml:mn>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                  <mml:msup>
                    <mml:mn>2</mml:mn>
                    <mml:mrow class="MJX-TeXAtom-ORD">
                      <mml:mo>&#x2212;<!-- − --></mml:mo>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>,</mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>&#x2212;<!-- − --></mml:mo>
                  <mml:mn>1024</mml:mn>
                  <mml:mo>&#x2264;<!-- ≤ --></mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mi>e</mml:mi>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>&#x2264;<!-- ≤ --></mml:mo>
                  <mml:mtext>&#xA0;</mml:mtext>
                  <mml:mo>+</mml:mo>
                  <mml:mn>1024</mml:mn>
                </mml:math>
              </d:informalequation><d:screen>    FLT_RADIX                        2
    DECIMAL_DIG                     17
    FLT_MANT_DIG                    24
    FLT_EPSILON        1.19209290E-07F // decimal constant
    FLT_EPSILON               0x1P-23F // hex constant
    FLT_DIG                          6
    FLT_MIN_EXP                   -125
    FLT_MIN            1.17549435E-38F // decimal constant
    FLT_MIN                  0X1P-126F // hex consttant
    FLT_MIN_10_EXP                 -37
    FLT_MAX_EXP                   +128
    FLT_MAX            3.40282347E+38F // decimal constant
    FLT_MAX            0X1.fffffeP127F // hex constant
    FLT_MAX_10_EXP                 +38
    DBL_MANT_DIG                    53
    DBL_EPSILON 2.2204460492503131E-16 // deciaml constant
    DBL_EPSILON                0X1P-52 // hex constant
    DBL_DIG                         15
    DBL_MIN_EXP                  -1021
    DBL_MIN    2.2250738585072014E-308 // deciaml constant
    DBL_MIN                  0X1P-1022 // hex constant
    DBL_MIN_10_EXP                -307
    DBL_MAX_EXP                  +1024
    DBL_MAX    1.7976931348623157E+308 // decimal constant
    DBL_MAX     0X1.fffffffffffffP1023 // hex constant
    DBL_MAX_10_EXP                +308</d:screen></d:para>
            <d:para>If a type wider than double were supported, then <d:code>DECIMAL_DIG</d:code>
              would be greater than 17. For example, if the widest type were to use the
              minimal-width IEC 60559 double-extended format (64 bits of precision), then
                <d:code>DECIMAL_DIG</d:code> would be 21.</d:para>
            <d:para><d:emphasis role="bold">Forward references:</d:emphasis> conditional inclusion
              (Conditional Inclusion), complex arithmetic <d:code>&lt;complex.h&gt;</d:code>
              (Complex arithmetic <d:code>&lt;complex.h&gt;,</d:code> extended multibyte and wide
              character utilities <d:code>&lt;wchar.h&gt;</d:code> (Extended multibyte and wide
              character utilities <d:code>&lt;wchar.h&gt;</d:code>), floating-point environment
                <d:code>&lt;fenv.h&gt;</d:code> (Floating-point environment
                <d:code>&lt;fenv.h&gt;</d:code>), general utilities
                <d:code>&lt;stdlib.h&gt;</d:code> (General utilities
                <d:code>&lt;stdlib.h&gt;</d:code>), input/output <d:code>&lt;stdio.h&gt;</d:code>
              (Input/output <d:code>&lt;stdio.h&gt;</d:code>), mathematics
                <d:code>&lt;math.h&gt;</d:code> (Mathematics
              <d:code>&lt;math.h&gt;</d:code>).</d:para>
          </d:sect4>
        </d:sect3>
      </d:sect2>
    </d:sect1>
  </d:chapter>
  <d:chapter>
    <?dbhtml filename="lang/index.html" ?>
    <d:title>Language</d:title>
    <d:para>This is going to be meat of the book. This chapter is mapped with chapter 6 of
      specification. This will almost cover entire language. If you are already proficient in any
      programming language you must read it. However for it might be too involving without much
      introduction to language. I would recommend to skip and come back later. I could have put this
      later but then the flow of specification would have been broken.</d:para>
    <d:sect1>
      <d:title>Notation</d:title>
      <d:para>In the syntax notation used in this clause, syntactic categories (nonterminals) are
        indicated by italic type, and literal words and character set members (terminals) by
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">bold</emphasis> type. A colon
        (:) following a nonterminal introduces its definition. Alternative definitions are listed on
        separate lines, except when prefaced by the words “one of”. An optional symbol is indicated
        by the subscript “opt”, so that<d:screen><d:inlineequation>
        <mml:math
              xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>e</mml:mi>
              <mml:mi>x</mml:mi>
              <mml:mi>p</mml:mi>
              <mml:mi>r</mml:mi>
              <mml:mi>e</mml:mi>
              <mml:mi>s</mml:mi>
              <mml:mi>s</mml:mi>
              <mml:mi>i</mml:mi>
              <mml:mi>o</mml:mi>
              <mml:msub>
                <mml:mi>n</mml:mi>
                <mml:mrow class="MJX-TeXAtom-ORD">
                  <mml:mi>o</mml:mi>
                  <mml:mi>p</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:msub>
            </mml:math></d:inlineequation></d:screen></d:para>
      <d:para>indicates an optional expression enclosed in braces.</d:para>
      <d:para>When syntactic categories are referred to in the main text, they are not italicized
        and words are separated by spaces instead of hyphens.</d:para>
      <d:para>A summary of the language syntax is given in annex A.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Conceptes</title>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Scope of Identifiers</title>
        <d:para>An identifier can denote an object; a function; a tag or a member of a structure,
          union, or enumeration; a typedef name; a label name; a macro name; or a macro parameter.
          The same identifier can denote different entities at different points in the program. A
          member of an enumeration is called an <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">enumeration constant</emphasis>. Macro names and macro parameters are not
          considered further here, because prior to the semantic phase of program translation any
          occurrences of macro names in the source file are replaced by the preprocessing token
          sequences that constitute their macro definitions.</d:para>
        <d:para>The interesting part is “The same identifier can denote different entities at
          different points in the program.”. This can happen if the identifer is in different
          scopes.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  int f=0;
}

int main()
{
  f();

  return 0;
}</d:programlisting>
        <d:para>For each different entity that an identifier designates, the identifier is visible
          (i.e., can be used) only within a region of program text called its scope. Different
          entities designated by the same identifier either have different scopes, or are in
          different name spaces. There are four kinds of scopes: function, file, block, and function
          prototype. (A function prototype is a declaration of a function that declares the types of
          its parameters.)</d:para>
        <d:para>For example; consider following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int i = 25;

void f(int );

void f(int i)
{
  printf("%d\n",i); //uses file scope

  i = 24;

  printf("%d\n",i); //uses function scope

  {
    i = 27;

    printf("%d\n",i); //uses block scope
  }
}

int main()
{
  f(i);

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>25
24
27</d:screen>
        <d:para>A label name is the only kind of identifier that has function scope. It can be used
          (in a goto statement) anywhere in the function in which it appears, and is declared
          implicitly by its syntactic appearance (followed by a : and a statement).</d:para>
        <d:para>For example, consider following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  int i=1;

  ONE:  if(i==2)
          goto TWO;
        else {
          i=2;
          goto ONE;
        }
  TWO: ;
  //TWO: goto MAIN; //will cause error
}

int main()
{
  f();
  //goto MAIN; //will cause error
  //MAIN: ; //will cause error

  return 0;
}</d:programlisting>
        <d:para>Every other identifier has scope determined by the placement of its declaration (in
          a declarator or type specifier). If the declarator or type specifier that declares the
          identifier appears outside of any block or list of parameters, the identifier has
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">file scope</emphasis>,
          which terminates at the end of the translation unit. If the declarator or type specifier
          that declares the identifier appears inside a block or within the list of parameter
          declarations in a function definition, the identifier has <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">block scope</emphasis>, which
          terminates at the end of the associated block. If the declarator or type specifier that
          declares the identifier appears within the list of parameter declarations in a function
          prototype (not part of a function definition), the identifier has function <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">prototype scope</emphasis>, which
          terminates at the end of the function declarator. If an identifier designates two
          different entities in the same name space, the scopes might overlap. If so, the scope of
          one entity (the <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">inner
            scope</emphasis>) will be a strict subset of the scope of the other entity (the
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">outer scope</emphasis>).
          Within the inner scope, the identifier designates the entity declared in the inner scope;
          the entity declared in the outer scope is <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">hidden</emphasis> (and not visible) within the inner scope. For example,
          consider the following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f(int j);

void f(int i)
{
  //identifier j not available in this function
  {
    int i=5;
    printf("%d\n",i);
  }
  //printf("%d", i); not available outside inner scope will cause error
}

int main()
{
  f(7);

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>5</d:screen>
        <d:para>Unless explicitly stated otherwise, where International Standard uses the term
          “identifier” to refer to some entity (as opposed to the syntactic construct), it refers to
          the entity in the relevant name space whose declaration is visible at the point the
          identifier occurs.</d:para>
        <d:para>Two identifiers have the same scope if and only if their scopes terminate at the
          same point.</d:para>
        <d:para>Structure, union, and enumeration tags have scope that begins just after the
          appearance of the tag in a type specifier that declares the tag. Each enumeration constant
          has scope that begins just after the appearance of its defining enumerator in an
          enumerator list. Any other identifier has scope that begins just after the completion of
          its declarator.</d:para>
        <d:para>For example, consider the following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

typedef struct STRUCT {
  struct STRUCT *s1; //just a pointer so can be delared
  struct STRUCT s2;  //object therefore incomplete type error
}S;

int main()
{
  return 0;
}</d:programlisting>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

typedef struct {
  int i;
}S; //type S is has file scope

int main()
{
  S s; //s has function scope

  return 0;
}</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> declarations (Declarations), function calls (Function calls),
          function definitions (Function definitions), identifiers (Identifiers), name spaces of
          identifiers (Name Spaces of the Identifiers), macro replacement (Macro Replacement),
          source file inclusion (Source File Inclusion), statements (Statements and
          blocks).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Linkage of identifiers</title>
        <d:para>An identifier declared in different scopes or in the same scope more than once can
          be made to refer to the same object or function by a process called linkage.<d:footnote>
            <d:para>There is no linkage between different identifiers.</d:para>
          </d:footnote>There are three kinds of linkage: external, internal, and none.</d:para>
        <d:para>In the set of translation units and libraries that constitutes an entire program,
          each declaration of a particular identifier with <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">external linkage</emphasis> denotes
          the same object or function. Within one translation unit, each declaration of an
          identifier with internal linkage denotes the same object or function. Each declaration of
          an identifier with no linkage denotes a unique entity.</d:para>
        <d:para>For example, consider the following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int i; //external scope

void f()
{
  // int i=0; same problem
  int j=0; //can declare j as j has internal scope
}

int main()
{
  // int i=0; will give redeclaration error
  int j;

  f();

  return 0;
}</d:programlisting>
        <d:para>If the declaration of a file scope identifier for an object or a function contains
          the storage-class specifier static, the identifier has <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">internal linkage</emphasis>.<d:footnote>
            <d:para>A function declaration can contain the storage-class specifier static only if it
              is at file scope; see Storage-class specifiers.</d:para>
          </d:footnote></d:para>
        <d:para>For example, consider the following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

static int i; //internal scope not visible outside file

void f()
{
  // int i=0; same problem
  int j=0; //can declare j as j has internal scope
}

int main()
{
  // int i=0; will give redeclaration error
  int j;

  f();

  return 0;
}</d:programlisting>
        <d:para>For an identifier declared with the storage-class specifier <d:code>extern</d:code>
          in a scope in which a prior declaration of that identifier is visible,<d:footnote>
            <d:para>As specified in Scope of Identifiers, the later declaration might hide the prior
              declaration.</d:para>
          </d:footnote>if the prior declaration specifies internal or external linkage, the linkage
          of the identifier at the later declaration is the same as the linkage specified at the
          prior declaration. If no prior declaration is visible, or if the prior declaration
          specifies no linkage, then the identifier has external linkage.</d:para>
        <d:para>For example, consider the following programs:</d:para>
        <d:programlisting role="CLexer">//test.c
#include &lt;stdio.h>

int i; //external scope not visible outside file

int main()
{
  printf("%d\n", i);
  f();

  return 0;
}</d:programlisting>
        <d:programlisting role="CLexer">//test1.c
#include &lt;stdio.h>

extern int i;

void f()
{
  printf("%d\n", i);
}</d:programlisting>
        <d:para>compile them like <d:code>gcc test.c test1.c -o out</d:code>.</d:para>
        <d:para>The output is:<d:screen>0
0</d:screen></d:para>
        <d:para>If the declaration of an identifier for a function has no storage-class specifier,
          its linkage is determined exactly as if it were declared with the storage-class specifier
            <d:code>extern</d:code>. If the declaration of an identifier for an object has file
          scope and no storage-class specifier, its linkage is external.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int i;   //external linkage can be called from other files
void f() //external linkage can be called from other files
{
  //do something here
}

int main()
{
  f();

  return 0;
}</d:programlisting>
        <d:para>The following identifiers have no linkage: an identifier declared to be anything
          other than an object or a function; an identifier declared to be a function parameter; a
          block scope identifier for an object declared without the storage-class specifier
          extern.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f(int i) //i has no linkage
{
}

int main()
{
  {
    int i;//no linkage
    f(i);
  }
  return 0;
}</d:programlisting>
        <d:para>If, within a translation unit, the same identifier appears with both internal and
          external linkage, the behavior is undefined.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> declarations (Declarations), expressions (Expressions), external
          definitions (External definitions), statements (Statements and blocks).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Name Spaces of the Identifiers</title>
        <d:para>If more than one declaration of a particular identifier is visible at any point in a
          translation unit, the syntactic context disambiguates uses that refer to different
          entities. Thus, there are separate <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">name spaces</emphasis> for various categories of identifiers, as
          follows:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><emphasis role="italic">label
                names</emphasis> (disambiguated by the syntax of the label declaration and
              use);</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">the tags of structures, unions, and
              enumerations (disambiguated by following any<footnote>
                <para>There is only one name space for tags even though three are possible.</para>
              </footnote>of the keywords <code>struct, union</code> or <code>enum</code>);</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">all other identifiers, called <code>ordinary
                identifiers</code> (declared in ordinary declarators or as enumeration
              constants).</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>For example, consider the following</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

struct S{
  int i;
};

union U {
  int i;
};

int main()
{
  int i = 0;
  int END = 0;
  int S = 0;
  int U = 0;
  struct S s;
  union U u;

  s.i = 7;
  u.i = 9;

  goto END;
  END: ;

  return 0;
}</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> enumeration specifiers (Enumeration specifiers), labeled
          statements (Labeled statements), structure and union specifiers (Structure and union
          specifiers), structure and union members (Structure and union members), tags (Tags), the
          goto statement (The goto statement).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Storage duration of objects</title>
        <d:para>An object has a <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >storage duration</emphasis> that determines its lifetime. There are three storage
          durations: static, automatic, and allocated. Allocated storage is described in <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">Memory management
            functions</emphasis>.</d:para>
        <d:para>The <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >lifetime</emphasis> of an object is the portion of program execution during which
          storage is guaranteed to be reserved for it. An object exists, has a constant address,<d:footnote>
            <d:para>The term “constant address” means that two pointers to the object constructed at
              possibly different times will compare equal. The address may be different during two
              different executions of the same program.</d:para>
          </d:footnote> and retains its last-stored value throughout its lifetime.<d:footnote>
            <d:para>In the case of a volatile object, the last store need not be explicit in the
              program.</d:para>
          </d:footnote> If an object is referred to outside of its lifetime, the behavior is
          undefined. The value of a pointer becomes indeterminate when the object it points to
          reaches the end of its lifetime.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int *p;
  {
    int i=4;

    p=&amp;i;

    printf("%d %d\n", i, *p);
  }

  //printf("%d\n", i) //will cause error
  printf("%d\n", *p); //dangerous because i is dead

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>4 4
4</d:screen>
        <d:para>Note that even though 4 has been printed for <d:code>*p</d:code> that is because
          stack has not been touched. Make some function calls between brace and printf and most
          probably 4 will be overwritten.</d:para>
        <d:para>An object whose identifier is declared with external or internal linkage, or with
          the storage-class specifier <d:code>static</d:code> has <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">static storage duration</emphasis>.
          Its lifetime is the entire execution of the program and its stored value is initialized
          only once, prior to program startup.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  static int i=0;

  printf("%d\n", i++);
}

int main()
{
  f();
  f();
  f();

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>0
1
2</d:screen>
        <d:para>An object whose identifier is declared with no linkage and without the storage-class
          specifier <d:code>static</d:code> has <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">automatic storage duration</emphasis>.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  {
    int i=0;

    printf("%d\n", i++);
  }
}

int main()
{
  f();
  f();
  f();

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>0
0
0</d:screen>
        <d:para>For such an object that does not have a variable length array type, its lifetime
          extends from entry into the block with which it is associated until execution of that
          block ends in any way. (Entering an enclosed block or calling a function suspends, but
          does not end, execution of the current block.) If the block is entered recursively, a new
          instance of the object is created each time. The initial value of the object is
          indeterminate. If an initialization is specified for the object, it is performed each time
          the declaration is reached in the execution of the block; otherwise, the value becomes
          indeterminate each time the declaration is reached.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  int i=0;
  static int n=0;

  if(n&lt;4)
    printf("%d\n", i++);
  n++;
  f();
}

int main()
{
  f();

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>0
0
0
0</d:screen>
        <d:para>For such an object that does have a variable length array type, its lifetime extends
          from the declaration of the object until execution of the program leaves the scope of the declaration.<d:footnote>
            <d:para>Leaving the innermost block containing the declaration, or jumping to a point in
              that block or an embedded block prior to the declaration, leaves the scope of the
              declaration.</d:para>
          </d:footnote> If the scope is entered recursively, a new instance of the object is created
          each time. The initial value of the object is indeterminate.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> statements (Statements and blocks), function calls (Function
          calls), declarators (Declarators), array declarators (Array declarators), initialization
          (Initialization).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Types</title>
        <d:para>The meaning of a value stored in an object or returned by a function is determined
          by the <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">type</emphasis> of
          the expression used to access it. (An identifier declared to be an object is the simplest
          such expression; the type is specified in the declaration of the identifier.) Types are
          partitioned into <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">object
            types</emphasis> (types that fully describe objects), <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">function types</emphasis> (types
          that describe functions), and <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">incomplete types</emphasis> (types that describe objects but lack
          information needed to determine their sizes).</d:para>
        <d:para>An object declared as type <d:code>_Bool</d:code> is large enough to store the
          values 0 and 1.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int main()
{
  _Bool b=23;

  printf("%d %d\n", b, sizeof(_Bool));

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>1 1</d:screen>
        <d:para>Note that size of 1 byte which means whatever nonzero value we assign will be
          converted to 1 implicitly.</d:para>
        <d:para>An object declared as type char is large enough to store any member of the basic
          execution character set. If a member of the basic execution character set is stored in a
            <d:code>char</d:code> object, its value is guaranteed to be nonnegative. If any other
          character is stored in a char object, the resulting value is implementation-defined but
          shall be within the range of values that can be represented in that type.</d:para>
        <d:para>First let us see how big is <d:code>char</d:code>:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int main()
{
  printf("%d\n", sizeof(char));

  return 0;
}</d:programlisting>
        <d:para>and the output is 1. Now let us see what we can store in it.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;conio.h>

int main()
{
  for(register int i=0;  i&lt;256; i++)
    printf("%c\t", i);

  return 0;
}</d:programlisting>
        <d:para>It will show lots of non-printable characters as well. Run it as
            <d:command>./a.out|od -c</d:command> and maximum possible characters will be
          shown.</d:para>
        <d:para>There are five standard <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">signed integer types</emphasis>, designated as <d:code>signed char, short
            int, int, long int</d:code> and <d:code>long long int</d:code>. (These and other types
          may be designated in several additional ways, as described in Type specifiers.) There may
          also be implementation-defined <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">extended signed integer types</emphasis>.<d:footnote>
            <d:para>Implementation-defined keywords shall have the form of an identifier reserved
              for any use as described in 7.1.3.</d:para>
          </d:footnote> The standard and extended signed integer types are collectively called
          signed integer types.<d:footnote>
            <d:para>Therefore, any statement in this Standard about signed integer types also
              applies to the extended signed integer types.</d:para>
          </d:footnote></d:para>
        <d:para>An object declared as type signed char occupies the same amount of storage as a
          “plain” char object. A “plain” int object has the natural size suggested by the
          architecture of the execution environment (large enough to contain any value in the range
            <d:code>INT_MIN</d:code> to <d:code>INT_MAX</d:code> as defined in the header
            <d:code>&lt;limits.h></d:code>).</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;limits.h>

int main()
{
  printf("%d %d", INT_MIN, INT_MAX);

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>-2147483648 2147483647</d:screen>
        <d:para>which is much much greater than -127 and 128 possible for our 1 byte
          character.</d:para>
        <d:para>For each of the signed integer types, there is a corresponding (but different)
          unsigned integer type (designated with the keyword <d:code>unsigned</d:code>) that uses
          the same amount of storage (including sign information) and has the same alignment
          requirements. The type <d:code>_Bool</d:code> and the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">unsigned integer types</emphasis>
          that correspond to the standard signed integer types are the standard unsigned integer
          types. The unsigned integer types that correspond to the extended signed integer types are
          the extended unsigned integer types. The standard and extended unsigned integer types are
          collectively called <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">unsigned
            integer types</emphasis>.<d:footnote>
            <d:para>Therefore, any statement in this Standard about unsigned integer types also
              applies to the extended unsigned integer types.</d:para>
          </d:footnote></d:para>
        <d:para>The standard signed integer types and standard unsigned integer types are
          collectively called the <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >standard integer types</emphasis>, the extended signed integer types and extended
          unsigned integer types are collectively called the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">extended integer
          types</emphasis>.</d:para>
        <d:para>For any two integer types with the same signedness and different integer conversion
          rank (see Booleans, Characters and Integers), the range of values of the type with smaller
          integer conversion rank is a subrange of the values of the other type.</d:para>
        <d:para>The range of nonnegative values of a signed integer type is a subrange of the
          corresponding unsigned integer type, and the representation of the same value in each type
          is the same.<d:footnote>
            <d:para>The same representation and alignment requirements are meant to imply
              interchangeability as arguments to functions, return values from functions, and
              members of unions.</d:para>
          </d:footnote> A computation involving unsigned operands can never overflow, because a
          result that cannot be represented by the resulting unsigned integer type is reduced modulo
          the number that is one greater than the largest value that can be represented by the
          resulting type.</d:para>
        <d:para>There are three real <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >floating types</emphasis>, designated as <d:code>float, double</d:code> and
            <d:code>long double</d:code>. The set of values of the type <d:code>float</d:code> is a
          subset of the set of values of the type <d:code>double</d:code>; the set of values of the
          type <d:code>double</d:code> is a subset of the set of values of the type <d:code>long
            double</d:code>.</d:para>
        <d:para>There are three <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >complex types</emphasis>, designated as <d:code>float _Complex, double
            _Complex,</d:code> and <d:code>long double _Complex</d:code>. The real floating and
          complex types are collectively called the <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">floating types</emphasis>.</d:para>
        <d:para>For each floating type there is a <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">corresponding real type</emphasis>, which is always a real floating type.
          For real floating types, it is the same type. For complex types, it is the type given by
          deleting the keyword <d:code>_Complex</d:code> from the type name.</d:para>
        <d:para>Each complex type has the same representation and alignment requirements as an array
          type containing exactly two elements of the corresponding real type; the first element is
          equal to the real part, and the second element to the imaginary part, of the complex
          number.</d:para>
        <d:para>The type <d:code>char</d:code>, the signed and unsigned integer types, and the
          floating types are collectively called the <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">basic types</emphasis>. Even if the implementation defines two or more
          basic types to have the same representation, they are nevertheless different types.<d:footnote>
            <d:para>An implementation may define new keywords that provide alternative ways to
              designate a basic (or any other) type; this does not violate the requirement that all
              basic types be different. Implementation-defined keywords shall have the form of an
              identifier reserved for any use as described in 7.1.3.</d:para>
          </d:footnote></d:para>
        <d:para>The three types <d:code>char, signed char</d:code> and <d:code>unsigned
            char</d:code> are collectively called the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">character types</emphasis>. The
          implementation shall define <d:code>char</d:code> to have the same range, representation,
          and behavior as either <d:code>signed char</d:code> or <d:code>unsigned char</d:code>.<d:footnote>
            <d:para><d:code>CHAR_MIN</d:code>, defined in <d:code>&lt;limits.h></d:code>, will have
              one of the values 0 or <d:code>SCHAR_MIN</d:code>, and this can be used to distinguish
              the two options. Irrespective of the choice made, char is a separate type from the
              other two and is not compatible with either.</d:para>
          </d:footnote></d:para>
        <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >enumeration</emphasis> comprises a set of named integer constant values. Each distinct
          enumeration constitutes a different <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">enumerated type</emphasis>.</d:para>
        <d:para>The type <d:code>char</d:code>, the signed and unsigned integer types, and the
          enumerated types are collectively called <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">integer types</emphasis>. The integer and real floating types are
          collectively called <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">real
            types</emphasis>.</d:para>
        <d:para>Integer and floating types are collectively called <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">arithmetic types</emphasis>. Each
          arithmetic type belongs to one <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">type domain</emphasis>: the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">real type domain</emphasis>
          comprises the real types, the <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">complex type domain</emphasis> comprises the complex types.</d:para>
        <d:para>The <d:code>void</d:code> type comprises an empty set of values; it is an incomplete
          type that cannot be completed.</d:para>
        <d:para>Any number of <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">derived
            types</emphasis> can be constructed from the object, function, and incomplete types, as
          follows:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">An <emphasis role="italic">array
                type</emphasis> describes a contiguously allocated nonempty set of objects with a
              particular member object type, called the <emphasis role="italic">element
                type</emphasis>.<footnote>
                <para>Since object types do not include incomplete types, an array of incomplete
                  type cannot be constructed.</para>
              </footnote>Array types are characterized by their element type and by the number of
              elements in the array. An array type is said to be derived from its element type, and
              if its element type is <emphasis role="italic">T</emphasis>, the array type is
              sometimes called “array of <emphasis role="italic">T</emphasis>”. The construction of
              an array type from an element type is called “array type derivation”.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A <emphasis role="italic">structure
                type</emphasis> describes a sequentially allocated nonempty set of member objects
              (and, in certain circumstances, an incomplete array), each of which has an optionally
              specified name and possibly distinct type.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A <emphasis role="italic">union
                type</emphasis> describes an overlapping nonempty set of member objects, each of
              which has an optionally specified name and possibly distinct type.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A <emphasis role="italic">function
                type</emphasis> describes a function with specified return type. A function type is
              characterized by its return type and the number and types of its parameters. A
              function type is said to be derived from its return type, and if its return type is
                <emphasis role="italic">T</emphasis>, the function type is sometimes called
              “function returning <emphasis role="italic">T</emphasis>”. The construction of a
              function type from a return type is called “function type derivation”.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A pointer type may be derived from a
              function type, an object type, or an incomplete type, called the referenced type. A
              pointer type describes an object whose value provides a reference to an entity of the
              referenced type. A pointer type derived from the referenced type <emphasis
                role="italic">T</emphasis> is sometimes called “pointer to <emphasis role="italic"
                >T</emphasis>”. The construction of a pointer type from a referenced type is called
              “pointer type derivation”.</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>These methods of constructing derived types can be applied recursively. What this
          mean is you can have structures of structrues of structures and so on. Similarly, you can
          have array of array of array and so on. And you can have array of array of array of such
          structures of structures of structures ... .</d:para>
        <d:para>Arithmetic types and pointer types are collectively called <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">scalar types</emphasis>. Array and
          structure types are collectively called <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">aggregate types</emphasis>.<d:footnote>
            <d:para>Note that aggregate type does not include union type because an object with
              union type can only contain one member at a time.</d:para>
          </d:footnote></d:para>
        <d:para>An array type of unknown size is an incomplete type. It is completed, for an
          identifier of that type, by specifying the size in a later declaration (with internal or
          external linkage). A structure or union type of unknown content (as described in Tags) is
          an incomplete type. It is completed, for all declarations of that type, by declaring the
          same structure or union tag with its defining content later in the same scope.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

S s[10]; //incomplete type at this moment

typedef struct {
  int i;
}S; //type completed here

int main()
{
  return 0;
}</d:programlisting>
        <d:para>Array, function, and pointer types are collectively called <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">derived declarator types</emphasis>.
          A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">declarator type
            derivation</emphasis> from a type <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">T</emphasis> is the construction of a derived declarator type from
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">T</emphasis> by the
          application of an array-type, a function-type, or a pointer-type derivation to <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">T</emphasis>.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

S s[10];

S f()
{
  S s1;

  return s1;
}

S (*g)()
{
  S s2;

  return s2;
}

typedef struct {
  int i;
}S;

int main()
{
  return 0;
}</d:programlisting>
        <d:para>A type is characterized by its <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">type category</emphasis>, which is either the outermost derivation of a
          derived type (as noted above in the construction of derived type), or the type itself if
          the type consists of no derived types.</d:para>
        <d:para>Any type so far mentioned is an unqualified type. Each unqualified type has several
          qualified versions of its type,<d:footnote>
            <d:para>See Type qualifiers regarding qualified array and function types.</d:para>
          </d:footnote> corresponding to the combinations of one, two, or all three of the
            <d:code>const, volatile</d:code> and <d:code>restrict</d:code> qualifiers. The qualified
          or unqualified versions of a type are distinct types that belong to the same type category
          and have the same representation and alignment requirements.<d:footnote xml:id="a">
            <d:para>The same representation and alignment requirements are meant to imply
              interchangeability as arguments to functions, return values from functions, and
              members of unions.</d:para>
          </d:footnote> A derived type is not qualified by the qualifiers (if any) of the type from
          which it is derived.</d:para>
        <d:para>A pointer to void shall have the same representation and alignment requirements as a
          pointer to a character type.<d:footnoteref linkend="a"/> Similarly, pointers to qualified
          or unqualified versions of compatible types shall have the same representation and
          alignment requirements. All pointers to structure types shall have the same representation
          and alignment requirements as each other. All pointers to union types shall have the same
          representation and alignment requirements as each other. Pointers to other types need not
          have the same representation or alignment requirements.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Representation of Types</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">General</title>
          <d:para>The representations of all types are unspecified except as stated in this
            subclause.</d:para>
          <d:para>Except for bit-fields, objects are composed of contiguous sequences of one or more
            bytes, the number, order, and encoding of which are either explicitly specified or
            implementation-defined.</d:para>
          <d:para>Values stored in unsigned bit-fields and objects of type <d:code>unsigned
              char</d:code> shall be represented using a pure binary notation.<d:footnote>
              <d:para>A positional representation for integers that uses the binary digits 0 and 1,
                in which the values represented by successive bits are additive, begin with 1, and
                are multiplied by successive integral powers of 2, except perhaps the bit with the
                highest position. (Adapted from the American National Dictionary for Information
                Processing Systems.) A byte contains <d:code>CHAR_BIT</d:code> bits, and the values
                of type unsigned char range from 0 to <d:inlineequation>
                  <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mml:msup>
                      <mml:mn>2</mml:mn>
                      <mml:mrow class="MJX-TeXAtom-ORD">
                        <mml:mi>C</mml:mi>
                        <mml:mi>H</mml:mi>
                        <mml:mi>A</mml:mi>
                        <mml:mi>R</mml:mi>
                        <mml:mi mathvariant="normal">&#x005F;<!-- _ --></mml:mi>
                        <mml:mi>B</mml:mi>
                        <mml:mi>I</mml:mi>
                        <mml:mi>T</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:math>
                </d:inlineequation>.</d:para>
            </d:footnote></d:para>
          <d:para>Values stored in non-bit-field objects of any other object type consist of
              <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">n x</emphasis>
            <d:code>CHAR_BIT</d:code> bits, where n is the size of an object of that type, in bytes.
            The value may be copied into an object of type unsigned char <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">[n]</emphasis> (e.g., by memcpy);
            the resulting set of bytes is called the object representation of the value. Values
            stored in bit-fields consist of <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">m</emphasis> bits, where m is the size specified for the bit-field. The
            object representation is the set of <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">m</emphasis> bits the bit-field comprises in the addressable storage
            unit holding it. Two values (other than NaNs) with the same object representation
            compare equal, but values that compare equal may have different object
            representations.</d:para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>

typedef struct {
  char   c:7;
  int    i:3;
}S;

int main()
{
  S s;

  s.c = '0';
  s.i = 5;

  printf("%c %d\n", s.c, s.i);

  return 0;
}</d:programlisting>
          <d:para>and the output is:</d:para>
          <d:screen>0 -3</d:screen>
          <d:para>Consider the following program:</d:para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>

typedef struct {
  int    i:1;
}S;

int main()
{
  S s;

  s.i = 1;

  printf("%d\n", s.i);

  return 0;
}</d:programlisting>
          <d:para>what do you think the output will be? 0 to 1 that is what my gut feeling tells me
            but I am wrong. With <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >N</emphasis> bits the range of integer is <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:mo>&#x2212;<!-- − --></mml:mo>
                <mml:msup>
                  <mml:mn>2</mml:mn>
                  <mml:mi>N</mml:mi>
                </mml:msup>
                <mml:mo>&#x2212;<!-- − --></mml:mo>
                <mml:mn>1</mml:mn>
              </mml:math>
            </d:inlineequation> to <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:msup>
                  <mml:mn>2</mml:mn>
                  <mml:mrow class="MJX-TeXAtom-ORD">
                    <mml:mi>N</mml:mi>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>&#x2212;<!-- − --></mml:mo>
                <mml:mo>&#x2212;<!-- − --></mml:mo>
                <mml:mn>1</mml:mn>
              </mml:math>
            </d:inlineequation>. This evaluates to -1 to 0. So any even no. stored in 1 bits field
            is 0 and any odd no. is -1. Useful for finding odd and even numbers eh?</d:para>
          <d:para>The output is:<d:screen>-1</d:screen></d:para>
          <d:para>Certain object representations need not represent a value of the object type. If
            the stored value of an object has such a representation and is read by an lvalue
            expression that does not have character type, the behavior is undefined. If such a
            representation is produced by a side effect that modifies all or any part of the object
            by an lvalue expression that does not have character type, the behavior is undefined.<d:footnote>
              <d:para>Thus, an automatic variable can be initialized to a trap representation
                without causing undefined behavior, but the value of the variable cannot be used
                until a proper value is stored in it.</d:para>
            </d:footnote> Such a representation is called a <d:emphasis role="italic">trap
              representation</d:emphasis>.</d:para>
          <d:para>There are two places where trap representation has been talked about in the
            specification. First is parity bits on numeric types which are visible to software. This
            is given in footnote 44 of n1124.pdf at page no. 38. Second is negative zeros in
            non-twos-complement architecture, given on page 39.</d:para>
          <d:para>When a value is stored in an object of structure or union type, including in a
            member object, the bytes of the object representation that correspond to any padding
            bytes take unspecified values.<d:footnote>
              <d:para>Thus, for example, structure assignment need not copy any padding
                bits.</d:para>
            </d:footnote> The value of a structure or union object is never a trap representation,
            even though the value of a member of the structure or union object may be a trap
            representation.</d:para>
          <d:para>When a value is stored in a member of an object of union type, the bytes of the
            object representation that do not correspond to that member but do correspond to other
            members take unspecified values. What this means is that say you have two members where
            one is of <d:emphasis role="italic">m</d:emphasis> bytes and another of <d:emphasis
              role="italic">n</d:emphasis> bytes and <d:emphasis role="italic">m>n</d:emphasis>.
            Then if you assign value to one having <d:emphasis role="italic">n</d:emphasis> bytes
            then <d:emphasis role="italic">m - n</d:emphasis> bytes will have unspecified
            value.</d:para>
          <d:para>Where an operator is applied to a value that has more than one object
            representation, which object representation is used shall not affect the value of the result.<d:footnote>
              <d:para>It is possible for objects <d:code>x</d:code> and <d:code>y</d:code> with the
                same effective type <d:emphasis role="italic">T</d:emphasis> to have the same value
                when they are accessed as objects of type <d:emphasis role="italic">T</d:emphasis>,
                but to have different values in other contexts. In particular, if
                  <d:code>==</d:code> is defined for type <d:emphasis role="italic">T</d:emphasis>,
                then <d:code>x == y</d:code> does not imply that <d:code>memcmp(&amp;x, &amp;y,
                  sizeof (T)) == 0</d:code>. Furthermore, <d:code>x == y</d:code> does not
                necessarily imply that <d:code>x</d:code> and <d:code>y</d:code> have the same
                value; other operations on values of type <d:emphasis role="italic">T</d:emphasis>
                may distinguish between them.</d:para>
            </d:footnote> Where a value is stored in an object using a type that has more than one
            object representation for that value, it is unspecified which representation is used,
            but a trap representation shall not be generated.</d:para>
          <d:para>For example, char is integral type. Therefore all operations of integers can be
            done on characters.</d:para>
          <d:para><d:emphasis role="bold">Forward references:</d:emphasis> declarations
            (Declarations), expressions (Expressions), lvalues, arrays, and function designators
            (Other Operands).</d:para>
        </d:sect3>
        <d:sect3>
          <d:title>Integer Types</d:title>
          <d:para>For unsigned integer types other than unsigned char, the bits of the object
            representation shall be divided into two groups: value bits and padding bits (there need
            not be any of the latter). If there are <d:emphasis role="italic">N</d:emphasis> value
            bits, each bit shall represent a different power of 2 between 1 and <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:msup>
                  <mml:mn>2</mml:mn>
                  <mml:mrow class="MJX-TeXAtom-ORD">
                    <mml:mi>N</mml:mi>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
              </mml:math>
            </d:inlineequation>, so that objects of that type shall be capable of representing
            values from 0 to <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:msup>
                  <mml:mn>2</mml:mn>
                  <mml:mrow class="MJX-TeXAtom-ORD">
                    <mml:mi>N</mml:mi>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
              </mml:math>
            </d:inlineequation> using a pure binary representation; this shall be known as the value
            representation. The values of any padding bits are unspecified. <d:footnote>
              <d:para>Some combinations of padding bits might generate trap representations, for
                example, if one padding bit is a parity bit. Regardless, no arithmetic operation on
                valid values can generate a trap representation other than as part of an exceptional
                condition such as an overflow, and this cannot occur with unsigned types. All other
                combinations of padding bits are alternative object representations of the value
                specified by the value bits.</d:para>
            </d:footnote></d:para>
          <d:para>For signed integer types, the bits of the object representation shall be divided
            into three groups: value bits, padding bits, and the sign bit. There need not be any
            padding bits; there shall be exactly one sign bit. Each bit that is a value bit shall
            have the same value as the same bit in the object representation of the corresponding
            unsigned type (if there are <d:emphasis role="italic">M</d:emphasis> value bits in the
            signed type and <d:emphasis role="italic">N</d:emphasis> in the unsigned type, then
              <d:emphasis role="italic">M &lt;= N</d:emphasis>). If the sign bit is zero, it shall
            not affect the resulting value. If the sign bit is one, the value shall be modified in
            one of the following ways:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <d:para>the corresponding value with sign bit 0 is negated <d:emphasis role="italic"
                  >(sign and magnitude);</d:emphasis></d:para>
            </d:listitem>
            <d:listitem>
              <d:para>the sign bit has the value <d:inlineequation>
                  <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mml:msup>
                      <mml:mn>2</mml:mn>
                      <mml:mi>N</mml:mi>
                    </mml:msup>
                  </mml:math>
                </d:inlineequation>
                <d:emphasis role="italic">(two's complement);</d:emphasis></d:para>
            </d:listitem>
            <d:listitem>
              <d:para>the sign bit has the value <d:inlineequation>
                  <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mml:msup>
                      <mml:mn>2</mml:mn>
                      <mml:mi>N</mml:mi>
                    </mml:msup>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:math>
                </d:inlineequation>
                <d:emphasis role="italic">(ones' complement).</d:emphasis></d:para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>Which of these applies is implementation-defined, as is whether the value with
            sign bit 1 and all value bits zero (for the first two), or with sign bit and all value
            bits 1 (for one’s complement), is a trap representation or a normal value. In the case
            of sign and magnitude and one's complement, if this representation is a normal value it
            is called a negative zero.</d:para>
          <d:para>If the implementation supports negative zeros, they shall be generated only
            by:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <d:para>the &amp;, |, ^, ~, &lt;&lt;, and >> operators with arguments that produce
                such a value;</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>the +, -, *, /, and % operators where one argument is a negative zero and the
                result is zero;</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>compound assignment operators based on the above cases.</d:para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>It is unspecified whether these cases actually generate a negative zero or a
            normal zero, and whether a negative zero becomes a normal zero when stored in an
            object.</d:para>
          <d:para>If the implementation does not support negative zeros, the behavior of the &amp;,
            |, ^, ~, &lt;&lt;, and >> operators with arguments that would produce such a value is
            undefined.</d:para>
          <d:para>The values of any padding bits are unspecified.<d:footnote>
              <d:para>Some combinations of padding bits might generate trap representations, for
                example, if one padding bit is a parity bit. Regardless, no arithmetic operation on
                valid values can generate a trap representation other than as part of an exceptional
                condition such as an overflow. All other combinations of padding bits are
                alternative object representations of the value specified by the value
                bits.</d:para>
            </d:footnote> A valid (non-trap) object representation of a signed integer type where
            the sign bit is zero is a valid object representation of the corresponding unsigned
            type, and shall represent the same value. For any integer type, the object
            representation where all the bits are zero shall be a representation of the value zero
            in that type.</d:para>
          <d:para>The <d:emphasis role="italic">precision</d:emphasis> of an integer type is the
            number of bits it uses to represent values, excluding any sign and padding bits. The
              <d:emphasis role="italic">width</d:emphasis> of an integer type is the same but
            including any sign bit; thus for unsigned integer types the two values are the same,
            while for signed integer types the width is one greater than the precision.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <d:title>Compatible and Composite Types</d:title>
        <d:para>Two types have compatible type if their types are the same. Additional rules for
          determining whether two types are compatible are described in Type specifiers for type
          specifiers, in Type qualifiers for type qualifiers, and in Declarators for declarators.<d:footnote>
            <d:para>Two types need not be identical to be compatible.</d:para>
          </d:footnote> Moreover, two structure, union, or enumerated types declared in separate
          translation units are compatible if their tags and members satisfy the following
          requirements: If one is declared with a tag, the other shall be declared with the same
          tag. If both are complete types, then the following additional requirements apply: there
          shall be a one-to-one correspondence between their members such that each pair of
          corresponding members are declared with compatible types, and such that if one member of a
          corresponding pair is declared with a name, the other member is declared with the same
          name. For two structures, corresponding members shall be declared in the same order. For
          two structures or unions, corresponding bit-fields shall have the same widths. For two
          enumerations, corresponding members shall have the same values.</d:para>
        <d:para>All declarations that refer to the same object or function shall have compatible
          type; otherwise, the behavior is undefined.</d:para>
        <d:para>A <d:emphasis role="italic">composite type</d:emphasis> can be constructed from two
          types that are compatible; it is a type that is compatible with both of the two types and
          satisfies the following conditions:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <d:para>If one type is an array of known constant size, the composite type is an array
              of that size; otherwise, if one type is a variable length array, the composite type is
              that type.</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>If only one type is a function type with a parameter type list (a function
              prototype), the composite type is a function prototype with the parameter type
              list.</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>If both types are function types with parameter type lists, the type of each
              parameter in the composite parameter type list is the composite type of the
              corresponding parameters.</d:para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>These rules apply recursively to the types from which the two types are
          derived.</d:para>
        <d:para>For an identifier with internal or external linkage declared in a scope in which a
          prior declaration of that identifier is visible,<d:footnote>
            <d:para>As specified in Scope of Identifiers, the later declaration might hide the prior
              declaration.</d:para>
          </d:footnote> if the prior declaration specifies internal or external linkage, the type of
          the identifier at the later declaration becomes the composite type.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Conversion</d:title>
      <d:para>Several operators convert operand values from one type to another automatically. This
        subclause specifies the result required from such an implicit conversion, as well as those
        that result from a cast operation (an explicit conversion). The list in 4.3.1.8 summarizes
        the conversions performed by most ordinary operators; it is supplemented as required by the
        discussion of each operator in 4.5.</d:para>
      <d:para>Conversion of an operand value to a compatible type causes no change to the value or
        the representation.</d:para>
      <d:para><d:emphasis role="bold">Forward references:</d:emphasis> cast operators (Cast
        operators).</d:para>
      <d:sect2>
        <d:title>Arithmetics Operands</d:title>
        <d:sect3>
          <d:title>Booleans, Characters and Integers</d:title>
          <d:para>Every integer type has an <d:emphasis role="italic">integer conversion
              rank</d:emphasis> defined as follows:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <d:para>No two signed integer types shall have the same rank, even if they have the
                same representation.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of a signed integer type shall be greater than the rank of any signed
                integer type with less precision.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of <d:code>long long int</d:code> shall be greater than the rank of
                  <d:code>long int</d:code>, which shall be greater than the rank of
                  <d:code>int</d:code>, which shall be greater than the rank of <d:code>short
                  int</d:code>, which shall be greater than the rank of <d:code>signed
                char</d:code>.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of any unsigned integer type shall equal the rank of the
                corresponding signed integer type, if any.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of any standard integer type shall be greater than the rank of any
                extended integer type with the same width. The rank of <d:code>char</d:code> shall
                equal the rank of <d:code>signed char</d:code> and <d:code>unsigned
                char</d:code>.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of <d:code>_Bool</d:code> shall be less than the rank of all other
                standard integer types.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of any enumerated type shall equal the rank of the compatible integer
                type (see Enumeration specifiers).</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of any extended signed integer type relative to another extended
                signed integer type with the same precision is implementation-defined, but still
                subject to the other rules for determining the integer conversion rank.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>For all integer types <d:code>T1, T2,</d:code> and <d:code>T3</d:code>, if
                  <d:code>T1</d:code> has greater rank than <d:code>T2</d:code> and
                  <d:code>T2</d:code> has greater rank than <d:code>T3</d:code>, then
                  <d:code>T1</d:code> has greater rank than <d:code>T3</d:code>.</d:para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>The following may be used in an expression wherever an int or unsigned int may be
            used:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">An object or expression with an integer
                type whose integer conversion rank is less than or equal to the rank of
                  <code>int</code> and <code>unsigned int</code>.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">A bit-field of type <code>_Bool, int,
                  signed int,</code> or <code>unsigned int</code>.</para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>If an int can represent all values of the original type, the value is converted to
            an int; otherwise, it is converted to an unsigned int. These are called the integer promotions.<d:footnote>
              <d:para>The integer promotions are applied only: as part of the usual arithmetic
                conversions, to certain argument expressions, to the operands of the unary +, -, and
                ~ operators, and to both operands of the shift operators, as specified by their
                respective subclauses.</d:para>
            </d:footnote> All other types are unchanged by the integer promotions.</d:para>
          <d:para>The integer promotions preserve value including sign. As discussed earlier,
            whether a “plain” char is treated as signed is implementation-defined.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> enumeration specifiers (Enumeration specifiers), structure and
            union specifiers (Structure and union specifiers).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Boolean Type</title>
          <d:para>When any scalar value is converted to <d:code>_Bool</d:code>, the result is 0 if
            the value compares equal to 0; otherwise, the result is 1.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Signed and Unsigned Integers</title>
          <d:para>When a value with integer type is converted to another integer type other than
              <d:code>_Bool</d:code>, if the value can be represented by the new type, it is
            unchanged.</d:para>
          <d:para>Otherwise, if the new type is unsigned, the value is converted by repeatedly
            adding or subtracting one more than the maximum value that can be represented in the new
            type until the value is in the range of the new type.<d:footnote>
              <d:para>The rules describe arithmetic on the mathematical value, not the value of a
                given type of expression.</d:para>
            </d:footnote></d:para>
          <d:para>Otherwise, the new type is signed and the value cannot be represented in it;
            either the result is implementation-defined or an implementation-defined signal is
            raised.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Real Floating and Integer</title>
          <d:para>When a finite value of real floating type is converted to an integer type other
            than <d:code>_Bool</d:code>, the fractional part is discarded (i.e., the value is
            truncated toward zero). If the value of the integral part cannot be represented by the
            integer type, the behavior is undefined.<d:footnote>
              <d:para>The remaindering operation performed when a value of integer type is converted
                to unsigned type need not be performed when a value of real floating type is
                converted to unsigned type. Thus, the range of portable real floating values is (-1,
                U <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">type </emphasis>_
                  <d:code>MAX+1</d:code> ).</d:para>
            </d:footnote></d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Real Floating Types</title>
          <d:para>When a <d:code>float</d:code> is promoted to <d:code>double</d:code> or
              <d:code>long double</d:code>, or a <d:code>double</d:code> is promoted to <d:code>long
              double</d:code>, its value is unchanged. When a <d:code>double</d:code> is demoted to
              <d:code>float</d:code>, a l<d:code>ong double</d:code> is demoted to
              <d:code>double</d:code> or <d:code>float</d:code>, or a value being represented in
            greater precision and range than required by its semantic type (see Usual Arithmetic
            Conversions) is explicitly converted to its semantic type, if the value being converted
            can be represented exactly in the new type, it is unchanged. If the value being
            converted is in the range of values that can be represented but cannot be represented
            exactly, the result is either the nearest higher or nearest lower representable value,
            chosen in an implementation-defined manner. If the value being converted is outside the
            range of values that can be represented, the behavior is undefined.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Complex Types</title>
          <d:para>When a value of complex type is converted to another complex type, both the real
            and imaginary parts follow the conversion rules for the corresponding real
            types.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Real and Complex</title>
          <d:para>When a value of real type is converted to a complex type, the real part of the
            complex result value is determined by the rules of conversion to the corresponding real
            type and the imaginary part of the complex result value is a positive zero or an
            unsigned zero. When a value of complex type is converted to a real type, the imaginary
            part of the complex value is discarded and the value of the real part is converted
            according to the conversion rules for the corresponding real type.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Usual Arithmetic Conversion</title>
          <d:para>Many operators that expect operands of arithmetic type cause conversions and yield
            result types in a similar way. The purpose is to determine a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">common real typ</emphasis>e for
            the operands and result. For the specified operands, each operand is converted, without
            change of type domain, to a type whose corresponding real type is the common real type.
            Unless explicitly stated otherwise, the common real type is also the corresponding real
            type of the result, whose type domain is the type domain of the operands if they are the
            same, and complex otherwise. This pattern is called the <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">usual arithmetic
              conversions</emphasis>:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">First, if the corresponding real type of
                either operand is long double, the other operand is converted, without change of
                type domain, to a type whose corresponding real type is <code>long
                double</code>.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Otherwise, if the corresponding real type
                of either operand is double, the other operand is converted, without change of type
                domain, to a type whose corresponding real type is <code>double</code>.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Otherwise, if the corresponding real type
                of either operand is float, the other operand is converted, without change of type
                domain, to a type whose corresponding real type is <code>float</code>.<footnote>
                  <para>For example, addition of a <code>double _Complex</code> and a
                      <code>float</code> entails just the conversion of the <code>float</code>
                    operand to <code>double</code> (and yields a <code>double _Complex</code>
                    result).</para>
                </footnote></para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Otherwise, the integer promotions are
                performed on both operands. Then the following rules are applied to the promoted
                operands:</para>
              <d:itemizedlist>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">If both operands have the same type,
                    then no further conversion is needed.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">Otherwise, if both operands have
                    signed integer types or both have unsigned integer types, the operand with the
                    type of lesser integer conversion rank is converted to the type of the operand
                    with greater rank.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">Otherwise, if the operand that has
                    unsigned integer type has rank greater or equal to the rank of the type of the
                    other operand, then the operand with signed integer type is converted to the
                    type of the operand with unsigned integer type.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">Otherwise, if the type of the operand
                    with signed integer type can represent all of the values of the type of the
                    operand with unsigned integer type, then the operand with unsigned integer type
                    is converted to the type of the operand with signed integer type.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">Otherwise, both operands are converted
                    to the unsigned integer type corresponding to the type of the operand with
                    signed integer type.</para>
                </d:listitem>
              </d:itemizedlist>
            </d:listitem>
          </d:itemizedlist>
          <d:para>The values of floating operands and of the results of floating expressions may be
            represented in greater precision and range than that required by the type; the types are
            not changed thereby.<d:footnote>
              <d:para>The cast and assignment operators are still required to perform their
                specified conversions as described in Real Floating and Integer and Real Floating
                Types.</d:para>
            </d:footnote></d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Other Operands</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Lvalues, Arrays and Function
            Designators</title>
          <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">lvalue</emphasis>
            is an expression with an object type or an incomplete type other than
              <d:code>void</d:code>;<d:footnote>
              <d:para>The name “lvalue” comes originally from the assignment expression <d:inlineequation>
                  <mml:math>
                    <mml:mrow>
                      <mml:mtext>E1 </mml:mtext>
                      <mml:mo>=</mml:mo>
                      <mml:mtext> E2</mml:mtext>
                    </mml:mrow>
                  </mml:math>
                </d:inlineequation>, in which the left operand <d:inlineequation>
                  <mml:math>
                    <mml:mtext>E1</mml:mtext>
                  </mml:math>
                </d:inlineequation> is required to be a (modifiable) lvalue. It is perhaps better
                considered as representing an object “locator value”. What is sometimes called
                “rvalue” is in this International Standard described as the “value of an
                expression”.</d:para>
            </d:footnote> if an lvalue does not designate an object when it is evaluated, the
            behavior is undefined. When an object is said to have a particular type, the type is
            specified by the lvalue used to designate the object. A <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">modifiable lvalue</emphasis> is an
            lvalue that does not have array type, does not have an incomplete type, does not have a
            const-qualified type, and if it is a structure or union, does not have any member
            (including, recursively, any member or element of all contained aggregates or unions)
            with a const-qualified type.</d:para>
          <d:para>Except when it is the operand of the <d:code>sizeof</d:code> operator, the unary
            &amp; operator, the ++ operator, the – operator, or the left operand of the . operator
            or an assignment operator, an lvalue that does not have array type is converted to the
            value stored in the designated object (and is no longer an lvalue). If the lvalue has
            qualified type, the value has the unqualified version of the type of the lvalue;
            otherwise, the value has the type of the lvalue. If the lvalue has an incomplete type
            and does not have array type, the behavior is undefined.</d:para>
          <d:para>Except when it is the operand of the <d:code>sizeof</d:code> operator or the unary
            &amp; operator, or is a string literal used to initialize an array, an expression that
            has type “array of type” is converted to an expression with type “pointer to type” that
            points to the initial element of the array object and is not an lvalue. If the array
            object has register storage class, the behavior is undefined.</d:para>
          <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">function
              designator</emphasis> is an expression that has function type. Except when it is the
            operand of the <d:code>sizeof</d:code> operator<d:footnote>
              <d:para>Because this conversion does not occur, the operand of the sizeof operator
                remains a function designator and violates the constraint in 4.5.3.4.</d:para>
            </d:footnote> or the unary &amp; operator, a function designator with type “function
            returning type” is converted to an expression that has type “pointer to function
            returning type”.</d:para>
          <d:para>For example, consider following:</d:para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  printf("Hello\n");
}

int main()
{
  f();
  (*f)();
  (&amp;f)();
  (**f)();
  (***f)();

  return 0;
}</d:programlisting>
          <d:para>and the output is:</d:para>
          <d:screen>Hello
Hello
Hello
Hello
Hello</d:screen>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> address and indirection operators (Address and indirection
            operators), assignment operators (Assignment operators), common definitions
              <d:code>&lt;stddef.h></d:code> (Common definitions <d:code>&lt;stddef.h></d:code>),
            initialization (Initialization), postfix increment and decrement operators (Postfix
            increment and decrement operators), prefix increment and decrement operators (Prefix
            increment and decrement operators), the sizeof operator (The sizeof operator), structure
            and union members (Structure and union members).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">void</title>
          <d:para>The (nonexistent) value of a <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">void expression</emphasis> (an expression that has type void) shall not
            be used in any way, and implicit or explicit conversions (except to
              <d:code>void</d:code>) shall not be applied to such an expression. If an expression of
            any other type is evaluated as a void expression, its value or designator is discarded.
            (A void expression is evaluated for its side effects.)</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Pointers</title>
          <d:para>A pointer to void may be converted to or from a pointer to any incomplete or
            object type. A pointer to any incomplete or object type may be converted to a pointer to
              <d:code>void</d:code> and back again; the result shall compare equal to the original
            pointer.</d:para>
          <d:para>For any qualifier q, a pointer to a non-q-qualified type may be converted to a
            pointer to the q-qualified version of the type; the values stored in the original and
            converted pointers shall compare equal.</d:para>
          <d:para>An integer constant expression with the value 0, or such an expression cast to
            type <d:code>void *</d:code>, is called a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">null pointer constant</emphasis>.<d:footnote>
              <d:para>The macro <d:code>NULL</d:code> is defined in <d:code>&lt;stddef.h></d:code>
                (and other headers) as a null pointer constant; see 7.17.</d:para>
            </d:footnote> If a null pointer constant is converted to a pointer type, the resulting
            pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any
            object or function.</d:para>
          <d:para>Conversion of a null pointer to another pointer type yields a null pointer of that
            type. Any two null pointers shall compare equal.</d:para>
          <d:para>An integer may be converted to any pointer type. Except as previously specified,
            the result is implementation-defined, might not be correctly aligned, might not point to
            an entity of the referenced type, and might be a trap representation.<d:footnote>
              <d:para>The mapping functions for converting a pointer to an integer or an integer to
                a pointer are intended to be consistent with the addressing structure of the
                execution environment.</d:para>
            </d:footnote></d:para>
          <d:para>Any pointer type may be converted to an integer type. Except as previously
            specified, the result is implementation-defined. If the result cannot be represented in
            the integer type, the behavior is undefined. The result need not be in the range of
            values of any integer type.</d:para>
          <d:para>A pointer to an object or incomplete type may be converted to a pointer to a
            different object or incomplete type. If the resulting pointer is not correctly aligned<d:footnote>
              <d:para>In general, the concept “correctly aligned” is transitive: if a pointer to
                type A is correctly aligned for a pointer to type B, which in turn is correctly
                aligned for a pointer to type C, then a pointer to type A is correctly aligned for a
                pointer to type C.</d:para>
            </d:footnote> for the pointed-to type, the behavior is undefined. Otherwise, when
            converted back again, the result shall compare equal to the original pointer. When a
            pointer to an object is converted to a pointer to a character type, the result points to
            the lowest addressed byte of the object. Successive increments of the result, up to the
            size of the object, yield pointers to the remaining bytes of the object.</d:para>
          <d:para>A pointer to a function of one type may be converted to a pointer to a function of
            another type and back again; the result shall compare equal to the original pointer. If
            a converted pointer is used to call a function whose type is not compatible with the
            pointed-to type, the behavior is undefined.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> cast operators (Cast operators), equality operators (Equality
            operators), integer types capable of holding object pointers (Integer types capable of
            holding object pointers), simple assignment (Simple assignment).</d:para>
        </d:sect3>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Lexical Elements</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Constraint</emphasis></d:para>
      <d:para>Each preprocessing token that is converted to a token shall have the lexical form of a
        keyword, an identifier, a constant, a string literal, or a punctuator.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">token</emphasis> is
        the minimal lexical element of the language in translation phases 7 and 8. The categories of
        tokens are: keywords, identifiers, constants, string literals, and punctuators. A
        preprocessing token is the minimal lexical element of the language in translation phases 3
        through 6. The categories of preprocessing tokens are: header names, identifiers,
        preprocessing numbers, character constants, string literals, punctuators, and single
        non-white-space characters that do not lexically match the other preprocessing token categories.<d:footnote>
          <d:para>An additional category, placemarkers, is used internally in translation phase 4
            (see The ## Operator); it cannot occur in source files.</d:para>
        </d:footnote> If a ‘ or a ” character matches the last category, the behavior is undefined.
        Preprocessing tokens can be separated by white space; this consists of comments (described
        later), or white-space characters (space, horizontal tab, new-line, vertical tab, and
        form-feed), or both. As described in Preprocessing Directives, in certain circumstances
        during translation phase 4, white space (or the absence thereof) serves as more than
        preprocessing token separation. White space may appear within a preprocessing token only as
        part of a header name or between the quotation characters in a character constant or string
        literal.</d:para>
      <d:para>If the input stream has been parsed into preprocessing tokens up to a given character,
        the next preprocessing token is the longest sequence of characters that could constitute a
        preprocessing token. There is one exception to this rule: a header name preprocessing token
        is only recognized within a <d:code>#include</d:code> preprocessing directive, and within
        such a directive, a sequence of characters that could be either a header name or a string
        literal is recognized as the former.</d:para>
      <d:para>EXAMPLE 1 The program fragment <d:code>1Ex</d:code> is parsed as a preprocessing
        number token (one that is not a valid floating or integer constant token), even though a
        parse as the pair of preprocessing tokens 1 and <d:code>Ex</d:code> might produce a valid
        expression (for example, if <d:code>Ex</d:code> were a macro defined as +1). Similarly, the
        program fragment <d:code>1E1</d:code> is parsed as a preprocessing number (one that is a
        valid floating constant token), whether or not <d:code>E</d:code> is a macro name.</d:para>
      <d:para>EXAMPLE 2 The program fragment <d:code>x+++++y</d:code> is parsed as <d:code>x ++ ++ +
          y</d:code>, which violates a constraint on increment operators, even though the parse
          <d:code>x ++ + ++ y</d:code> might yield a correct expression.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> character constants (Character constants), comments (Comments),
        expressions (Expressions), floating constants (Floating Constants), header names (Header
        names), macro replacement (Macro Replacement), postfix increment and decrement operators
        (Postfix increment and decrement operators), prefix increment and decrement operators
        (Prefix increment and decrement operators), preprocessing directives (Preprocessing
        Directives), preprocessing numbers (Preprocessing numbers), string literals (String
        literals).</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Keywords</title>
        <d:para>List of keywords are given in Environmental considerations</d:para>
        <d:para>The keywords token (case sensitive) are reserved (in translation phases 7 and 8) for
          use as keywords, and shall not be used otherwise. The keyword <d:code>_Imaginary</d:code>
          is reserved for specifying imaginary types.<d:footnote>
            <d:para>One possible specification for imaginary types appears in annex G.</d:para>
          </d:footnote></d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Identifiers</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">General</title>
          <d:para>The characterset for ideantifiers is given in The C Character Set.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>An identifier is a sequence of nondigit characters (including the underscore _,
            the lowercase and uppercase Latin letters, and other characters) and digits, which
            designates one or more entities as described in Scope of Identifiers. Lowercase and
            uppercase letters are distinct. There is no specific limit on the maximum length of an
            identifier.</d:para>
          <d:para>Each universal character name in an identifier shall designate a character whose
            encoding in ISO/IEC 10646 falls into one of the ranges specified in annex D.<d:footnote>
              <d:para>On systems in which linkers cannot accept extended characters, an encoding of
                the universal character name may be used in forming valid external identifiers. For
                example, some otherwise unused character or sequence of characters may be used to
                encode the \u in a universal character name. Extended characters may produce a long
                external identifier.</d:para>
            </d:footnote> The initial character shall not be a universal character name designating
            a digit. An implementation may allow multibyte characters that are not part of the basic
            source character set to appear in identifiers; which characters and their correspondence
            to universal character names is implementation-defined.</d:para>
          <d:para>When preprocessing tokens are converted to tokens during translation phase 7, if a
            preprocessing token could be converted to either a keyword or an identifier, it is
            converted to a keyword.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Implementation
              Limits</emphasis></d:para>
          <d:para>As discussed in Translation limits, an implementation may limit the number of
            significant initial characters in an identifier; the limit for an <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">external name</emphasis> (an
            identifier that has external linkage) may be more restrictive than that for an <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">internal name</emphasis> (a macro
            name or an identifier that does not have external linkage). The number of significant
            characters in an identifier is implementation-defined.</d:para>
          <d:para>Any identifiers that differ in a significant character are different identifiers.
            If two identifiers differ only in nonsignificant characters, the behavior is
            undefined.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> universal character names (Universal character names), macro
            replacement (Macro Replacement).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Predefined Identifiers</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The identifier “__func__” shall be implicitly declared by the translator as if,
            immediately following the opening brace of each function definition, the
            declaration</d:para>
          <d:programlisting role="CLexer">static const char __func__[] = "function-name";</d:programlisting>
          <d:para>appeared, where <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >function-name</emphasis> is the name of the lexically-enclosing function.<d:footnote>
              <d:para>Since the name <d:code>__func__</d:code> is reserved for any use by the
                implementation (Macro Replacement), if any other identifier is explicitly declared
                using the name <d:code>__func__</d:code>, the behavior is undefined.</d:para>
            </d:footnote> This name is encoded as if the implicit declaration had been written in
            the source character set and then translated into the execution character set as
            indicated in translation phase 5.</d:para>
          <d:para>EXAMPLE Consider the code fragment:</d:para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>
void myfunc(void)
{
  printf("%s\n", __func__);
  /* ... */
}</d:programlisting>
          <d:para>Each time the function is called, it will print to the standard output
            stream:</d:para>
          <d:screen>myfunc</d:screen>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> function definitions (Function definitions).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Universal Character Names</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>A universal character name shall not specify a character whose short identifier is
          less than 00A0 other than 0024 ($), 0040 (@), or 0060 (‘), nor one in the range D800
          through DFFF inclusive.<d:footnote>
            <d:para>The disallowed characters are the characters in the basic character set and the
              code positions reserved by ISO/IEC 10646 for control characters, the character DELETE,
              and the S-zone (reserved for use by UTF-16).</d:para>
          </d:footnote></d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Description</emphasis></d:para>
        <d:para>Universal character names may be used in identifiers, character constants, and
          string literals to designate characters that are not in the basic character set.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The universal character name \Unnnnnnnn designates the character whose eight-digit
          short identifier (as specified by ISO/IEC 10646) is nnnnnnnn.<d:footnote>
            <d:para>Short identifiers for characters were first specified in ISO/IEC
              10646-1/AMD9:1997.</d:para>
          </d:footnote> Similarly, the universal character name \unnnn designates the character
          whose four-digit short identifier is nnnn (and whose eight-digit short identifier is
          0000nnnn).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Constants</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The value of a constant shall be in the range of representable values for its
          type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>Each constant has a type, determined by its form and value, as detailed
          later.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Integer Constants</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Description</emphasis></d:para>
          <d:para>An integer constant begins with a digit, but has no period or exponent part. It
            may have a prefix that specifies its base and a suffix that specifies its type.</d:para>
          <d:para>A decimal constant begins with a nonzero digit and consists of a sequence of
            decimal digits. An octal constant consists of the prefix 0 optionally followed by a
            sequence of the digits 0 through 7 only. A hexadecimal constant consists of the prefix
            0x or 0X followed by a sequence of the decimal digits and the letters a (or A) through f
            (or F) with values 10 through 15 respectively.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The value of a decimal constant is computed base 10; that of an octal constant,
            base 8; that of a hexadecimal constant, base 16. The lexically first digit is the most
            significant.</d:para>
          <d:para>The type of an integer constant is the first of the corresponding list in which
            its value can be represented.<table xmlns="http://docbook.org/ns/docbook"
              frame="void" class="dynamic" border="1">
	    <colgroup width="100px" />
	    <colgroup width="200px" />
	    <colgroup width="200px" />
              <thead>
                <tr bgcolor="#aaa">
                  <th>Suffix</th>
                  <th>Decimal Constant</th>
                  <th>Octal or Hexadecimal Constant</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>none</td>
                  <td>
                    <para><code>int</code></para>
                    <para><code>long int</code></para>
                    <para><code>long long int</code></para>
                  </td>
                  <td>
                    <para><code>int</code></para>
                    <para><code>unsigned int</code></para>
                    <para><code>long int</code></para>
                    <para><code>unsigned long int</code></para>
                    <para><code>long long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td><code>u</code> or <code>U</code></td>
                  <td>
                    <para><code>unsigned int</code></para>
                    <para><code>unsigned long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                  <td>
                    <para><code>unsigned int</code></para>
                    <para><code>unsigned long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td><code>l</code> or <code>L</code></td>
                  <td>
                    <para><code>long int</code></para>
                    <para><code>long long int</code></para>
                  </td>
                  <td>
                    <para><code>long int</code></para>
                    <para><code>unsigned long int</code></para>
                    <para><code>long long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td>
                    <para>Both <code>u</code> or <code>U</code></para>
                    <para>and <code>l</code> or <code>L</code></para>
                  </td>
                  <td>
                    <para><code>unsigned long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                  <td>
                    <para><code>unsigned long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td><code>ll</code> or <code>LL</code></td>
                  <td><code>long long int</code></td>
                  <td>
                    <para><code>long long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td>
                    <para>Both <code>u</code> or <code>U</code></para>
                    <para>and <code>ll</code> or <code>L</code>
                    </para>
                  </td>
                  <td><code>unsigned long long int</code></td>
                  <td><code>unsigned long long int</code></td>
                </tr>
              </tbody>
            </table></d:para>
          <d:para>If an integer constant cannot be represented by any type in its list, it may have
            an extended integer type, if the extended integer type can represent its value. If all
            of the types in the list for the constant are signed, the extended integer type shall be
            signed. If all of the types in the list for the constant are unsigned, the extended
            integer type shall be unsigned. If the list contains both signed and unsigned types, the
            extended integer type may be signed or unsigned.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Floating Constants</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Description</emphasis></d:para>
          <d:para>A floating constant has a <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">significand</emphasis> part that may be followed by an <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">exponent</emphasis> part and a
              <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">suffix</emphasis> that
            specifies its type. The components of the significand part may include a digit sequence
            representing the whole-number part, followed by a period (.), followed by a digit
            sequence representing the fraction part. The components of the exponent part are an
              <d:code>e, E, p</d:code> or <d:code>P</d:code> followed by an exponent consisting of
            an optionally signed digit sequence. Either the whole-number part or the fraction part
            has to be present; for decimal floating constants, either the period or the exponent
            part has to be present.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The significand part is interpreted as a (decimal or hexadecimal) rational number;
            the digit sequence in the exponent part is interpreted as a decimal integer. For decimal
            floating constants, the exponent indicates the power of 10 by which the significand part
            is to be scaled. For hexadecimal floating constants, the exponent indicates the power of
            2 by which the significand part is to be scaled. For decimal floating constants, and
            also for hexadecimal floating constants when <d:code>FLT_RADIX</d:code> is not a power
            of 2, the result is either the nearest representable value, or the larger or smaller
            representable value immediately adjacent to the nearest representable value, chosen in
            an implementation-defined manner. For hexadecimal floating constants when
              <d:code>FLT_RADIX</d:code> is a power of 2, the result is correctly rounded.</d:para>
          <d:para>An unsuffixed floating constant has type <d:code>double</d:code>. If suffixed by
            the letter <d:code>f</d:code> or <d:code>F</d:code>, it has type <d:code>float</d:code>.
            If suffixed by the letter <d:code>l</d:code> or <d:code>L</d:code>, it has type
              <d:code>long double</d:code>. </d:para>
          <d:para>Floating constants are converted to internal format as if at translation-time. The
            conversion of a floating constant shall not raise an exceptional condition or a
            floating- point exception at execution time.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Recommended
              Practice</emphasis></d:para>
          <d:para>The implementation should produce a diagnostic message if a hexadecimal constant
            cannot be represented exactly in its evaluation format; the implementation should then
            proceed with the translation of the program.</d:para>
          <d:para>The translation-time conversion of floating constants should match the
            execution-time conversion of character strings by library functions, such as strtod,
            given matching inputs suitable for both conversions, the same result format, and default
            execution-time rounding.<d:footnote>
              <d:para>The specification for the library functions recommends more accurate
                conversion than required for floating constants (see The strtod, strtof and strtold
                functions).</d:para>
            </d:footnote></d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Enumeration Constants</title>
          <d:para>An identifier declared as an enumeration constant has type
            <d:code>int</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> enumeration specifiers (Enumeration specifiers).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Character Constants</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Description</emphasis></d:para>
          <d:para>An integer character constant is a sequence of one or more multibyte characters
            enclosed in single-quotes, as in <d:code>'x'</d:code>. A wide character constant is the
            same, except prefixed by the letter <d:code>L</d:code>. With a few exceptions detailed
            later, the elements of the sequence are any members of the source character set; they
            are mapped in an implementation-defined manner to members of the execution character
            set.</d:para>
          <d:para>The single-quote ‘, the double-quote ”, the question-mark ?, the backslash \, and
            arbitrary integer values are representable according to the following table of escape
            sequences:</d:para>
          <d:literallayout>    single quote                     '       \\'
    double quote                    "      \\"
    question mark                  ?      \\?
    backslash                         \\      \\\\
    octal character                  \\o    octal digits
    hexadecimal character       \\x    hexadecimal digits</d:literallayout>
          <d:para>The double-quote ” and question-mark ? are representable either by themselves or
            by the escape sequences \” and \?, respectively, but the single-quote ‘ and the
            backslash \ shall be represented, respectively, by the escape sequences \’ and
            \\.</d:para>
          <d:para>The octal digits that follow the backslash in an octal escape sequence are taken
            to be part of the construction of a single character for an integer character constant
            or of a single wide character for a wide character constant. The numerical value of the
            octal integer so formed specifies the value of the desired character or wide
            character.</d:para>
          <d:para>The hexadecimal digits that follow the backslash and the letter x in a hexadecimal
            escape sequence are taken to be part of the construction of a single character for an
            integer character constant or of a single wide character for a wide character constant.
            The numerical value of the hexadecimal integer so formed specifies the value of the
            desired character or wide character.</d:para>
          <d:para>Each octal or hexadecimal escape sequence is the longest sequence of characters
            that can constitute the escape sequence.</d:para>
          <d:para>In addition, characters not in the basic character set are representable by
            universal character names and certain nongraphic characters are representable by escape
            sequences consisting of the backslash \ followed by a lowercase letter: <d:code>\a, \b,
              \f, \n, \r, \t,</d:code> and <d:code>\v</d:code>.<d:footnote>
              <d:para>The semantics of these characters were discussed in Character display
                semantics. If any other character follows a backslash, the result is not a token and
                a diagnostic is required. See “future language directions” (Character escape
                sequences).</d:para>
            </d:footnote></d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The value of an octal or hexadecimal escape sequence shall be in the range of
            representable values for the type <d:code>unsigned char</d:code> for an integer
            character constant, or the unsigned type corresponding to <d:code>wchar_t</d:code> for a
            wide character constant.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>An integer character constant has type <d:code>int</d:code>. The value of an
            integer character constant containing a single character that maps to a single-byte
            execution character is the numerical value of the representation of the mapped character
            interpreted as an integer. The value of an integer character constant containing more
            than one character (e.g., '<d:code>ab</d:code>'), or containing a character or escape
            sequence that does not map to a single-byte execution character, is
            implementation-defined. If an integer character constant contains a single character or
            escape sequence, its value is the one that results when an object with type
              <d:code>char</d:code> whose value is that of the single character or escape sequence
            is converted to type <d:code>int</d:code>.</d:para>
          <d:para>A wide character constant has type <d:code>wchar_t</d:code>, an integer type
            defined in the <d:code>&lt;stddef.h></d:code> header. The value of a wide character
            constant containing a single multibyte character that maps to a member of the extended
            execution character set is the wide character corresponding to that multibyte character,
            as defined by the <d:code>mbtowc</d:code> function, with an implementation-defined
            current locale. The value of a wide character constant containing more than one
            multibyte character, or containing a multibyte character or escape sequence not
            represented in the extended execution character set, is implementation-defined.</d:para>
          <d:para>EXAMPLE 1 The construction '<d:code>\0</d:code>' is commonly used to represent the
            null character.</d:para>
          <d:para>EXAMPLE 2 Consider implementations that use two’s-complement representation for
            integers and eight bits for objects that have type <d:code>char</d:code>. In an
            implementation in which type <d:code>char</d:code> has the same range of values as
              <d:code>signed char</d:code>, the integer character constant '<d:code>\xFF</d:code>'
            has the value <d:code>-1</d:code>; if type <d:code>char</d:code> has the same range of
            values as <d:code>unsigned char</d:code>, the character constant '<d:code>\xFF</d:code>'
            has the value <d:code>+255</d:code>.</d:para>
          <d:para>EXAMPLE 3 Even if eight bits are used for objects that have type char, the
            construction '<d:code>\x123</d:code>' specifies an integer character constant containing
            only one character, since a hexadecimal escape sequence is terminated only by a
            non-hexadecimal character. To specify an integer character constant containing the two
            characters whose values are '<d:code>\x12</d:code>' and '<d:code>3</d:code>', the
            construction '<d:code>\0223</d:code>' may be used, since an octal escape sequence is
            terminated after three octal digits. (The value of this two-character integer character
            constant is implementation-defined.)</d:para>
          <d:para>EXAMPLE 4 Even if <d:code>12</d:code> or more bits are used for objects that have
            type <d:code>wchar_t</d:code>, the construction <d:code>L'\1234'</d:code> specifies the
            implementation-defined value that results from the combination of the values
              <d:code>0123</d:code> and '<d:code>4</d:code>'.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> common definitions <d:code>&lt;stddef.h></d:code> (Common
            definitions <d:code>&lt;stddef.h></d:code>), the <d:code>mbtowc</d:code> function (The
              <d:code>mbtowc</d:code> function).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">String Literals</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Description</emphasis></d:para>
        <d:para>A character <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">string
            literal</emphasis> is a sequence of zero or more multibyte characters enclosed in
          double-quotes, as in “<d:code>xyz</d:code>”. A <d:code>wide string literal</d:code> is the
          same, except prefixed by the letter <d:code>L</d:code>. The same considerations apply to
          each element of the sequence in a character string literal or a wide string literal as if
          it were in an integer character constant or a wide character constant, except that the
          single-quote ' is representable either by itself or by the escape sequence
            <d:code>\'</d:code>, but the double-quote <d:code>"</d:code> shall be represented by the
          escape sequence <d:code>\"</d:code>.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>In translation phase 6, the multibyte character sequences specified by any sequence
          of adjacent character and wide string literal tokens are concatenated into a single
          multibyte character sequence. If any of the tokens are wide string literal tokens, the
          resulting multibyte character sequence is treated as a wide string literal; otherwise, it
          is treated as a character string literal.</d:para>
        <d:para>In translation phase 7, a byte or code of value zero is appended to each multibyte
          character sequence that results from a string literal or literals.66) The multibyte
          character sequence is then used to initialize an array of static storage duration and
          length just sufficient to contain the sequence. For character string literals, the array
          elements have type <d:code>char</d:code>, and are initialized with the individual bytes of
          the multibyte character sequence; for wide string literals, the array elements have type
            <d:code>wchar_t</d:code>, and are initialized with the sequence of wide characters
          corresponding to the multibyte character sequence, as defined by the
            <d:code>mbstowcs</d:code> function with an implementation-defined current locale. The
          value of a string literal containing a multibyte character or escape sequence not
          represented in the execution character set is implementation-defined.</d:para>
        <d:para>It is unspecified whether these arrays are distinct provided their elements have the
          appropriate values. If the program attempts to modify such an array, the behavior is
          undefined.</d:para>
        <d:para>EXAMPLE This pair of adjacent character string literals:</d:para>
        <d:screen>"\x12" "3"</d:screen>
        <d:para>produces a single character string literal containing the two characters whose
          values are '<d:code>\x12</d:code>' and '<d:code>3</d:code>', because escape sequences are
          converted into single members of the execution character set just prior to adjacent string
          literal concatenation.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> common definitions <d:code>&lt;stddef.h></d:code> (Common
          definitions <d:code>&lt;stddef.h></d:code>), the <d:code>mbstowcs</d:code> function (The
            <d:code>mbstowcs</d:code> function).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Punctuators</title>
        <d:para>These are one of:</d:para>
        <d:screen>[ ] ( ) { } . -> ++ -- &amp; * + - ~ ! / % &lt;&lt; >> &lt; > &lt;= > ? : ; ... = *= /=
%= += -= &lt;&lt;= , # ## &lt;: :> &lt;% %> %: %:%: == >>= != &amp;= ^ | ^= &amp;&amp;  || |=</d:screen>
        <d:para>A punctuator is a symbol that has independent syntactic and semantic significance.
          Depending on context, it may specify an operation to be performed (which in turn may yield
          a value or a function designator, produce a side effect, or some combination thereof) in
          which case it is known as an <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >operator</emphasis> (other forms of operator also exist in some contexts). An operand
          is an entity on which an operator acts.</d:para>
        <d:para>In all aspects of the language, the six tokens<d:footnote>
            <d:para>These tokens are sometimes called “digraphs”.</d:para>
          </d:footnote></d:para>
        <d:screen>&lt;: :> &lt;% %> %: %:%:</d:screen>
        <d:para>behave, respectively, the same as the six tokens:</d:para>
        <d:screen>[ ] { } # ##</d:screen>
        <d:para>except for their spelling.<d:footnote>
            <d:para>Thus [ and &lt;: behave differently when “stringized (see The # Operator), but
              can otherwise be freely interchanged.</d:para>
          </d:footnote></d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> expressions (Expressions), declarations (Declarations),
          preprocessing directives (Preprocessing Directives), statements (Statements and
          blocks).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Header Names</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The sequences in both forms of header names are mapped in an implementation-defined
          manner to headers or external source file names as specified in Source File
          Inclusion.</d:para>
        <d:para>If the characters ', \, ", // or /* occur in the sequence between the &lt; and >
          delimiters, the behavior is undefined. Similarly, if the characters ', \, // or /* occur
          in the sequence between the " delimiters, the behavior is undefined.<d:footnote>
            <d:para>Thus, sequences of characters that resemble escape sequences cause undefined
              behavior.</d:para>
          </d:footnote> A header name preprocessing token is recognized only within a
            <d:code>#include</d:code> preprocessing directive.</d:para>
        <d:para>EXAMPLE The following sequence of characters:</d:para>
        <d:programlisting role="CLexer">0x3&lt;1/a.h>1e2
#include &lt;1/a.h>
#define const.member@$</d:programlisting>
        <d:para>forms the following sequence of preprocessing tokens (with each individual
          preprocessing token delimited by a { on the left and a } on the right).</d:para>
        <d:programlisting role="CLexer">{0x3}{&lt;}{1}{/}{a}{.}{h}{>}{1e2}
{#}{include} {&lt;1/a.h>}
{#}{define} {const}{.}{member}{@}{$}</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> source file inclusion (Source File Inclusion).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Preprocessing Numbers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A preprocessing number begins with a digit optionally preceded by a period (.) and
          may be followed by valid identifier characters and the character sequences <d:code>e+, e-,
            E+, E-, p+, p-, P</d:code>+ or <d:code>P-</d:code>.</d:para>
        <d:para>Preprocessing number tokens lexically include all floating and integer constant
          tokens.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A preprocessing number does not have type or a value; it acquires both after a
          successful conversion (as part of translation phase 7) to a floating constant token or an
          integer constant token.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Comments</title>
        <d:para>Except within a character constant, a string literal, or a comment, the characters
            <d:code>/*</d:code> introduce a comment. The contents of such a comment are examined
          only to identify multibyte characters and to find the characters <d:code>*/</d:code> that
          terminate it.<d:footnote>
            <d:para>Thus, /* ... */ comments do not nest.</d:para>
          </d:footnote></d:para>
        <d:para>Except within a character constant, a string literal, or a comment, the characters
            <d:code>//</d:code> ntroduce a comment that includes all multibyte characters up to, but
          not including, the next new-line character. The contents of such a comment are examined
          only to identify multibyte characters and to find the terminating new-line
          character.</d:para>
        <d:para>EXAMPLE</d:para>
        <d:programlisting role="CLexer">"a//b"                      // four-character string literal
#include "//e"              // undefined behavior
// */                       // comment, not syntax error
f = g/**//h;                // equivalent to f = g / h;
//\
i();                        // part of a two-line comment
/\
/ j();                      // part of a two-line comment
#define glue(x,y) x##y
glue(/,/) k();              // syntax error, not comment
/*//*/ l();                 // equivalent to l();
m = n//**/o
+ p;                        // equivalent to m = n + p;</d:programlisting>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Expressions</title>
      <d:para>An expression is a sequence of operators and operands that specifies computation of a
        value, or that designates an object or a function, or that generates side effects, or that
        performs a combination thereof.</d:para>
      <d:para>Between the previous and next sequence point an object shall have its stored value
        modified at most once by the evaluation of an expression. Furthermore, the prior value shall
        be read only to determine the value to be stored.<d:footnote>
          <d:para>This paragraph renders undefined statement expressions such as <d:code>i = ++i +
              1;</d:code></d:para>
          <d:para><d:code>a[i++] = i;</d:code></d:para>
          <d:para>while allowing</d:para>
          <d:para><d:code>i = i + 1; a[i] = i;</d:code></d:para>
        </d:footnote></d:para>
      <d:para>The grouping of operators and operands is indicated by the syntax.<d:footnote>
          <d:para>The syntax specifies the precedence of operators in the evaluation of an
            expression, which is the same as the order of the major subclauses of this subclause,
            highest precedence first. Thus, for example, the expressions allowed as the operands of
            the binary + operator (Additive operators) are those expressions defined in Primary
            expressions through Additive operators. The exceptions are cast expressions (Cast
            operators) as operands of unary operators (Unary operators), and an operand contained
            between any of the following pairs of operators: grouping parentheses () (Primary
            expressions), subscripting brackets [] (:ref:`4.5.2.1`), function-call parentheses ``()
            (Function calls), and the conditional operator ?: (Conditional operator).</d:para>
          <d:para>Within each major subclause, the operators have the same precedence. Left- or
            right-associativity is indicated in each subclause by the syntax for the expressions
            discussed therein.</d:para>
        </d:footnote> Except as specified later (for the function-call <d:code>(), &amp;&amp;, ||,
          ?:</d:code> and comma operators), the order of evaluation of subexpressions and the order
        in which side effects take place are both unspecified.</d:para>
      <d:para>Some operators (the unary operator <d:code>~</d:code>, and the binary operators
          <d:code>&lt;&lt;, >>, &amp;, ^</d:code> and <d:code>|</d:code>, collectively described as
        bitwise operators) are required to have operands that have integer type. These operators
        yield values that depend on the internal representations of integers, and have
        implementation-defined and undefined aspects for signed types. If an exceptional condition
        occurs during the evaluation of an expression (that is, if the result is not mathematically
        defined or not in the range of representable values for its type), the behavior is
        undefined.</d:para>
      <d:para>The effective type of an object for an access to its stored value is the declared type
        of the object, if any.<d:footnote>
          <d:para>Allocated objects have no declared type.</d:para>
        </d:footnote> If a value is stored into an object having no declared type through an lvalue
        having a type that is not a character type, then the type of the lvalue becomes the
        effective type of the object for that access and for subsequent accesses that do not modify
        the stored value. If a value is copied into an object having no declared type using memcpy
        or memmove or is copied as an array of character type, then the effective type of the
        modified object for that access and for subsequent accesses that do not modify the value is
        the effective type of the object from which the value is copied, if it has one. For all
        other accesses to an object having no declared type, the effective type of the object is
        simply the type of the lvalue used for the access.</d:para>
      <d:para>An object shall have its stored value accessed only by an lvalue expression that has
        one of the following types:<d:footnote>
          <d:para>The intent of this list is to specify those circumstances in which an object may
            or may not be aliased.</d:para>
        </d:footnote><d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a type compatible with the effective type of
              the object,</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a qualified version of a type compatible
              with the effective type of the object,</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a type that is the signed or unsigned type
              corresponding to the effective type of the object,</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a type that is the signed or unsigned type
              corresponding to a qualified version of the effective type of the object,</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">an aggregate or union type that includes one
              of the aforementioned types among its members (including, recursively, a member of a
              subaggregate or contained union), or</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a character type.</para>
          </d:listitem>
        </d:itemizedlist></d:para>
      <d:para>A floating expression may be <d:code>contracted</d:code>, that is, evaluated as though
        it were an atomic operation, thereby omitting rounding errors implied by the source code and
        the expression evaluation method.<d:footnote>
          <d:para>A contracted expression might also omit the raising of floating-point
            exceptions.</d:para>
        </d:footnote> The <d:code>FP_CONTRACT</d:code> pragma in <d:code>&lt;math.h></d:code>
        provides a way to disallow contracted expressions. Otherwise, whether and how expressions
        are contracted is implementation-defined.<d:footnote>
          <d:para>This license is specifically intended to allow implementations to exploit fast
            machine instructions that combine multiple C operators. As contractions potentially
            undermine predictability, and can even decrease accuracy for containing expressions,
            their use needs to be well-defined and clearly documented.</d:para>
        </d:footnote></d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> the <d:code>FP_CONTRACT</d:code> pragma (The FP_CONTRACT pragma),
        copying functions (Copying functions).</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Primary Expressions</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>An identifier is a primary expression, provided it has been declared as designating
          an object (in which case it is an lvalue) or a function (in which case it is a function designator).<d:footnote>
            <d:para>Thus, an undeclared identifier is a violation of the syntax.</d:para>
          </d:footnote></d:para>
        <d:para>A constant is a primary expression. Its type depends on its form and value, as
          detailed in Constants.</d:para>
        <d:para>A string literal is a primary expression. It is an lvalue with type as detailed in
          String literals.</d:para>
        <d:para>A parenthesized expression is a primary expression. Its type and value are identical
          to those of the unparenthesized expression. It is an lvalue, a function designator, or a
          void expression if the unparenthesized expression is, respectively, an lvalue, a function
          designator, or a void expression.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> declarations (Declarations).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Postfix Operators</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Array Subscripting</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>One of the expressions shall have type “pointer to object type”, the other
            expression shall have integer type, and the result has type “type”.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A postfix expression followed by an expression in square brackets
              <d:code>[]</d:code> is a subscripted designation of an element of an array object. The
            definition of the subscript operator <d:code>[]</d:code> is that <d:code>E1[E2]</d:code>
            is identical to <d:code>(*((E1)+(E2)))</d:code>. Because of the conversion rules that
            apply to the binary + operator, if <d:code>E1</d:code> is an array object (equivalently,
            a pointer to the initial element of an array object) and <d:code>E2</d:code> is an
            integer, <d:code>E1[E2]</d:code> designates the <d:code>E2</d:code>-th element of
              <d:code>E1</d:code> (counting from zero).</d:para>
          <d:para>Successive subscript operators designate an element of a multidimensional array
            object. If E is an <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >n</emphasis>-dimensional array <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:mi>(n</mml:mi>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2265;<!-- ≥ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mn>2)</mml:mn>
              </mml:math>
            </d:inlineequation> with dimensions <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:mi>i</mml:mi>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mi>j</mml:mi>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mi>k</mml:mi>
              </mml:math>
            </d:inlineequation>, then <d:code>E</d:code> (used as other than an lvalue) is converted
            to a pointer to an <d:code>(n - 1)</d:code>-dimensional array with dimensions <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:mi>j</mml:mi>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mi>k</mml:mi>
              </mml:math>
            </d:inlineequation>. If the unary <d:code>*</d:code> operator is applied to this pointer
            explicitly, or implicitly as a result of subscripting, the result is the pointed-to
              <d:code>(n - 1)</d:code>-dimensional array, which itself is converted into a pointer
            if used as other than an lvalue. It follows from this that arrays are stored in
            row-major order (last subscript varies fastest).</d:para>
          <d:para>EXAMPLE Consider the array object defined by the declaration</d:para>
          <d:programlisting role="CLexer">int x[3][5];</d:programlisting>
          <d:para>Here <d:code>x</d:code> is a <d:code>3 ∗ 5</d:code> array of ints; more precisely,
              <d:code>x</d:code> is an array of three element objects, each of which is an array of
            five ints. In the expression <d:code>x[i]</d:code> which is equivalent to
              <d:code>(*((x)+(i))), x</d:code> is first converted to a pointer to the initial array
            of five ints. Then i is adjusted according to the type of <d:code>x</d:code>, which
            conceptually entails multiplying <d:code>i</d:code> by the size of the object to which
            the pointer points, namely an array of five int objects. The results are added and
            indirection is applied to yield an array of five ints. When used in the expression
              <d:code>x[i][j]</d:code> that array is in turn converted to a pointer to the first of
            the ints, so <d:code>x[i][j]</d:code> yields an <d:code>int</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> additive operators (Additive operators), address and
            indirection operators (Address and indirection operators), array declarators (Array
            declarators).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Function Calls</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The expression that denotes the called function<d:footnote>
              <d:para>Most often, this is the result of converting an identifier that is a function
                designator.</d:para>
            </d:footnote> shall have type pointer to function returning void or returning an object
            type other than an array type.</d:para>
          <d:para>If the expression that denotes the called function has a type that includes a
            prototype, the number of arguments shall agree with the number of parameters. Each
            argument shall have a type such that its value may be assigned to an object with the
            unqualified version of the type of its corresponding parameter.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A postfix expression followed by parentheses () containing a possibly empty,
            comma- separated list of expressions is a function call. The postfix expression denotes
            the called function. The list of expressions specifies the arguments to the
            function.</d:para>
          <d:para>An argument may be an expression of any object type. In preparing for the call to
            a function, the arguments are evaluated, and each parameter is assigned the value of the
            corresponding argument.<d:footnote>
              <d:para>A function may change the values of its parameters, but these changes cannot
                affect the values of the arguments. On the other hand, it is possible to pass a
                pointer to an object, and the function may change the value of the object pointed
                to. A parameter declared to have array or function type is adjusted to have a
                pointer type as described in Function definitions.</d:para>
            </d:footnote></d:para>
          <d:para>If the expression that denotes the called function has type pointer to function
            returning an object type, the function call expression has the same type as that object
            type, and has the value determined as specified in The return statement. Otherwise, the
            function call has type void. If an attempt is made to modify the result of a function
            call or to access it after the next sequence point, the behavior is undefined.</d:para>
          <d:para>If the expression that denotes the called function has a type that does not
            include a prototype, the integer promotions are performed on each argument, and
            arguments that have type float are promoted to double. These are called the default
              <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">argument
              promotions</emphasis>. If the number of arguments does not equal the number of
            parameters, the behavior is undefined. If the function is defined with a type that
            includes a prototype, and either the prototype ends with an ellipsis (, ...) or the
            types of the arguments after promotion are not compatible with the types of the
            parameters, the behavior is undefined. If the function is defined with a type that does
            not include a prototype, and the types of the arguments after promotion are not
            compatible with those of the parameters after promotion, the behavior is undefined,
            except for the following cases:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">one promoted type is a signed integer
                type, the other promoted type is the corresponding unsigned integer type, and the
                value is representable in both types;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">both types are pointers to qualified or
                unqualified versions of a character type or <code>void</code>.</para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>converted, as if by assignment, to the types of the corresponding parameters,
            taking the type of each parameter to be the unqualified version of its declared type.
            The ellipsis notation in a function prototype declarator causes argument type conversion
            to stop after the last declared parameter. The default argument promotions are performed
            on trailing arguments.</d:para>
          <d:para>No other conversions are performed implicitly; in particular, the number and types
            of arguments are not compared with those of the parameters in a function definition that
            does not include a function prototype declarator.</d:para>
          <d:para>If the function is defined with a type that is not compatible with the type (of
            the expression) pointed to by the expression that denotes the called function, the
            behavior is undefined.</d:para>
          <d:para>The order of evaluation of the function designator, the actual arguments, and
            subexpressions within the actual arguments is unspecified, but there is a sequence point
            before the actual call.</d:para>
          <d:para>Recursive function calls shall be permitted, both directly and indirectly through
            any chain of other functions.</d:para>
          <d:para>EXAMPLE In the function call</d:para>
          <d:programlisting role="CLexer">(*pf[f1()]) (f2(), f3() + f4())</d:programlisting>
          <d:para>the functions <d:code>f1, f2, f3</d:code> and <d:code>f4</d:code> may be called in
            any order. All side effects have to be completed before the function pointed to by
              <d:code>pf[f1()]</d:code> is called.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> function declarators (including prototypes) (Function
            declarators (including prototypes)), function definitions (Function definitions), the
            return statement (The return statement), simple assignment (Simple assignment).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Structures and union members</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The first operand of the <d:code>.</d:code> operator shall have a qualified or
            unqualified structure or union type, and the second operand shall name a member of that
            type.</d:para>
          <d:para>The first operand of the <d:code>-></d:code> operator shall have type “pointer to
            qualified or unqualified structure” or “pointer to qualified or unqualified union”, and
            the second operand shall name a member of the type pointed to.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A postfix expression followed by the <d:code>.</d:code> operator and an identifier
            designates a member of a structure or union object. The value is that of the named
            member, and is an lvalue if the first expression is an lvalue. If the first expression
            has qualified type, the result has the so-qualified version of the type of the
            designated member. \</d:para>
          <d:para>A postfix expression followed by the <d:code>-></d:code> operator and an
            identifier designates a member of a structure or union object. The value is that of the
            named member of the object to which the first expression points, and is an lvalue.<d:footnote>
              <d:para>If <d:code>&amp;E</d:code> is a valid pointer expression (where
                  <d:code>&amp;</d:code> is the “address-of” operator, which generates a pointer to
                its operand), the expression <d:code>(&amp;E)->MOS</d:code> is the same as
                  <d:code>E.MOS</d:code>.</d:para>
            </d:footnote> If the first expression is a pointer to a qualified type, the result has
            the so-qualified version of the type of the designated member.</d:para>
          <d:para>One special guarantee is made in order to simplify the use of unions: if a union
            contains several structures that share a common initial sequence (see below), and if the
            union object currently contains one of these structures, it is permitted to inspect the
            common initial part of any of them anywhere that a declaration of the complete type of
            the union is visible. Two structures share a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">common initial sequence</emphasis>
            if corresponding members have compatible types (and, for bit-fields, the same widths)
            for a sequence of one or more initial members.</d:para>
          <d:para>EXAMPLE 1 If <d:code>f</d:code> is a function returning a structure or union, and
              <d:code>x</d:code> is a member of that structure or union, <d:code>f().x</d:code> is a
            valid postfix expression but is not an lvalue.</d:para>
          <d:para>EXAMPLE 2 In:</d:para>
          <d:programlisting role="CLexer">struct s { int i; const int ci; };
struct s s;
const struct s cs;
volatile struct s vs;</d:programlisting>
          <d:para>the various members have the types:</d:para>
          <d:programlisting role="CLexer">s.i   int
s.ci  const int
cs.i  const int
cs.ci const int
vs.i  volatile int
vs.ci volatile const int</d:programlisting>
          <d:para>EXAMPLE 3 The following is a valid fragment:</d:para>
          <d:programlisting role="CLexer">union {
  struct {
    int alltypes;
  } n;
  struct {
    int type;
    int intnode;
  } ni;
  struct {
  int type;
  double doublenode;
  } nf;
} u;
u.nf.type = 1;
u.nf.doublenode = 3.14;
/* ... */
if (u.n.alltypes == 1)
if (sin(u.nf.doublenode) == 0.0)
/* ... */</d:programlisting>
          <d:para>The following is not a valid fragment (because the union type is not visible
            within function <d:code>f</d:code>):</d:para>
          <d:programlisting role="CLexer">struct t1 { int m; };
struct t2 { int m; };
int f(struct t1 *p1, struct t2 *p2)
{
  if (p1->m &lt; 0)
    p2->m = -p2->m;
  return p1->m;
}
int g()
{
  union {
    struct t1 s1;
    struct t2 s2;
  } u;
  /* ... */
  return f(&amp;u.s1, &amp;u.s2);
}</d:programlisting>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> address and indirection operators (Address and indirection
            operators), structure and union specifiers (Structure and union specifiers).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Postfix increment and decrement
            operators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The operand of the postfix increment or decrement operator shall have qualified or
            unqualified real or pointer type and shall be a modifiable lvalue.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The result of the postfix <d:code>++</d:code> operator is the value of the
            operand. After the result is obtained, the value of the operand is incremented. (That
            is, the value 1 of the appropriate type is added to it.) See the discussions of additive
            operators and compound assignment for information on constraints, types, and conversions
            and the effects of operations on pointers. The side effect of updating the stored value
            of the operand shall occur between the previous and the next sequence point.</d:para>
          <d:para>The postfix <d:code>--</d:code> operator is analogous to the postfix
              <d:code>++</d:code> operator, except that the value of the operand is decremented
            (that is, the value 1 of the appropriate type is subtracted from it).</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> additive operators (Additive operators), compound assignment
            (Compound assignment).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Compound literals</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The type name shall specify an object type or an array of unknown size, but not a
            variable length array type.</d:para>
          <d:para>No initializer shall attempt to provide a value for an object not contained within
            the entire unnamed object specified by the compound literal.</d:para>
          <d:para>If the compound literal occurs outside the body of a function, the initializer
            list shall consist of constant expressions.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A postfix expression that consists of a parenthesized type name followed by a
            brace- enclosed list of initializers is a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">compound literal</emphasis>. It
            provides an unnamed object whose value is given by the initializer list.<d:footnote>
              <d:para>Note that this differs from a cast expression. For example, a cast specifies a
                conversion to scalar types or void only, and the result of a cast expression is not
                an lvalue.</d:para>
            </d:footnote></d:para>
          <d:para>If the type name specifies an array of unknown size, the size is determined by the
            initializer list as specified in Initialization, and the type of the compound literal is
            that of the completed array type. Otherwise (when the type name specifies an object
            type), the type of the compound literal is that specified by the type name. In either
            case, the result is an lvalue.</d:para>
          <d:para>The value of the compound literal is that of an unnamed object initialized by the
            initializer list. If the compound literal occurs outside the body of a function, the
            object has static storage duration; otherwise, it has automatic storage duration
            associated with the enclosing block.</d:para>
          <d:para>All the semantic rules and constraints for initializer lists in Initialization are
            applicable to compound literals.<d:footnote>
              <d:para>For example, subobjects without explicit initializers are initialized to
                zero.</d:para>
            </d:footnote></d:para>
          <d:para>String literals, and compound literals with const-qualified types, need not
            designate distinct objects.<d:footnote>
              <d:para>This allows implementations to share storage for string literals and constant
                compound literals with the same or overlapping representations.</d:para>
            </d:footnote></d:para>
          <d:para>EXAMPLE 1 The file scope definition</d:para>
          <d:programlisting role="CLexer">int *p = (int []){2, 4};</d:programlisting>
          <d:para>initializes p to point to the first element of an array of two ints, the first
            having the value two and the second, four. The expressions in this compound literal are
            required to be constant. The unnamed object has static storage duration.</d:para>
          <d:para>EXAMPLE 2 In contrast, in</d:para>
          <d:programlisting role="CLexer">void f(void)
{
  int *p;
  /*...*/
  p = (int [2]){*p};
  /*...*/
}</d:programlisting>
          <d:para><d:code>p</d:code> is assigned the address of the first element of an array of two
            ints, the first having the value previously pointed to by <d:code>p</d:code> and the
            second, zero. The expressions in this compound literal need not be constant. The unnamed
            object has automatic storage duration.</d:para>
          <d:para>EXAMPLE 3 Initializers with designations can be combined with compound literals.
            Structure objects created using compound literals can be passed to functions without
            depending on member order:</d:para>
          <d:programlisting role="CLexer">drawline((struct point){.x=1, .y=1},
(struct point){.x=3, .y=4});</d:programlisting>
          <d:para>Or, if drawline instead expected pointers to struct point:</d:para>
          <d:programlisting role="CLexer">drawline(&amp;(struct point){.x=1, .y=1},
&amp;(struct point){.x=3, .y=4});</d:programlisting>
          <d:para>EXAMPLE 4 A read-only compound literal can be specified through constructions
            like:</d:para>
          <d:programlisting role="CLexer">(const float []){1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6}</d:programlisting>
          <d:para>EXAMPLE 5 The following three expressions have different meanings:</d:para>
          <d:programlisting role="CLexer">"/tmp/fileXXXXXX"
(char []){"/tmp/fileXXXXXX"}
(const char []){"/tmp/fileXXXXXX"}</d:programlisting>
          <d:para>The first always has static storage duration and has type array of char, but need
            not be modifiable; the last two have automatic storage duration when they occur within
            the body of a function, and the first of these two is modifiable.</d:para>
          <d:para>EXAMPLE 6 Like string literals, const-qualified compound literals can be placed
            into read-only memory and can even be shared. For example,</d:para>
          <d:programlisting role="CLexer">(const char []){"abc"} == "abc"</d:programlisting>
          <d:para>might yield 1 if the literals’ storage is shared.</d:para>
          <d:para>EXAMPLE 7 Since compound literals are unnamed, a single compound literal cannot
            specify a circularly linked object. For example, there is no way to write a
            self-referential compound literal that could be used as the function argument in place
            of the named object endless_zeros below:</d:para>
          <d:programlisting role="CLexer">struct int_list { int car; struct int_list *cdr; };
struct int_list endless_zeros = {0, &amp;endless_zeros};
eval(endless_zeros);</d:programlisting>
          <d:para>EXAMPLE 8 Each compound literal creates only a single object in a given
            scope:</d:para>
          <d:programlisting role="CLexer">struct s { int i; };
int f (void)
{
  struct s *p = 0, *q;
  int j = 0;
again:
  q = p, p = &amp;((struct s){ j++ });
  if (j &lt; 2) goto again;
  return p == q &amp;&amp; q->i == 1;
}</d:programlisting>
          <d:para>The function <d:code>f()</d:code> always returns the value 1.</d:para>
          <d:para>Note that if an iteration statement were used instead of an explicit goto and a
            labeled statement, the lifetime of the unnamed object would be the body of the loop
            only, and on entry next time around <d:code>p</d:code> would have an indeterminate
            value, which would result in undefined behavior.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> type names (Type names), initialization
            (Initialization).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Unary Operators</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Prefix increment and decrement
            operators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The operand of the prefix increment or decrement operator shall have qualified or
            unqualified real or pointer type and shall be a modifiable lvalue.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The value of the operand of the prefix <d:code>++</d:code> operator is
            incremented. The result is the new value of the operand after incrementation. The
            expression <d:code>++E</d:code> is equivalent to <d:code>(E+=1)</d:code>. See the
            discussions of additive operators and compound assignment for information on onstraints,
            types, side effects, and conversions and the effects of operations on pointers.</d:para>
          <d:para>The prefix <d:code>--</d:code> operator is analogous to the prefix
              <d:code>++</d:code> operator, except that the value of the operand is
            decremented.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> additive operators (Additive operators), compound assignment
            (Compound assignment).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Address and indirection operators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The operand of the unary <d:code>&amp;</d:code> operator shall be either a
            function designator, the result of a <d:code>[]</d:code> or unary <d:code>*</d:code>
            operator, or an lvalue that designates an object that is not a bit-field and is not
            declared with the register storage-class specifier.</d:para>
          <d:para>The operand of the unary <d:code>*</d:code> operator shall have pointer
            type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The unary <d:code>&amp;</d:code> operator yields the address of its operand. If
            the operand has type “type”, the result has type “pointer to type”. If the operand is
            the result of a unary <d:code>*</d:code> operator, neither that operator nor the
              <d:code>&amp;</d:code> operator is evaluated and the result is as if both were
            omitted, except that the constraints on the operators still apply and the result is not
            an lvalue. Similarly, if the operand is the result of a <d:code>[]</d:code> operator,
            neither the <d:code>&amp;</d:code> operator nor he unary <d:code>*</d:code> that is
            implied by the <d:code>[]</d:code> is evaluated and the result is as if the
              <d:code>&amp;</d:code> operator were removed and the <d:code>[]</d:code> operator were
            changed to a <d:code>+</d:code> operator. Otherwise, the result is a pointer to the
            object or function designated by its operand.</d:para>
          <d:para>The unary <d:code>*</d:code> operator denotes indirection. If the operand points
            to a function, the result is a function designator; if it points to an object, the
            result is an lvalue designating the object. If the operand has type “pointer to type”,
            the result has type “type”. If an invalid value has been assigned to the pointer, the
            behavior of the unary <d:code>*</d:code> operator is undefined.<d:footnote>
              <d:para>Thus, <d:code>&amp;*E</d:code> is equivalent to <d:code>E</d:code> (even if
                  <d:code>E</d:code> is a null pointer), and <d:code>&amp;(E1[E2]) to
                  ((E1)+(E2))</d:code>. It is always true that if <d:code>E</d:code> is a function
                designator or an lvalue that is a valid operand of the unary &amp; operator,
                  <d:code>*&amp;E</d:code> is a function designator or an lvalue equal to
                  <d:code>E</d:code>. If <d:code>*P</d:code> is an lvalue and <d:code>T</d:code> is
                the name of an object pointer type, <d:code>*(T)P</d:code> is an lvalue that has a
                type compatible with that to which <d:code>T</d:code> points. Among the invalid
                values for dereferencing a pointer by the unary <d:code>*</d:code> operator are a
                null pointer, an address inappropriately aligned for the type of object pointed to,
                and the address of an object after the end of its lifetime.</d:para>
            </d:footnote></d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> storage-class specifiers (Storage-class specifiers), structure
            and union specifiers (Structure and union specifiers).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Unary arithmetic operators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The operand of the unary <d:code>+</d:code> or <d:code>-</d:code> operator shall
            have arithmetic type; of the <d:code>-</d:code> operator, integer type; of the
              <d:code>!</d:code> operator, scalar type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The result of the unary <d:code>+</d:code> operator is the value of its (promoted)
            operand. The integer promotions are performed on the operand, and the result has the
            promoted type.</d:para>
          <d:para>The result of the unary <d:code>-</d:code> operator is the negative of its
            (promoted) operand. The integer promotions are performed on the operand, and the result
            has the promoted type.</d:para>
          <d:para>The result of the <d:code>~</d:code> operator is the bitwise complement of its
            (promoted) operand (that is, each bit in the result is set if and only if the
            corresponding bit in the converted operand is not set). The integer promotions are
            performed on the operand, and the result has the promoted type. If the promoted type is
            an unsigned type, the expression <d:code>~E</d:code> is equivalent to the maximum value
            representable in that type minus <d:code>E</d:code>.</d:para>
          <d:para>The result of the logical negation operator <d:code>!</d:code> is 0 if the value
            of its operand compares unequal to 0, 1 if the value of its operand compares equal to 0.
            The result has type int. The expression <d:code>!E</d:code> is equivalent to
              <d:code>(0==E)</d:code>.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The sizeof operator</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The <d:code>sizeof</d:code> operator shall not be applied to an expression that
            has function type or an incomplete type, to the parenthesized name of such a type, or to
            an expression that designates a bit-field member.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The <d:code>sizeof</d:code> operator yields the size (in bytes) of its operand,
            which may be an expression or the parenthesized name of a type. The size is determined
            from the type of the operand. The result is an integer. If the type of the operand is a
            variable length array type, the operand is evaluated; otherwise, the operand is not
            evaluated and the result is an integer constant.</d:para>
          <d:para>When applied to an operand that has type <d:code>char, unsigned char</d:code> or
              <d:code>signed char</d:code>, (or a qualified version thereof) the result is 1. When
            applied to an operand that has array type, the result is the total number of bytes in
            the array.<d:footnote>
              <d:para>When applied to a parameter declared to have array or function type, the
                sizeof operator yields the size of the adjusted (pointer) type (see Function
                definitions).</d:para>
            </d:footnote> When applied to an operand that has structure or union type, the result is
            the total number of bytes in such an object, including internal and trailing
            padding.</d:para>
          <d:para>The value of the result is implementation-defined, and its type (an unsigned
            integer type) is <d:code>size_t</d:code>, defined in <d:code>&lt;stddef.h></d:code> (and
            other headers).</d:para>
          <d:para>EXAMPLE 1 A principal use of the sizeof operator is in communication with routines
            such as storage allocators and I/O systems. A storage-allocation function might accept a
            size (in bytes) of an object to allocate and return a pointer to void. For
            example:</d:para>
          <d:programlisting role="CLexer">extern void *alloc(size_t);
double *dp = alloc(sizeof *dp);</d:programlisting>
          <d:para>The implementation of the alloc function should ensure that its return value is
            aligned suitably for conversion to a pointer to double.</d:para>
          <d:para>EXAMPLE 2 Another use of the <d:code>sizeof</d:code> operator is to compute the
            number of elements in an array:</d:para>
          <d:programlisting role="CLexer">sizeof array / sizeof array[0]</d:programlisting>
          <d:para>In this example, the size of a variable length array is computed and returned from
            a function:</d:para>
          <d:programlisting role="CLexer">#include &lt;stddef.h>
size_t fsize3(int n)
{
  char b[n+3];     // variable length array
  return sizeof b; // execution time sizeof
}
int main()
{
  size_t size;
  size = fsize3(10); // fsize3 returns 13
  return 0;
}</d:programlisting>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> common definitions &lt;stddef.h> (Common definitions
            &lt;stddef.h>), declarations (Declarations), structure and union specifiers (Structure
            and union specifiers), type names (Type names), array declarators (Array
            declarators).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Cast operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Unless the type name specifies a <d:code>void</d:code> type, the type name shall
          specify qualified or unqualified scalar type and the operand shall have scalar
          type.</d:para>
        <d:para>Conversions that involve pointers, other than where permitted by the constraints of
          Simple assignment, shall be specified by means of an explicit cast.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>Preceding an expression by a parenthesized type name converts the value of the
          expression to the named type. This construction is called a cast.<d:footnote>
            <d:para>A cast does not yield an lvalue. Thus, a cast to a qualified type has the same
              effect as a cast to the unqualified version of the type.</d:para>
          </d:footnote> A cast that specifies no conversion has no effect on the type or value of an expression.<d:footnote>
            <d:para>If the value of the expression is represented with greater precision or range
              than required by the type named by the cast (Usual Arithmetic Conversions), then the
              cast specifies a conversion even if the type of the expression is the same as the
              named type.</d:para>
          </d:footnote></d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> equality operators (Equality operators), function declarators
          (including prototypes) (Function declarators (including prototypes)), simple assignment
          (Simple assignment), type names (Type names).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Multiplicative operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have arithmetic type. The operands of the
            <d:code>%</d:code> operator shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The usual arithmetic conversions are performed on the operands.</d:para>
        <d:para>The result of the binary <d:code>*</d:code> operator is the product of the
          operands.</d:para>
        <d:para>The result of the <d:code>/</d:code> operator is the quotient from the division of
          the first operand by the second; the result of the <d:code>%</d:code> operator is the
          remainder. In both operations, if the value of the second operand is zero, the behavior is
          undefined.</d:para>
        <d:para>When integers are divided, the result of the <d:code>/</d:code> operator is the
          algebraic quotient with any fractional part discarded.<d:footnote>
            <d:para>This is often called “truncation toward zero”.</d:para>
          </d:footnote> If the quotient <d:code>a/b</d:code> is representable, the expression
            <d:code>(a/b)*b + a%b</d:code> shall equal <d:code>a</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Additive operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>For addition, either both operands shall have arithmetic type, or one operand shall
          be a pointer to an object type and the other shall have integer type. (Incrementing is
          equivalent to adding 1.)</d:para>
        <d:para>For subtraction, one of the following shall hold:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands have arithmetic type;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands are pointers to qualified or
              unqualified versions of compatible object types; or</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">the left operand is a pointer to an object
              type and the right operand has integer type.</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>(Decrementing is equivalent to subtracting 1.)</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>If both operands have arithmetic type, the usual arithmetic conversions are
          performed on them.</d:para>
        <d:para>The result of the binary <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >+</emphasis> operator is the sum of the operands.</d:para>
        <d:para>The result of the binary <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >-</emphasis> operator is the difference resulting from the subtraction of the second
          operand from the first.</d:para>
        <d:para>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the stype of the object as its element type.</d:para>
        <d:para>When an expression that has integer type is added to or subtracted from a pointer,
          the result has the type of the pointer operand. If the pointer operand points to an
          element of an array object, and the array is large enough, the result points to an element
          offset from the original element such that the difference of the subscripts of the
          resulting and original array elements equals the integer expression. In other words, if
          the expression <d:code>P</d:code> points to the <d:code>i</d:code>-th element of an array
          object, the expressions <d:code>(P)+N</d:code> (equivalently, <d:code>N+(P))</d:code> and
            <d:code>(P)-N</d:code> (where <d:code>N</d:code> has the value <d:code>n</d:code>) point
          to, respectively, the <d:code>i+n</d:code>-th and <d:code>i-n</d:code>-th elements of the
          array object, provided they exist. Moreover, if the expression <d:code>P</d:code> points
          to the last element of an array object, the expression <d:code>(P)+1</d:code> points one
          past the last element of the array object, and if the expression <d:code>Q</d:code> points
          one past the last element of an array object, the expression <d:code>(Q)-1</d:code> points
          to the last element of the array object. If both the pointer operand and the result point
          to elements of the same array object, or one past the last element of the array object,
          the evaluation shall not produce an overflow; otherwise, the behavior is undefined. If the
          result points one past the last element of the array object, it shall not be used as the
          operand of a unary <d:code>*</d:code> operator that is evaluated.</d:para>
        <d:para>When two pointers are subtracted, both shall point to elements of the same array
          object, or one past the last element of the array object; the result is the difference of
          the subscripts of the two array elements. The size of the result is
          implementation-defined, and its type (a signed integer type) is <d:code>ptrdiff_t</d:code>
          defined in the <d:code>&lt;stddef.h></d:code> header. If the result is not representable
          in an object of that type, the behavior is undefined. In other words, if the expressions
            <d:code>P</d:code> and <d:code>Q</d:code> point to, respectively, the
          <d:code>i</d:code>-th and <d:code>j</d:code>-th elements of an array object, the
          expression <d:code>(P)-(Q)</d:code> has the value <d:code>i-j</d:code> provided the value
          fits in an object of type <d:code>ptrdiff_t</d:code>. Moreover, if the expression
            <d:code>P</d:code> points either to an element of an array object or one past the last
          element of an array object, and the expression <d:code>Q</d:code> points to the last
          element of the same array object, the expression <d:code>((Q)+1)-(P)</d:code> has the same
          value as <d:code>((Q)-(P))+1</d:code> and as <d:code>-((P)-((Q)+1))</d:code>, and has the
          value zero if the expression <d:code>P</d:code> points one past the last element of the
          array object, even though the expression <d:code>(Q)+1</d:code> does not point to an
          element of the array object.<d:footnote>
            <d:para>Another way to approach pointer arithmetic is first to convert the pointer(s) to
              character pointer(s): In this scheme the integer expression added to or subtracted
              from the converted pointer is first multiplied by the size of the object originally
              pointed to, and the resulting pointer is converted back to the original type. For
              pointer subtraction, the result of the difference between the character pointers is
              similarly divided by the size of the object originally pointed to.</d:para>
            <d:para>When viewed in this way, an implementation need only provide one extra byte
              (which may overlap another object in the program) just after the end of the object in
              order to satisfy the “one past the last element” requirements.</d:para>
          </d:footnote></d:para>
        <d:para>EXAMPLE Pointer arithmetic is well defined with pointers to variable length array
          types.</d:para>
        <d:programlisting role="CLexer">{
  int n = 4, m = 3;
  int a[n][m];
  int (*p)[m] = a; // p == &amp;a[0]
  p += 1;          // p == &amp;a[1]
  (*p)[2] = 99;    // a[1][2] == 99
  n = p - a;       // n == 1
}</d:programlisting>
        <d:para>If array a in the above example were declared to be an array of known constant size,
          and pointer <d:code>p</d:code> were declared to be a pointer to an array of the same known
          constant size (pointing to <d:code>a</d:code>), the results would be the same.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> array declarators (Array declarators), common definitions
          &lt;stddef.h> (Common definitions &lt;stddef.h>).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Bitwise shift operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraint</emphasis></d:para>
        <d:para>Each of the operands shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The integer promotions are performed on each of the operands. The type of the result
          is that of the promoted left operand. If the value of the right operand is negative or is
          greater than or equal to the width of the promoted left operand, the behavior is
          undefined.</d:para>
        <d:para>The result of <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mo>&lt;&lt;</mml:mo>
              <mml:mi>E</mml:mi>
              <mml:mn>2</mml:mn>
            </mml:math>
          </d:inlineequation>is <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> left-shifted <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>2</mml:mn>
            </mml:math>
          </d:inlineequation> bit positions; vacated bits are filled with zeros. If <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has an unsigned type, the value of the result is <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mtext>&#xA0;</mml:mtext>
              <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
              <mml:mtext>&#xA0;</mml:mtext>
              <mml:msup>
                <mml:mn>2</mml:mn>
                <mml:mrow class="MJX-TeXAtom-ORD">
                  <mml:mi>E</mml:mi>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msup>
            </mml:math>
          </d:inlineequation>, reduced modulo one more than the maximum value representable in the
          result type. If <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has a signed type and nonnegative value, and <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mtext>&#xA0;</mml:mtext>
              <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
              <mml:mtext>&#xA0;</mml:mtext>
              <mml:msup>
                <mml:mn>2</mml:mn>
                <mml:mrow class="MJX-TeXAtom-ORD">
                  <mml:mi>E</mml:mi>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msup>
            </mml:math>
          </d:inlineequation> is representable in the result type, then that is the resulting value;
          otherwise, the behavior is undefined.</d:para>
        <d:para>The result of <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mo>&gt;&gt;</mml:mo>
              <mml:mi>E</mml:mi>
              <mml:mn>2</mml:mn>
            </mml:math>
          </d:inlineequation> is <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> right-shifted <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>2</mml:mn>
            </mml:math>
          </d:inlineequation> bit positions. If <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has an unsigned type or if <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has a signed type and a nonnegative value, the value of the result is
          the integral part of the quotient of <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mrow class="MJX-TeXAtom-ORD">
                <mml:mo>/</mml:mo>
              </mml:mrow>
              <mml:msup>
                <mml:mn>2</mml:mn>
                <mml:mrow class="MJX-TeXAtom-ORD">
                  <mml:mi>E</mml:mi>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msup>
            </mml:math>
          </d:inlineequation>. If <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has a signed type and a negative value, the resulting value is
          implementation-defined.</d:para>
      </d:sect2>
      <d:sect2>
        <d:title>Relational operators</d:title>
        <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
        <d:para>One of the following shall hold:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <d:para>both operands have real type;</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>both operands are pointers to qualified or unqualified versions of compatible
              object types; or</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>both operands are pointers to qualified or unqualified versions of compatible
              incomplete types.</d:para>
          </d:listitem>
        </d:itemizedlist>
        <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
        <d:para>If both of the operands have arithmetic type, the usual arithmetic conversions are
          performed.</d:para>
        <d:para>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the type of the object as its element type.</d:para>
        <d:para>When two pointers are compared, the result depends on the relative locations in the
          address space of the objects pointed to. If two pointers to object or incomplete types
          both point to the same object, or both point one past the last element of the same array
          object, they compare equal. If the objects pointed to are members of the same aggregate
          object, pointers to structure members declared later compare greater than pointers to
          members declared earlier in the structure, and pointers to array elements with larger
          subscript values compare greater than pointers to elements of the same array with lower
          subscript values. All pointers to members of the same union object compare equal. If the
          expression <d:code>P</d:code> points to an element of an array object and the expression
            <d:code>Q</d:code> points to the last element of the same array object, the pointer
          expression <d:code>Q+1</d:code> compares greater than <d:code>P</d:code>. In all other
          cases, the behavior is undefined.</d:para>
        <d:para>Each of the operators <d:code>&lt;</d:code> (less than), <d:code>></d:code> (greater
          than), <d:code>&lt;=</d:code> (less than or equal to), and <d:code>>=</d:code> (greater
          than or equal to) shall yield 1 if the specified relation is true and 0 if it is false.<d:footnote>
            <d:para>The expression <d:code>a &lt; b &lt; c</d:code> is not interpreted as in ordinary
              mathematics. As the syntax indicates, it means <d:code>(a &lt; b)
	      &lt; c</d:code>; in
              other words, “if a is less than b, compare 1 to c; otherwise, compare 0 to
              c”.</d:para>
          </d:footnote></d:para>
      </d:sect2>
      <d:sect2>
        <d:title>Equality operators</d:title>
        <d:para>Constraints</d:para>
        <d:para>One of the following shall hold:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <d:para>both operands have arithmetic type;</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>both operands are pointers to qualified or unqualified versions of compatible
              types;</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>one operand is a pointer to an object or incomplete type and the other is a
              pointer to a qualified or unqualified version of void; or</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>one operand is a pointer and the other is a null pointer constant.</d:para>
          </d:listitem>
        </d:itemizedlist>
        <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
        <d:para>The <d:code>==</d:code> (equal to) and <d:code>!=</d:code> (not equal to) operators
          are analogous to the relational operators except for their lower precedence. <d:footnote>
            <d:para>Because of the precedences, <d:code>a &lt; b == c &lt; d</d:code> is 1 whenever
                <d:code>a &lt; b</d:code> and <d:code>c &lt; d</d:code> have the same
              truth-value.</d:para>
          </d:footnote> Each of the operators yields 1 if the specified relation is true and 0 if it
          is false. The result has type <d:code>int</d:code>. For any pair of operands, exactly one
          of the relations is true.</d:para>
        <d:para>If both of the operands have arithmetic type, the usual arithmetic conversions are
          performed. Values of complex types are equal if and only if both their real parts are
          equal and also their imaginary parts are equal. Any two values of arithmetic types from
          different type domains are equal if and only if the results of their conversions to the
          (complex) result type determined by the usual arithmetic conversions are equal.</d:para>
        <d:para>Otherwise, at least one operand is a pointer. If one operand is a pointer and the
          other is a null pointer constant, the null pointer constant is converted to the type of
          the pointer. If one operand is a pointer to an object or incomplete type and the other is
          a pointer to a qualified or unqualified version of <d:code>void</d:code>, the former is
          converted to the type of the latter.</d:para>
        <d:para>Two pointers compare equal if and only if both are null pointers, both are pointers
          to the same object (including a pointer to an object and a subobject at its beginning) or
          function, both are pointers to one past the last element of the same array object, or one
          is a pointer to one past the end of one array object and the other is a pointer to the
          start of a different array object that happens to immediately follow the first array
          object in the address space.<d:footnote>
            <d:para>Two objects may be adjacent in memory because they are adjacent elements of a
              larger array or adjacent members of a structure with no padding between them, or
              because the implementation chose to place them so, even though they are unrelated. If
              prior invalid pointer operations (such as accesses outside array bounds) produced
              undefined behavior, subsequent comparisons also produce undefined behavior.</d:para>
          </d:footnote></d:para>
        <d:para>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the type of the object as its element type.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Bitwise AND operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The usual arithmetic conversions are performed on the operands. The result of the
          binary <d:code>&amp;</d:code> operator is the bitwise AND of the operands (that is, each
          bit in the result is set if and only if each of the corresponding bits in the converted
          operands is set).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Bitwise exlusive OR operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The usual arithmetic conversions are performed on the operands. The result of the
            <d:code>^</d:code> operator is the bitwise exclusive OR of the operands (that is, each
          bit in the result is set if and only if exactly one of the corresponding bits in the
          converted operands is set).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Bitwise inclusive OR operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The usual arithmetic conversions are performed on the operands. The result of the
            <d:code>|</d:code> operator is the bitwise inclusive OR of the operands (that is, each
          bit in the result is set if and only if at least one of the corresponding bits in the
          converted operands is set).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Logical AND operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have scalar type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The <d:code>&amp;&amp;</d:code> operator shall yield 1 if both of its operands
          compare unequal to 0; otherwise, it yields 0. The result has type
          <d:code>int</d:code>.</d:para>
        <d:para>Unlike the bitwise binary <d:code>&amp;</d:code> operator, the
            <d:code>&amp;&amp;</d:code> operator guarantees left-to-right evaluation; there is a
          sequence point after the evaluation of the first operand. If the first operand compares
          equal to 0, the second operand is not evaluated.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Logical OR operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have scalar type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The <d:code>||</d:code> operator shall yield 1 if either of its operands compare
          unequal to 0; otherwise, it yields 0. The result has type <d:code>int</d:code>. Unlike the
          bitwise <d:code>|</d:code> operator, the <d:code>||</d:code> operator guarantees
          left-to-right evaluation; there is a sequence point after the evaluation of the first
          operand. If the first operand compares unequal to 0, the second operand is not
          evaluated.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Conditional operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The first operand shall have scalar type. One of the following shall hold for the
          second and third operands:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands have arithmetic type;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands have the same structure or
              union type;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands have void type;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands are pointers to qualified or
              unqualified versions of compatible types;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">one operand is a pointer and the other is a
              null pointer constant; or</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">one operand is a pointer to an object or
              incomplete type and the other is a pointer to a qualified or unqualified version of
              void.</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para> The first operand is evaluated; there is a sequence point after its evaluation. The
          second operand is evaluated only if the first compares unequal to 0; the third operand is
          evaluated only if the first compares equal to 0; the result is the value of the second or
          third operand (whichever is evaluated), converted to the type described below.<d:footnote>
            <d:para>A conditional expression does not yield an lvalue.</d:para>
          </d:footnote> If an attempt is made to modify the result of a conditional operator or to
          access it after the next sequence point, the behavior is undefined.</d:para>
        <d:para>If both the second and third operands have arithmetic type, the result type that
          would be determined by the usual arithmetic conversions, were they applied to those two
          operands, is the type of the result. If both the operands have structure or union type,
          the result has that type. If both operands have void type, the result has <code
            xmlns="http://docbook.org/ns/docbook">void</code> type.</d:para>
        <d:para>If both the second and third operands are pointers or one is a null pointer constant
          and the other is a pointer, the result type is a pointer to a type qualified with all the
          type qualifiers of the types pointed-to by both operands. Furthermore, if both operands
          are pointers to compatible types or to differently qualified versions of compatible types,
          the result type is a pointer to an appropriately qualified version of the composite type;
          if one operand is a null pointer constant, the result has the type of the other operand;
          otherwise, one operand is a pointer to <d:code>void</d:code> or a qualified version of
            <d:code>void</d:code>, in which case the result type is a pointer to an appropriately
          qualified version of <d:code>void</d:code>.</d:para>
        <d:para>EXAMPLE The common type that results when the second and third operands are pointers
          is determined in two independent stages. The appropriate qualifiers, for example, do not
          depend on whether the two pointers have compatible types.</d:para>
        <d:para>Given the declarations</d:para>
        <d:programlisting role="CLexer">const void *c_vp;
void *vp;
const int *c_ip;
volatile int *v_ip;
int *ip;
const char *c_cp;</d:programlisting>
        <d:para>the third column in the following table is the common type that is the result of a
          conditional expression in which the first two columns are the second and third operands
          (in either order):</d:para>
        <d:programlisting role="CLexer">c_vp c_ip const void *
v_ip 0    volatile int *
c_ip v_ip const volatile int *
vp   c_cp const void *
ip   c_ip const int *
vp   ip   void *</d:programlisting>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Assignment operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Contraints</emphasis></d:para>
        <d:para>An assignment operator shall have a modifiable lvalue as its left operand.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>An assignment operator stores a value in the object designated by the left operand.
          An assignment expression has the value of the left operand after the assignment, but is
          not an lvalue. The type of an assignment expression is the type of the left operand unless
          the left operand has qualified type, in which case it is the unqualified version of the
          type of the left operand. The side effect of updating the stored value of the left operand
          shall occur between the previous and the next sequence point.</d:para>
        <d:para>The order of evaluation of the operands is unspecified. If an attempt is made to
          modify the result of an assignment operator or to access it after the next sequence point,
          the behavior is undefined.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Simple Assignment</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>One of the following shall hold:<d:footnote>
              <d:para>The asymmetric appearance of these constraints with respect to type qualifiers
                is due to the conversion (specified in Other Operands) that changes lvalues to “the
                value of the expression” and thus removes any type qualifiers that were applied to
                the type category of the expression (for example, it removes <d:code>const</d:code>
                but not <d:code>volatile</d:code> from the type int volatile * const).</d:para>
            </d:footnote></d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">the left operand has qualified or
                unqualified arithmetic type and the right has arithmetic type;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">the left operand has a qualified or
                unqualified version of a structure or union type compatible with the type of the
                right;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">both operands are pointers to qualified or
                unqualified versions of compatible types, and the type pointed to by the left has
                all the qualifiers of the type pointed to by the right;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">one operand is a pointer to an object or
                incomplete type and the other is a pointer to a qualified or unqualified version of
                void, and the type pointed to by the left has all the qualifiers of the type pointed
                to by the right;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">the left operand is a pointer and the
                right is a null pointer constant; or</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">the left operand has type
                  <code>_Bool</code> and the right is a pointer.</para>
            </d:listitem>
          </d:itemizedlist>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>In simple assignment (=), the value of the right operand is converted to the type
            of the assignment expression and replaces the value stored in the object designated by
            the left operand.</d:para>
          <d:para>If the value being stored in an object is read from another object that overlaps
            in any way the storage of the first object, then the overlap shall be exact and the two
            objects shall have qualified or unqualified versions of a compatible type; otherwise,
            the behavior is undefined.</d:para>
          <d:para>EXAMPLE 1 In the program fragment</d:para>
          <d:programlisting role="CLexer">int f(void);
char c;
/* ... */
if ((c = f()) == -1)
/* ... */</d:programlisting>
          <d:para>the int value returned by the function may be truncated when stored in the
              <d:code>char</d:code>, and then converted back to <d:code>int</d:code> width prior to
            the comparison. In an implementation in which “plain” <d:code>char</d:code> has the same
            range of values as <d:code>unsigned char</d:code> (and <d:code>char</d:code> is narrower
            than <d:code>int</d:code>), the result of the conversion cannot be negative, so the
            operands of the comparison can never compare equal. Therefore, for full portability, the
            variable c should be declared as <d:code>int</d:code>.</d:para>
          <d:para>EXAMPLE 2 In the fragment:</d:para>
          <d:programlisting role="CLexer">char c;
int i;
long l;
l = (c = i);</d:programlisting>
          <d:para>the value of <d:code>i</d:code> is converted to the type of the assignment
            expression <d:code>c = i</d:code>, that is, <d:code>char</d:code> type. The value of the
            expression enclosed in parentheses is then converted to the type of the outer assignment
            expression, that is, <d:code>long int</d:code> type.</d:para>
          <d:para>EXAMPLE 3 Consider the fragment:</d:para>
          <d:programlisting role="CLexer">const char **cpp;
char *p;
const char c = 'A';
cpp = &amp;p;   // constraint violation
*cpp = &amp;c;  // valid
*p = 0;     // valid</d:programlisting>
          <d:para>The first assignment is unsafe because it would allow the following valid code to
            attempt to change the value of the <d:code>const</d:code> object
            <d:code>c</d:code>.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Compound assignments</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>For the operators <d:code>+=</d:code> and <d:code>-=</d:code> only, either the
            left operand shall be a pointer to an object type and the right shall have integer type,
            or the left operand shall have qualified or unqualified arithmetic type and the right
            shall have arithmetic type.</d:para>
          <d:para>For the other operators, each operand shall have arithmetic type consistent with
            those allowed by the corresponding binary operator.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A compound assignment of the form <d:code>E1 op = E2</d:code> differs from the
            simple assignment expression <d:code>E1 = E1 op (E2)</d:code> only in that the lvalue
              <d:code>E1</d:code> is evaluated only once.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Comma operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The left operand of a comma operator is evaluated as a void expression; there is a
          sequence point after its evaluation. Then the right operand is evaluated; the result has
          its type and value.<d:footnote>
            <d:para>A comma operator does not yield an lvalue.</d:para>
          </d:footnote> If an attempt is made to modify the result of a comma operator or to access
          it after the next sequence point, the behavior is undefined.</d:para>
        <d:para>EXAMPLE As indicated by the syntax, the comma operator (as described in this
          subclause) cannot appear in contexts where a comma is used to separate items in a list
          (such as arguments to functions or lists of initializers). On the other hand, it can be
          used within a parenthesized expression or within the second expression of a conditional
          operator in such contexts. In the function call:</d:para>
        <d:programlisting roel="CLexer">f(a, (t=3, t+2), c)</d:programlisting>
        <d:para>the function has three arguments, the second of which has the value 5.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> initialization (Initialization).</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Constant expressions</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Description</emphasis></d:para>
      <d:para>A constant expression can be evaluated during translation rather than runtime, and
        accordingly may be used in any place that a constant may be.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Constraints</emphasis></d:para>
      <d:para>Constant expressions shall not contain assignment, increment, decrement,
        function-call, or comma operators, except when they are contained within a subexpression
        that is not evaluated.<d:footnote>
          <d:para>The operand of a <d:code>sizeof</d:code> operator is usually not evaluated (The
            sizeof operator).</d:para>
        </d:footnote></d:para>
      <d:para>Each constant expression shall evaluate to a constant that is in the range of
        representable values for its type.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>An expression that evaluates to a constant is required in several contexts. If a
        floating expression is evaluated in the translation environment, the arithmetic precision
        and range shall be at least as great as if the expression were being evaluated in the
        execution environment.</d:para>
      <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">integer constant
          expression</emphasis><d:footnote>
          <d:para>An integer constant expression is used to specify the size of a bit-field member
            of a structure, the value of an enumeration constant, the size of an array, or the value
            of a case constant. Further constraints that apply to the integer constant expressions
            used in conditional-inclusion preprocessing directives are discussed in Conditional
            Inclusion.</d:para>
        </d:footnote> shall have integer type and shall only have operands that are integer
        constants, enumeration constants, character constants, <d:code>sizeof</d:code> expressions
        whose results are integer constants, and floating constants that are the immediate operands
        of casts. Cast operators in an integer constant expression shall only convert arithmetic
        types to integer types, except as part of an operand to the <d:code>sizeof</d:code>
        operator.</d:para>
      <d:para>More latitude is permitted for constant expressions in initializers. Such a constant
        expression shall be, or evaluate to, one of the following:</d:para>
      <d:itemizedlist>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">an arithmetic constant expression,</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">a null pointer constant,</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">an address constant, or</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">an address constant for an object type plus or
            minus an integer constant expression.</para>
        </d:listitem>
      </d:itemizedlist>
      <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">arithmetic constant
          expression</emphasis> shall have arithmetic type and shall only have operands that are
        integer constants, floating constants, enumeration constants, character constants, and
        sizeof expressions. Cast operators in an arithmetic constant expression shall only convert
        arithmetic types to arithmetic types, except as part of an operand to a
          <d:code>sizeof</d:code> operator whose result is an integer constant.</d:para>
      <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">address
          constant</emphasis> is a null pointer, a pointer to an lvalue designating an object of
        static storage duration, or a pointer to a function designator; it shall be created
        explicitly using the unary <d:code>&amp;</d:code> operator or an integer constant cast to
        pointer type, or implicitly by the use of an expression of array or function type. The
        array-subscript <d:code>[]</d:code> and member-access <d:code>.</d:code> and
          <d:code>-></d:code> operators, the address <d:code>&amp;</d:code> and indirection
          <d:code>*</d:code> unary operators, and pointer casts may be used in the creation of an
        address constant, but the value of an object shall not be accessed by use of these
        operators.</d:para>
      <d:para>An implementation may accept other forms of constant expressions.</d:para>
      <d:para>The semantic rules for the evaluation of a constant expression are the same as for
        nonconstant expressions.<d:footnote>
          <d:para>Thus, in the following initialization, <d:code>static int i = 2 || 1 / 0;
            </d:code>the expression is a valid integer constant expression with value one.</d:para>
        </d:footnote></d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> array declarators (Array declarators), initialization
        (Initialization).</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Declarations</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Constraints</emphasis></d:para>
      <d:para>A declaration shall declare at least a declarator (other than the parameters of a
        function or the members of a structure or union), a tag, or the members of an
        enumeration.</d:para>
      <d:para>If an identifier has no linkage, there shall be no more than one declaration of the
        identifier (in a declarator or type specifier) with the same scope and in the same name
        space, except for tags as specified in Tags.</d:para>
      <d:para>All declarations in the same scope that refer to the same object or function shall
        specify compatible types.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>A declaration specifies the interpretation and attributes of a set of identifiers. A
        definition of an identifier is a declaration for that identifier that:</d:para>
      <d:itemizedlist>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">for an object, causes storage to be reserved
            for that object;</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">for a function, includes the function body;<footnote>
              <para>Function definitions have a different syntax, described in Function
                definitions.</para>
            </footnote></para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">for an enumeration constant or typedef name,
            is the (only) declaration of the identifier.</para>
        </d:listitem>
      </d:itemizedlist>
      <d:para>The declaration specifiers consist of a sequence of specifiers that indicate the
        linkage, storage duration, and part of the type of the entities that the declarators denote.
        The init- declarator-list is a comma-separated sequence of declarators, each of which may
        have additional type information, or an initializer, or both. The declarators contain the
        identifiers (if any) being declared.</d:para>
      <d:para>If an identifier for an object is declared with no linkage, the type for the object
        shall be complete by the end of its declarator, or by the end of its init-declarator if it
        has an initializer; in the case of function parameters (including in prototypes), it is the
        adjusted type (see Function declarators (including prototypes)) that is required to be
        complete.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> declarators (Declarators), enumeration specifiers (Enumeration
        specifiers), initialization (Initialization).</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Storage-class specifiers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>At most, one storage-class specifier may be given in the declaration specifiers in a
          declaration.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The typedef specifier is called a “storage-class specifier” for syntactic
          convenience only; it is discussed in Type definitions. The meanings of the various
          linkages and storage durations were discussed in Linkages of identifiers and Storage
          duration of objects.</d:para>
        <d:para>A declaration of an identifier for an object with storage-class specifier
            <d:code>register</d:code> suggests that access to the object be as fast as possible. The
          extent to which such suggestions are effective is implementation-defined.<d:footnote>
            <d:para>The implementation may treat any <d:code>register</d:code> declaration simply as
              an auto declaration. However, whether or not addressable storage is actually used, the
              address of any part of an object declared with storage-class specifier register cannot
              be computed, either explicitly (by use of the unary &amp; operator as discussed in
              Address and indirection operators) or implicitly (by converting an array name to a
              pointer as discussed in :ref:14.3.2.1`). Thus, the only operator that can be applied
              to an array declared with storage-class specifier <d:code>register</d:code> is
                <d:code>sizeof</d:code>.</d:para>
          </d:footnote></d:para>
        <d:para>The declaration of an identifier for a function that has block scope shall have no
          explicit storage-class specifier other than <d:code>extern</d:code>.</d:para>
        <d:para>If an aggregate or union object is declared with a storage-class specifier other
          than <d:code>typedef</d:code>, the properties resulting from the storage-class specifier,
          except with respect to linkage, also apply to the members of the object, and so on
          recursively for any aggregate or union member objects.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> type definitions (Type definitions).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Type specifiers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>At least one type specifier shall be given in the declaration specifiers in each
          declaration, and in the specifier-qualifier list in each struct declaration and type name.
          Each list of type specifiers shall be one of the following sets (delimited by commas, when
          there is more than one set on a line); the type specifiers may occur in any order,
          possibly intermixed with the other declaration specifiers.</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>void</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>char</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>signed char</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned char</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>short, signed short, short int</code>
              or <code>signed short int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned short</code> or
                <code>unsigned short int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>int, signed</code> or <code>signed
                int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned</code> or <code>unsigned
                int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long, signed long, long int</code> or
                <code>signed long int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned long</code> or <code>unsigned
                long int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long long, signed long long, long long
                int</code> or <code>signed long long int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned long long</code> or
                <code>unsigned long long int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>float</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>double</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long double</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>_Bool</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>float _Complex</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>double _Complex</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long double _Complex</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>struct</code> or <code>union</code>
              specifier</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>enum</code> specifier</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>typedef</code> name </para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>The type specifier <d:code>_Complex</d:code> shall not be used if the implementation
          does not provide complex types.<d:footnote>
            <d:para>Freestanding implementations are not required to provide complex types.</d:para>
          </d:footnote></d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>Specifiers for structures, unions, and enumerations are discussed in Structure and
          union specifiers through Tags. Declarations of typedef names are discussed in Type
          definitions. The characteristics of the other types are discussed in Types.</d:para>
        <d:para>Each of the comma-separated sets designates the same type, except that for
          bit-fields, it is implementation-defined whether the specifier int designates the same
          type as <d:code>signed int</d:code> or the same type as <d:code>unsigned
          int</d:code>.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> enumeration specifiers (Enumeration specifiers), structure and
          union specifiers (Structure and union specifiers), tags (Tags), type definitions (Type
          definitions).</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Structure and union specifiers</title>
          <d:para>A structure or union shall not contain a member with incomplete or function type
            (hence, a structure shall not contain an instance of itself, but may contain a pointer
            to an instance of itself), except that the last member of a structure with more than one
            named member may have incomplete array type; such a structure (and any union containing,
            possibly recursively, a member that is such a structure) shall not be a member of a
            structure or an element of an array.</d:para>
          <d:para>The expression that specifies the width of a bit-field shall be an integer
            constant expression with a nonnegative value that does not exceed the width of an object
            of the type that would be specified were the colon and expression omitted. If the value
            is zero, the declaration shall have no declarator.</d:para>
          <d:para>A bit-field shall have a type that is a qualified or unqualified version of
              <d:code>_Bool, signed int, unsigned int</d:code> or some other implementation-defined
            type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>As discussed in Types, a structure is a type consisting of a sequence of members,
            whose storage is allocated in an ordered sequence, and a union is a type consisting of a
            sequence of members whose storage overlap.</d:para>
          <d:para>Structure and union specifiers have the same form.</d:para>
          <d:para>The presence of a struct-declaration-list in a struct-or-union-specifier declares
            a new type, within a translation unit. The struct-declaration-list is a sequence of
            declarations for the members of the structure or union. If the struct-declaration-list
            contains no named members, the behavior is undefined. The type is incomplete until after
            the <d:code>}</d:code> that terminates the list.</d:para>
          <d:para>A member of a structure or union may have any object type other than a variably
            modified type.<d:footnote>
              <d:para>A structure or union can not contain a member with a variably modified type
                because member names are not ordinary identifiers as defined in Name Spaces of the
                Identifiers.</d:para>
            </d:footnote> In addition, a member may be declared to consist of a specified number of
            bits (including a sign bit, if any). Such a member is called a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">bit-field</emphasis>;<d:footnote>
              <d:para>The unary <d:code>&amp;</d:code> (address-of) operator cannot be applied to a
                bit-field object; thus, there are no pointers to or arrays of bit-field
                objects.</d:para>
            </d:footnote> its width is preceded by a colon.</d:para>
          <d:para>A bit-field is interpreted as a signed or unsigned integer type consisting of the
            specified number of bits.<d:footnote>
              <d:para>As specified in Type specifiers above, if the actual type specifier used is
                  <d:code>int</d:code> or a typedef-name defined as <d:code>int</d:code>, then it is
                implementation-defined whether the bit-field is signed or unsigned.</d:para>
            </d:footnote> If the value 0 or 1 is stored into a nonzero-width bit-field of type
              <d:code>_Bool</d:code>, the value of the bit-field shall compare equal to the value
            stored.</d:para>
          <d:para>An implementation may allocate any addressable storage unit large enough to hold a
            bit- field. If enough space remains, a bit-field that immediately follows another
            bit-field in a structure shall be packed into adjacent bits of the same unit. If
            insufficient space remains, whether a bit-field that does not fit is put into the next
            unit or overlaps adjacent units is implementation-defined. The order of allocation of
            bit-fields within a unit (high-order to low-order or low-order to high-order) is
            implementation-defined. The alignment of the addressable storage unit is
            unspecified.</d:para>
          <d:para>A bit-field declaration with no declarator, but only a colon and a width,
            indicates an unnamed bit-field.<d:footnote>
              <d:para>An unnamed bit-field structure member is useful for padding to conform to
                externally imposed layouts.</d:para>
            </d:footnote>As a special case, a bit-field structure member with a width of 0 indicates
            that no further bit-field is to be packed into the unit in which the previous bit-
            field, if any, was placed.</d:para>
          <d:para>Each non-bit-field member of a structure or union object is aligned in an
            implementation- defined manner appropriate to its type.</d:para>
          <d:para>Within a structure object, the non-bit-field members and the units in which
            bit-fields reside have addresses that increase in the order in which they are declared.
            A pointer to a structure object, suitably converted, points to its initial member (or if
            that member is a bit-field, then to the unit in which it resides), and vice versa. There
            may be unnamed padding within a structure object, but not at its beginning.</d:para>
          <d:para>The size of a union is sufficient to contain the largest of its members. The value
            of at most one of the members can be stored in a union object at any time. A pointer to
            a union object, suitably converted, points to each of its members (or if a member is a
            bit- field, then to the unit in which it resides), and vice versa.</d:para>
          <d:para>There may be unnamed padding at the end of a structure or union.</d:para>
          <d:para>As a special case, the last element of a structure with more than one named member
            may have an incomplete array type; this is called a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">flexible array member</emphasis>.
            In most situations, the flexible array member is ignored. In particular, the size of the
            structure is as if the flexible array member were omitted except that it may have more
            trailing padding than the omission would imply. However, when a <d:code>.</d:code> (or
              <d:code>-></d:code>) operator has a left operand that is (a pointer to) a structure
            with a flexible array member and the right operand names that member, it behaves as if
            that member were replaced with the longest array (with the same element type) that would
            not make the structure larger than the object being accessed; the offset of the array
            shall remain that of the flexible array member, even if this would differ from that of
            the replacement array. If this array would have no elements, it behaves as if it had one
            element but the behavior is undefined if any attempt is made to access that element or
            to generate a pointer one past it.</d:para>
          <d:para>EXAMPLE After the declaration:</d:para>
          <d:programlisting role="CLexer">struct s { int n; double d[]; };</d:programlisting>
          <d:para>the structure struct s has a flexible array member d. A typical way to use this
            is:</d:para>
          <d:programlisting role="CLexer">int m = /* some value */;
struct s *p = malloc(sizeof (struct s) + sizeof (double [m]));</d:programlisting>
          <d:para>and assuming that the call to malloc succeeds, the object pointed to by p behaves,
            for most purposes, as if p had been declared as:</d:para>
          <d:programlisting role="CLexer">struct { int n; double d[m]; } *p;</d:programlisting>
          <d:para>(there are circumstances in which this equivalence is broken; in particular, the
            offsets of member d might not be the same).</d:para>
          <d:para>Following the above declaration:</d:para>
          <d:programlisting role="CLexer">struct s t1 = { 0 };         // valid
struct s t2 = { 1, { 4.2 }}; // invalid
t1.n = 4;                    // valid
t1.d[0] = 4.2;               // might be undefined behavior</d:programlisting>
          <d:para>The initialization of <d:code>t2</d:code> is invalid (and violates a constraint)
            because <d:code>struct s</d:code> is treated as if it did not contain member
              <d:code>d</d:code>. The assignment to <d:code>t1.d[0]</d:code> is probably undefined
            behavior, but it is possible that</d:para>
          <d:programlisting role="CLexer">sizeof (struct s) >= offsetof(struct s, d) + sizeof (double)</d:programlisting>
          <d:para>in which case the assignment would be legitimate. Nevertheless, it cannot appear
            in strictly conforming code. After the further declaration:</d:para>
          <d:programlisting role="CLexer">struct ss { int n; };
the expressions:
sizeof (struct s) >= sizeof (struct ss)
sizeof (struct s) >= offsetof(struct s, d)</d:programlisting>
          <d:para>are always equal to 1.</d:para>
          <d:para>If <d:code>sizeof (double)</d:code> is 8, then after the following code is
            executed:</d:para>
          <d:programlisting role="CLexer">struct s *s1;
struct s *s2;
s1 = malloc(sizeof (struct s) + 64);
s2 = malloc(sizeof (struct s) + 46);</d:programlisting>
          <d:para>and assuming that the calls to <d:code>malloc</d:code> succeed, the objects
            pointed to by <d:code>s1</d:code> and <d:code>s2</d:code> behave, for most purposes, as
            if the identifiers had been declared as:</d:para>
          <d:programlisting role="CLexer">struct { int n; double d[8]; } *s1;
struct { int n; double d[5]; } *s2;</d:programlisting>
          <d:para>Following the further successful assignments:</d:para>
          <d:programlisting role="CLexer">s1 = malloc(sizeof (struct s) + 10);
s2 = malloc(sizeof (struct s) + 6);</d:programlisting>
          <d:para>they then behave as if the declarations were:</d:para>
          <d:programlisting role="CLexer">struct { int n; double d[1]; } *s1, *s2;</d:programlisting>
          <d:para>and:</d:para>
          <d:programlisting role="CLexer">double *dp;
dp = &amp;(s1->d[0]); // valid
*dp = 42;         // valid
dp = &amp;(s2->d[0]); // valid
*dp = 42;         // undefined behavior</d:programlisting>
          <d:para>The assignment:</d:para>
          <d:programlisting>*s1 = *s2;</d:programlisting>
          <d:para>only copies the member <d:code>n</d:code>; if any of the array elements are within
            the first <d:code>sizeof (struct s)</d:code> bytes of the structure, they might be
            copied or simply overwritten with indeterminate values.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> tags (Tags).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Enumeration specifiers</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The expression that defines the value of an enumeration constant shall be an
            integer constant expression that has a value representable as an
            <d:code>int</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The identifiers in an enumerator list are declared as constants that have type int
            and may appear wherever such are permitted.<d:footnote>
              <d:para>Thus, the identifiers of enumeration constants declared in the same scope
                shall all be distinct from each other and from other identifiers declared in
                ordinary declarators.</d:para>
            </d:footnote> An enumerator with = defines its enumeration constant as the value of the
            constant expression. If the first enumerator has no =, the value of its enumeration
            constant is 0. Each subsequent enumerator with no = defines its enumeration constant as
            the value of the constant expression obtained by adding 1 to the value of the previous
            enumeration constant. (The use of enumerators with = may produce enumeration constants
            with values that duplicate other values in the same enumeration.) The enumerators of an
            enumeration are also known as its members.</d:para>
          <d:para>Each enumerated type shall be compatible with char, a signed integer type, or an
            unsigned integer type. The choice of type is implementation-defined,<d:footnote>
              <d:para>An implementation may delay the choice of which integer type until all
                enumeration constants have been seen.</d:para>
            </d:footnote> but shall be capable of representing the values of all the members of the
            enumeration. The enumerated type is incomplete until after the } that terminates the
            list of enumerator declarations.</d:para>
          <d:para>The following fragment:</d:para>
          <d:programlisting role="CLexer">enum hue { chartreuse, burgundy, claret=20, winedark };
enum hue col, *cp;
col = claret;
cp = &amp;col;
if (*cp != burgundy)
/* ... */</d:programlisting>
          <d:para>makes <d:code>hue</d:code> the tag of an enumeration, and then declares
              <d:code>col</d:code> as an object that has that type and <d:code>cp</d:code> as a
            pointer to an object that has that type. The enumerated values are in the set <d:code>{
              0, 1, 20, 21 }</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> tags (Tags).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Tags</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>A specific type shall have its content defined at most once.</d:para>
          <d:para>A type specifier of the form:</d:para>
          <d:programlisting>enum *identifier*</d:programlisting>
          <d:para>without an enumerator list shall only appear after the type it specifies is
            complete.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>All declarations of structure, union, or enumerated types that have the same scope
            and use the same tag declare the same type. The type is incomplete<d:footnote>
              <d:para>An incomplete type may only by used when the size of an object of that type is
                not needed. It is not needed, for example, when a typedef name is declared to be a
                specifier for a structure or union, or when a pointer to or a function returning a
                structure or union is being declared. (See incomplete types in Types.) The
                specification has to be complete before such a function is called or
                defined.</d:para>
            </d:footnote> until the closing brace of the list defining the content, and complete
            thereafter.</d:para>
          <d:para>Two declarations of structure, union, or enumerated types which are in different
            scopes or use different tags declare distinct types. Each declaration of a structure,
            union, or enumerated type which does not include a tag declares a distinct
            type.</d:para>
          <d:para>A type specifier of the form:</d:para>
          <d:programlisting>struct-or-union identifier(optional) { struct-declaration-list }</d:programlisting>
          <d:para>or:</d:para>
          <d:programlisting>enum identifier { enumerator-list }</d:programlisting>
          <d:para>or:</d:para>
          <d:programlisting>enum identifier { enumerator-list , }</d:programlisting>
          <d:para>declares a structure, union, or enumerated type. The list defines the <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">structure content, union
              content</emphasis> or <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >enumeration content</emphasis>. If an identifier is provided,<d:footnote>
              <d:para>If there is no identifier, the type can, within the translation unit, only be
                referred to by the declaration of which it is a part. Of course, when the
                declaration is of a typedef name, subsequent declarations can make use of that
                typedef name to declare objects having the specified structure, union, or enumerated
                type.</d:para>
            </d:footnote> the type specifier also declares the identifier to be the tag of that
            type.</d:para>
          <d:para>A declaration of the form:</d:para>
          <d:programlisting>struct-or-union identifier ;</d:programlisting>
          <d:para>specifies a structure or union type and declares the identifier as a tag of that
              type.<d:footnote xml:id="b">
              <d:para>A similar construction with <d:code>enum</d:code> does not exist.</d:para>
            </d:footnote></d:para>
          <d:para>If a type specifier of the form:</d:para>
          <d:programlisting>struct-or-union identifier</d:programlisting>
          <d:para>occurs other than as part of one of the above forms, and no other declaration of
            the identifier as a tag is visible, then it declares an incomplete structure or union
            type, and declares the identifier as the tag of that type.<d:footnoteref linkend="b"
            /></d:para>
          <d:para>If a type specifier of the form:</d:para>
          <d:programlisting>struct-or-union identifier</d:programlisting>
          <d:para>or:</d:para>
          <d:programlisting>enum specifier</d:programlisting>
          <d:para>occurs other than as part of one of the above forms, and a declaration of the
            identifier as a tag is visible, then it specifies the same type as that other
            declaration, and does not redeclare the tag.</d:para>
          <d:para>EXAMPLE 1 This mechanism allows declaration of a self-referential
            structure.</d:para>
          <d:programlisting role="CLexer">struct tnode {
  int count;
  struct tnode *left, *right;
};</d:programlisting>
          <d:para>specifies a structure that contains an integer and two pointers to objects of the
            same type. Once this declaration has been given, the declaration</d:para>
          <d:programlisting role="CLexer">struct tnode s, *sp;</d:programlisting>
          <d:para>declares <d:code>s</d:code> to be an object of the given type and
              <d:code>sp</d:code> to be a pointer to an object of the given type. With these
            declarations, the expression <d:code>sp->left</d:code> refers to the <d:code>left struct
              tnode</d:code> pointer of the object to which sp points; the expression
              <d:code>s.right->count</d:code> designates the count member of the <d:code>right
              struct tnode</d:code> pointed to from <d:code>s</d:code>.</d:para>
          <d:para>The following alternative formulation uses the typedef mechanism:</d:para>
          <d:programlisting role="CLexer">typedef struct tnode TNODE;
struct tnode {
  int count;
  TNODE *left, *right;
};
TNODE s, *sp;</d:programlisting>
          <d:para>EXAMPLE 2 To illustrate the use of prior declaration of a tag to specify a pair of
            mutually referential structures, the declarations</d:para>
          <d:programlisting role="CLexer">struct s1 { struct s2 *s2p; /* ... */ }; // D1
struct s2 { struct s1 *s1p; /* ... */ }; // D2</d:programlisting>
          <d:para>specify a pair of structures that contain pointers to each other. Note, however,
            that if <d:code>s2</d:code> were already declared as a tag in an enclosing scope, the
            declaration <d:code>D1</d:code> would refer to it, not to the tag <d:code>s2</d:code>
            declared in <d:code>D2</d:code>. To eliminate this context sensitivity, the
            declaration</d:para>
          <d:programlisting role="CLexer">struct s2;</d:programlisting>
          <d:para>may be inserted ahead of <d:code>D1</d:code>. This declares a new tag
              <d:code>s2</d:code> in the inner scope; the declaration <d:code>D2</d:code> then
            completes the specification of the new type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> declarators (Declarators), array declarators (Array
            declarators), type definitions (Type definitions).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Type qualifiers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Types other than pointer types derived from object or incomplete types shall not be
          restrict-qualified.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The properties associated with qualified types are meaningful only for expressions
          that are lvalues.<d:footnote>
            <d:para>The implementation may place a const object that is not
                <d:code>volatile</d:code> in a read-only region of storage. Moreover, the
              implementation need not allocate storage for such an object if its address is never
              used.</d:para>
          </d:footnote></d:para>
        <d:para>If the same qualifier appears more than once in the same <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">specifier-qualifier-list</emphasis>,
          either directly or via one or more typedefs, the behavior is the same as if it appeared
          only once. If an attempt is made to modify an object defined with a const-qualified type
          through use of an lvalue with non-const-qualified type, the behavior is
          undefined.</d:para>
        <d:para>If an attempt is made to refer to an object defined with a volatile-qualified type
          through use of an lvalue with non-volatile-qualified type, the behavior is undefined.<d:footnote>
            <d:para>This applies to those objects that behave as if they were defined with qualified
              types, even if they are never actually defined as objects in the program (such as an
              object at a memory-mapped input/output address).</d:para>
          </d:footnote></d:para>
        <d:para>An object that has volatile-qualified type may be modified in ways unknown to the
          implementation or have other unknown side effects. Therefore any expression referring to
          such an object shall be evaluated strictly according to the rules of the abstract machine,
          as described in Program Execution. Furthermore, at every sequence point the value last
          stored in the object shall agree with that prescribed by the abstract machine, except as
          modified by the unknown factors mentioned previously.<d:footnote>
            <d:para>A <d:code>volatile</d:code> declaration may be used to describe an object
              corresponding to a memory-mapped input/output port or an object accessed by an
              asynchronously interrupting function. Actions on objects so declared shall not be
              “optimized out” by an implementation or reordered except as permitted by the rules for
              evaluating expressions.</d:para>
          </d:footnote> What constitutes an access to an object that has volatile-qualified type is
          implementation-defined.</d:para>
        <d:para>An object that is accessed through a restrict-qualified pointer has a special
          association with that pointer. This association, defined in Formal definition of restrict
          below, requires that all accesses to that object use, directly or indirectly, the value of
          that particular pointer.<d:footnote>
            <d:para>For example, a statement that assigns a value returned by malloc to a single
              pointer establishes this association between the allocated object and the
              pointer.</d:para>
          </d:footnote> The intended use of the <d:code>restrict</d:code> qualifier (like the
            <d:code>register</d:code> storage class) is to promote optimization, and deleting all
          instances of the qualifier from all preprocessing translation units composing a conforming
          program does not change its meaning (i.e., observable behavior).</d:para>
        <d:para>If the specification of an array type includes any type qualifiers, the element type
          is so- qualified, not the array type. If the specification of a function type includes any
          type qualifiers, the behavior is undefined.<d:footnote>
            <d:para>Both of these can occur through the use of typedefs.</d:para>
          </d:footnote></d:para>
        <d:para>For two qualified types to be compatible, both shall have the identically qualified
          version of a compatible type; the order of type qualifiers within a list of specifiers or
          qualifiers does not affect the specified type.</d:para>
        <d:para>EXAMPLE 1 An object declared</d:para>
        <d:programlisting role="CLexer">extern const volatile int real_time_clock;</d:programlisting>
        <d:para>may be modifiable by hardware, but cannot be assigned to, incremented, or
          decremented.</d:para>
        <d:para>EXAMPLE 2 The following declarations and expressions illustrate the behavior when
          type qualifiers modify an aggregate type:</d:para>
        <d:programlisting role="CLexer">const struct s { int mem; } cs = { 1 };
struct s ncs; // the object ncs is modifiable
typedef int A[2][3];
const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const int
int *pi;
const int *pci;

ncs = cs;       // valid
cs = ncs;       // violates modifiable lvalue constraint for =
pi = &amp;ncs.mem;  // valid
pi = &amp;cs.mem;   // violates type constraints for =
pci = &amp;cs.mem;  // valid
pi = a[0];      // nvalid: a[0] has type "const int *"</d:programlisting>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Formal definition of restrict</title>
          <d:para>Let <d:code>D</d:code> be a declaration of an ordinary identifier that provides a
            means of designating an object <d:code>P</d:code> as a restrict-qualified pointer to
            type <d:code>T</d:code>.</d:para>
          <d:para>If <d:code>D</d:code> appears inside a block and does not have storage class
              <d:code>extern</d:code>, let <d:code>B</d:code> denote the block. If
              <d:code>D</d:code> appears in the list of parameter declarations of a function
            definition, let <d:code>B</d:code> denote the associated block. Otherwise, let
              <d:code>B</d:code> denote the block of main (or the block of whatever function is
            called at program startup in a freestanding environment).</d:para>
          <d:para>In what follows, a pointer expression <d:code>E</d:code> is said to be based on
            object <d:code>P</d:code> if (at some sequence point in the execution of
              <d:code>B</d:code> prior to the evaluation of <d:code>E</d:code>) modifying
              <d:code>P</d:code> to point to a copy of the array object into which it formerly
            pointed would change the value of <d:code>E</d:code>.<d:footnote>
              <d:para>In other words, <d:code>E</d:code> depends on the value of <d:code>P</d:code>
                itself rather than on the value of an object referenced indirectly through
                  <d:code>P</d:code>. For example, if identifier <d:code>p</d:code> has type
                  (<d:code>int **restrict</d:code>), then the pointer expressions <d:code>p</d:code>
                and <d:code>p+1</d:code> are based on the restricted pointer object designated by
                  <d:code>p</d:code>, but the pointer expressions <d:code>*p</d:code> and
                  <d:code>p[1]</d:code> are not.</d:para>
            </d:footnote> Note that “based” is defined only for expressions with pointer
            types.</d:para>
          <d:para>During each execution of <d:code>B</d:code>, let <d:code>L</d:code> be any lvalue
            that has <d:code>&amp;L</d:code> based on <d:code>P</d:code>. If L is used to access the
            value of the object <d:code>X</d:code> that it designates, and <d:code>X</d:code> is
            also modified (by any means), then the following requirements apply: <d:code>T</d:code>
            shall not be const-qualified. Every other lvalue used to access the value of
              <d:code>X</d:code> shall also have its address based on <d:code>P</d:code>. Every
            access that modifies <d:code>X</d:code> shall be considered also to modify
              <d:code>P</d:code>, for the purposes of this subclause. If <d:code>P</d:code> is
            assigned the value of a pointer expression <d:code>E</d:code> that is based on another
            restricted pointer object <d:code>P2</d:code>, associated with block
            <d:code>B2</d:code>, then either the execution of <d:code>B2</d:code> shall begin before
            the execution of <d:code>B</d:code>, or the execution of <d:code>B2</d:code> shall end
            prior to the assignment. If these requirements are not met, then the behavior is
            undefined.</d:para>
          <d:para>Here an execution of <d:code>B</d:code> means that portion of the execution of the
            program that would correspond to the lifetime of an object with scalar type and
            automatic storage duration ssociated with <d:code>B</d:code>.</d:para>
          <d:para>A translator is free to ignore any or all aliasing implications of uses of
            restrict.</d:para>
          <d:para>EXAMPLE 1 The file scope declarations</d:para>
          <d:programlisting role="CLexer">int * restrict a;
int * restrict b;
extern int c[];</d:programlisting>
          <d:para>assert that if an object is accessed using one of <d:code>a, b</d:code> or
              <d:code>c</d:code>, and that object is modified anywhere in the program, then it is
            never accessed using either of the other two.</d:para>
          <d:para>EXAMPLE 2 The function parameter declarations in the following example</d:para>
          <d:programlisting role="CLexer">void f(int n, int * restrict p, int * restrict q)
{
  while (n-- > 0)
  *p++ = *q++;
}</d:programlisting>
          <d:para>assert that, during each execution of the function, if an object is accessed
            through one of the pointer parameters, then it is not also accessed through the
            other.</d:para>
          <d:para>The benefit of the restrict qualifiers is that they enable a translator to make an
            effective dependence analysis of function <d:code>f</d:code> without examining any of
            the calls of <d:code>f</d:code> in the program. The cost is that the programmer has to
            examine all of those calls to ensure that none give undefined behavior. For example, the
            second call of <d:code>f</d:code> in <d:code>g</d:code> has undefined behavior because
            each of <d:code>d[1]</d:code> through <d:code>d[49]</d:code> is accessed through both
              <d:code>p</d:code> and <d:code>q</d:code>.</d:para>
          <d:programlisting role="CLexer">void g(void)
{
  extern int d[100];
  f(50, d + 50, d); // valid
  f(50, d + 1, d); // undefined behavior
}</d:programlisting>
          <d:para>EXAMPLE 3 The function parameter declarations</d:para>
          <d:programlisting role="CLexer">void h(int n, int * restrict p, int * restrict q, int * restrict r)
{
  int i;
  for (i = 0; i &lt; n; i++)
  p[i] = q[i] + r[i];
}</d:programlisting>
          <d:para>illustrate how an unmodified object can be aliased through two restricted
            pointers. In particular, if <d:code>a</d:code> and <d:code>b</d:code> are disjoint
            arrays, a call of the form <d:code>h(100, a, b, b)</d:code> has defined behavior,
            because array <d:code>b</d:code> is not modified within function
            <d:code>h</d:code>.</d:para>
          <d:para>EXAMPLE 4 The rule limiting assignments between restricted pointers does not
            distinguish between a function call and an equivalent nested block. With one exception,
            only “outer-to-inner” assignments between restricted pointers declared in nested blocks
            have defined behavior.</d:para>
          <d:programlisting role="CLexer">{
  int * restrict p1;
  int * restrict q1;
  p1 = q1; // undefined behavior
  {
    int * restrict p2 = p1; // valid
    int * restrict q2 = q1; // valid
    p1 = q2;                // undefined behavior
    p2 = q2;                // undefined behavior
  }
}</d:programlisting>
          <d:para>The one exception allows the value of a restricted pointer to be carried out of
            the block in which it (or, more precisely, the ordinary identifier used to designate it)
            is declared when that block finishes execution. For example, this permits
              <d:code>new_vector</d:code> to return a <d:code>vector</d:code>.</d:para>
          <d:programlisting role="CLexer">typedef struct { int n; float * restrict v; } vector;
vector new_vector(int n)
{
  vector t;
  t.n = n;
  t.v = malloc(n * sizeof (float));
  return t;
}</d:programlisting>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Function specifiers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Function specifiers shall be used only in the declaration of an identifier for a
          function.</d:para>
        <d:para>An <d:code>inline</d:code> definition of a function with external linkage shall not
          contain a definition of a modifiable object with static storage duration, and shall not
          contain a reference to an identifier with internal linkage.</d:para>
        <d:para>In a hosted environment, the inline function specifier shall not appear in a
          declaration of <d:code>main</d:code>.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A function declared with an <d:code>inline</d:code> function specifier is an
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">inline
          function</emphasis>. The function specifier may appear more than once; the behavior is the
          same as if it appeared only once. Making a function an inline function suggests that calls
          to the function be as fast as possible.<d:footnote>
            <d:para>By using, for example, an alternative to the usual function call mechanism, such
              as “inline substitution”. Inline substitution is not textual substitution, nor does it
              create a new function. Therefore, for example, the expansion of a macro used within
              the body of the function uses the definition it had at the point the function body
              appears, and not where the function is called; and identifiers refer to the
              declarations in scope where the body occurs. Likewise, the function has a single
              address, regardless of the number of inline definitions that occur in addition to the
              external definition.</d:para>
          </d:footnote> The extent to which such suggestions are effective is implementation-defined.<d:footnote>
            <d:para>For example, an implementation might never perform inline substitution, or might
              only perform inline substitutions to calls in the scope of an inline
              declaration.</d:para>
          </d:footnote></d:para>
        <d:para>Any function with internal linkage can be an inline function. For a function with
          external linkage, the following restrictions apply: If a function is declared with an
            <d:code>inline</d:code> function specifier, then it shall also be defined in the same
          translation unit. If all of the file scope declarations for a function in a translation
          unit include the <d:code>inline</d:code> function specifier without
            <d:code>extern</d:code>, then the definition in that translation unit is an <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">inline definition</emphasis>. An
          inline definition does not provide an external definition for the function, and does not
          forbid an external definition in another translation unit. An inline definition provides
          an alternative to an external definition, which a translator may use to implement any call
          to the function in the same translation unit. It is unspecified whether a call to the
          function uses the inline definition or the external definition.<d:footnote>
            <d:para>Since an inline definition is distinct from the corresponding external
              definition and from any other corresponding inline definitions in other translation
              units, all corresponding objects with static storage duration are also distinct in
              each of the definitions.</d:para>
          </d:footnote></d:para>
        <d:para>EXAMPLE The declaration of an inline function with external linkage can result in
          either an external definition, or a definition available for use only within the
          translation unit. A file scope declaration with extern creates an
            <d:code>external</d:code> definition. The following example shows an entire translation
          unit.</d:para>
        <d:programlisting role="CLexer">inline double fahr(double t)
{
  return (9.0 * t) / 5.0 + 32.0;
}
inline double cels(double t)
{
  return (5.0 * (t - 32.0)) / 9.0;
}
extern double fahr(double);
// creates an external definition
double convert(int is_fahr, double temp)
{
  /* A translator may perform inline substitutions */
  return is_fahr ? cels(temp) : fahr(temp);
}</d:programlisting>
        <d:para>Note that the definition of <d:code>fahr</d:code> is an external definition because
            <d:code>fahr</d:code> is also declared with <d:code>extern</d:code>, but the definition
          of <d:code>cels</d:code> is an inline definition. Because <d:code>cels</d:code> has
          external linkage and is referenced, an external definition has to appear in another
          translation unit (see External definitions); the inline definition and the external
          definition are distinct and either may be used for the call.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> function definitions (Function definitions).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Declarators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each declarator declares one identifier, and asserts that when an operand of the
          same form as the declarator appears in an expression, it designates a function or object
          with the scope, storage duration, and type indicated by the declaration
          specifiers.</d:para>
        <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">full
            declarator</emphasis> is a declarator that is not part of another declarator. The end of
          a full declarator is a sequence point. If the nested sequence of declarators in a full
          declarator contains a variable length array type, the type specified by the full
          declarator is said to be <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >variably modified</emphasis>.</d:para>
        <d:para>In the following subclauses, consider a declaration:</d:para>
        <d:programlisting>T D1</d:programlisting>
        <d:para>where <d:code>T</d:code> contains the declaration specifiers that specify a type
            <d:code>T</d:code> (such as <d:code>int</d:code>) and <d:code>D1</d:code> is a
          declarator that contains an identifier ident. The type specified for the identifier ident
          in the various forms of declarator is described inductively using this notation. If, in
          the declaration "<d:code>T D1</d:code>", <d:code>D1</d:code> has the form:</d:para>
        <d:programlisting>identifier</d:programlisting>
        <d:para>then the type specified for ident is <d:code>T</d:code>. If, in the declaration
            "<d:code>T D1</d:code>", <d:code>D1</d:code> has the form:</d:para>
        <d:programlisting>( D )</d:programlisting>
        <d:para>then ident has the type specified by the declaration “<d:code>T D</d:code>”. Thus, a
          declarator in parentheses is identical to the unparenthesized declarator, but the binding
          of complicated declarators may be altered by parentheses.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Implementation
            limits</emphasis></d:para>
        <d:para>As discussed in Translation limits, an implementation may limit the number of
          pointer, array, and function declarators that modify an arithmetic, structure, union, or
          incomplete type, either directly or via one or more typedefs.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> array declarators (Array declarators), type definitions (Type
          definitions).</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Pointer declarators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>If, in the declaration "<d:code>T D1</d:code>", <d:code>D1</d:code> has the
            form:</d:para>
          <d:programlisting>* type-qualifier-listopt D</d:programlisting>
          <d:para>and the type specified for ident in the declaration "<d:code>T D</d:code>" is
            “derived-declarator-type-list <d:code>T</d:code>”, then the type specified for ident is
            “derived-declarator-type-list type-qualifier-list pointer to <d:code>T</d:code>”. For
            each type qualifier in the list, ident is a so-qualified pointer.</d:para>
          <d:para>For two pointer types to be compatible, both shall be identically qualified and
            both shall be pointers to compatible types.</d:para>
          <d:para>EXAMPLE The following pair of declarations demonstrates the difference between a
            “variable pointer to a constant value” and a “constant pointer to a variable
            value”.</d:para>
          <d:programlisting role="CLexer">const int *ptr_to_constant;
int *const constant_ptr;</d:programlisting>
          <d:para>The contents of any object pointed to by <d:code>ptr_to_constant</d:code> shall
            not be modified through that pointer, but <d:code>ptr_to_constant</d:code> itself may be
            changed to point to another object. Similarly, the contents of the int pointed to by
              <d:code>constant_ptr</d:code> may be modified, but <d:code>constant_ptr</d:code>
            itself shall always point to the same location. The declaration of the constant pointer
              <d:code>constant_ptr</d:code> may be clarified by including a definition for the type
            “pointer to <d:code>int</d:code>”.</d:para>
          <d:programlisting role="CLexer">typedef int *int_ptr;
const int_ptr constant_ptr;</d:programlisting>
          <d:para>declares <d:code>constant_ptr</d:code> as an object that has type “const-qualified
            pointer to <d:code>int</d:code>”.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Array declarators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>In addition to optional type qualifiers and the keyword <d:code>static</d:code>,
            the <d:code>[</d:code> and <d:code>]</d:code> may delimit an expression or
              <d:code>*</d:code>. If they delimit an expression (which specifies the size of an
            array), the expression shall have an integer type. If the expression is a constant
            expression, it shall have a value greater than zero. The element type shall not be an
            incomplete or function type. The optional type qualifiers and the keyword
              <d:code>static</d:code> shall appear only in a declaration of a function parameter
            with an array type, and then only in the outermost array type derivation.</d:para>
          <d:para>Only an ordinary identifier (as defined in 6.2.3) with both block scope or
            function prototype scope and no linkage shall have a variably modified type. If an
            identifier is declared to be an object with static storage duration, it shall not have a
            variable length array type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>If, in the declaration "<d:code>T D1</d:code>", <d:code>D1</d:code> has one of the
            forms:</d:para>
          <d:programlisting>D[ type-qualifier-listopt assignment-expressionopt ]
D[ static type-qualifier-list(opt) assignment-expression ]
D[ type-qualifier-list static assignment-expression ]
D[ type-qualifier-listopt * ]</d:programlisting>
          <d:para>and the type specified for ident in the declaration "<d:code>T D</d:code>" is
            “derived-declarator-type-list <d:code>T</d:code>”, then the type specified for ident is
            “derived-declarator-type-list array of <d:code>T</d:code>”.<d:footnote>
              <d:para>When several “array of” specifications are adjacent, a multidimensional array
                is declared.</d:para>
            </d:footnote> (See Function declarators (including prototypes) for the meaning of the
            optional type qualifiers and the keyword <d:code>static</d:code>.)</d:para>
          <d:para>If the size is not present, the array type is an incomplete type. If the size is *
            instead of being an expression, the array type is a variable length array type of
            unspecified size, which can only be used in declarations with function prototype scope;<d:footnote>
              <d:para>Thus, <d:code>*</d:code> can be used only in function declarations that are
                not definitions (see Function declarators (including prototypes)).</d:para>
            </d:footnote> such arrays are nonetheless complete types. If the size is an integer
            constant expression and the element type has a known constant size, the array type is
            not a variable length array type; otherwise, the array type is a variable length array
            type.</d:para>
          <d:para>If the size is an expression that is not an integer constant expression: if it
            occurs in a declaration at function prototype scope, it is treated as if it were
            replaced by *; otherwise, each time it is evaluated it shall have a value greater than
            zero. The size of each instance of a variable length array type does not change during
            its lifetime. Where a size expression is part of the operand of a
              <d:code>sizeof</d:code> operator and changing the value of the size expression would
            not affect the result of the operator, it is unspecified whether or not the size
            expression is evaluated.</d:para>
          <d:para>For two array types to be compatible, both shall have compatible element types,
            and if both size specifiers are present, and are integer constant expressions, then both
            size specifiers shall have the same constant value. If the two array types are used in a
            context which requires them to be compatible, it is undefined behavior if the two size
            specifiers evaluate to unequal values.</d:para>
          <d:para>EXAMPLE 1</d:para>
          <d:programlisting role="CLexer">float fa[11], *afp[17];</d:programlisting>
          <d:para>declares an array of <d:code>float</d:code> numbers and an array of pointers to
              <d:code>float</d:code> numbers.</d:para>
          <d:para>EXAMPLE 2 Note the distinction between the declarations</d:para>
          <d:programlisting role="CLexer">extern int *x;
extern int y[];</d:programlisting>
          <d:para>The first declares <d:code>x</d:code> to be a pointer to <d:code>int</d:code>; the
            second declares <d:code>y</d:code> to be an array of int of unspecified size (an
            incomplete type), the storage for which is defined elsewhere.</d:para>
          <d:para>EXAMPLE 3 The following declarations demonstrate the compatibility rules for
            variably modified types.</d:para>
          <d:programlisting role="CLexer">extern int n;
extern int m;
void fcompat(void)
{
  int a[n][6][m];
  int (*p)[4][n+1];
  int c[n][n][6][m];
  int (*r)[n][n][n+1];
  p = a;               // invalid: not compatible because 4 != 6
  r = c;               // compatible, but defined behavior only if
                       // n == 6 and m == n+1
}</d:programlisting>
          <d:para>EXAMPLE 4 All declarations of variably modified (VM) types have to be at either
            block scope or function prototype scope. Array objects declared with the
              <d:code>static</d:code> or <d:code>extern</d:code> storage-class specifier cannot have
            a variable length array (VLA) type. However, an object declared with the
              <d:code>static</d:code> storage-class specifier can have a VM type (that is, a pointer
            to a VLA type). Finally, all identifiers declared with a VM type have to be ordinary
            identifiers and cannot, therefore, be members of structures or unions.</d:para>
          <d:programlisting role="CLexer">extern int n;                  // invalid: file scope VLA
int A[n];                      // invalid: file scope VM
extern int (*p2)[n];           // valid: file scope but not VM
int B[100];
void fvla(int m, int C[m][m]); // valid: VLA with prototype scope
void fvla(int m, int C[m][m])  // valid: adjusted to auto pointer to VLA
{
  typedef int VLA[m][m];         // valid: block scope typedef VLA

  struct tag {
    int (*y)[n];                   // invalid: y not ordinary identifier
    int z[n];                      // invalid: z not ordinary identifier
  };
  int D[m];                      // valid: auto VLA
  static int E[m];               // invalid: static block scope VLA
  extern int F[m];               // invalid: F has linkage and is VLA
  int (*s)[m];                   // valid: auto pointer to VLA
  extern int (*r)[m];            // invalid: r has linkage and points to VLA
  static int (*q)[m] = &amp;B;       // valid: q is a static block pointer to VLA
}</d:programlisting>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> function declarators (Function declarators (including
            prototypes)), function definitions (Function definitions), initialization
            (Initialization).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Function declarators (including
            prototypes)</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>A function declarator shall not specify a return type that is a function type or
            an array type.</d:para>
          <d:para>The only storage-class specifier that shall occur in a parameter declaration is
              <d:code>register</d:code>.</d:para>
          <d:para>An identifier list in a function declarator that is not part of a definition of
            that function shall be empty.</d:para>
          <d:para>After adjustment, the parameters in a parameter type list in a function declarator
            that is part of a definition of that function shall not have incomplete type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>If, in the declaration "<d:code>T D1</d:code>", <d:code>D1</d:code> has the
            form:</d:para>
          <d:programlisting>D( parameter-type-list )</d:programlisting>
          <d:para>or:</d:para>
          <d:programlisting>D( identifier-listopt )</d:programlisting>
          <d:para>and the type specified for ident in the declaration "T D" is
            “derived-declarator-type-list T”, then the type specified for ident is
            “derived-declarator-type-list function returning T”.</d:para>
          <d:para>A parameter type list specifies the types of, and may declare identifiers for, the
            parameters of the function.</d:para>
          <d:para>A declaration of a parameter as “array of type” shall be adjusted to “qualified
            pointer to type”, where the type qualifiers (if any) are those specified within the [
            and ] of the array type derivation. If the keyword <d:code>static</d:code> also appears
            within the <d:code>[</d:code> and <d:code>]</d:code> of the array type derivation, then
            for each call to the function, the value of the corresponding actual argument shall
            provide access to the first element of an array with at least as many elements as
            specified by the size expression.</d:para>
          <d:para>A declaration of a parameter as “function returning type” shall be adjusted to
            “pointer to function returning type”, as in Other Operands.</d:para>
          <d:para>If the list terminates with an ellipsis (, ...), no information about the number
            or types of the parameters after the comma is supplied.<d:footnote>
              <d:para>The macros defined in the &lt;stdarg.h> header (Variable arguments
                &lt;stdarg.h>) may be used to access arguments that correspond to the
                ellipsis.</d:para>
            </d:footnote></d:para>
          <d:para>The special case of an unnamed parameter of type void as the only item in the list
            specifies that the function has no parameters.</d:para>
          <d:para>If, in a parameter declaration, an identifier can be treated either as a typedef
            name or as a parameter name, it shall be taken as a typedef name.</d:para>
          <d:para>If the function declarator is not part of a definition of that function,
            parameters may have incomplete type and may use the <d:code>[*]</d:code> notation in
            their sequences of declarator specifiers to specify variable length array
            types.</d:para>
          <d:para>The storage-class specifier in the declaration specifiers for a parameter
            declaration, if present, is ignored unless the declared parameter is one of the members
            of the parameter type list for a function definition.</d:para>
          <d:para>An identifier list declares only the identifiers of the parameters of the
            function. An empty list in a function declarator that is part of a definition of that
            function specifies that the function has no parameters. The empty list in a function
            declarator that is not part of a definition of that function specifies that no
            information about the number or types of the parameters is supplied.</d:para>
          <d:para>For two function types to be compatible, both shall specify compatible return
            types. Moreover, the parameter type lists, if both are present, shall agree in the
            number of parameters and in use of the ellipsis terminator; corresponding parameters
            shall have compatible types. If one type has a parameter type list and the other type is
            specified by a function declarator that is not part of a function definition and that
            contains an empty identifier list, the parameter list shall not have an ellipsis
            terminator and the type of each parameter shall be compatible with the type that results
            from the application of the default argument promotions. If one type has a parameter
            type list and the other type is specified by a function definition that contains a
            (possibly empty) identifier list, both shall agree in the number of parameters, and the
            type of each prototype parameter shall be compatible with the type that results from the
            application of the default argument promotions to the type of the corresponding
            identifier. (In the determination of type compatibility and of a composite type, each
            parameter declared with function or array type is taken as having the adjusted type and
            each parameter declared with qualified type is taken as having the unqualified version
            of its declared type.)<d:footnote>
              <d:para>If both function types are “old style”, parameter types are not
                compared.</d:para>
            </d:footnote></d:para>
          <d:para>EXAMPLE 1 The declaration</d:para>
          <d:programlisting role="CLexer">int f(void), *fip(), (*pfi)();</d:programlisting>
          <d:para>declares a function <d:code>f</d:code> with no parameters returning an
              <d:code>int</d:code>, a function <d:code>fip</d:code> with no parameter specification
            returning a pointer to an <d:code>int</d:code>, and a pointer <d:code>pfi</d:code> to a
            function with no parameter specification returning an <d:code>int</d:code>. It is
            especially useful to compare the last two. The binding of <d:code>*fip()</d:code> is
              <d:code>*(fip())</d:code>, so that the declaration suggests, and the same construction
            in an expression requires, the calling of a function <d:code>fip</d:code>, and then
            using indirection through the pointer result to yield an <d:code>int</d:code>. In the
            declarator <d:code>(*pfi)()</d:code>, the extra parentheses are necessary to indicate
            that indirection through a pointer to a function yields a function designator, which is
            then used to call the function; it returns an <d:code>int</d:code>. If the declaration
            occurs outside of any function, the identifiers have file scope and external linkage. If
            the declaration occurs inside a function, the identifiers of the functions
              <d:code>f</d:code> and <d:code>fip</d:code> have block scope and either internal or
            external linkage (depending on what file scope declarations for these identifiers are
            visible), and the identifier of the pointer <d:code>pfi</d:code> has block scope and no
            linkage.</d:para>
          <d:para>EXAMPLE 2 The declaration</d:para>
          <d:programlisting role="CLexer">int (*apfi[3])(int *x, int *y);</d:programlisting>
          <d:para>declares an array <d:code>apfi</d:code> of three pointers to functions returning
              <d:code>int</d:code>. Each of these functions has two parameters that are pointers to
              <d:code>int</d:code>. The identifiers <d:code>x</d:code> and <d:code>y</d:code> are
            declared for descriptive purposes only and go out of scope at the end of the declaration
            of <d:code>apfi</d:code>.</d:para>
          <d:para>EXAMPLE 3 The declaration</d:para>
          <d:programlisting role="CLexer">int (*fpfi(int (*)(long), int))(int, ...);</d:programlisting>
          <d:para>declares a function <d:code>fpfi</d:code> that returns a pointer to a function
            returning an <d:code>int</d:code>. The function <d:code>fpfi</d:code> has two
            parameters: a pointer to a function returning an <d:code>int</d:code> (with one
            parameter of type <d:code>long int</d:code>), and an <d:code>int</d:code>. The pointer
            returned by <d:code>fpfi</d:code> points to a function that has one <d:code>int</d:code>
            parameter and accepts zero or more additional arguments of any type.</d:para>
          <d:para>EXAMPEL 4 The following prototype has a variably modified parameter.</d:para>
          <d:programlisting role="CLexer">void addscalar(int n, int m,
double a[n][n*m+300], double x);
int main()
{
  double b[4][308];
  addscalar(4, 2, b, 2.17);
  return 0;
}
void addscalar(int n, int m, double a[n][n*m+300], double x)
{
  for (int i = 0; i &lt; n; i++)
    for (int j = 0, k = n*m+300; j &lt; k; j++)
     // a is a pointer to a VLA with n*m+300 elements
     a[i][j] += x;
}</d:programlisting>
          <d:para>EXAMPLE 5 The following are all compatible function prototype
            declarators.</d:para>
          <d:programlisting role="CLexer">double maximum(int n, int m, double a[n][m]);
double maximum(int n, int m, double a[*][*]);
double maximum(int n, int m, double a[ ][*]);
double maximum(int n, int m, double a[*][m]);</d:programlisting>
          <d:para>as are:</d:para>
          <d:programlisting role="CLexer">void f(double (*restrict a)[5]);
void f(double  a[restrict][5]);
void f(double  a[restrict 3][5]);
void f(double  a[restrict static 3][5]);</d:programlisting>
          <d:para>(Note that the last declaration also specifies that the argument corresponding to
            a in any call to <d:code>f</d:code> must be a non-null pointer to the first of at least
            three arrays of 5 doubles, which the others do not.)</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> function definitions (Function definitions), type names (Type
            names).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Type names</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>In several contexts, it is necessary to specify a type. This is accomplished using a
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">type name</emphasis>,
          which is syntactically a declaration for a function or an object of that type that omits
          the identifier.<d:footnote>
            <d:para>As indicated by the syntax, empty parentheses in a type name are interpreted as
              “function with no parameter specification”, rather than redundant parentheses around
              the omitted identifier.</d:para>
          </d:footnote></d:para>
        <d:para>EXAMPLE The constructions:</d:para>
        <d:programlisting>(a) int
(b) int *
(c) int *[3]
(d) int (*)[3]
(e) int (*)[*]
(f) int *()
(g) int(*)(void)
(h) int (*const [])(unsigned int, ...)</d:programlisting>
        <d:para>name respectively the types (a) <d:code>int</d:code>, (b) pointer to int, (c) array
          of three pointers to <d:code>int</d:code>, (d) pointer to an array of three
            <d:code>int</d:code>s, (e) pointer to a variable length array of an unspecified number
          of <d:code>int</d:code>s, (f) function with no parameter specification returning a pointer
          to <d:code>int</d:code>, (g) pointer to function with no parameters returning an
            <d:code>int</d:code>, and (h) array of an unspecified number of constant pointers to
          functions, each with one parameter that has type <d:code>unsigned int</d:code> and an
          unspecified number of other parameters, returning an <d:code>int</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Type definitions</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>If a typedef name specifies a variably modified type then it shall have block
          scope.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>In a declaration whose storage-class specifier is <d:code>typedef</d:code>, each
          declarator defines an identifier to be a typedef name that denotes the type specified for
          the identifier in the way described in Declarators. Any array size expressions associated
          with variable length array declarators are evaluated each time the declaration of the
          typedef name is reached in the order of execution. A <d:code>typedef</d:code> declaration
          does not introduce a new type, only a synonym for the type so specified. That is, in the
          following declarations:</d:para>
        <d:programlisting role="CLexer">typedef T type_ident;
type_ident D;</d:programlisting>
        <d:para><d:code>type_ident</d:code> is defined as a typedef name with the type specified by
          the declaration specifiers in <d:code>T</d:code> (known as <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">T</emphasis> ), and the identifier
          in <d:code>D</d:code> has the type “<emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">derived-declarator-type-list T</emphasis>” where the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic"
            >derived-declarator-type-list</emphasis> is specified by the declarators of
            <d:code>D</d:code>. A typedef name shares the same name space as other identifiers
          declared in ordinary declarators.</d:para>
        <d:para>EXAMPLE 1 After</d:para>
        <d:programlisting role="CLexer">typedef int MILES, KLICKSP();
typedef struct { double hi, lo; } range;</d:programlisting>
        <d:para>the constructions:</d:para>
        <d:programlisting role="CLexer">MILES distance;
extern KLICKSP *metricp;
range x;
range z, *zp;</d:programlisting>
        <d:para>are all valid declarations. The type of <d:code>distance</d:code> is
            <d:code>int</d:code>, that of <d:code>metricp</d:code> is “pointer to function with no
          parameter specification returning <d:code>int</d:code>”, and that of <d:code>x</d:code>
          and <d:code>z</d:code> is the specified structure; <d:code>zp</d:code> is a pointer to
          such a structure. The object distance has a type compatible with any other int
          object.</d:para>
        <d:para>EXAMPLE 2 After the declarations</d:para>
        <d:programlisting role="CLexer">typedef struct s1 { int x; } t1, *tp1;
typedef struct s2 { int x; } t2, *tp2;</d:programlisting>
        <d:para>type <d:code>t1</d:code> and the type pointed to by <d:code>tp1</d:code> are
          compatible. Type <d:code>t1</d:code> is also compatible with type <d:code>struct
            s1</d:code>, but not compatible with the types <d:code>struct s2</d:code>,
            <d:code>t2</d:code> the type pointed to by <d:code>tp2</d:code> or
          <d:code>int</d:code>.</d:para>
        <d:para>The following obscure constructions</d:para>
        <d:programlisting role="CLexer">typedef signed int t;
typedef int plain;
struct tag {
  unsigned t:4;
  const t:5;
  plain r:5;
};</d:programlisting>
        <d:para>declare a typedef name <d:code>t</d:code> with type <d:code>signed int</d:code>, a
          typedef name <d:code>plain</d:code> with type <d:code>int</d:code> and a structure with
          three bit-field members, one named <d:code>t</d:code> that contains values in the range
            <d:code>[0, 15]</d:code>, an unnamed const- qualified bit-field which (if it could be
          accessed) would contain values in either the range <d:code>[-15, +15]</d:code> or
            <d:code>[-16, +15]</d:code>, and one named <d:code>r</d:code> that contains values in
          one of the ranges <d:code>[0, 31], [-15, +15]</d:code> or <d:code>[-16, +15]</d:code>.
          (The choice of range is implementation-defined.) The first two bit-field declarations
          differ in that unsigned is a type specifier (which forces <d:code>t</d:code> to be the
          name of a structure member), while const is a type qualifier (which modifies
            <d:code>t</d:code> which is still visible as a typedef name). If these declarations are
          followed in an inner scope by</d:para>
        <d:programlisting role="CLexer">t f(t (t));
long t;</d:programlisting>
        <d:para>then a function <d:code>f</d:code> is declared with type “function returning signed
          int with one unnamed parameter with type pointer to function returning <d:code>signed
            int</d:code> with one unnamed parameter with type <d:code>signed int</d:code>”, and an
          identifier t with type <d:code>long int</d:code>.</d:para>
        <d:para>EXAMPLE 4 On the other hand, typedef names can be used to improve code readability.
          All three of the following declarations of the <d:code>signal</d:code> function specify
          exactly the same type, the first without making use of any typedef names.</d:para>
        <d:programlisting role="CLexer">typedef void fv(int), (*pfv)(int);
void (*signal(int, void (*)(int)))(int);
fv *signal(int, fv *);
pfv signal(int, pfv);</d:programlisting>
        <d:para>EXAMPLE 5 If a typedef name denotes a variable length array type, the length of the
          array is fixed at the time the typedef name is defined, not each time it is used:</d:para>
        <d:programlisting role="CLexer">void copyt(int n)
{
  typedef int B[n];      // B is n ints, n evaluated now

  n += 1;
  B a;                   // a is n ints, n without += 1
  int b[n];              // a and b are different sizes
  for (int i = 1; i &lt; n;
    a[i-1] = b[i];
}</d:programlisting>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Initialization</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>No initializer shall attempt to provide a value for an object not contained within
          the entity being initialized.</d:para>
        <d:para>The type of the entity to be initialized shall be an array of unknown size or an
          object type that is not a variable length array type.</d:para>
        <d:para>All the expressions in an initializer for an object that has static storage duration
          shall be constant expressions or string literals.</d:para>
        <d:para>If the declaration of an identifier has block scope, and the identifier has external
          or internal linkage, the declaration shall have no initializer for the
          identifier.</d:para>
        <d:para>If a designator has the form <d:code>[</d:code><emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic"
            >constant-expression</emphasis><d:code>]</d:code> then the current object (defined
          below) shall have array type and the expression shall be an integer constant
          expression.</d:para>
        <d:para>If the array is of unknown size, any nonnegative value is valid. If a designator has
          the form <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >.identifier</emphasis> then the current object (defined below) shall have structure or
          union type and the identifier shall be the name of a member of that type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>An initializer specifies the initial value stored in an object.</d:para>
        <d:para>Except where explicitly stated otherwise, for the purposes of this subclause unnamed
          members of objects of structure and union type do not participate in initialization.
          Unnamed members of structure objects have indeterminate value even after
          initialization.</d:para>
        <d:para>If an object that has automatic storage duration is not initialized explicitly, its
          value is indeterminate. If an object that has static storage duration is not initialized
          explicitly, then:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">if it has pointer type, it is initialized to
              a null pointer;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">if it has arithmetic type, it is initialized
              to (positive or unsigned) zero;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">if it is an aggregate, every member is
              initialized (recursively) according to these rules;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">if it is a union, the first named member is
              initialized (recursively) according to these rules.</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>The initializer for a scalar shall be a single expression, optionally enclosed in
          braces. The initial value of the object is that of the expression (after conversion); the
          same type constraints and conversions as for simple assignment apply, taking the type of
          the scalar to be the unqualified version of its declared type.</d:para>
        <d:para>The rest of this subclause deals with initializers for objects that have aggregate
          or union type.</d:para>
        <d:para>The initializer for a structure or union object that has automatic storage duration
          shall be either an initializer list as described below, or a single expression that has
          compatible structure or union type. In the latter case, the initial value of the object,
          including unnamed members, is that of the expression.</d:para>
        <d:para>An array of character type may be initialized by a character string literal,
          optionally enclosed in braces. Successive characters of the character string literal
          (including the terminating null character if there is room or if the array is of unknown
          size) initialize the elements of the array.</d:para>
        <d:para>An array with element type compatible with <d:code>wchar_t</d:code> may be
          initialized by a wide string literal, optionally enclosed in braces. Successive wide
          characters of the wide string literal (including the terminating null wide character if
          there is room or if the array is of unknown size) initialize the elements of the
          array.</d:para>
        <d:para>Otherwise, the initializer for an object that has aggregate or union type shall be a
          brace-enclosed list of initializers for the elements or named members.</d:para>
        <d:para>Each brace-enclosed initializer list has an associated current object. When no
          designations are present, subobjects of the current object are initialized in order
          according to the type of the current object: array elements in increasing subscript order,
          structure members in declaration order, and the first named member of a union.<d:footnote>
            <d:para>If the initializer list for a subaggregate or contained union does not begin
              with a left brace, its subobjects are initialized as usual, but the subaggregate or
              contained union does not become the current object: current objects are associated
              only with brace-enclosed initializer lists.</d:para>
          </d:footnote> In contrast, a designation causes the following initializer to begin
          initialization of the subobject described by the designator. Initialization then continues
          forward in order, beginning with the next subobject after that described by the designator.<d:footnote>
            <d:para>After a union member is initialized, the next object is not the next member of
              the union; instead, it is the next subobject of an object containing the
              union.</d:para>
          </d:footnote></d:para>
        <d:para>Each designator list begins its description with the current object associated with
          the closest surrounding brace pair. Each item in the designator list (in order) specifies
          a particular member of its current object and changes the current object for the next
          designator (if any) to be that member.<d:footnote>
            <d:para>Thus, a designator can only specify a strict subobject of the aggregate or union
              that is associated with the surrounding brace pair. Note, too, that each separate
              designator list is independent.</d:para>
          </d:footnote> The current object that results at the end of the designator list is the
          subobject to be initialized by the following initializer.</d:para>
        <d:para>The initialization shall occur in initializer list order, each initializer provided
          for a particular subobject overriding any previously listed initializer for the same subobject;<d:footnote>
            <d:para>Any initializer for the subobject which is overridden and so not used to
              initialize that subobject might not be evaluated at all.</d:para>
          </d:footnote> all subobjects that are not initialized explicitly shall be initialized
          implicitly the same as objects that have static storage duration.</d:para>
        <d:para>If the aggregate or union contains elements or members that are aggregates or
          unions, these rules apply recursively to the subaggregates or contained unions. If the
          initializer of a subaggregate or contained union begins with a left brace, the
          initializers enclosed by that brace and its matching right brace initialize the elements
          or members of the subaggregate or the contained union. Otherwise, only enough initializers
          from the list are taken to account for the elements or members of the subaggregate or the
          first member of the contained union; any remaining initializers are left to initialize the
          next element or member of the aggregate of which the current subaggregate or contained
          union is a part.</d:para>
        <d:para>If there are fewer initializers in a brace-enclosed list than there are elements or
          members of an aggregate, or fewer characters in a string literal used to initialize an
          array of known size than there are elements in the array, the remainder of the aggregate
          shall be initialized implicitly the same as objects that have static storage
          duration.</d:para>
        <d:para>If an array of unknown size is initialized, its size is determined by the largest
          indexed element with an explicit initializer. At the end of its initializer list, the
          array no longer has incomplete type.</d:para>
        <d:para>The order in which any side effects occur among the initialization list expressions
          is unspecified.<d:footnote>
            <d:para>In particular, the evaluation order need not be the same as the order of
              subobject initialization.</d:para>
          </d:footnote></d:para>
        <d:para>EXAMPLE 1 Provided that &lt;complex.h> has been #included, the declarations</d:para>
        <d:programlisting role="CLexer">int i = 3.5;
double complex c = 5 + 3 * I;</d:programlisting>
        <d:para>define and initialize <d:code>i</d:code> with the value 3 and <d:code>c</d:code>
          with the value 5. 0 + i3. 0.</d:para>
        <d:para>EXAMPLE 2 The declaration</d:para>
        <d:programlisting role="CLexer">int x[] = { 1, 3, 5 };</d:programlisting>
        <d:para>defines and initializes <d:code>x</d:code> as a one-dimensional array object that
          has three elements, as no size was specified and there are three initializers.</d:para>
        <d:para>EXAMPLE 3 The declaration</d:para>
        <d:programlisting role="CLexer">int y[4][3] = {
      { 1, 3, 5 },
      { 2, 4, 6 },
      { 3, 5, 7 },
};</d:programlisting>
        <d:para>is a definition with a fully bracketed initialization: <d:code>1, 3,</d:code> and
            <d:code>5</d:code> initialize the first row of <d:code>y</d:code> (the array object
            <d:code>y[0]</d:code>), namely <d:code>y[0][0], y[0][1]</d:code> and
            <d:code>y[0][2]</d:code>. Likewise the next two lines initialize <d:code>y[1]</d:code>
          and <d:code>y[2]</d:code>. The initializer ends early, so <d:code>y[3]</d:code> is
          initialized with zeros. Precisely the same effect could have been achieved by</d:para>
        <d:programlisting role="CLexer">int y[4][3] = {
      1, 3, 5, 2, 4, 6, 3, 5, 7
};</d:programlisting>
        <d:para>The initializer for <d:code>y[0]</d:code> does not begin with a left brace, so three
          items from the list are used. Likewise the next three are taken successively for
            <d:code>y[1]</d:code> and <d:code>y[2]</d:code>.</d:para>
        <d:para>EXAMPLE 4 The declaration</d:para>
        <d:programlisting role="CLexer">int z[4][3] = {
      { 1 }, { 2 }, { 3 }, { 4 }
};</d:programlisting>
        <d:para>initializes the first column of <d:code>z</d:code> as specified and initializes the
          rest with zeros.</d:para>
        <d:para>EXAMPLE 5 The declaration</d:para>
        <d:programlisting role="CLexer">struct { int a[3], b; } w[] = { { 1 }, 2 };</d:programlisting>
        <d:para>is a definition with an inconsistently bracketed initialization. It defines an array
          with two element structures: <d:code>w[0].a[0]</d:code> is 1 and
            <d:code>w[1].a[0]</d:code> is 2; all the other elements are zero.</d:para>
        <d:para>EXAMPLE 6 The declaration</d:para>
        <d:programlisting role="CLexer">short q[4][3][2] = {
        { 1 },
        { 2, 3 },
        { 4, 5, 6 }
};</d:programlisting>
        <d:para>contains an incompletely but consistently bracketed initialization. It defines a
          three-dimensional array object: <d:code>q[0][0][0]</d:code> is 1,
            <d:code>q[1][0][0]</d:code> is 2, <d:code>q[1][0][1]</d:code> is 3, and 4, 5, and 6
          initialize <d:code>q[2][0][0], q[2][0][1]</d:code> and <d:code>q[2][1][0]</d:code>,
          respectively; all the rest are zero. The initializer for <d:code>q[0][0]</d:code> does not
          begin with a left brace, so up to six items from the current list may be used. There is
          only one, so the values for the remaining five elements are initialized with zero.
          Likewise, the initializers for <d:code>q[1][0]</d:code> and <d:code>q[2][0]</d:code> do
          not begin with a left brace, so each uses up to six items, initializing their respective
          two-dimensional subaggregates. If there had been more than six items in any of the lists,
          a diagnostic message would have been issued. The same initialization result could have
          been achieved by:</d:para>
        <d:programlisting role="CLexer">short q[4][3][2] = {
        1, 0, 0, 0, 0, 0,
        2, 3, 0, 0, 0, 0,
        4, 5, 6
};</d:programlisting>
        <d:para>or by:</d:para>
        <d:programlisting role="CLexer">short q[4][3][2] = {
      {
       { 1 },
      },
      {
       { 2, 3 },
      },
      {
       { 4, 5 },
       { 6 },
      }
};</d:programlisting>
        <d:para>in a fully bracketed form.</d:para>
        <d:para>Note that the fully bracketed and minimally bracketed forms of initialization are,
          in general, less likely to cause confusion.</d:para>
        <d:para>EXAMPLE 7 One form of initialization that completes array types involves typedef
          names. Given the declaration</d:para>
        <d:programlisting role="CLexer">typedef int A[]; // OK - declared with block scope</d:programlisting>
        <d:para>the declaration</d:para>
        <d:programlisting>A a = { 1, 2 }, b = { 3, 4, 5 };</d:programlisting>
        <d:para>is identical to:</d:para>
        <d:programlisting role="CLexer">int a[] = { 1, 2 }, b[] = { 3, 4, 5 };</d:programlisting>
        <d:para>due to the rules for incomplete types.</d:para>
        <d:para>EXAMPLE 8 The declaration</d:para>
        <d:programlisting role="CLexer">char s[] = "abc", t[3] = "abc";</d:programlisting>
        <d:para>defines “plain” char array objects <d:code>s</d:code> and <d:code>t</d:code> whose
          elements are initialized with character string literals.</d:para>
        <d:para>This declaration is identical to</d:para>
        <d:programlisting role="CLexer">char s[] = { 'a', 'b', 'c', '\0' },
t[] = { 'a', 'b', 'c' };</d:programlisting>
        <d:para>The contents of the arrays are modifiable. On the other hand, the
          declaration</d:para>
        <d:programlisting role="CLexer">char *p = "abc";</d:programlisting>
        <d:para>defines p with type “pointer to <d:code>char</d:code>” and initializes it to point
          to an object with type “array of <d:code>char</d:code>” with length 4 whose elements are
          initialized with a character string literal. If an attempt is made to use p to modify the
          contents of the array, the behavior is undefined.</d:para>
        <d:para>EXAMPLE 9 Arrays can be initialized to correspond to the elements of an enumeration
          by using designators:</d:para>
        <d:programlisting role="CLexer">enum { member_one, member_two };
const char *nm[] = {
  [member_two] = "member two",
  [ember_one] = "member one",
};</d:programlisting>
        <d:para>EXAMPLE 10 Structure members can be initialized to nonzero values without depending
          on their order:</d:para>
        <d:programlisting role="CLexer">div_t answer = { .quot = 2, .rem = -1 };</d:programlisting>
        <d:para>EXAMPLE 11 Designators can be used to provide explicit initialization when unadorned
          initializer lists might be misunderstood:</d:para>
        <d:programlisting role="CLexer">struct { int a[3], b; } w[] =
         { [0].a = {1}, [1].a[0] = 2 };</d:programlisting>
        <d:para>EXAMPLE 12 Space can be “allocated” from both ends of an array by using a single
          designator:</d:para>
        <d:programlisting role="CLexer">int a[MAX] = {
      1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0
};</d:programlisting>
        <d:para>In the above, if <d:code>MAX</d:code> is greater than ten, there will be some
          zero-valued elements in the middle; if it is less than ten, some of the values provided by
          the first five initializers will be overridden by the second five.</d:para>
        <d:para>EXAMPLE 13 Any member of a union can be initialized:</d:para>
        <d:programlisting role="CLexer">union { /* ... */ } u = { .any_member = 42 };</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> common definitions <d:code>&lt;stddef.h></d:code> (Common
          definitions &lt;stddef.h>).</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Statements and blocks</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>A statement specifies an action to be performed. Except as indicated, statements are
        executed in sequence.</d:para>
      <d:para>A block allows a set of declarations and statements to be grouped into one syntactic
        unit. The initializers of objects that have automatic storage duration, and the variable
        length array declarators of ordinary identifiers with block scope, are evaluated and the
        values are stored in the objects (including storing an indeterminate value in objects
        without an initializer) each time the declaration is reached in the order of execution, as
        if it were a statement, and within each declaration in the order that declarators
        appear.</d:para>
      <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">full
          expression</emphasis> is an expression that is not part of another expression or of a
        declarator. Each of the following is a full expression: an initializer; the expression in an
        expression statement; the controlling expression of a selection statement
          (<d:code>if</d:code> or <d:code>switch</d:code>); the controlling expression of a
          <d:code>while</d:code> or <d:code>do</d:code> statement; each of the (optional)
        expressions of a <d:code>for</d:code> statement; the (optional) expression in a
          <d:code>return</d:code> statement. The end of a full expression is a sequence
        point.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> expression and null statements (Expression and null statements),
        selection statements (Selection statements), iteration statements (Iteration statements),
        the return statement (The return statement).</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Labeled statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>A <d:code>case</d:code> or <d:code>default</d:code> label shall appear only in a
            <d:code>switch</d:code> statement. Further constraints on such labels are discussed
          under the <d:code>switch</d:code> statement.</d:para>
        <d:para>Label names shall be unique within a function.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>Any statement may be preceded by a prefix that declares an identifier as a label
          name. Labels in themselves do not alter the flow of control, which continues unimpeded
          across them.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> the <d:code>goto</d:code> statement (The goto statement), the
            <d:code>switch</d:code> statement (The switch statement).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Compound statement</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">compound
            statement</emphasis> is a block.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Expressions and null statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The expression in an expression statement is evaluated as a void expression for its
          side effects.<d:footnote>
            <d:para>Such as assignments, and function calls which have side effects.</d:para>
          </d:footnote></d:para>
        <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">null
            statement</emphasis> (consisting of just a semicolon) performs no operations.</d:para>
        <d:para>EXAMPLE 1 If a function call is evaluated as an expression statement for its side
          effects only, the discarding of its value may be made explicit by converting the
          expression to a void expression by means of a cast:</d:para>
        <d:programlisting role="CLexer">int p(int);
/* ... */
(void)p(0);</d:programlisting>
        <d:para>EXAMPLE 2 In the program fragment</d:para>
        <d:programlisting role="CLexer">char *s;
/* ... */
while (*s++ != '\0')
;</d:programlisting>
        <d:para>a null statement is used to supply an empty loop body to the iteration
          statement.</d:para>
        <d:para>EXAMPLE 3 A null statement may also be used to carry a label just before the closing
            <d:code>}</d:code> of a compound statement.</d:para>
        <d:programlisting role="CLexer">while (loop1) {
  /* ... */
  while (loop2) {
    /* ... */
    if (want_out)
    goto end_loop1;
    /* ... */
  }
  /* ... */
  end_loop1: ;
}</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> iteration statements (Iteration statements).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Selection statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A selection statement selects among a set of statements depending on the value of a
          controlling expression.</d:para>
        <d:para>A selection statement is a block whose scope is a strict subset of the scope of its
          enclosing block. Each associated substatement is also a block whose scope is a strict
          subset of the scope of the selection statement.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>if</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The controlling expression of an <d:code>if</d:code> statement shall have scalar
            type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>In both forms, the first substatement is executed if the expression compares
            unequal to 0. In the <d:code>else</d:code> form, the second substatement is executed if
            the expression compares equal to 0. If the first substatement is reached via a label,
            the second substatement is not executed.</d:para>
          <d:para>An <d:code>else</d:code> is associated with the lexically nearest preceding if
            that is allowed by the syntax.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>switch</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The controlling expression of a switch statement shall have integer type.</d:para>
          <d:para>If a <d:code>switch</d:code> statement has an associated <d:code>case</d:code> or
              <d:code>default</d:code> label within the scope of an identifier with a variably
            modified type, the entire switch statement shall be within the scope of that identifier.<d:footnote>
              <d:para>That is, the declaration either precedes the <d:code>switch</d:code>
                statement, or it follows the last <d:code>case</d:code> or <d:code>default</d:code>
                label associated with the switch that is in the block containing the
                declaration.</d:para>
            </d:footnote></d:para>
          <d:para>The expression of each <d:code>case</d:code> label shall be an integer constant
            expression and no two of the case constant expressions in the same
              <d:code>switch</d:code> statement shall have the same value after conversion. There
            may be at most one <d:code>default</d:code> label in a switch statement. (Any enclosed
              <d:code>switch</d:code> statement may have a <d:code>default</d:code> label or
              <d:code>case</d:code> constant expressions with values that duplicate
              <d:code>case</d:code> constant expressions in the enclosing <d:code>switch</d:code>
            statement.)</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <d:code>switch</d:code> statement causes control to jump to, into, or past the
            statement that is the <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >switch body</emphasis>, depending on the value of a controlling expression, and on
            the presence of a <d:code>default</d:code> label and the values of any
              <d:code>case</d:code> labels on or in the switch body. A <d:code>case</d:code> or
              <d:code>default</d:code> label is accessible only within the closest enclosing switch
            statement.</d:para>
          <d:para>The integer promotions are performed on the controlling expression. The constant
            expression in each <d:code>case</d:code> label is converted to the promoted type of the
            controlling expression. If a converted value matches that of the promoted controlling
            expression, control jumps to the statement following the matched <d:code>case</d:code>
            label. Otherwise, if there is a <d:code>default</d:code> label, control jumps to the
            labeled statement. If no converted case constant expression matches and there is no
              <d:code>default</d:code> label, no part of the switch body is executed.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Implementation
              limits</emphasis></d:para>
          <d:para>As discussed in Translation limits, the implementation may limit the number of
              <d:code>case</d:code> values in a switch statement.</d:para>
          <d:para>EXAMPLE In the artificial program fragment</d:para>
          <d:programlisting role="CLexer">switch (expr)
{
  int i = 4;
    f(i);
  case 0:
    i = 17;
    /* falls through into default code */
  default:
    printf("%d\n", i);
}</d:programlisting>
          <d:para>the object whose identifier is i exists with automatic storage duration (within
            the block) but is never initialized, and thus if the controlling expression has a
            nonzero value, the call to the <d:code>printf</d:code> function will access an
            indeterminate value. Similarly, the call to the function f cannot be reached.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Iteration statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The controlling expression of an iteration statement shall have scalar
          type.</d:para>
        <d:para>The declaration part of a for statement shall only declare identifiers for objects
          having storage class <d:code>auto</d:code> or <d:code>register</d:code>.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>An iteration statement causes a statement called the loop body to be executed
          repeatedly until the controlling expression compares equal to 0.An iteration statement is
          a block whose scope is a strict subset of the scope of its enclosing block. The loop body
          is also a block whose scope is a strict subset of the scope of the iteration
          statement.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>while</code> statement</title>
          <d:para>The evaluation of the controlling expression takes place before each execution of
            the loop body.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>do</code> statement</title>
          <d:para>The evaluation of the controlling expression takes place after each execution of
            the loop body.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>for</code> statement</title>
          <d:para>The statement</d:para>
          <d:screen>for ( clause-1 ; expression-2 ; expression-3 ) statement</d:screen>
          <d:para>behaves as follows: The expression <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">expression-2</emphasis> is the controlling expression that is evaluated
            before each execution of the loop body. The expression <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">expression-3</emphasis> is
            evaluated as a void expression after each execution of the loop body. If <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">clause-1</emphasis> is a
            declaration, the scope of any variables it declares is the remainder of the declaration
            and the entire loop, including the other two expressions; it is reached in the order of
            execution before the first evaluation of the controlling expression. If clause-1 is an
            expression, it is evaluated as a void expression before the first evaluation of the
            controlling expression.<d:footnote>
              <d:para>Thus, <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
                  >clause-1</emphasis> specifies initialization for the loop, possibly declaring one
                or more variables for use in the loop; the controlling expression, <emphasis
                  xmlns="http://docbook.org/ns/docbook" role="italic">expression-2</emphasis>,
                specifies an evaluation made before each iteration, such that execution of the loop
                continues until the expression compares equal to 0; and <emphasis
                  xmlns="http://docbook.org/ns/docbook" role="italic">expression-3</emphasis>
                specifies an operation (such as incrementing) that is performed after each
                iteration.</d:para>
            </d:footnote></d:para>
          <d:para>Both <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >clause-1</emphasis> and <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >expression-3</emphasis> can be omitted. An omitted <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">expression-2</emphasis> is
            replaced by a nonzero constant.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Jump statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A jump statement causes an unconditional jump to another place.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>goto</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The identifier in a <d:code>goto</d:code> statement shall name a label located
            somewhere in the enclosing function. A <d:code>goto</d:code> statement shall not jump
            from outside the scope of an identifier having a variably modified type to inside the
            scope of that identifier.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <d:code>goto</d:code> statement causes an unconditional jump to the statement
            prefixed by the named label in the enclosing function.</d:para>
          <d:para>EXAMPLE 1 It is sometimes convenient to jump into the middle of a complicated set
            of statements. The following outline presents one possible approach to a problem based
            on these three assumptions:</d:para>
          <d:orderedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">The general initialization code accesses
                objects only visible to the current function.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">The general initialization code is too
                large to warrant duplication.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">The code to determine the next operation
                is at the head of the loop. (To allow it to be reached by continue statements, for
                example.)</para>
            </d:listitem>
          </d:orderedlist>
          <d:programlisting role="CLexer">/* ... */
goto first_time;
for (;;) {
  // determine next operation
  /* ... */
  if (need to reinitialize) {
    // reinitialize-only code
    /* ... */
    first_time:
    // general initialization code
    /* ... */
    continue;
  }
  // handle other operations
  /* ... */
}</d:programlisting>
          <d:para>EXAMPLE 2 A <d:code>goto</d:code> statement is not allowed to jump past any
            declarations of objects with variably modified types. A jump within the scope, however,
            is permitted.</d:para>
          <d:programlisting role="CLexer">goto lab3; // invalid: going INTO scope of VLA.
{
  double a[n];
  a[j] = 4.4;
lab3:
  a[j] = 3.3;
goto lab4; // valid: going WITHIN scope of VLA.
  a[j] = 5.5;
lab4:
  a[j] = 6.6;
}
goto lab4; // invalid: going INTO scope of VLA.</d:programlisting>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>continue</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>A <d:code>continue</d:code> statement shall appear only in or as a loop
            body.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">continue</emphasis>
            statement causes a jump to the loop-continuation portion of the smallest enclosing
            iteration statement; that is, to the end of the loop body. More precisely, in each of
            the statements</d:para>
          <d:programlisting role="CLexer">while (/* ... */) {
  /* ... */
  continue;
  /* ... */
  contin: ;
}
do {
  /* ... */
  continue;
  /* ... */
  contin: ;
} while (/* ... */);
for (/* ... */) {
  /* ... */
  continue;
  /* ... */
  contin: ;
}</d:programlisting>
          <d:para>unless the continue statement shown is in an enclosed iteration statement (in
            which case it is interpreted within that statement), it is equivalent to <d:code>goto
              contin;</d:code><d:footnote>
              <d:para>Following the <d:code>contin:</d:code> label is a null statement.</d:para>
            </d:footnote></d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>break</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>A <d:code>break</d:code> statement shall appear only in or as a switch body or
            loop body.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <d:code>break</d:code> statement terminates execution of the smallest enclosing
              <d:code>switch</d:code> or iteration statement.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>return</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constaints</emphasis></d:para>
          <d:para>A <d:code>return</d:code> statement with an expression shall not appear in a
            function whose return type is <d:code>void</d:code>. A return statement without an
            expression shall only appear in a function whose return type is
            <d:code>void</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <d:code>return</d:code> statement terminates execution of the current function
            and returns control to its caller. A function may have any number of
              <d:code>return</d:code> statements.</d:para>
          <d:para>If a <d:code>return</d:code> statement with an expression is executed, the value
            of the expression is returned to the caller as the value of the function call
            expression. If the expression has a type different from the return type of the function
            in which it appears, the value is converted as if by assignment to an object having the
            return type of the function.<d:footnote>
              <d:para>The <d:code>return</d:code> statement is not an assignment. The overlap
                restriction of subclause 6.5.16.1 does not apply to the case of function
                return.</d:para>
            </d:footnote></d:para>
          <d:para>EXAMPLE In:</d:para>
          <d:programlisting role="CLexer">struct s { double i; } f(void);
union {
  struct {
    int f1;
    struct s f2;
  } u1;
  struct {
    struct s f3;
    int f4;
  } u2;
} g;
struct s f(void)
{
  return g.u1.f2;
}
/* ... */
g.u2.f3 = f();</d:programlisting>
          <d:para>there is no undefined behavior, although there would be if the assignment were
            done directly (without using a function call to fetch the value).</d:para>
        </d:sect3>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">External definitions</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Constraints</emphasis></d:para>
      <d:para>The storage-class specifiers <d:code>auto</d:code> and <d:code>register</d:code> shall
        not appear in the declaration specifiers in an external declaration.</d:para>
      <d:para>There shall be no more than one external definition for each identifier declared with
        internal linkage in a translation unit. Moreover, if an identifier declared with internal
        linkage is used in an expression (other than as a part of the operand of a
          <d:code>sizeof</d:code> operator whose result is an integer constant), there shall be
        exactly one external definition for the identifier in the translation unit.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>As discussed in Program Structure, the unit of program text after preprocessing is a
        translation unit, which consists of a sequence of external declarations. These are described
        as external because they appear outside any function (and hence have file scope). As
        discussed in Declarations, a declaration that also causes storage to be reserved for an
        object or a function named by the identifier is a definition.</d:para>
      <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">external
          definition</emphasis> is an external declaration that is also a definition of a function
        (other than an inline definition) or an object. If an identifier declared with external
        linkage is used in an expression (other than as part of the operand of a
          <d:code>sizeof</d:code> operator whose result is an integer constant), somewhere in the
        entire program there shall be exactly one external definition for the identifier; otherwise,
        there shall be no more than one.<d:footnote>
          <d:para>Thus, if an identifier declared with external linkage is not used in an
            expression, there need be no external definition for it.</d:para>
        </d:footnote></d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Function definitions</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The identifier declared in a function definition (which is the name of the function)
          shall have a function type, as specified by the declarator portion of the function
          definition.</d:para>
        <d:para>The intent is that the type category in a function definition cannot be inherited
          from a typedef:</d:para>
        <d:programlisting role="CLexer">typedef int F(void);                  // type F is ‘‘function with no parameters
                                      // returning int’’
F f, g;                               // fand g both have type compatible with F
F f { /* ... */ }                     // WRONG: syntax/constraint error
F g() { /* ... */ }                   // WRONG: declares that g returns a function
int f(void) { /* ... */ }             // RIGHT: f has type compatible with F
int g() { /* ... */ }                 // RIGHT: g has type compatible with F
F *e(void) { /* ... */ }              // e returns a pointer to a function
F *((e))(void) { /* ... */ }          // same: parentheses irrelevant
int (*fp)(void);                      // fp points to a function that has type F
F*Fp;                                 //Fp points to a function that has type F</d:programlisting>
        <d:para>The return type of a function shall be <d:code>void</d:code> or an object type other
          than array type.</d:para>
        <d:para>The storage-class specifier, if any, in the declaration specifiers shall be either
            <d:code>extern</d:code> or <d:code>static</d:code>.</d:para>
        <d:para>If the declarator includes a parameter type list, the declaration of each parameter
          shall include an identifier, except for the special case of a parameter list consisting of
          a single parameter of type <d:code>void</d:code>, in which case there shall not be an
          identifier. No declaration list shall follow.</d:para>
        <d:para>If the declarator includes an identifier list, each declaration in the declaration
          list shall have at least one declarator, those declarators shall declare only identifiers
          from the identifier list, and every identifier in the identifier list shall be declared.
          An identifier declared as a typedef name shall not be redeclared as a parameter. The
          declarations in the declaration list shall contain no storage-class specifier other than
            <d:code>register</d:code> and no initializations.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The declarator in a function definition specifies the name of the function being
          defined and the identifiers of its parameters. If the declarator includes a parameter type
          list, the list also specifies the types of all the parameters; such a declarator also
          serves as a function prototype for later calls to the same function in the same
          translation unit. If the declarator includes an identifier list, the types of the
          parameters shall be declared in a following declaration list. In either case, the type of
          each parameter is adjusted as described in Function declarators (including prototypes) for
          a parameter type list; the resulting type shall be an object type.</d:para>
        <d:para>If a function that accepts a variable number of arguments is defined without a
          parameter type list that ends with the ellipsis notation, the behavior is
          undefined.</d:para>
        <d:para>Each parameter has automatic storage duration. Its identifier is an lvalue, which is
          in effect declared at the head of the compound statement that constitutes the function
          body (and therefore cannot be redeclared in the function body except in an enclosed
          block). The layout of the storage for parameters is unspecified. 10 On entry to the
          function, the size expressions of each variably modified parameter are evaluated and the
          value of each argument expression is converted to the type of the corresponding parameter
          as if by assignment. (Array expressions and function designators as arguments were
          converted to pointers before the call.)</d:para>
        <d:para>After all parameters have been assigned, the compound statement that constitutes the
          body of the function definition is executed.</d:para>
        <d:para>If the <d:code>}</d:code> that terminates a function is reached, and the value of
          the function call is used by the caller, the behavior is undefined.</d:para>
        <d:para>EXAMPLE 1 In the following:</d:para>
        <d:programlisting role="CLexer">extern int max(int a, int b)
{
  return a > b ? a : b;
}</d:programlisting>
        <d:para><d:code>extern</d:code> is the storage-class specifier and <d:code>int</d:code> is
          the type specifier; <d:code>max(int a, int b)</d:code> is the function declarator;
          and</d:para>
        <d:programlisting role="CLexer">{ return a > b ? a : b; }</d:programlisting>
        <d:para>is the function body. The following similar definition uses the identifier-list form
          for the parameter declarations:</d:para>
        <d:programlisting role="CLexer">extern int max(a, b)
int a, b;
{
  return a > b ? a : b;
}</d:programlisting>
        <d:para>Here <d:code>int a, b;</d:code> is the declaration list for the parameters. The
          difference between these two definitions is that the first form acts as a prototype
          declaration that forces conversion of the arguments of subsequent calls to the function,
          whereas the second form does not.</d:para>
        <d:para>EXAMPLE 2 To pass one function to another, one might say</d:para>
        <d:programlisting role="CLexer">int f(void);
/* ... */
g(f);</d:programlisting>
        <d:para>Then the definition of <d:code>g</d:code> might read</d:para>
        <d:programlisting role="CLexer">void g(int (*funcp)(void))
{
  /* ... */
  (*funcp)() /* or funcp() ... */
}</d:programlisting>
        <d:para>or, equivalently</d:para>
        <d:programlisting role="CLexer">void g(int func(void))
{
  /* ... */
  func() /* or (*func)() ... */
}</d:programlisting>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">External object definitions</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>If the declaration of an identifier for an object has file scope and an initializer,
          the declaration is an external definition for the identifier.</d:para>
        <d:para>A declaration of an identifier for an object that has file scope without an
          initializer, and without a storage-class specifier or with the storage-class specifier
            <d:code>static</d:code>, constitutes a <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">tentative definition</emphasis>. If a translation unit contains one or
          more tentative definitions for an identifier, and the translation unit contains no
          external definition for that identifier, then the behavior is exactly as if the
          translation unit contains a file scope declaration of that identifier, with the composite
          type as of the end of the translation unit, with an initializer equal to 0.</d:para>
        <d:para>If the declaration of an identifier for an object is a tentative definition and has
          internal linkage, the declared type shall not be an incomplete type.</d:para>
        <d:para>EXAMPLE 1</d:para>
        <d:programlisting role="CLexer">int i1 = 1;        // definition, external linkage
static int i2 = 2; // definition, internal linkage
extern int i3 = 3; // definition, external linkage
int i4;            // tentative definition, external linkage
static int i5;     // tentative definition, internal linkage
int i1;            // valid tentative definition, refers to pre vious
int i2;            // 4.2.2 renders undefined, linkage disagreement
int i3;            // valid tentative definition, refers to pre vious
int i4;            // valid tentative definition, refers to pre vious
int i5;            // 4.2.2 renders undefined, linkage disagreement
extern int i1;     // refers to pre vious, whose linkage is external
extern int i2;     // refers to pre vious, whose linkage is internal
extern int i3;     // refers to pre vious, whose linkage is external
extern int i4;     // refers to pre vious, whose linkage is external
extern int i5;     // refers to pre vious, whose linkage is internal</d:programlisting>
        <d:para>EXAMPLE 2 If at the end of the translation unit containing</d:para>
        <d:programlisting role="CLexer">int i[];</d:programlisting>
        <d:para>the array <d:code>i</d:code> still has incomplete type, the implicit initializer
          causes it to have one element, which is set to zero on program startup.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Preprocessing directives</title>
      <d:para>This is dicussed in chapter Preprocessing Directives.</d:para>
    </d:sect1>
  </d:chapter>
  <d:chapter>
    <?dbhtml filename="basics/index.html" ?>
    <d:title>Basics of C</d:title>
    <d:para>Now is the time for learning basics. There are certain rules in every language, certain
      grammar which dictates the way language will be spoken and written. It has a script to write
      using. Similarly, programming languages have BNF (Backus-Naur Form) context-free grammar.
      There are valid characters in a programming language and a set of keywords. However,
      programming language ruleset is very small compared to a natural programming language. Also,
      when using natural programming language like talking to someone or writing something the other
      person can understand your intent but in programming you cannot violate rules. The grammar is
      context-free. Compilers or interpreters cannot deduce your intent by reading code. They are
      not intelligent. You make a mistake and it will refuse to listen to you no matter what you do.
      Therefore, it is very essential to understand these rules very clearly and correctly.</d:para>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">The C Character Set</title>
      <d:para>The following form the C character set you are allowed to use in it:</d:para>
      <d:screen>[a-z] [A-Z] [0-9] ~ ! # % ^ &amp; * ( ) - = [ ] \ ; ' , . / _ + { } | : " &lt; > ?</d:screen>
      <d:para>This means along with other symbols you can use all English alphabets (both uppercase
        and lowercase) and Arabic numerals. However, English is not the only spoken language in the
        world. Therefore in other non-English speaking counties there are keyboard where certain
        characters present in above set are not present. The inventors of C were wise enough to
        envision this and provide the facility in form of trigraph sequences. The table of trigraph
        sequences is given in chapter 4.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Keywords</title>
      <d:para>The following are reserved keywords for C programming language which you are not
        allows to use other than what they are meant for:<table
          xmlns="http://docbook.org/ns/docbook" frame="void" class="dynamic" border="1">
          <caption>Keywords of C</caption>
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
          <tbody>
            <tr>
              <td>auto</td>
              <td>enum</td>
              <td>restrict</td>
              <td>unsigned</td>
            </tr>
            <tr>
              <td>break</td>
              <td>extern</td>
              <td>return</td>
              <td>void</td>
            </tr>
            <tr>
              <td>case</td>
              <td>float</td>
              <td>short</td>
              <td>volatile</td>
            </tr>
            <tr>
              <td>char</td>
              <td>for</td>
              <td>signed</td>
              <td>while</td>
            </tr>
            <tr>
              <td>const</td>
              <td>goto</td>
              <td>sizeof</td>
              <td>_Bool</td>
            </tr>
            <tr>
              <td>continue</td>
              <td>if</td>
              <td>static</td>
              <td>_Complex</td>
            </tr>
            <tr>
              <td>default</td>
              <td>inline</td>
              <td>struct</td>
              <td>_Imaginary</td>
            </tr>
            <tr>
              <td>do </td>
              <td>int</td>
              <td>switch</td>
              <td/>
            </tr>
            <tr>
              <td>double</td>
              <td>long</td>
              <td>typedef</td>
              <td/>
            </tr>
            <tr>
              <td>else</td>
              <td>register</td>
              <td>union</td>
              <td/>
            </tr>
          </tbody>
        </table></d:para>
      <d:para>These keywords serve specific purpose. You will come to know about all of them as you
        progress through the book. Next we look at identifiers.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Identifers</title>
      <d:para>The names which we give to our variables are known as identifiers. Something with
        which we identify. As you have already seen what is allowed in C’s character set but not all
        are allowed in an identifiers name. Only alphabets from English language both lowercase and
        uppercase, Arabic digits from zero to nine and underscore (<d:code>_</d:code>) are allowed
        in an identifiers name. The rule for constructing names is that among the allowed characters
        it can only begin with only English alphabets and underscore. Numbers must not be first
        character. For example, <d:code>x, _myVar, varX, yourId78</d:code> are all valid names.
        However, take care with names starting from underscore as they are mostly used by different
        library authors. Invalid identifier examples are <d:code>9x, my$, your age</d:code>. Please
        read this section carefully and make sure understand the rules for naming identifiers. Later
        at the end of chapter there are some simple problems to work on.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Programming</title>
      <d:para>Now is time for some programming. Let us revisit our first program and try to
        understand what it does. Here I am giving code once again for quick reference:</d:para>
      <d:programlisting role="CLexer">//My first program
/* Author: Shiv Shankar Dayal
   Description: This program does nothing.*/

#include &lt;stdio.h>

int main(int argc, char* argv[])
{
  return 0;
}</d:programlisting>
      <d:para>You can now issue a command as <d:command>$clang nothing.c</d:command> where
          <d:code>nothing.c</d:code> is the filename by which you saved the source code. Note that
          <d:code>$</d:code> is the prompt not part of command itself. Then you can do an
          <d:command>ls</d:command> and you will find that <d:code>a.out</d:code> is a file which
        has been produced by <d:application>clang</d:application>. Now you can run this program by
        saying <d:command>./a.out</d:command> and nothing will happen. But if you type
          <d:command>echo $?</d:command> then you will find that 0 is printed on screen which is
        nothing but 0 after return of our program.</d:para>
      <d:para>As you can see this program does almost nothing but it is fairly complete program and
        we can learn a lot from it about C. The first line is a comment. Whenever C compiler parses
        C programs and it encounters <d:code>//</d:code> it ignores rest of line as code i.e. it
        does not compile them. This type of single line comment were introduced in C99 standard and
        if your compiler is really old the compiler may give you error message about it. The second
        and third lines are also comments. Anything between <d:code>/*</d:code> and
          <d:code>*/</d:code> is ignored like <d:code>//</d:code>. However, be careful of something
        like <d:code>/* some comment */ more comment */</d:code>. Such comments will produce error
        messages and your program will fail to compile.</d:para>
      <d:para>Comments are very integral part of programming. They are used to describe various
        things. You can write whatever you want. They may also be used to generate documentation
        with tools like doxygen. Typically comments tell what the program is doing. Sometimes how,
        when the logic is really complex. One should be generous while commenting the code.</d:para>
      <d:para><d:code>#include</d:code> is a pre-processor directive. It will look for whatever is
        contained in angular brackets in the <d:code>INCLUDEPATH</d:code> of compiler. For now you
        can assume that <d:code>/usr/include</d:code> is in include path of compiler. For the
        curious I refer you to <link xmlns="http://docbook.org/ns/docbook"
          xlink:href="http://clang.llvm.org/doxygen/InitHeaderSearch_8cpp_source.html"
          >http://clang.llvm.org/doxygen/InitHeaderSearch_8cpp_source.html</link>. Basically what it
        does is that it looks for a file names <d:code>stdio.h</d:code> in the
          <d:code>INCLUDEPATH</d:code>. If that is found the content of that file is pasted here in
        our program.If you really want to see what happens then you can type <d:command>$clang -E
          nothing.c</d:command>. You will see lots of text scrolling on your screen. The
          <d:option>-E</d:option> switch tells <d:application>clang</d:application> that just
        preprocess the file, do not compile it, and send the resulting output to standard output (we
        will know about this more later), which happens to be your monitor in this case.</d:para>
      <d:para>Next line is <d:code>int main(int argc, char* argv[])</d:code>. Now this is very
        special function. Every complete executable(shared objects or dlls do not have main even
        though they are C programs) C program will have one main function unless you do assembly
        hacking. This function is where the programs start. The first word <d:code>int</d:code> is a
        keyword which stands for integer. This signifies the return type of function.
          <d:code>main</d:code> is the name of the function. Inside parenthesis you see <d:code>int
          argc</d:code> which tells how many arguments were passed to program. While <d:code>char*
          argv[]</d:code> is a pointer to array which we will see later. For now it holds all the
        arguments to the program.</d:para>
      <d:para>Next is a brace. The scope in C is determined by braces. Something outside any brace
        has global scope (we will see these later), something inside first level of brace has
        function or local scope. Something inside second or more level of braces have got that
        particular block scope. Scope here means that when there will be a closing brace that
        particular variable which is valid in that scope will cease to exist. However, we do not
        have to worry about that yet as we do not have any variable. Just note that a corresponding
        closing brace will be the end of main function.</d:para>
      <d:para>Next line is <d:code>return 0;</d:code> This means whoever has called
          <d:code>main()</d:code> will get a 0 as return is returning 0. In this case, receiver is
        the shell or operating system which has invoked the very program. The semicolon is called
        the terminator and used also on Java or C++ for example. The very requirement of semicolon
        is to terminate the statement and move on to next statement.</d:para>
      <d:para>However, the program shown does not do much. Let us write a program which has some
        more functionality and we can explore more of C. So here is a program which takes two
        integers as input from users and presents their sum as output. Here is the program:</d:para>
      <d:programlisting role="CLexer">// My second program
// Author: Shiv S. Dayal
// Description: It adds two numbers

#include &lt;stdio.h>

int main()
{
  int x=0, y=0, sum=0;

  printf("Please enter an integer:\n");
  scanf("%d", &amp;x);

  printf("Please enter another integer:\n");
  scanf("%d", &amp;y);

  sum = x + y;

  printf("%d + %d = %d\n", x, y, sum);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>shiv@shiv:~/book/code$ ./addition
Please enter an integer:
7
Please enter another integer:
8
7 + 8 = 15
shiv@shiv:~/book/code$</d:screen>
      <d:para>Note that <d:code>shiv@shiv:~/book/code$</d:code> is the prompt. The Makefile is also
        updated:</d:para>
      <d:programlisting role="MakefileLexer">check-syntax:
    clang -o nul -Wall -S $ (CHK_SOURCES)

nothing:nothing.c
    clang nothing.c -o nothing

addition:addition.c
    clang addition.c -o addition</d:programlisting>
      <d:para>You can choose <d:code>Tools->Compile</d:code> then enter <d:code>make -k
          addition</d:code> as make commands in the Emacs’s minibuffer and execute like
          <d:code>$./addition</d:code>.</d:para>
      <d:para>Let us discuss new lines one by one. The line <d:code>int x=0, y=0, z=0;</d:code> is
        declaration and definition or initialization of three ints. int keyword in C is used to
        represent integers. Now we have three integers with there values set to 0. Note that how the
        variables are separated by commas and terminated by semicolon(as we saw in last program
        also). We could have also written it like this:</d:para>
      <d:programlisting role="CLexer">int x;
int y;
int z;

x = 0;
y = 0;
z = 0;</d:programlisting>
      <d:para>or:</d:para>
      <d:programlisting role="CLexer">int x, y, z;

x = y = z = 0;</d:programlisting>
      <d:para>However, the first method is best and most preferred as it prevents use before
        definition. int is a data-type in C. <d:code>x, y,</d:code> and <d:code>z</d:code> are
        variables of type <d:code>int</d:code>. This means that the size of these variables will be
        same as <d:code>int</d:code>. Note that C is a statically typed language and all types have
        predefined memory requirements. In cour case, int requires 4 bytes on 32-bit
        systems.</d:para>
      <d:para>Now I will talk about <d:code>printf()</d:code> function. This function is declared in
          <d:code>stdio.h</d:code>. The prototype of <d:code>printf()</d:code> is</d:para>
      <d:programlisting role="CLexer">int printf(const char *restrict format, ...);</d:programlisting>
      <d:para>The first argument format is what we have in first two function calls. The second is a
          <d:code>...</d:code> which means it can take variable number of arguments known as
        variable-list. We have seen this in the third call.This means it will take a string with
        optional variable no. of arguments. The string is called the format-string and determines
        what can be printed with supplied arguments. These <d:code>...</d:code> are used to supply
        variable no. of arguments. In the first two <d:code>printf()</d:code> statements we just
        print the format-string so that is simple. However, in the last one, we have format as
          <d:code>%d</d:code> which signifies a decimal integer. The integers printed are in the
        same order in which they were supplied.</d:para>
      <d:para>Time for some input. <d:code>scanf()</d:code> is scan function which scans for
        keyboard input. As by now you know that <d:code>%d</d:code> is for decimal integer but we
        have not said <d:code>x</d:code> or <d:code>y</d:code>. The reason is <d:code>x</d:code> and
          <d:code>y</d:code> are values while <d:code>&amp;x</d:code> and <d:code>&amp;y</d:code>
        are the addresses of <d:code>x</d:code> and <d:code>y</d:code> in memory.
          <d:code>scanf()</d:code> needs the memory address to which it can write the contents to.
        You will see <d:code>&amp;</d:code> operator in action later when we deal with pointers.
        Just remember for now that to use a simple variable with <d:code>scanf()</d:code> requires
          <d:code>&amp;</d:code> before its name.</d:para>
      <d:para>Now I am going to take you on a tour of data types. Till now we have just seen only
          <d:code>int</d:code>. So onward to data types.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Data Types</title>
      <d:para>Why data types? What is the need? When everything is a voltage level why not just deal
        with 0s and 1s? The answer is simple. You need to abstract and segregate how much is
        required. For example, say you are given a sequence of 0s and 1s how much can you work with
        them. We as humans are not very versed with 0s and 1s. Also, say we encode character
          ‘<d:code>A</d:code>’ for 10101 will it be easy for you to see A or numbers. Also, numbers
        range from −∞ to ∞. Also, since C is statically typed the sizes of data types have to be
        known at compile time. There are four types of data types. Integral, floating-point, arrays
        and pointers. Here, I will deal with the two former types and leave latter two for later.
        The integral types are <d:code>char, short int, int, long</d:code> and <d:code>long
          long</d:code> and floating-point types are <d:code>float, double</d:code> and <d:code>long
          double. signed</d:code> and <d:code>unsigned</d:code> are sign modifiers which also
        modified the range of data types but do not affect their memory requirements. By default all
        basic data types are signed in nature and you must qualify you variables with unsigned if
        you want that behavior. <d:code>short</d:code> and <d:code>long</d:code> are modifiers for
        size which the data type occupies but I consider them as different types because memory
        requirements are different. The ranges of integral data types directly reflect their memory
        requirements and if you know how much memory they are going to occupy you can easily compute
        their ranges. The range of floating-point comes from IEEE specification. Clang at present
        does not support C99 floating-point specification at the time of this writing but rest
        assured they will st some point of time. However, I will present the C99 floating-point
        specification given by C99.</d:para>
      <d:para>Let us write a program to find out ranges for integral data types:</d:para>
      <d:programlisting role="CLexer">// My range program
// Author: Shiv S. Dayal
// Description: It gives ranges of integral data types

#include &lt;stdio.h>
#include &lt;limits.h>

int main()
{
  printf("Size of char is..........%d\n", sizeof(char));
  printf("Size of short int is.....%d\n", sizeof(short int));
  printf("Size of int is...........%d\n", sizeof(int));
  printf("Size of long is..........%d\n", sizeof(long));
  printf("Size of long long is.....%d\n", sizeof(long long));
  printf("Size of float is.........%d\n", sizeof(float));
  printf("Size of double is........%d\n", sizeof(double));
  printf("Size of long double is...%d\n", sizeof(long double));c

  return 0;
}</d:programlisting>
      <d:para>and the output will be:</d:para>
      <d:screen>Size of char is..........1
Size of short int is.....2
Size of int is...........4
Size of long is..........4
Size of long long is.....8
Size of float is.........4
Size of double is........8
Size of long double is...12</d:screen>
      <d:para>Based on this it is left as an exercise to reader to compute the ranges of these data
        types. Here I am giving the contents of limits.h for you to see limits of data types and
        check for yourself.</d:para>
      <d:programlisting role="CLexer">/* Copyright (C) 1991, 1992, 1996, 1997, 1998, 1999, 2000, 2005
Free Software Foundation, Inc.
This file is part of the GNU C Library.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.  */

/*
*      ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types &lt;limits.h>
*/

#ifndef _LIBC_LIMITS_H_
#define _LIBC_LIMITS_H_ 1

#include &lt;features.h>


/* Maximum length of any multibyte character in any locale.
 We define this value here since the gcc header does not define
 the correct value.  */
 #define MB_LEN_MAX      16


/* If we are not using GNU CC we have to define all the symbols ourself.
Otherwise use gcc's definitions (see below).  */
#if !defined __GNUC__ || __GNUC__ &lt; 2

/* We only protect from multiple inclusion here, because all the other
#include's protect themselves, and in GCC 2 we may #include_next through
multiple copies of this file before we get to GCC's.  */
# ifndef _LIMITS_H
#  define _LIMITS_H     1

#include &lt;bits/wordsize.h>

/* We don't have #include_next.
Define ANSI &lt;limits.h> for standard 32-bit words.  */

/* These assume 8-bit `char's, 16-bit `short int's,
and 32-bit `int's and `long int's.  */

/* Number of bits in a `char'.  */
#  define CHAR_BIT      8

/* Minimum and maximum values a `signed char' can hold.  */
#  define SCHAR_MIN     (-128)
#  define SCHAR_MAX     127

/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */
#  define UCHAR_MAX     255

/* Minimum and maximum values a `char' can hold.  */
#  ifdef __CHAR_UNSIGNED__
#   define CHAR_MIN     0
#   define CHAR_MAX     UCHAR_MAX
#  else
#   define CHAR_MIN     SCHAR_MIN
#   define CHAR_MAX     SCHAR_MAX
#  endif

/* Minimum and maximum values a `signed short int' can hold.  */
#  define SHRT_MIN      (-32768)
#  define SHRT_MAX      32767

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  */
#  define USHRT_MAX     65535

/* Minimum and maximum values a `signed int' can hold.  */
#  define INT_MIN       (-INT_MAX - 1)
#  define INT_MAX       2147483647

/* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  */
#  define UINT_MAX      4294967295U

/* Minimum and maximum values a `signed long int' can hold.  */
#  if __WORDSIZE == 64
#   define LONG_MAX     9223372036854775807L
#  else
#   define LONG_MAX     2147483647L
#  endif
#  define LONG_MIN      (-LONG_MAX - 1L)

/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */
#  if __WORDSIZE == 64
#   define ULONG_MAX    18446744073709551615UL
#  else
#   define ULONG_MAX    4294967295UL
#  endif

#  ifdef __USE_ISOC99

/* Minimum and maximum values a `signed long long int' can hold.  */
#   define LLONG_MAX    9223372036854775807LL
#   define LLONG_MIN    (-LLONG_MAX - 1LL)

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */
#   define ULLONG_MAX   18446744073709551615ULL

#  endif /* ISO C99 */

# endif /* limits.h  */
#endif  /* GCC 2.  */

#endif  /* !_LIBC_LIMITS_H_ */

/* Get the compiler's limits.h, which defines almost all the ISO constants.

We put this #include_next outside the double inclusion check because
it should be possible to include this file more than once and still get
the definitions from gcc's header.  */
#if defined __GNUC__ &amp;&amp; !defined _GCC_LIMITS_H_
/* `_GCC_LIMITS_H_' is what GCC's file defines.  */
# include_next &lt;limits.h>
#endif

/* The &lt;limits.h> files in some gcc versions don't define LLONG_MIN,
LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
ages are available.  */
#if defined __USE_ISOC99 &amp;&amp; defined __GNUC__
# ifndef LLONG_MIN
#  define LLONG_MIN     (-LLONG_MAX-1)
# endif
# ifndef LLONG_MAX
#  define LLONG_MAX     __LONG_LONG_MAX__
# endif
# ifndef ULLONG_MAX
#  define ULLONG_MAX    (LLONG_MAX * 2ULL + 1)
# endif
#endif

#ifdef  __USE_POSIX
/* POSIX adds things to &lt;limits.h>.  */
# include &lt;bits/posix1_lim.h>
#endif

#ifdef  __USE_POSIX2
# include &lt;bits/posix2_lim.h>
#endif

#ifdef  __USE_XOPEN
# include &lt;bits/xopen_lim.h>
#endif</d:programlisting>
      <d:para>Here, I have given <d:application>gcc</d:application>’s <d:code>limits.h</d:code> as
          <d:application>clang</d:application> includes that. For knowing exact implementation for
        floating-point implementation on your platform I recommend you to read <link
          xmlns="http://docbook.org/ns/docbook"
          xlink:href="http://en.wikipedia.org/wiki/IEEE_754-2008"
          >http://en.wikipedia.org/wiki/IEEE_754-2008</link>. It is not possible to present all the
        information in detail here and I do not want to give you partial information. :-) I
        recommend you to go through <link xmlns="http://docbook.org/ns/docbook"
          xlink:href="http://en.wikipedia.org/wiki/Single_precision"
          >http://en.wikipedia.org/wiki/Single_precision</link> and <link
          xmlns="http://docbook.org/ns/docbook"
          xlink:href="http://en.wikipedia.org/wiki/Double_precision"
          >http://en.wikipedia.org/wiki/Double_precision</link> in particular. The range of log
        double varies from compiler to compiler.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">New Data Types of C99</title>
      <d:para>There are some new data types introduced in C99. They are <d:code>_Bool,
          _Complex</d:code> and <d:code>_Imaginary</d:code>.</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Boolean Types</title>
        <d:para><d:code>_Bool</d:code> counts as an integral type and is used to represent boolean
          values. Here is <d:code>stdbool.h</d:code> for your quick reference.</d:para>
        <d:programlisting role="CLexer">/*===---- stdbool.h - Standard header for booleans -------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __STDBOOL_H
#define __STDBOOL_H

/* Don't define bool, true, and false in C++, except as a GNU extension. */
#ifndef __cplusplus
#define bool _Bool
#define true 1
#define false 0
#elif defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__)
/* Define _Bool, bool, false, true as a GNU extension. */
#define _Bool bool
#define bool  bool
#define false false
#define true  true
#endif

#define __bool_true_false_are_defined 1

#endif /* __STDBOOL_H */</d:programlisting>
        <d:para>As you can see from the definition <d:code>true</d:code> is 1 and
            <d:code>false</d:code> is 0. Any non-zero value is considered to be true. Here is a
          program demonstrating that.</d:para>
        <d:programlisting role="CLexer">// Boolean Program
// Author: Shiv S. Dayal
// Description: Demo of boolean data typec

#include &lt;stdio.h>
#include &lt;stdbool.h>

int main()
{
  bool bcpp      = 4;
  _Bool bc       = 5;
  bool True      = true;
  _Bool False    = false;
  bool bFalseCPP = -4;
  _Bool bFalseC  = -7;

  printf("%d %d %d %d %d %d\n", bcpp, bc, True, False, bFalseCPP, bFalseC);

  getchar();

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>1 1 1 0 1 1</d:screen>
        <d:para>Note that <d:code>true</d:code> and <d:code>false</d:code> are keywords while
            <d:code>True</d:code> and <d:code>False</d:code> are identifiers.</d:para>
        <d:para>Though I wanted to avoid dealing with this but since I am including header files
          verbatim I must give an explanation of <d:code>#define</d:code> pre-processor macro at
          least. I will touch it very little as it will be covered in more detail later.
            <d:code>#define</d:code> has two parameters though not as function arguments. Whenever
          the first part is encountered second will be replaced. Consider this example:</d:para>
        <d:programlisting role="CLexer">// Boolean Program
// Author: Shiv S. Dayal
// Description: Demo of boolean data type

#define MAX 7
int main()
{
  MAX;
  return 0;
}</d:programlisting>
        <d:para>Just do <d:command>$clang -E define.c</d:command> to see the magic. Note that
            <d:code>#define</d:code> parameters are not type safe. Compiler will just paste the
          contents. Notice how <d:code>MAX</d:code> is replaced by 7.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Complex Types</title>
        <d:para>For complex types, there is a system header <d:code>complex.h</d:code> which
          internally includes various other headers. However I am giving you the summary here. There
          are following <d:code>#define</d:code> macros:</d:para>
        <d:para><d:code>complex</d:code>: Expands to <d:code>_Complex</d:code>
          <d:code>_Complex_I</d:code>: Expands to a constant expression of type <d:code>const float
            _Complex</d:code> with the value of the imaginary.</d:para>
        <d:para><d:code>imaginary</d:code>: Expands to <d:code>_Imaginary</d:code>.
            <d:code>_Imaginary_I</d:code>: Expands to a constant expression of type <d:code>const
            float _Imaginary</d:code> with the value of the imaginary value.</d:para>
        <d:para><d:code>I</d:code>: Expands to either <d:code>_Imaginary_I</d:code> or
            <d:code>_Complex_I</d:code>. If <d:code>_Imaginary_I</d:code> is not defined,
            <d:code>I</d:code> expands to <d:code>_Complex_I</d:code>.</d:para>
        <d:para>Complex types are declared as given below:</d:para>
        <d:orderedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">
              <code>float complex fCompZ;</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>double complex dCompZ;</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long double ldCompZ;</code></para>
          </d:listitem>
        </d:orderedlist>
        <d:para>Now I will present a summary of library functions provided by
            <d:code>complex.h</d:code></d:para>
        <d:programlisting role="CLexer">//cabs, cabsf, cabsl - these compute and return absolute value
//of a complex number z

double cabs(double complex z);
float cabsf(float complex z);
long double cabsl(long double complex z);

//carg, cargf, cargl - these compute and return argument of a complex
//number z. The range of return value's range from one +ve pi radian
//to one -ve pi radian.

double carg(double complex z);
float cargf(float complex z);
long double cargl(long double complex z);

//cimag, cimagf, cimagl - these compute imaginary part of a complex
//number z and return that as a real number.

double cimag(double complex z);
float cimagf(float complex z);
long double cimagl(long double complex z);

//creal, crealf, creall - these compute real part of a complex
//number z and return the computed value.

double creal(double complex z);
float crealf(float complex z);
long double creall(long double complex z);

//conj, conjf, conjl - these functions compute the complex conjugate
//of z, by reversing the sign of its imaginary part and return the
//computed value.

double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);

//cproj, cprojf, cprojl - these functions compute a projection of z
// onto the Riemann sphere: z projects to z, except that all complex
//infinities (even those with one infinite part and one NaN (not a
//number) part) project to positive infinity on the real axis. If z
//has an infinite part, then cproj( z) shall be equivalent to:
//INFINITY + I * copysign(0.0, cimag(z))
//These functions return the computed value.

double complex cproj(double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex z);

//cexp, cexpf, cexpl - these functions shall compute the complex
//exponent of z, defined as e^z and return the computed value

double complex cexp(double complex z);
float complex cexpf(float complex z);
long double complex cexpl(long double complex z);

//clog, clogf, clogl - these functions compute the complex
//natural (base e) logarithm of z, with a branch cut along
//the negative real axis and return complex natural logarithm
//value, in a range of a strip mathematically unbounded along
//real axis and in the interval -ipi to +ipi along the
//imaginary axis.

double complex clog(double complex z);
float complex clogf(float complex z);
long double complex clogl(long double complex z);

//csqrt, csqrtf, csqrtl - these functions compute the complex
//square root of z, with a branch cut along the negative real
//axis and return the computed value in the range of the right
//half-plane (including the imaginary axis)

double complex csqrt(double complex z);
float complex csqrtf(float complex z);
long double complex csqrtl(long double complex z);

//cpow, cpowf, cpowl - these functions compute the complex
//power function x^y, with a branch cut for the first
//parameter along the negative real axis and return the
//computed value.

double complex cpow(double complex x, double complex y);
float complex cpowf(float complex x, float complex y);
long double complex cpowl(long double complex x,
long double complex y);

//csin, csinf, csinl - these functions compute the complex
//sine of z and return the computed value.

double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);

//ccos, ccosf, ccosl - these functions compute the complex
//cosine of z and return the computed value.

double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);

//ctan, ctanf, ctanl - these functions compute the complex
//tangent of z and return the computed value.

double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);

//casin, casinf, casinl - these functions compute the complex
//arc sine of z, with branch cuts outside the interval
//[-1, +1] along the real axis and return the computed value
//in the range of a strip mathematically unbounded along the
//imaginary axis and in the interval -0.5pi to +0.5pi radian
//inclusive along the real axis.

double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);

//cacos, cacosf, cacosl - these functions compute the complex
//arc cosine of z, with branch cuts outside the interval
//[-1, +1] along the real axis and return the computed value
//in the range of a strip mathematically unbounded along the
//imaginary axis and in the interval -0 to +pi radian
//inclusive along the real axis.

double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);

//catan, catanf, catanl - these functions compute the complex
//arc tangent of z, with branch cuts outside the interval
//[-i, +i] along the real axis and return the computed value
//in the range of a strip mathematically unbounded along the
//imaginary axis and in the interval -0.5pi to +0.5pi radian
//inclusive along the real axis.

double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);

//csinh, csinhf, csinhl - these functions compute the complex
//hyperbolic sine of z and return the comupted value.

double complex csinh(double complex z);
float complex csinhf(float complex z);
long double complex csinhl(long double complex z);

//ccosh, ccoshf, ccoshl - these functions shall compute the
//complex hyperbolic cosine of z and return the computed
//value

double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl(long double complex z);

//ctanh, ctanhf, ctanhl - these functions compute the
//complex hyperbolic tangent of z and return the computed
//value.

double complex ctanh(double complex z);
float complex ctanhf(float complex z);
long double complex ctanhl(long double complex z);

//casinh, casinhf, casinhl - these functions compute the
//complex arc hyperbolic sine of z, with branch cuts
//outside the interval [-i, +i] along the imaginary axis and
//return the complex arc hyperbolic sine value, in the range
//of a strip mathematically unbounded along the real axis
//and in the interval [-i0.5pi, +i0.5pi] along the imaginary
//axis.

double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);
cacosh, cacoshf, cacoshl - theese functions compute the

//complex arc hyperbolic cosine of z, with a branch cut at
//values less than 1 along the real axis and return the complex
//arc hyperbolic cosine value, in the range of a half-strip
//of non-negative values along the real axis and in the
//interval [-ipi, +ipi] along the imaginary axis.

double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);

//catanh, catanhf, catanhl - these functions shall compute the
//complex arc hyperbolic tangent of z, with branch cuts outside
//the interval [-1, +1] along the real axis and return the
//complex arc hyperbolic tangent value, in the range of a strip
//mathematically unbounded along the real axis and in the
//interval [-i0.5pi, +i0.5pi] along the imaginary axis.

double complex catanh(double complex z);
float complex catanhf(float complex z);
long double complex catanhl(long double complex z);</d:programlisting>
        <d:para>Hers is a small demo program which explains three functions:</d:para>
        <d:programlisting role="CLexer">// Complex Number Program
// Author: Shiv S. Dayal
// Description: Demo of complex data type

#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 4.0 + 3.0i;

  printf("Absolute value of z is %lf\n", cabs(z));

  double complex zConj = conj(z);
  printf("Imaghinary part of conjugate is now %lf\n", cimag(zConj));

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:programlisting>Absolute value of z is 5.000000
Imaghinary part of conjugate is now -3.000000</d:programlisting>
        <d:para>You must note that in Makefile you must compile it like <d:command>$clang complex.c
            -o complex -lm</d:command>. Note the <d:code>-lm</d:code> part. It tells to look for
          definition of these functions in Math library of C. Without it the program won’t compile.
          At this point I encourage you to further explore different functions presented in the
          summary. There are even more data types for integral type. I am sorry but I am unwrapping
          the layers one by one. These types are defined in <d:code>inttypes.h</d:code> and
            <d:code>stdint.h</d:code>. The types are <d:code>int8_t, int16_t, int32_t, uint8_t,
            uint16_t</d:code> and <d:code>uint32_t</d:code>. The numbers tell you how many bits each
          data type will occupy. The types without leading <d:code>u</d:code> are of signed type and
          the ones with it are of unsigned type. You can use the good old <d:code>%d</d:code> or
            <d:code>%i</d:code> for decimal integers and <d:code>%o</d:code> and <d:code>%x</d:code>
          for octals and hexes. Have a look at headers and try to decipher them.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook"><code>void</code> and <code>enum</code>
        Types</title>
      <d:para>There are these two types remianing. void type comprises an empty set of values; it is
        an incomplete type that cannot be completed. You cannot declare an array of
          <d:code>void</d:code>s. It is a generic type in the sense that any other pointer to any
        type can be converted to pointer type of void and vice-versa. It is a low level type and
        should be only used to convert data types from one type to another and sparingly. A type
        occupies one byte. Typically you never declare a variable of void type. It is used mostly
        for casting.</d:para>
      <d:para><d:code>enum</d:code> comprises a set of named integer constant values. Each distinct
        enumeration constitutes a different enumerated type. In C enums are very much equivalent to
        integers. You can do all operations of an enum on an enumeration member. An enumeration is
        is a set of values. It starts from zero by default and increments by one unless specifically
        specified. Consider the following example:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of enum

#include &lt;stdio.h>

int main()
{
  typedef enum {zero, one, two} enum1;
  typedef enum {alpha=-5, beta, gamma, theta=4, delta, omega} enum2;

  printf("zero = %d, one = %d, two=%d\n", zero, one, two);
  printf("alpha = %d, beta = %d, gamma=%d, theta=%d, delta=%d, omega=%d\n", \
          alpha, beta, gamma, theta, delta, omega);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>zero = 0, one = 1, two=2
alpha = -5, beta = -4, gamma=-3, tehta=4, delta=5, omega=6</d:screen>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Constants</title>
      <d:para>We have seen some variables now let us see some constants. There are five categories
        of constants: character, integer, floating-point, string, and enumeration constant. We will
        see enumeration constants later first we see remaining four types of constants. There are
        certain rules about constants. Commas and spaces are not allowed except for character and
        string constants. Their range cannot outgrow the range of there data type. For numeric type
        of stants they can have a leading (-)minus sign.</d:para>
      <d:para>Given below is an example:</d:para>
      <d:programlisting role="CLexer">// Integer constants
// Author: Shiv S. Dayal
// Description: Demo of integer constants

#include &lt;stdio.h>

int main()
{
  int decimal = 7;
  int octal = 06;
  int hex = 0xb;

  printf("%d %o %x\n", decimal, octal, hex);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>7 6 b</d:screen>
      <d:para>As you can see there are three different categories for integer constants: decimal
        constants (base 10), octal constants (base 8) and hexadecimal constants (base 16). Also, you
        must have noticed how a zero is prefixed before octal type and a zero and x for hexadecimal
        type. The <d:code>%d</d:code> format specifier is already known to you for signed decimals.
        However, now you know two more <d:code>%o</d:code> and <d:code>%x</d:code> for unsigned
        octal and unsigned hexadecimal respectively. For unsigned integer it is <d:code>%u</d:code>.
        There is one more format specifier which you may encounter for signed decimal and that is
          <d:code>%i</d:code>.</d:para>
      <d:para>Note that there is nothing for binary constants. I leave this as an exercise to you to
        convert a number in any base shown above to binary and print it. Also vice-versa that is
        take a input in binary and convert to these three. Later I will show you this
        program.</d:para>
      <d:para>Now let us move to floating-point constants. Again, I will explain using an
        example:</d:para>
      <d:programlisting role="CLexer">// Floating-point constants
// Author: Shiv S. Dayal
// Description: Demo of floating-point constants

#include &lt;stdio.h>

int main()
{
  float f = 7.5384589234;
  double d = 13.894578834538578234784;
  long double ld = 759.8263478234729402354028358208358230829304;

  printf("%f %lf, %Lf\n", f, d, ld);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:programlisting>7.538459 13.894579, 759.826348</d:programlisting>
      <d:para>We will learn to change precision later when we deal with format specifiers along with
        printf and all input/output family. Here also, you learn three format specifiers. Other are
          <d:code>%e</d:code> or <d:code>%E</d:code> for scientific notation of float family. Then
        there is <d:code>%g</d:code> or <d:code>%G</d:code> which uses shorter of
          <d:code>%e</d:code> and <d:code>%f</d:code> types.</d:para>
      <d:para>Now we move on to character and string type constants and as usual with a small
        program.</d:para>
      <d:programlisting role="CLexer">// Character constants
// Author: Shiv S. Dayal
// Description: Demo of character constants

#include &lt;stdio.h>

int main()
{
  char c = 'S';
  char* str ="Shiv S, Dayal";

  printf("%c %s\n", c, str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>S Shiv S, Dayal</d:screen>
      <d:para>As I had said that commas and blanks are not allowed in numeric types but you can see
        both are allowed on character and string types. Also, the string is a character pointer that
        is it can point to memory location where a character is stored. In this case the string is
        stored in an area of memory called stack. When memory is allocated the compiler knows how
        much has been allocated. For string there is something called null character represented by
          ‘<d:code>\0</d:code>’ which is used to terminate string. By using this mechanism the
        program knows where the string is terminating. It is treated in next section as well.A very
        interesting thing to be noted is char is considered to be an integral type. It is allowed to
        perform addition etc on char type. Till now you have learnt many format specifiers and have
        seen they all start with <d:code>%</d:code>. Think how will you print <d:code>%</d:code> on
        stdout. It is printed like <d:code>%%</d:code>. It was simple,wasn’t it? C program have got
        something called ASCII table which is a 7-bit character table values ranging from0 to 127.
        There is also something called escape sequences and it is worth to have a look at
        them.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Escape Sequences</title>
      <d:para>All escape sequences start with a leading <d:code>\</d:code> . Following table shows
          them:<table xmlns="http://docbook.org/ns/docbook" frame="border" class="centered"
          border="1">
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
          <caption>Escape Sequences</caption>
          <thead>
            <tr bgcolor="#aaa">
              <th>Character</th>
              <th>Escape Sequences</th>
              <th>ASCII Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>null</td>
              <td>\0</td>
              <td>000</td>
            </tr>
            <tr>
              <td>bell (alert)</td>
              <td>\a</td>
              <td>007</td>
            </tr>
            <tr>
              <td>backspace</td>
              <td>\b</td>
              <td>008</td>
            </tr>
            <tr>
              <td>horizontal tab</td>
              <td>\t</td>
              <td>009</td>
            </tr>
            <tr>
              <td>newline(line feed)</td>
              <td>\n</td>
              <td>010</td>
            </tr>
            <tr>
              <td>vertical tab</td>
              <td>\v</td>
              <td>011</td>
            </tr>
            <tr>
              <td>form feed</td>
              <td>\f</td>
              <td>012</td>
            </tr>
            <tr>
              <td>carriage return</td>
              <td>\r</td>
              <td>013</td>
            </tr>
            <tr>
              <td>quotation mark (")</td>
              <td>\"</td>
              <td>034</td>
            </tr>
            <tr>
              <td>apostophe (')</td>
              <td>\'</td>
              <td>039</td>
            </tr>
            <tr>
              <td>question mark</td>
              <td>\?</td>
              <td>063</td>
            </tr>
            <tr>
              <td>backslash</td>
              <td>\\</td>
              <td>092</td>
            </tr>
          </tbody>
        </table></d:para>
      <d:para>Note that there is no space between two backslashes. Sphinx does not allow me to write
        four continuous backslashes. Now we will talk about all these one by one.
          <d:code>\0</d:code> which is also known as <d:code>NULL</d:code> is the string terminating
        character, as said previously, and must be present in string for it to terminate. For
        example, in our character constant program the str string is “<d:code>Shiv S.
        Dayal</d:code>”. So how many characters are there 13? Wrong 14! The <d:code>NULL</d:code>
        character is hidden. Even if we say <d:code>str=””;</d:code> then it will contain one
        character and that is this <d:code>NULL</d:code>. Many standard C functions rely on this
        presence of <d:code>NULL</d:code> and causes a lot of mess because of this. The bell escape
        sequence if for a bell from CPU. Let us write a program and see it in effect.</d:para>
      <d:programlisting role="CLexer">// Bell Program
// Author: Shiv S. Dayal
// Description: Demo of bell escape sequence

#include &lt;stdio.h>

int main()
{
  printf("hello\a");

  getchar();

  return 0;
}</d:programlisting>
      <d:para>The output of this program will be <d:code>hello</d:code> on stdout and an audible or
        visible bell as per settings of your shell. Notice the <d:code>getchar()</d:code> function
        which waits for input and reads a character from stdin. Next is backspace escape sequence.
        Let us see a program for its demo as well:</d:para>
      <d:programlisting role="CLexer">// Backspace Program
// Author: Shiv S. Dayal
// Description: Demo of backspace escape sequence

#include &lt;stdio.h>

int main()
{
  printf("h\b*e\b*l\b*l\b*o\b*\n");
  printf("\b");

  getchar();

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>*****</d:screen>
      <d:para>It is hello replaced by <d:code>*</d:code>. A minor modification in this program to
        replace the character as soon as key is pressed by some other character will turn it into a
        password program. Backspace escape sequence means when it is encountered the cursor moves to
        the previous position on the line in context. If active position of cursor is initial
        position then C99 standard does not specify the behavior of display device. However, the
        behavior on my system is that cursor remains at initial position. Check out on yours. The
        second <d:code>printf</d:code> function determines this behavior.</d:para>
      <d:para>Next we are going to deal with newline and horizontal tab escape sequences together as
        combined together they are used to format output in a beautiful fashion. The program is
        listed below:</d:para>
      <d:programlisting role="CLexer">// Newline and Horizontal tab program Program
// Author: Shiv S. Dayal
// Description: Demo of newline and horizontal tab escape sequence

#include &lt;stdio.h>

int main()
{
  printf("Before tab\tAftertab\n");
  printf("\nAfter newline\n");

  getchar();

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Before tab      Aftertab

After newline</d:screen>
      <d:para>Here I leave you to experiment with other escape sequences. Feel free to explore them.
        Try various combinations; let your creative juices flow.</d:para>
    </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="io/index.html" ?>
    <d:title>Console I/O</d:title>
    <d:para>What is I/O? I know you may be wondering what rubbish question? It is input/output.
      Well, yes you are right. However, i/o can be further categorized in several categories. First
      of them is console i/o, which is what we are concerned with. In console i/o your keyboard is
      input device or <d:code>stdin</d:code> file stream and display device or monitor is output
      device or <d:code>stdout</d:code> file stream. There is also also something called
        <d:code>stderr</d:code> which is standard error file stream. For historical reasons these
      are known as <d:code>FILE</d:code>, which, happens to be the data type for handling these
      streams. Then there are more different kind of i/o. In everyday usage you use mouse to handle
      GUI. Standard C99 does not have anything for mouse. For your hard disk i/o that is real files
      like our source code files and executable file same FILE stream is used. Network i/o is also
      there. There is an opengroup which specifies functions for network related functions. Some
      operating system like GNU/Linux are POSIX compatible which defines how network i/o will be
      used. Even a printer is a special output device, a camera input, speakers output, microphone
      input and so on. However, before we go on with i/o I would like to present C’s memory model
      which will be needed by our discussion of i/o related functions. However, if things do not
      make sense even then please go through it and come later to understand more.</d:para>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">C's Memory Model</title>
      <d:para>C programs use <d:hardware>RAM</d:hardware> as primary memory except when you use
        register keyword to request compiler to store variables in cpu register. C’s memory model is
        split into three area at a higher level. Data, Stack and Code Segment. Date is further split
        in three parts; initialized data segment, uninitialized data segment or BSS which is name
        after an ancient assembler Block Started by Symbol and heap. Initialized data segment
        contains initialized global variables and static variables. Here both global and local
        static variables are counted. For uninitialized data segment it is same as above just that
        the variables are not initialized explicitly but implicitly to zero. Next is heap. Heap is
        the largest area of memory used for dynamic memory allocation. As you will see later that
        you can manage heap using <d:code>malloc(), calloc(), realloc(),</d:code> and
          <d:code>free()</d:code>. Note that compiler does not manage memory allocated for you. You,
        the programmer, are responsible for allocating and freeing up memory in area. If heap gets
        full os will use virtual memory or swap space on hard disk. Objects allocated on heap
        persist across function calls. However, there are some very nasty problems, which, come in
        picture when you use heap. There are several of them. You may forget to allocate memory and
        want to dereference unallocated pointer. You may have initialized it to
          <d:code>NULL</d:code> and try to dereference that. You may allocate and free twice. You
        forgot to set pointer to <d:code>NULL</d:code> after freeing it. And last but not the least
        you loose all pointers to the memory area before you can free. The nature with this
        particular problem is that if your program is going to run for long time then it is going to
        consume more and more memory. Because of its nature it is known as memory leak. It is very
        difficult to detect such problems in code which does not run for long periods of time. Our
        friend valgrind will come to help up with this problem. When a memory leak happens it eats
        up <d:hardware>RAM</d:hardware> slowly and then operating system has to use virtual memory
        as explained above. In a nutshell, I will say that heap means you have to handle
        it.</d:para>
      <d:para>Stack is relatively simple. All non-static and non-register variables go on stack.
        Stack variables do not retain there value across function calls unless they are passed as
        pointers. Also, when they go out of scope, that is the scope in which they were declared
        ends, they will be kind of lost. The way in which stack frame moves the same area will be
        used for new variables. However, stack is very limited (compared to heap) and in deeply
        nested function calls or recursion (you will see these in Functions chapter) stack may get
        full and program may crash. The reason for crashing is that operating system will not use
        virtual memory but will do a segmentation fault in its place. GNU/Linux allow its users to
        modify the stack size by ulimit command. Note that stack and heap are adjacent in memory and
        grow in opposite direction.</d:para>
      <d:para>Code segment or text segment is an area where the executable instructions of program
        reside. It is typically constant and read-only area unless your system allows self-modifying
        code. Following diagram shows the memory layout.</d:para>
      <d:figure>
        <d:title>C's Memory Model</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="images/memmod.png"/>
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
      <d:para>In this chapter we will look at only those functions, which, allow us to do console
        i/o. We will begin with our familiar friends. Can you guess who are they? Yes! They are
          <d:code>printf</d:code> and <d:code>scanf</d:code>.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>printf</d:title>
      <d:para><d:code>printf</d:code> is a string based output function that is It writes character
        strings to <d:code>stdout</d:code>. The data which has to be written is formatted by format
        string as shown previously. After the format specifier it expects as many arguments as
        specified in format string. The characters which are not like, say <d:code>%d</d:code> for
        example, arecalled ordinary characters. These are simply copied to output stream, which, is
          <d:code>stdout</d:code> for <d:code>printf</d:code>. The <d:code>%d</d:code> like
        conversion charcaters are known as conversion specification or format specifiers. Each
        conversion specification should be augmented with one one argument. The results are
        undefined if there are insufficient arguments for the format. If extra arguments are given
        the excess arguments will be evaluated but are otherwise ignored. However, there is a big
        problem here! There is no type-safety.:-( In general compiler will warn you about it and
        you, the programmer, are responsible for giving correct format string, correct no. of
        correct type of arguments. Consider the following program for
        example:<d:programlisting role="CLexer">// printf demo
// Author: Shiv Shankar Dayal
// Description: printf demo

#include &lt;stdio.h>

int main()
{
  printf("%d %d\n", 3, 8);

  //do not mess it. undefined behavior
  printf("%d %d\n", 5);

  //extra arguments ignored
  printf("%d %d\n", 3, 5, "hello");

  //legal because char is integer type
  printf("%d\n", 's');

  //wrap around of integer as char
  printf("%c\n", 836);

  //do not mess with type-safety
  int i = printf("%d\n", "hello");
  prinf("%d\n", i);

  return 0;
}</d:programlisting>
        now that if you give the command like <d:code>clang printf.c</d:code> then you will be shown
        following warnings:
        <d:screen>printf.c:12:14: warning: more '%' conversions than data arguments [-Wformat]
        printf("%d %d\n", 5);
                 ~^
printf.c:15:26: warning: data argument not used by format string [-Wformat-extra-args]
        printf("%d %d\n", 3, 5, "hello");
             ~~~~~~~~~        ^
printf.c:24:19: warning: conversion specifies type 'int' but the argument has type
'char *' [-Wformat]
      int i = printf("%d\n", "hello");
                      ~^     ~~~~~~~
                      %s
3 warnings generated.</d:screen>
        Clearly this is not a good sign for any program. A program should compile cleanly. In our
        case compiler is generating binary even though there are warnings. You can make compiler
        generate more warnings by issuing a <d:code>-Wall</d:code> flag. You can also treat all
        warnings as errors by passing <d:code>-Werror</d:code> to compiler. These two options will
        ensure that your code has no warnings. Now let us move to output and try to understand it.
        The output on my system is as given below. It may differ on your system:
        <d:screen>3 8
5 8
3 5
115
D
134514119
10</d:screen> First
          <d:code>printf</d:code> is correct as expected. The second line causes undefined behavior.
        You may think it is the previous 8 but rest assured it is not guaranteed that it will always
        the case. Ii is <d:emphasis role="bold">UNDEFINED</d:emphasis>. Third printf is also fine in
        the sense that extra argument is ignored. Fourth and fifth are normal. Sixth is again a big
        problem. You are trying to print a decimal integer while argument is a character string.
        There is no way for compiler to determine that what should be printed which will fit on
        standards. Now we will have to take a look at all possible format specifier and their
        meanings. You have seen most of them so this is more for a reference. I have taken following
        from <d:link xlink:href="http://www3.opengroup.org">http://www3.opengroup.org</d:link> and
        modified to suit the book. In particular, I have omitted facts related to XSI specification. </d:para>
      <d:para>Each conversion specification starts with '<d:code>%</d:code>' character. After this
        following appear in sequence:</d:para>
      <d:itemizedlist>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">Zero or more flags, in any order, which modify
            the meaning of the conversion specification.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional minimum field width. If the
            converted value from argument has fewer characters (bytes) than the field width, it will
            be padded with spaces by default on left; it will be padded on right if the
            left-adjustment flag (‘-‘) is given to the field width. The field width takes the form
            of an asterisk or a decimal integer.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional precision that gives the minimum
            number of digits to appear for the <code>d, i, o, u, x</code> and <code>X</code>
            conversion specifiers; the number of digits to appear for radix character for the
              <code>a, A, e, E, f</code> and <code>F</code> conversion specifiers; the maximum
            number of significant digits for the <code>g</code> and <code>G</code> conversion
            specifiers; or the maximum number of bytes to be printed from a string in the s
            conversion specifiers. The precision takes form of a period (‘.’) followed either by an
            asterisk (‘*’), described below, or an optional decimal digit string, where a null digit
            string is treated as zero. If a precision appears with any other conversion specifier,
            the behavior is undefined.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional length modifier that specifies the
            size of the argument.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">A conversion specifier character that
            indicates the type of conversion to be applied.</para>
        </d:listitem>
      </d:itemizedlist>
      <d:para>A field width, or precision, or both, may be indicated by an asterisk(‘*’). In this
        case an argument of type int supplies the field width or precision. You, the programmer,
        will have to ensure that arguments specifying field, width or precision, or both appear in
        that order before the argument, if any to be converted. A negative field width is taken as a
        ‘-‘ flag followed a positive field width. A negative precision is taken as if the precision
        were omitted.</d:para>
      <d:para>The flag characters and their meanings are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">-</emphasis> The result of
        the conversion will be left-justified within the field. The conversion is right-justified if
        the flag is not specified.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">+</emphasis> The result of
        a signed conversion will always begin with a sign (‘+’ or ‘-‘). The conversion will begin
        with a sign only when a negative value is converted if this value is not specified.</d:para>
      <d:para>If the first character of a signed conversion is not a sign or if a signed conversion
        results in no characters, a will be prefixed to the result. This means that if the and ‘+’
        flags both appear, the flag will be ignored.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">#</emphasis> Specifies
        that the value is to be converted to an alternative form. For o conversion, it increases the
        precision (if necessary) to force the first digit of the result to be zero. For
          <d:code>x</d:code> or <d:code>X</d:code> conversion specifiers, a non-zero result will
        have <d:code>0x (0X)</d:code> prefixed to it. For <d:code>a, A, e, E, f, F, g</d:code> and
          <d:code>G</d:code> conversion specifiers, the result will always contain a radix
        character, even if no digits follow the radix character. Without this flag, a radix
        character appears in the result of these conversions only if a digit follows it.</d:para>
      <d:para>For 0 and <d:code>G</d:code> conversion specifiers, trailing zeros will not be removed
        from the result as they normally are. For other conversion specifiers the, the behavior is
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">UNDEFINED</emphasis>.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">0</emphasis> For
          <d:code>d, i, o, x, X, a, A, e, E, f, F, g</d:code> and <d:code>G</d:code> conversion
        specifiers, leading zeros (following any indication of sign or base) are used to pad to the
        field width; no space padding is performed. If the ‘0’ and ‘-‘ flags both appear, the ‘0’
        flag is ignored. For <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion
        specifiers, if a precision is specified, the ‘0’ flag is ignored.</d:para>
      <d:para>The length and their meanings are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">hh</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifiers
        applies to a <d:code>signed char</d:code> or <d:code>unsigned char</d:code> argument (the
        argument will have been promoted according to integer promotions, but its value will be
        converted to <d:code>signed char</d:code> or <d:code>unsigned char</d:code> before printing;
        or that a following n conversion specifier applies to a pointer to a <d:code>signed
          char</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">h</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>short</d:code> or <d:code>unsigned short</d:code> argument (the
        argument will have been promoted according to the integer promotions, but its value will be
        converted to <d:code>short</d:code> or <d:code>unsigned short</d:code> before printing); or
        that a following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>short</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">l</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>long</d:code> or <d:code>unsigned long</d:code> argument; that a
        following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>long</d:code> argument; that a following <d:code>c</d:code> conversion specifier
        applies to a <d:code>win_t</d:code> argument; that a following <d:code>s</d:code> conversion
        specifier applies to a <d:code>wchar_t</d:code> argument; or has not effect on a following
          <d:code>a, A, e, R, f, F, g</d:code> or <d:code>G</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">ll</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>long long</d:code> or <d:code>unsigned long long</d:code> argument;
        that a following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>long long</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">j</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to an <d:code>intmax_t</d:code> or <d:code>uintmax_t</d:code> argument; or that a
        following <d:code>n</d:code> conversion specifier applies to an <d:code>intmax_t</d:code>
        argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">z</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>size_t</d:code> or the corresponding signed integer type argument; or
        that a following <d:code>n</d:code> conversion specifier applies to a signed integer type
        corresponding to a <d:code>size_t</d:code> argument.</d:para>
      <d:para><d:code>t</d:code> Specifies that a following <d:code>d, i, o, u, x</d:code> and
          <d:code>X</d:code> conversion specifier applies to a <d:code>ptrdiff_t</d:code> or the
        corresponding <d:code>unsigned int</d:code> type argument; or that a following
          <d:code>n</d:code> conversion specifier applies to a unsigned integer type corresponding
        to a <d:code>ptrdiff_t</d:code> argument.</d:para>
      <d:para><d:code>L</d:code> Specifies that a following <d:code>a, A, e, E, f, F, g</d:code> and
          <d:code>G</d:code> conversion specifier applies to a <d:code>long double</d:code>
        argument.</d:para>
      <d:para>If a length modifier appears with any conversion specfier other than as specified
        above, the behavior is <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >UNDEFINED</emphasis>. You may have noted data types like <d:code>intmax_t,
          size_t</d:code> and <d:code>ptrdiff_t</d:code>, which you may not know and I have not told
        you about them. But do not worry in due course of time we will see them.</d:para>
      <d:para>The conversion specifiers and their meaning are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">d, i</emphasis> The
          <d:code>int</d:code> argument will be converted to a signed decimal in the style
          “[-]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be converted in fewer digits, it will be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">o</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned octal format in the style
          “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be represented in fewer digits, it will be expanded with leading zeros. The default
        precision is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">u</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned decimal format in the
        style “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be represented in fewer digits, it will be expanded with leading zeros. The default
        precision is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">x</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned decimal format in the
        style “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”; the
        letters “abcdef” are used. The precision specifiers specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer digits, it will be
        expanded with leading zeros. The default precision is 1. The result of converting zero with
        an explicit precision of zero will be no characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">X</emphasis> Equivalent to
        the x conversion specifier, except that letters "<d:code>ABCDEF</d:code>" are used instead
        of "<d:code>abcdef</d:code>".</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">f, F</emphasis> The
          <d:code>double</d:code> argument will be converted to decimal notation in the style
          “[-]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">ddd.ddd</emphasis>”,
        where the number of digits after the radix character is equal to the precision
        specification. If the precision is missing, it will be taken as 6; if the precision is
        explicitly zero and no ‘#’ flag is present, no radix character will appear. If a radix
        character appears, at least one digit appears before it. The low-order digit will be rounded
        in an implementation-defined manner.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity will be converted in one
        of the styles “[-]<d:code>inf</d:code>” or “[-]<d:code>infinity</d:code>” ; which style is
        implementation-defined. A double argument representing a NaN will be converted in one of the
        styles “[-]<d:code>nan</d:code>(<emphasis xmlns="http://docbook.org/ns/docbook"
          role="italic">n-char-sequence</emphasis>)” or “[-]<d:code>nan</d:code>”; which style, and
        the meaning of any n-char-sequence, is implementation-defined. The F conversion specifier
        produces "<d:code>INF</d:code>", "<d:code>INFINITY</d:code>" or "<d:code>NAN</d:code>"
        instead of "<d:code>inf</d:code>", "<d:code>infinity</d:code>" or "<d:code>nan</d:code>",
        respectively.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">e, E</emphasis> The
          <d:code>double</d:code> argument will be converted in the style “[-]<emphasis
          xmlns="http://docbook.org/ns/docbook" role="italic">d.ddde</emphasis>[<d:inlineequation>
          <mml:math>
            <mml:mo>±</mml:mo>
          </mml:math>
        </d:inlineequation>]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
          >dd</emphasis>”, where there is one digit before the radix character (which is non-zero if
        the argument is non-zero) and the number of digits after it is equal to the precision; if
        the precision is missing, it will be taken as 6; if the precision is zero and no ‘#’ flag is
        present, no radix character will appear. The low-order digit will be rounded in an
        implementation-defined manner. The E conversion specifier will produce a number with ‘E’
        instead of ‘e’ introducing the exponent. The exponent will always contain at least two
        digits. If the value is zero, the exponent will be zero.</d:para>
      <d:para>A double argument representing an infinity or NaN will be converted in the style of an
          <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">g, G</emphasis> The double
        argument will be converted in the style <d:code>f</d:code> or <d:code>e</d:code> (or in the
        style <d:code>F</d:code> or <d:code>E</d:code> in the case of a <d:code>G</d:code>
        conversion specifier), with the precision specifying the number of significant digits. If an
        explicit precision is zero, it will be taken as 1. The style used depends on the value
        converted; style <d:code>e</d:code> (or <d:code>E</d:code> ) will be used only if the
        exponent resulting from such a conversion is less than -4 or greater than or equal to the
        precision. Trailing zeros will be removed from the fractional portion of the result; a radix
        character will appear only if it is followed by a digit or a ‘<d:code>#</d:code>’ flag is
        present.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity or NaN will be converted
        in the style of an <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><d:code>a, A</d:code> A <d:code>double</d:code> argument representing a floating-point
        number will be converted in the style “[-]<emphasis xmlns="http://docbook.org/ns/docbook"
          role="italic">0xh.hhhhp</emphasis>(<d:inlineequation>
          <mml:math>
            <mml:mo>±</mml:mo>
          </mml:math>
        </d:inlineequation>)<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
          >d</emphasis>”, where there is one hexadecimal digit (which will be non-zero if the
        argument is a normalized floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is equal to the
        precision; if the precision is missing and <d:code>FLT_RADIX</d:code> is a power of 2, then
        the precision will be sufficient for an exact representation of the value; if the precision
        is missing and <d:code>FLT_RADIX</d:code> is not a power of 2, then the precision will be
        sufficient to distinguish values of type <d:code>double</d:code>, except that trailing zeros
        may be omitted; if the precision is zero and the ‘<d:code>#</d:code>’ flag is not specified,
        no decimal-point character will appear. The letters "<d:code>abcdef</d:code>" will be used
        for a conversion and the letters "<d:code>ABCDEF</d:code>" for A conversion. The
          <d:code>A</d:code> conversion specifier produces a number with ‘<d:code>X</d:code>’ and
          ‘<d:code>P</d:code>’ instead of ‘<d:code>x</d:code>’ and ‘<d:code>p</d:code>’. The
        exponent will always contain at least one digit, and only as many more digits as necessary
        to represent the decimal exponent of 2. If the value is zero, the exponent will be
        zero.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity or NaN will be converted
        in the style of an <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">c</emphasis> The <emphasis
          xmlns="http://docbook.org/ns/docbook" role="bold">int</emphasis> argument will be
        converted to an <d:code>unsigned char</d:code>, and the resulting byte will be written. If
        an <d:code>l</d:code> qualifier is present, the <d:code>wint_t</d:code> argument will be
        converted as if by an <d:code>ls</d:code> conversion specification with no precision and an
        argument that points to a two-element array of type <d:code>wchar_t</d:code>, the first
        element of which contains the <d:code>wint_t</d:code> argument to the <d:code>ls</d:code>
        conversion specification and the second element contains a null wide character.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">s</emphasis> The argument
        will be a pointer to an array of <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >char</emphasis>. Bytes from the array will be written up to (but not including) any
        terminating null byte. If the precision is specified, no more than that many bytes will be
        written. If the precision is not specified or is greater than the size of the array, the
        programmer will ensure that the array contains a null byte. Note that it is a big problem
        which causes <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">strcpy</emphasis>
        to be insecure. What is the char array does not have this null terminating character? We
        will see a safe implementation of <d:code>strcpy</d:code> later. Also,
          <d:code>strlen</d:code> suffers from this problem. Any function relying on null character
        will suffer from this. If an <d:code>l</d:code> qualifier is present, the argument will be a
        pointer to an array of type <d:code>wchar_t</d:code>. Wide characters from the array will be
        converted to characters (each as if by a call to the <d:code>wcrtomb()</d:code> function,
        with the conversion state described by an <d:code>mbstate_t</d:code> object initialized to
        zero before the first wide character is converted) up to and including a terminating null
        wide character. The resulting characters will be written up to (but not including) the
        terminating null character (byte). If no precision is specified, the programmer will ensure
        that the array contains a null wide character. If a precision is specified, no more than
        that many characters (bytes) will be written (including shift sequences, if any), and the
        array will contain a null wide character if, to equal the character sequence length given by
        the precision, the function would need to access a wide character one past the end of the
        array. In no case will a partial character be written.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">p</emphasis> The argument
        will be a pointer to <d:code>void</d:code>. The value of the pointer is converted to a
        sequence of printable characters, in an implementation-defined manner.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">n</emphasis> The argument
        will be a pointer to an <d:code>int</d:code> into which is written the number of bytes
        written to the output so far by this call to one of the fprintf() functions. No argument is
        converted.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">%</emphasis> Print a
          ‘<d:code>%</d:code>’ character; no argument is converted. The complete conversion
        specification will be <d:code>%%</d:code>.</d:para>
      <d:para>If a conversion specification does not match one of the above forms, the behavior is
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">UNDEFINED</emphasis>. If any
        argument is not the correct type for the corresponding conversion specification, the
        behavior is undefined. This is what happened to out string in <d:code>printf.c</d:code>
        shown above. In no case will a nonexistent or small field width cause truncation of a field;
        if the result of a conversion is wider than the field width, the field will be expanded to
        contain the conversion result. Characters generated by <d:code>fprintf()</d:code> and
          <d:code>printf()</d:code> are printed as if <d:code>fputc()</d:code> had been
        called.</d:para>
      <d:para>For the <d:code>a</d:code> and <d:code>A</d:code> conversion specifiers, if
          <d:code>FLT_RADIX</d:code> is a power of 2, the value will be correctly rounded to a
        hexadecimal floating number with the given precision. For <d:code>a</d:code> and
          <d:code>A</d:code> conversions, if <d:code>FLT_RADIX</d:code> is not a power of 2 and the
        result is not exactly representable in the given precision, the result should be one of the
        two adjacent numbers in hexadecimal floating style with the given precision, with the extra
        stipulation that the error should have a correct sign for the current rounding
        direction.</d:para>
      <d:para>For the <d:code>e, E, f, F, g</d:code> and <d:code>G</d:code> conversion specifiers,
        if the number of significant decimal digits is at most <d:code>DECIMAL_DIG</d:code>, then
        the result should be correctly rounded. If the number of significant decimal digits is more
        than <d:code>DECIMAL_DIG</d:code> but the source value is exactly representable with
          <d:code>DECIMAL_DIG</d:code> digits, then the result should be an exact representation
        with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
          <d:code>L &lt; U</d:code>, both having <d:code>DECIMAL_DIG</d:code> significant digits;
        the value of the resultant decimal string <d:code>D</d:code> should satisfy <d:code>L &lt;=
          D &lt;= U</d:code>, with the extra stipulation that the error should have a correct sign
        for the current rounding direction.</d:para>
      <d:para>Some of the capitalized words like <d:code>DECIMAL_DIG, FLT_RADIX</d:code> etc are
        macros defined in <d:code>float.h</d:code>. You should have a look at it. Now we will have
        one example and I will show you output but not explain it. Understanding the output is left
        as an exercise to you, the reader.</d:para>
      <d:programlisting role="CLexer">// Format Specifiers
// Author: Shiv S. Dayal
//Desciption: It is a demo of several format specifiers

#include&lt;stdio.h>

int main()
{
  int i   = 343456;
  float f = 123;
  long double ld = 78939.9347;

  printf("% d\n", i);
  printf("%+d\n", i);
  printf("%#o\n", i);
  printf("%#f\n", f);
  printf("%-08i\n", i);
  printf("%08i\n", i);
  printf("%8i\n", i);
  printf("%hhi\n", i);
  printf("%hi\n", i);
  printf("%li\n", i);
  printf("%lli\n", i);
  printf("%ji\n", i);
  printf("%zi\n", i);
  printf("%ti\n", i);
  printf("%8.8f\n", f);
  printf("%8.8Lf\n", ld);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen> 343456
+343456
01236640
123.000000
343456
00343456
  343456
-96
15776
343456
4638355772471066016
4638355772471066016
343456
343456
123.00000000
78939.93470000</d:screen>
<d:para>I suggest you to read the desciption of conversion specifiers
and experiment with various parameters to get different kind of
output.</d:para>
    </d:sect1>
    <d:sect1><d:title>scanf</d:title>
    <d:para><d:code>scanf()</d:code> is sister of
    <d:code>printf()</d:code>. They work in tandem. As its
    name says scan function it scans <d:code>stdin</d:code> or
    keyboard for input. Its signature is same as that of printf(). It
    raeds bytes from keyboard input, interprets them according to
    format string. It also expects a set of pointer arguments as
    opposed to values for <d:code>printf()</d:code>. The 
    pointers indicate where the interpreted data from the input will
    be stored. The result is <d:emphasis
    role="bold">UNDEFINED</d:emphasis>
    if there are less number of pointer arguments than the number of
    conversion specifers in format string. Excess arguments will be
    evaluated but ignored. The format string can have only white-space
    characters or an ordinary character (neither ‘<d:code>%</d:code>’
    nor a white-space character) or a conversion specification. Each
    conversion specification is introduced by ‘<d:code>%</d:code>’,
    after which the following appear in sequence.</d:para>
    <d:itemizedlist>
      <d:listitem>
	<d:para>An optoinal assignment suppressing character
	‘<d:code>*</d:code>’.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>An optional non-zero decimal integer that specifies
	the maximum field width</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>An option length modifier that specifies the size of
	the receiving object.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>A conversion specifier character that specifies the
	type of conversion to be applied. The valid conversion
	specifiers are described below.</d:para>
      </d:listitem>
    </d:itemizedlist>
    <d:para>A directive composed of one or more white-space characters
    will be executed by reading input until no more valid input can be
    read, or up to the first byte which is not a white-space character,
    which remains unread.</d:para>
    <d:para>A directive that is an ordinary character will be executed
    as follows: the next byte will be read from the input and compared
    with the byte that comprises the directive; if the comparison
    shows that they are not equivalent, the directive will fail, and
    the differing and subsequent bytes will remain unread. Similarly,
    if end-of-file, an encoding error, or a read error prevents a
    character from being read, the directive will fail.</d:para>
    <d:para>A directive that is a conversion specification defines a set
    of matching input sequences, as described below for each conversion
    character. A conversion specification will be executed in the
    following steps.</d:para>
    <d:para>Input white-space characters (as specified by
    <d:code>isspace()</d:code>) will be skipped, unless the conversion
    specification includes a <d:code>[, c, C</d:code> or
    <d:code>n</d:code> conversion specifier.</d:para>
    <d:para>An item will be read from the input, unless the conversion
    specification includes an n conversion specifier. An input item
    will be defined as the longest sequence of input bytes (up to any
    specified maximum field width, which may be measured in characters
    or bytes dependent on the conversion specifier) which is an
    initial subsequence of a matching sequence. The first byte, if
    any, after the input item will remain unread. If the length of the
    input item is 0, the execution of the conversion specification
    will fail; this condition is a matching failure, unless
    end-of-file, an encoding error, or a read error prevented input
    from the stream, in which case it is an input failure.</d:para>
    <d:para>Except in the case of a <d:code>%n</d:code> conversion
    specifier, the input item (or, in the case of a
    <d:code>%n</d:code> conversion specification, the count 
    of input bytes) will be converted to a type appropriate to the
    conversion character. If the input item is not a matching
    sequence, the execution of the conversion specification fails;
    this condition is a matching failure. Unless assignment
    suppression was indicated by a '<d:code>*</d:code>', the result of
    the conversion will be placed in the object pointed to by the
    first argument following the format argument that has not already
    received a conversion result if the conversion specification is
    introduced by <d:code>%</d:code>. If this object does not have an
    appropriate type, or if the result of the conversion cannot be
    represented in the space provided, the behavior is
    undefined.</d:para>
    <d:para>The length modifiers and their meanings are:</d:para>
    <d:para><d:emphasis role="bold">hh</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>signed char</d:code> or <d:code>unsigned
    char</d:code>.</d:para>
    <d:para><d:emphasis role="bold">h</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>short</d:code> or <d:code>unsigned
    short</d:code>.</d:para>
    <d:para><d:emphasis role="bold">l</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>long</d:code> or <d:code>unsigned long</d:code>; that a
    following <d:code>a, A, e, E, f, F, g</d:code> or
    <d:code>G</d:code> conversion specifier applies to an argument
    with type pointer to <d:code>double</d:code>; or that a following
    <d:code>c, s</d:code> or <d:code>[ conversion</d:code> specifier
    applies to an argument with type pointer to
    <d:code>wchar_t</d:code>.</d:para>
    <d:para><d:emphasis role="bold">j</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>intmax_t</d:code> or <d:code>uintmax_t</d:code>.</d:para>
    <d:para><d:emphasis role="bold">z</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to
    <d:code>size_t</d:code> or the corresponding <d:code>signed int</d:code>
    type.</d:para>
    <d:para><d:emphasis role="bold">t</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to
    <d:code>ptrdiff_t</d:code> or the corresponding <d:code>unsigned
    type</d:code>.</d:para>
    <d:para><d:emphasis role="bold">L</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to <d:code>long
    double</d:code>.</d:para>
    <d:para>If a length modifier appears with any conversion specifier other
    than as specified above, the bahavior is undefined. The following
    conversion specifiers are valid:</d:para>
    <d:para><d:emphasis role="bold">d</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 10 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">i</d:emphasis> Matches an optionally signed
    integer, whose format is the same as expected for the subject sequence of
    <d:code>strtol() with</d:code> 0 for the base argument. In the absence of a
    size modifier, the programmer will ensure that the corresponding argument
    is a pointer to <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">code</d:emphasis> Matches an optionally
    signed octal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 8 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to unsigned.</d:para>
    <d:para><d:emphasis role="bold">u</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 10 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">x</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 16 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">a, e, f, g</d:emphasis> Matches an
    optionally signed floating-point number, infinity, or NaN, whose format is
    the same as expected for the subject sequence of
    <d:code>strtod(). In</d:code> the absence of a size modifier, the
    programmer will ensure that the corresponding argument is a pointer to
    float.</d:para>
    <d:para>If the <d:code>printf() family</d:code> of functions generates
    character string representations for infinity and NaN (a symbolic entity
    encoded in floating-point format) to support IEEE Std 754-1985, the
    <d:code>scanf() family</d:code> of functions will recognize them as
    input.</d:para>
    <d:para><d:emphasis role="bold">s</d:emphasis> Matches a sequence of bytes
    that are not white-space characters. The programmer will ensure that the
    corresponding argument is a pointer to the initial byte of an array (will
    see them later) of <d:code>char, signed char</d:code> or <d:code>unsigned
    char</d:code> large enough to accept the sequence and a terminating null
    character code, which will be added automatically.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character will be converted to a wide character as if by a call to the
    <d:code>mbrtowc() function</d:code>, with the conversion state described by
    an <d:code>mbstate_t</d:code> object initialized to zero 
    before the first character is converted. The programmer will ensure that
    the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the sequence and the
    terminating null wide character, which will be added
    automatically.</d:para>
    <d:para><d:emphasis role="bold">c</d:emphasis> Matches a sequence of bytes
    of the number specified by the field width (1 if no field width is present
    in the conversion specification). The programmer will ensure that the
    corresponding argument is a pointer to the initial byte of an array of
    <d:code>char, signed char</d:code> or <d:code>unsigned char</d:code> large
    enough to accept the sequence. No null byte is added. The normal skip over
    white-space characters will be suppressed in this case.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character will be converted to a wide character as if by a call to the
    <d:code>mbrtowc() function</d:code>, with the conversion state described by
    an <d:code>mbstate_t</d:code> object initialized to zero 
    before the first character is converted. The programmer will ensure that
    the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the resulting sequence of
    wide characters. No null wide character is added.</d:para>
    <d:para><d:emphasis role="bold">p</d:emphasis> Matches an
    implementation-defined set of sequences, which shall be the same as the set
    of sequences that is produced by the %p conversion specification of the
    corresponding <d:code>printf() functions</d:code>. The application shall
    ensure that the corresponding argument is a pointer to a pointer to
    void. The interpretation of the input item is implementation-defined. If
    the input item is a value converted earlier during the same program
    execution, the pointer that results will compare equal to that value;
    otherwise, the behavior of the <d:code>%p</d:code> conversion specification
    is undefined.</d:para>
    <d:para><d:emphasis role="bold">[ </d:emphasis>Matches a non-empty sequence
    of bytes from a set of expected bytes (the scanset). The normal skip over
    white-space characters shall be suppressed in this case. The programmer
    will ensure that the corresponding argument is a pointer to the initial
    byte of an array of <d:code>char, signed char</d:code> or <d:code>unsigned
    char</d:code> large enough to accept the sequence and a terminating null
    byte, which shall be added automatically.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character in the sequence will be converted to a wide character as if by a
    call to the <d:code>mbrtowc() function</d:code>, 
    with the conversion state described by an <d:code>mbstate_t</d:code> object
    initialized to zero before the first character is converted. The programmer
    will ensure that the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the sequence and the
    terminating null wide character, which will be added
    automatically.</d:para>
    <d:para>The conversion specification includes all subsequent bytes in the format string up to
        and including the matching right square bracket ( '<d:code>]</d:code>' ). The bytes between
        the square brackets (the scanlist) comprise the scanset, unless the byte after the left
        square bracket is a circumflex ( '<d:code>^</d:code>^ ), in which case the scanset contains
        all bytes that do not appear in the scanlist between the circumflex and the right square
        bracket. If the conversion specification begins with "<d:code>[]</d:code>" or
          <d:code>"[^]"</d:code>, the right square bracket is included in the scanlist and the next
        right square bracket is the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that ends the conversion
        specification. If a '-' is in the scanlist and is not the first character, nor the second
        where the first character is a '<d:code>^</d:code>', nor the last character, the behavior is
        implementation-defined.</d:para>
      <d:para>The conversion specifiers <d:code>A, E, F, G</d:code> and <d:code>X</d:code> are also
        valid and shall be equivalent to <d:code>a, e, f, g</d:code> and <d:code>x</d:code>
        respectively.</d:para>
      <d:para>If end-of-file is encountered during input, conversion shall be terminated. If
        end-of-file occurs before any bytes matching the current conversion specification (except
        for <d:code>%n</d:code>) have been read (other than leading white-space characters, where
        permitted), execution of the current conversion specification will terminate with an input
        failure. Otherwise, unless execution of the current conversion specification is terminated
        with a matching failure, execution of the following conversion specification (if any) will
        be terminated with an input failure.</d:para>
      <d:para>Reaching the end of the string in <d:code>sscanf()</d:code> shall be equivalent to
        encountering end-of-file for <d:code>scanf()</d:code>. If conversion terminates on a
        conflicting input, the offending input is left unread in the input. Any trailing white space
        (including newlines) shall be left unread unless matched by a conversion specification. The
        success of literal matches and suppressed assignments is only directly determinable via the
          <d:code>%n</d:code> conversion specification.</d:para>
      <d:para>Time for some code. You have already seen many examples of <d:code>scanf</d:code> so I
        will just explain some concepts here. Consider the following program:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of string input

#include &lt;stdio.h>

int main()
{
  char str[128] = {0};

  scanf("%s", str);
  printf("You entered:\n%s\n", str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv.
You entered:
Hi!</d:screen>
      <d:para>It is certainly not the corect output. We had expected to see like: “Hi! My name is
        Shiv.”. What happend to input string after “Hi!”. Well, in a form given above for
          <d:code>scanf()</d:code> it will stop taking input after white-space for character
        strings. For numerics it does not matter as it does not match the format. For characters it
        is character-by-character so no confusion either. So what if you want to have the entire
        string including white-spaces. Use <d:code>[^n]</d:code> as given below:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Corrected demo of string input

#include &lt;stdio.h>

int main()
{
  char str[128] = {0};

  scanf("%[^\n]s", str);
  printf("You entered:\n%s\n", str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv.
You entered:
Hi! My name is Shiv.</d:screen>
      <d:para>What if you want to filter a string based on certain patterns. For example, a
        charcater string does not contain more that a single space, English alphabets, period and
        digits. To scan such a string you can define a pttern as program given below shows:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv. S Dayal
// Description: Demo of []

#include &lt;stdio.h>

int main()
{
  char c[100]={0};

  scanf("%[ A-Za-z0-9!.]", c);
  printf("%s\n", c);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv! My phone no. is 1234. %^$&amp;*
Hi! My name is Shiv! My phone no. is 1234.</d:screen>
      <d:para>There is also a major problem associated with input and that comes when you have
        characters involved. Consider the following program:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of scanf() function

#include &lt;stdio.h>

int main()
{
  int   i = 0;
  float f = 0.0;
  char  c1 = '\0';
  char  c2 = '\0';
  char  c3 = '\0';

  printf("Enter an integer, a float and three character one by one:\n");

  scanf("%d", &amp;i);
  scanf("%f", &amp;f);
  scanf("%c", &amp;c1);
  scanf("%c", &amp;c2);
  scanf("%c", &amp;c3);

  printf("You entered\n");
  printf("%d\n", i);
  printf("%f\n", f);
  printf("%c\n", c1);
  printf("%c\n", c2);
  printf("%c\n", c3);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>2
3.4
s
You entered
2
3.400000


s</d:screen>
      <d:para>What is happening here is that newline entered by our <d:code>RET</d:code> key is
        getting assigned to <d:code>c1</d:code> and <d:code>c3</d:code>. That is why the program
        accepted only second character. The enter after <d:code>float f;</d:code> was assigned to
          <d:code>c1</d:code> and the character entered to <d:code>c2</d:code> and then the RET
        newline to <d:code>c3</d:code>. There is a very simple way to recover from this:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of scanf() function

#include &lt;stdio.h>

int main()
{
  int   i = 0;
  float f = 0.0;
  char  c1 = '\0';
  char  c2 = '\0';
  char  c3 = '\0';

  printf("Enter an integer, a float and three character one by one:\n");
  scanf("%d", &amp;i);
  scanf("%f", &amp;f);
  scanf(" %c", &amp;c1);
  scanf(" %c", &amp;c2);
  scanf(" %c", &amp;c3);

  printf("%d\n", i);
  printf("%f\n", f);
  printf("%c\n", c1);
  printf("%c\n", c2);
  printf("%c\n", c3);

  return 0;
}</d:programlisting>
      <d:para>The whitespace character shown will eat up all the white-space given after the
        previous input. This concludes our discussion on <d:code>printf()</d:code> and
          <d:code>scanf()</d:code>. Now we will move to another set of i/o functions which take
        character string without filtering and print it to screen without filtering. What I am going
        to discuss are <d:code>gets(), fgets(), puts()</d:code> and
        <d:code>fputs()</d:code>.</d:para> 
  </d:sect1>
  <d:sect1>
    <d:title>Character String I/O Functions</d:title>
    <d:para>These functions are very simple compared to
    <d:code>printf()</d:code> and <d:code>scanf()</d:code>. They take a pointer
    to a character array or a character pointer and fill it with input or print
    it to monitor. Note that <d:code>gets()</d:code> and
    <d:code>puts()</d:code> work only with stdin and stdout respectively while
    <d:code>fgets()</d:code> and <d:code>fputs()</d:code> work with
    <d:code>FILE</d:code> streams. They can read and write to file streams that
    is. Here is a sample program:</d:para>
<d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description : Demo of string i/o
#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  char cStack[1024] = "";
  char *cHeap = (char*)malloc(sizeof(1024));

  gets(cStack);
  puts(cStack);

  cHeap = fgets(cHeap, 1024, stdin);
  fputs(cHeap, stdout);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>Hi!
Hi!
Hello!
Hello!</d:screen>
<d:para>First <d:code>"Hi!"</d:code> and <d:code>"Hello!"</d:code> are keyboard
inputs. Do not worry about array and pointer syntax at the moment. Just see the
difference between function calls. Their is a problem with
<d:code>gets()</d:code> that it can cause buffer overflow. If input is bigger
than 1024 bytes including the null terminator then buffer overflow will
happen. Note how you can prevent it with fgets() by specifying the number of
characters you want to read. Rest of input will be ignored by
<d:code>fgets()</d:code>. This is a security hole and therefore you should
never ever use <d:code>gets()</d:code>.</d:para>
<d:para>Time for single character input/output.</d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Single Character I/O</d:title>
    <d:para>There are several functions for single character i/o. They are
    <d:code>getc(), putc(), getchar(), putchar(), fgetc()</d:code> and
    <d:code>fputc()</d:code>. Apart from <d:code>getchar()</d:code> and
    <d:code>putchar()</d:code> rest can do any FILE stream-based i/o. Let us
    see them as they are mostly trivial.</d:para>
    <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Single character funciton demo
#include &lt;stdio.h>

int main()
{
  char c ='';

  c = getchar();
  putchar(c);

  c = getchar();
  putchar(c);

  c = fgetc(stdin);
  fputc(c, stdout);

  c = getchar();
  putchar(c);

  c = getc(stdin);
  putc(c, stdout);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>4
4
5
5
6
6</d:screen>
<d:para>The first 4, 5 and 6 were keyboard inputs. Note the use of extra
<d:code>getchar()</d:code> and <d:code>putchar()</d:code> to handle the
situation we faced during <d:code>scanf()</d:code>.</d:para>
<d:para>So we have seen many functions and programs for console i/o. File i/o
is still there and will be covered later. This chapter ends here. See you in
the next chapter with operators and expressions.:-)</d:para>
  </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="oae/index.html" ?>
      <d:title>Operators and Expressions</d:title>
      <d:para>Operators and expressions are in the core of every programming
      language. They form the major part of BNF grammar. They also decide how
      the syntax will look like. You as a programmer will spend considerable
      time using C operators. C has sevral type of operators like arithmetic
      operators, relational operators, bitwise operators, unary operators,
      logical operators to name some of them. Since C was first of very
      poopular structured general-pupose lnguages therefore many modern
      language use almost all the operators and supplement with their own. It
      is needless to say that to become a good programmar you must know all the
      operators of C and know where to use which one as it may decide
      performance, readability, simplicity of your code. Whenever you see array
      and pointer in following sections just plow through them. All will be
      clear soon.</d:para>
      <d:para>Whenever operators and expressions come in picture you may have a
      set of mixed data then to perform opration data is converted from one
      type to another. This is known as “Usual Arithmetic Conversion”, which I
      am going to tell you next.</d:para>
      <d:sect1>
	<d:title>Basic Operators</d:title>
	<d:para>There are five here. +, -, *, / and %. Please refer to chapter
	4 for their behavior. Let us see a simple example:</d:para>
	<d:programlisting role="CLexer">// Arithmetic operators
// Author: Shiv S. Dayal
// Description: Demo of arithmetic operators

#include &lt;stdio.h>

int main()
{
  int i = 10;
  float f= 6.45;
  char c = 'A';
  int iResult = 0;
  float fResult = 0.0;
  char cResult = '\0';

  cResult = c + i;
  printf("cResult = %c\n", cResult);
  cResult = cResult - 5;
  printf("cResult = %c\n", cResult);

  iResult = i - 10;
  printf("iResult = %d\n", iResult);
  iResult = i * c;
  printf("iResult = %d\n", iResult);
  iResult = (i + c)/3;
  printf("Result = %d\n", iResult);
  iResult = (i + c)%2;
  printf("iesult = %d\n", iResult);

  fResult = f * 2.12;
  printf("fesult = %f\n", fResult);
  fResult = f - i;
  printf("fesult = %f\n", fResult);
  fResult = f / 1.12;
  printf("fesult = %f\n", fResult);
  fResult = 1 % 3;
  printf("fesult = %f\n", fResult);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>cResult = K
cResult = F
iResult = 0
iResult = 650
Result = 25
iesult = 1
fesult = 13.674000
fesult = -3.550000
fesult = 5.758928
fesult = 1.000000</d:screen>
<d:para>First <d:code>cResult</d:code> is sum of <d:code>'A' + i</d:code> which
is <d:code>'K'</d:code> as <d:code>'K'</d:code> comes ten positions after A in
ASCII table. Then we subtract five and go back to F.</d:para>
<d:para>First <d:code>iReasult</d:code> is 10 - <d:code>i</d:code> where value
of <d:code>i</d:code> is 10 hence result is 0. Next we multiply it with
<d:code>i</d:code> which contains <d:code>'A'</d:code> who has got ASCII value
of 65 and result becomes 650. Then We take sum of <d:code>'A'</d:code> and
<d:code>i</d:code> and divide by 3 so the result is 25 as it is a division of
75 by 3. Next we use modulus operator and remainder is 1. Note that in case of
/ and % if denominator is zero the behavior is undefined.</d:para>
<d:para>Same way you can udnerstand floating-point operations. Note that you
cannot use modulus operator if either of the operands are floating-point
numbers as it will make no sense because of data type promotion rules. Here
data type promotion rule says smaller data types will be converted to bigger
data types. Also, if there is a data type on left side of assignment the result
of applying the operator to operands will be converted to the type of
that. chars are promoted to ints, ints are promoted to floats anf floats to
double. The point is that conversion will try to keep as much data as
possible.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Relational Operators</d:title>
	<d:para>There are four relational operators: &lt;, >, &lt;= and
	>=. Once again these are described in chapter 4. Let us see an
	example:</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of relational operator

#include &lt;stdio.h>
#include &lt;stdbool.h>

int main()
{
  int i = 4, j = 5;
  _Bool result = 0;

  result = i &lt; j;
  printf("%d\n", result);

  result = i > j;
  printf("%d\n", result);

  result = i &lt;= j;
  printf("%d\n", result);

  result = i >= j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>1
0
1
0</d:screen>
<d:para>Note that you should not apply these to floating-point data types as
they may not be represented correctly and two different entities have the same
internal representation.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Equality Operators</d:title>
	<d:para>There are two equlity operators == and !=. </d:para>
	<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of equality operator

#include &lt;stdio.h>
#include &lt;stdbool.h>
int main()
{
  int i = 4, j = 5;
  _Bool result = 0;

  result = i == j;
  printf("%d\n", result);

  result = i != j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>0
1</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Increment and Decrement Operators</d:title>
	<d:para>There is one increment and one decrement operator. ++ and
	--. Both come in two forms prefix and postfix. First we will see prefix
	versions then postfix ones. There is only one constraint on prefix
	operators of these and that is the operand of the prefix increment or
	decrement operator will have qualified or unqualified real or pointer
	type and will be a modifiable lvalue.</d:para>
	<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of increment decrement operators

#include &lt;stdio.h>

int main()
{
  float f = 7.123;

  printf("%f\n", ++f);
  printf("%f\n", --f);
  printf("%f\n", f++);
  printf("%f\n", f--);
  printf("%f\n", f);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>8.123000
7.123000
7.123000
8.123000
7.123000</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Logical Operators</d:title>
	<d:para>There are two such operators. &amp;&amp; logical AND and ||
	locical OR. Both the operators have the same constraints and it is that
	both the operands will have scalar type.</d:para>
	<d:para>The &amp;&amp; operator gives 1 if both the operands are
	non-zero else 0. The result type is int. It is different from bitwise
	&amp; operator in the sense that it guarantess left-to-right
	evaluation; if the second operand is evaluated, there is a sequence
	point between the evaluations of the first and second operands. If the
	first operand is 0 then the second operand is not evaluated. This is
	known as “short-circuit evaluation”.</d:para>
	<d:para>The || operator gives 1 if any of operands are non-zero else it
	gives 0. Same as logical AND operator and unlike bitwise | operator it
	guarantees left-to-right evaluation and same goes for sequence
	points. If first operand is non-zero, the second is not
	evaluated.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of logical AND &amp; OR operators

#include &lt;stdio.h>
#include &lt;stdbool.h>

int main()
{
  int i = 4, j = 5, k = 0;
  bool result;

  result = i&amp;&amp;j;
  printf("%d\n", result);

  result = i||j;
  printf("%d\n", result);

  result = k&amp;&amp;j;
  printf("%d\n", result);

  result = k||j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>1
1
0
1</d:screen>
<d:para>note the use of <d:code>bool</d:code> here instead of
<d:code>_Bool</d:code>.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Bitwise Operators</d:title>
	<d:para>There are three bitwise operators. &amp;, |, and ^. AND, OR and
	EX-OR respectively. OR is also called inclusive OR. These have the same
	contsraints and it is that operands should be integer types. The usual
	arithmetic conversions are performed on the operands.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of bitwise operators

#include &amp;stdio.h>
#include &amp;stdbool.h>

int main()
{
  int i = 4, j = 5;
  int result;

  result = i&amp;j;
  printf("%d\n", result);

  result = i|j;
  printf("%d\n", result);

  result = i^j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>4
5
1</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Bitwise Shift Operators</d:title>
	<d:para>The constraint is same as other bitwise operators that operands
	should be integers. The integer promotions are performed on each of the
	operands. The type of the result if that of the promoted left
	operand. If the value of the right operand is negative or is greater
	than or equal to the width of the promoted left operand, the behavior
	is undefined.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of shift operators

#include &lt;stdio.h>

int main()
{
  int i  = 4;
  char c ='A';
  int result;

  result = c&lt;&lt;i;
  printf("%d\n", result);

  result = c>>i;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
      </d:sect1>
      <d:sect1>
	<d:title>Assignment Operators</d:title>
	<d:para>These are = *= /= %= += -= &lt;&lt;= >>= &amp;= ^= and |= The only
	constraint is that left operand should be modifiable lvalue. An
	assignment operator stores a value in the object designated by the left
	operand. An assignment expression has the value of the left operand
	after the assignment, but is not an lvalue. The type of an assignment
	expression is the type of the left operand unless the left operand has
	qualified type, in which case it is the unqualified version of the type
	of the left operand. The side effect of updating the stored value of
	the left operand is sequenced after the value computations of the left
	and right operands. The evaluations of the operands are
	unsequenced.</d:para>
<d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of compound assignments.

#include &lt;stdio.h>

int main()
{
  int i   = 3;
  int j   = 3;
  float f = 4.7;
  float result=0.0;

  result += i+f;
  printf("%f\n", result);

  result -= f;
  printf("%f\n", result);

  j &lt;&lt;= i;
  printf("%d\n", j);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>7.700000
3.000000
24</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Conditional Operators</d:title>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of conditional operator

#include &lt;stdio.h>

int main()
{
  int i = (4 &lt; 5)? 7:10;

  printf("%d\n", i);

  return 0;
}</d:programlisting>
<d:para>output is 7 as 4 is less than 5 which is true.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Comma Operator</d:title>
	<d:para>It is a very simple operator. The left operand of a comma
	operator is evaluated as a void expression; there is a sequence point
	between its evaluation and that of the right operand. Then the right
	operand is evaluated; the result has its type and value. A comma
	operator does not give an lvalue.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>sizeof Operator</d:title>
	<d:para>You have already see sizeof operator in second chapter when we
	saw sizes of data types. However here is the constraint: the sizeof
	operator will not be applied to an expression that has function type or
	an incomplete type, to the parenthesized name of such a type, or to an
	expression that designates a bit-field member.</d:para>
	<d:para>The sizeof operator yields the size (in bytes) of its operand,
	which may be an expression or the parenthesized name of a type. The
	size is determined from the type of the operand. The result is an
	integer. If the type of the operand is a variable length array type,
	the operand is evaluated; otherwise, the operand is not evaluated and
	the result is an integer constant.</d:para>
	<d:para>When applied to an operand that has type char, unsigned char,
	or signed char, (or a qualified version thereof) the result is 1. When
	applied to an operand that has array type, the result is the total
	number of bytes in the array. When applied to an operand that has
	structure or union type, the result is the total number of bytes in
	such an object, including internal and trailing padding.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Unary Arithmetic Operators</d:title>
	<d:para>We will see casting, array subscripting, function parenthes,
	address and indirection operators later at appropriate time. For now I
	am going to tell you about operator precedence and associativity and
	then about grouping parenthes. Given below is the table for operator
	precedence and associativity, however, you may not be familiar with few
	of them but later you will be:</d:para>
	<d:table frame="border" class="leftcenter"
          border="1">
	  <d:colgroup width="0*"/>
	  <d:colgroup width="0*"/>
          <d:caption>Priority and assiciativity table</d:caption>
          <d:thead>
            <d:tr bgcolor="#aaa">
              <d:th>Operators</d:th>
              <d:th>Associativity</d:th>
            </d:tr>
          </d:thead>
	  <d:tr>
	    <d:td>() [] . -> ++ – (postfix)</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>++ – + - (unary) ! ~ (types) * &amp; sizeof</d:td>
	    <d:td>right-to-left</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>* / %</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>+ - (Addition/Subtraction)</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&lt;&lt; >></d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&lt; > &lt;= >=</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>== !=</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&amp;</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>^</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>|</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&amp;&amp;</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>||</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>Assignemnt operators</d:td>
	    <d:td>right-to-left</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>,</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	</d:table>
      </d:sect1>
      <d:sect1>
	<d:title>Grouping parentheses</d:title>
	<d:para>Grouping parentheses are used to override operator precedence
	and group expressions. NEVER EVER try to memorize and rely on
	precedence of operators. Always use grouping parentheses. Till now I
	have shown very simple examples of operators; here are some complex
	ones:</d:para>
	<d:programlisting role="CLexer">// Author: Shiv Shankar Dayal
// Description: Demo of grouping parentheses

#include &lt;stdio.h>

int main()
{
  printf("%f\n", 5.2*(3.7+2.3));
  printf("%d\n", ((4&lt;5)||(7^5)));

  return 0;
}</d:programlisting>
<d:para>This small program shows you what can go wrong if you rely on
memory. It allows you do addition first and then multiplcation. Inner
parentheses are evaluated first then inner ones. This concludes our chapter on
operators and expressions. Next we focus on control statements and flow
statements.</d:para> 
      </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="cf/index.html" ?>
      <d:title>Control Flow</d:title>
      <d:para>There are three things you will learn in this chapter. Switching
      the path of execution in program depending upon program variables or
      states using control statements. Repeating a set of instructions using
      loops. Bypassing certain set of instructions in a loop and jump
      around. Collectively, these elements of C allow or enable you to take
      driver’s seat over the control over a C program. You will spend much of
      your programming time even in future using these basic elements. Let us
      begin with if-else without spending much time over boring stuff. Before
      we proceed I would like to tell you about storage classes of array and
      their scope. I could have covered it in second chapter but I did not want
      to scare you with too many things in itself.</d:para>
      <d:sect1>
	<d:title>Storage Classes</d:title>
	<d:para>In C99 variables can be declared at any point in class without
	breaking an expression. This was not possible in older C and you could
	only declare at start of function. There is <d:code>auto, register,
	static</d:code> and <d:code>extern</d:code>.</d:para>
	<d:para><d:code>auto</d:code> is the default storage class for local
	variables. Local variables are those that are inside any function or
	any control-flow statement block. You will perhaps never use auto
	explicitly. For examle, <d:code>auto int i; register</d:code> is the
	storage class which tell the compiler that this variable will be stored
	in a CPU register instead of RAM. It is mostly used for loop counters
	and to store small 32-bit or 64-bit variables in CPU register. For
	example, <d:code>register int i;</d:code></d:para>
	<d:para><d:code>static</d:code> is the default storage class for global
	variables though local variables can also be made static. local static
	variables persist across function calls that is their values do not
	change.</d:para>
	<d:para><d:code>extern</d:code> keyword allows global variables to
	become visible in other modules than itself.</d:para>
	<d:para>There are two more modifiers: <d:code>const</d:code> and
	<d:code>volatile</d:code>. As their names specify const makes a
	variable constant. That is you cannot change value of a variable
	declared as <d:code>const</d:code>. <d:code>volatile</d:code> is kind
	of opposite but not really opposite. What it does is that the programs
	other than the program itself where it has been declared are allowed to
	change it. This means that a variable can be a <d:code>const</d:code>
	as well as <d:code>volatile</d:code> at the same time.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>if else Statement</d:title>
	<d:para>An if-else statement may consist of only <d:code>if</d:code> or
	both <d:code>if</d:code> and <d:code>else</d:code> or
	<d:code>if</d:code> and <d:code>else if</d:code> or <d:code>if, else
	if</d:code> and <d:code>else</d:code>. An if-else statement must have
	<d:code>if</d:code> at the beginning, zeor or more <d:code>else
	if</d:code> may come after <d:code>if</d:code> or before
	<d:code>else</d:code> and <d:code>else</d:code> must come at
	end. <d:code>else if</d:code> and <d:code>else</d:code> are optional
	and may not come. Consider the following program:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>

int main()
{
  int i = 0, j= 0;

  printf("Please enter two integers i and j:\n");
  scanf("%d%d", &amp;i , &amp;j);

  if(i==4)
    printf("you entered 4 for i.\n");

  if(i==7)
  {
    printf("you entered 7 for i.\n");
    printf("I am happy for you.\n");
  }
  else
  {
    printf("You did not enter 7 for i.\n");
  }
  if(i==7)
  {
    printf("you entered 7 for i.\n");
    printf("I am happy for you.\n");
  }
  else if(j==8)
    printf("You entered 8 for i.\n");

  if(i==7)
    printf("you entered my lucky number.\n");
  else if((i==7) &amp;&amp;(j==8))
    printf("May god bless you!\n");
  else
    printf("You entered bad number.\n");

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Please enter two integers i and j:
4
6
you entered 4 for i.
You did not enter 7 for i.
You entered bad number.</d:screen>
<d:para>As you can see from first if sttatement that if you enter the value of
i as 4 then the printf will be executed and you will be able to see it. Note
that if there are multiple lines below if which you want to execute then you
must put them in a block using curly braces. If you just want to execute one
line then these curly braces are optional. Note that how you must use curly
braces if you have more than one line and you want to execute them. Also, see
the syntax for missing else and missing else if. One if-else can be nested
inside another for example see the following code:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>
#include &lt;string.h>

int main()
{
  char fName[128]={0}, lName[128]={0};

  printf("Enter your first name and last name in that order:\n");
  gets(fName);
  gets(lName);

  if(strcmp(fName, "Shiv") == 0)
  {
    if(strcmp(lName, "Dayal") == 0)
      printf("Your name is Shiv Dayal.\n");
  }
  else
  {
    printf("Your name is %s %s.\n", fName, lName);
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Enter your first name and last name in that order:
Shiv
Dayal
Your name is Shiv Dayal.</d:screen>
<d:para>another run:</d:para>
<d:screen>Enter your first name and last name in that order:
Richard
Stallman
Your name is Richard Stallman.</d:screen>
<d:para>when first if matches but else does not:</d:para>
<d:screen>Enter your first name and last name in that order:
Shiv
Stallman</d:screen>
<d:para>Note the usage of nested if-else. Also, note how
<d:code>strcmp</d:code> has been used to compare two strings and
<d:code>gets</d:code> to read the input. <d:code>gets</d:code> is dangerous but
it is simple that is why has been used here. You can read about it at the link
of opengroup. We will see this in more detail towards the end when we deal with
chapter named C Standard Library.</d:para>
<d:warning>
  <d:title>Assignment in if/else-if</d:title>
  <d:para>Always remember the expression inside if evaluates to a boolean so
  you should never do an ASSIGNMENT inside if and else if as it will always
  evaluate to what is assigned. It can render all your logic meaningless. C is
  not Python, where assignment inside if is not allowed. However, if you assign
  0 to some variable it will evaluate to <d:code>false</d:code>.</d:para>
</d:warning>
<d:sect2>
  <d:title>Dangling else Problem</d:title>
  <d:para>The <d:code>else</d:code> part has a property that it will cling to
  closest if. So the following piece of code may give you surprise:</d:para>
<d:programlisting role="CLexer">if(x==1)
  if(y>2)
    printf("foo\n");
else
  printf("bar\n");</d:programlisting>
<d:para>Now consider <d:code>x!=1</d:code> then you may think that bar will be
printed. However, that will not be the case. The else part clings to inner
if. This can be fixed by using curly braces.</d:para>
</d:sect2>
      </d:sect1>
      <d:sect1>
	<d:title>switch Statement</d:title>
	<d:para><d:code>switch</d:code> statement is kind of if-else
	replacement to simplify it. Usage of switch statement is to compare one
	expression with others, and then execute a series of sub-statements
	inside case and default based on the result of the comparisons. Note
	that switch statement takes only integers or integreal type as its
	argument and same is valid for its cases. Consider the following
	example:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>

int main()
{
  int i  = 65;

  switch(i)
  {
    case 'A':
      printf("Value of i is 'A'.\n");
      break;
    case 'B':
      printf("Value of i is 'B'.\n");
      break;
    default:
      break;
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Value of i is 'A'.</d:screen>
<d:para>Notice the usage of <d:code>break</d:code>. It is used to terminate
execution once a match has been found for a particular case else what will
happen is shown below:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of switch statement.

#include &lt;stdio.h>

int main()
{
  int i  = 65;

  switch(i)
  {
    case 'A':
      printf("Value of i is 'A'.\n");
    case 'B':
      printf("Value of i is 'B'.\n");
    default:
      printf("Value of i is %c.\n", i);
      break;
    }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Value of i is 'A'.
Value of i is 'B'.
Value of i is A.</d:screen>
<d:para>This is also known as fall through of a <d:code>switch</d:code>
statement. Notice, the use of default that how it is analogous to
<d:code>else</d:code> statement. <d:code>switch</d:code> statements can also be
nested inside each other. However, node that lots of nesting is not good. At
most 2-3 levels are more than enough else you should look at alternative ways
of writing code.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>while Loop</d:title>
	<d:para>Of three loops I am first going to cover <d:code>while</d:code>
	loop. It is simplest of three. I will just give an example for you to
	understand.</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of while statement.

#include &lt;stdio.h>

int main()
{
  int i = 0;

  while(i &lt;= 10)
  {
    printf("%d * %2d = %4d\n", 2, i, 2*i);
    i++;
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>2 *  0 =    0
2 *  1 =    2
2 *  2 =    4
2 *  3 =    6
2 *  4 =    8
2 *  5 =   10
2 *  6 =   12
2 *  7 =   14
2 *  8 =   16
2 *  9 =   18
2 * 10 =   20</d:screen>
<d:para><d:code>while</d:code> loop just has one expression which is its
terminating condition. We have written <d:code>i&lt;=10</d:code> which is
terminating condition for our loop. The moment i will become greater than that
the loop will terminated. We are initializing our loop index to 0 and
incrementing within while loop. Note that you must use curly braces for body of
block of loop. If you have only one statement as body of loop then braces are
optional.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>do-while Loop</d:title>
	<d:para>It is very much similar to <d:code>while</d:code> loop but with
	a very subtle difference. Consider the following code:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of do while statement.

#include &lt;stdio.h>

int main()
{
  int i = 0;

  do {
    printf("I am Shiv.\n");
    i++;
  }while(i&lt;5);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>I am Shiv.
I am Shiv.
I am Shiv.
I am Shiv.
I am Shiv.</d:screen>
<d:para>Notice the semicolon at the end of while. Now time for that subtle
difference:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of do while statement.

#include &lt;stdio.h>

int main()
{
  int i = 10;

  do {
    printf("2 * 10 = 20\n");
    i++;
  }while(i&lt;5);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>2 * 10 = 20</d:screen>
<d:para>Notice how <d:code>do while</d:code> loop executes once even if the loop index is more than the terminating condition in the while part.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>for Loop</d:title>
	<d:para><d:code>for</d:code> loop is the last of loops and most
	versatile. It has three parts: initialization of loop counters,
	terminating condition, and loop index modification. If you declare a
	variable in the initialization part then that variable has just loop
	scope while for <d:code>while</d:code> and <d:code>do while</d:code>
	loop indices have at least outer block scope. This makes
	<d:code>for</d:code> loop better. Consider the following example for
	computing squares of numbers:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of for statement.

#include &lt;stdio.h>

int main()
{
  for(int i=1, j=1; (i&lt;=10)||(j&lt;=10); i++, j++)
    printf("%2d * %2d = %4d\n", i, j, i*j);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>1 *  1 =    1
2 *  2 =    4
3 *  3 =    9
4 *  4 =   16
5 *  5 =   25
6 *  6 =   36
7 *  7 =   49
8 *  8 =   64
9 *  9 =   81
10 * 10 =  100</d:screen>
<d:para>Notice how various things are coming in picture here: initialization,
terminating conditions loop counter incrementation and output formatting. Here
is how you can write an infinite for loop <d:code>for(;;)</d:code>. You can
write an infinite loop anywhere if your loop index counters are not getting
incremented/decremented properly or your termination condition is
incorrect. Also, always make sure that loop indices are initialized. As an
exercise you can try to implement this program using <d:code>while</d:code> and
<d:code>do while</d:code> loop. Last line of the above output is not having
first space properly.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>break and continue Statements</d:title>
	<d:para><d:code>break</d:code> statement breaks out of innermost
	<d:code>for, do, while</d:code> and <d:code>switch</d:code>
	statements. It terminates that loop. Consider for example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of break statement.

#include &lt;stdio.h>

int main()
{

  for(int i = 0;;i +=10)
  {
    if(i>100)
      break;
    printf("%d\n", i);
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>0
10
20
30
40
50
60
70
80
90
100</d:screen>
<d:para>Notice how the <d:code>for</d:code> loop is terminated once
<d:code>i</d:code> goes beyond 100 even though there is no terminating
condition. Try the same in <d:code>while</d:code> and <d:code>do-while</d:code>
loop and produce the same result.</d:para>
<d:para><d:code>continue</d:code> statement is slightly different than
<d:code>break</d:code> in the sense that it does not stop the execution of that
loop but simply does not execute remaining instructions of that block. Consider
for example:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of continue statement.

#include &lt;stdio.h>

int main()
{

  for(int i = 0;i&lt;=100;i +=10)
  {
    if(i==50)
      continue;
    printf("%d\n", i);
  }

  return 0;
}</d:programlisting>
and the output is:<d:screen>0
10
20
30
40
60
70
80
90
100</d:screen>
<d:para>Notice how 50 is missing from output.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>typedef and return Statements</d:title>
	<d:para><d:code>typedef</d:code> statement is used to define new types
	from existing types. For example:</d:para>
<d:programlisting role="CLexer">typedef char s8;
typedef unsigned char s8;
typedef short int s16;
typedef unsigned short int u16;</d:programlisting>
<d:para>You will be seeing its usage in function pointers, structures and
unions heavily.</d:para>
<d:para><d:code>return</d:code> statement is used to return from
function. Optionally you can return a value.</d:para>
      </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="ap/index.html" ?>
      <d:title>Arrays and Pointers</d:title>
      <d:para>In this chapter I am going to tell you about two very powerful
	constructs of C programming; arrays and pointers. Arrays are what they
	are; array of some data type. There can be an array of any complete
	type. You cannot create an array of any incomplete type, therefore, an
	array of type void is not allowed. There are fixed arrays and also
	variable length arrays. C99 inroduced variable length arrays before
	that arrays were only of fixed length. However, you can increase the
	capacity of a fixed sized array using <d:code>realloc()</d:code>
	function. There is single-dimensional array and then there is
	multi-dimensional array. We will first go through single-dimensional
	array then multi-dimensional.
      </d:para>
      <d:sect1>
	<d:title>Single-Dimensional Attau</d:title>
	<d:para>Let us first create a basic array and then see how to access it
	elements:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of array.

#include &lt;stdio.h>

int main()
{
  const int MAX = 8;
  //An initialized array
  int a[8] = {0};
  //An initialized array to 0
  int b[MAX];

  for(int i=0; i&lt;8; i++)
  {
    b[i] = i;
    printf("b[%d]=%d\n", i, b[i]);
  }

  for(int i=0; i&lt;8; i++)
  {
    printf("a[%d]=%d\n", i, a[i]);
  }

  return 0;
}</d:programlisting>
      </d:sect1>
    </d:chapter>
    <d:index>
    <d:title>Index</d:title>
  </d:index>
</d:book>
