<?xml version="1.0" encoding="UTF-8"?>
<d:book version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
  <d:info>
    <d:title>C Programming with C99</d:title>
    <d:author>
      <d:personname>
        <d:firstname>Shiv</d:firstname>
        <d:surname>Dayal</d:surname>
      </d:personname>
    </d:author>
    <d:copyright>
      <d:year>2011, 2013</d:year>
      <d:holder>Shiv S. Dayal</d:holder>
    </d:copyright>
  </d:info>
  <xi:include href="preface.xml"/>
  <xi:include href="introduction.xml"/>
  <xi:include href="fs.xml" />
  <xi:include href="env.xml" />
  <xi:include href="lang.xml" />
  <d:chapter>
    <?dbhtml filename="basics/index.html" ?>
    <d:title>Basics of C</d:title>
    <d:para>Now is the time for learning basics. There are certain rules in every language, certain
      grammar which dictates the way language will be spoken and written. It has a script to write
      using. Similarly, programming languages have BNF (Backus-Naur Form) context-free grammar.
      There are valid characters in a programming language and a set of keywords. However,
      programming language ruleset is very small compared to a natural programming language. Also,
      when using natural programming language like talking to someone or writing something the other
      person can understand your intent but in programming you cannot violate rules. The grammar is
      context-free. Compilers or interpreters cannot deduce your intent by reading code. They are
      not intelligent. You make a mistake and it will refuse to listen to you no matter what you do.
      Therefore, it is very essential to understand these rules very clearly and correctly.</d:para>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">The C Character Set</title>
      <d:para>The following form the C character set you are allowed to use in it:</d:para>
      <d:screen>[a-z] [A-Z] [0-9] ~ ! # % ^ &amp; * ( ) - = [ ] \ ; ' , . / _ + { } | : " &lt; > ?</d:screen>
      <d:para>This means along with other symbols you can use all English alphabets (both uppercase
        and lowercase) and Arabic numerals. However, English is not the only spoken language in the
        world. Therefore in other non-English speaking counties there are keyboard where certain
        characters present in above set are not present. The inventors of C were wise enough to
        envision this and provide the facility in form of trigraph sequences. The table of trigraph
        sequences is given in chapter 4.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Keywords</title>
      <d:para>The following are reserved keywords for C programming language which you are not
        allows to use other than what they are meant for:<table
          xmlns="http://docbook.org/ns/docbook" frame="void" class="dynamic" border="1">
          <caption>Keywords of C</caption>
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
          <tbody>
            <tr>
              <td>auto</td>
              <td>enum</td>
              <td>restrict</td>
              <td>unsigned</td>
            </tr>
            <tr>
              <td>break</td>
              <td>extern</td>
              <td>return</td>
              <td>void</td>
            </tr>
            <tr>
              <td>case</td>
              <td>float</td>
              <td>short</td>
              <td>volatile</td>
            </tr>
            <tr>
              <td>char</td>
              <td>for</td>
              <td>signed</td>
              <td>while</td>
            </tr>
            <tr>
              <td>const</td>
              <td>goto</td>
              <td>sizeof</td>
              <td>_Bool</td>
            </tr>
            <tr>
              <td>continue</td>
              <td>if</td>
              <td>static</td>
              <td>_Complex</td>
            </tr>
            <tr>
              <td>default</td>
              <td>inline</td>
              <td>struct</td>
              <td>_Imaginary</td>
            </tr>
            <tr>
              <td>do </td>
              <td>int</td>
              <td>switch</td>
              <td/>
            </tr>
            <tr>
              <td>double</td>
              <td>long</td>
              <td>typedef</td>
              <td/>
            </tr>
            <tr>
              <td>else</td>
              <td>register</td>
              <td>union</td>
              <td/>
            </tr>
          </tbody>
        </table></d:para>
      <d:para>These keywords serve specific purpose. You will come to know about all of them as you
        progress through the book. Next we look at identifiers.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Identifers</title>
      <d:para>The names which we give to our variables are known as identifiers. Something with
        which we identify. As you have already seen what is allowed in C’s character set but not all
        are allowed in an identifiers name. Only alphabets from English language both lowercase and
        uppercase, Arabic digits from zero to nine and underscore (<d:code>_</d:code>) are allowed
        in an identifiers name. The rule for constructing names is that among the allowed characters
        it can only begin with only English alphabets and underscore. Numbers must not be first
        character. For example, <d:code>x, _myVar, varX, yourId78</d:code> are all valid names.
        However, take care with names starting from underscore as they are mostly used by different
        library authors. Invalid identifier examples are <d:code>9x, my$, your age</d:code>. Please
        read this section carefully and make sure understand the rules for naming identifiers. Later
        at the end of chapter there are some simple problems to work on.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Programming</title>
      <d:para>Now is time for some programming. Let us revisit our first program and try to
        understand what it does. Here I am giving code once again for quick reference:</d:para>
      <d:programlisting role="CLexer">//My first program
/* Author: Shiv Shankar Dayal
   Description: This program does nothing.*/

#include &lt;stdio.h>

int main(int argc, char* argv[])
{
  return 0;
}</d:programlisting>
      <d:para>You can now issue a command as <d:command>$clang nothing.c</d:command> where
          <d:code>nothing.c</d:code> is the filename by which you saved the source code. Note that
          <d:code>$</d:code> is the prompt not part of command itself. Then you can do an
          <d:command>ls</d:command> and you will find that <d:code>a.out</d:code> is a file which
        has been produced by <d:application>clang</d:application>. Now you can run this program by
        saying <d:command>./a.out</d:command> and nothing will happen. But if you type
          <d:command>echo $?</d:command> then you will find that 0 is printed on screen which is
        nothing but 0 after return of our program.</d:para>
      <d:para>As you can see this program does almost nothing but it is fairly complete program and
        we can learn a lot from it about C. The first line is a comment. Whenever C compiler parses
        C programs and it encounters <d:code>//</d:code> it ignores rest of line as code i.e. it
        does not compile them. This type of single line comment were introduced in C99 standard and
        if your compiler is really old the compiler may give you error message about it. The second
        and third lines are also comments. Anything between <d:code>/*</d:code> and
          <d:code>*/</d:code> is ignored like <d:code>//</d:code>. However, be careful of something
        like <d:code>/* some comment */ more comment */</d:code>. Such comments will produce error
        messages and your program will fail to compile.</d:para>
      <d:para>Comments are very integral part of programming. They are used to describe various
        things. You can write whatever you want. They may also be used to generate documentation
        with tools like doxygen. Typically comments tell what the program is doing. Sometimes how,
        when the logic is really complex. One should be generous while commenting the code.</d:para>
      <d:para><d:code>#include</d:code> is a pre-processor directive. It will look for whatever is
        contained in angular brackets in the <d:code>INCLUDEPATH</d:code> of compiler. For now you
        can assume that <d:code>/usr/include</d:code> is in include path of compiler. For the
        curious I refer you to <link xmlns="http://docbook.org/ns/docbook"
          xlink:href="http://clang.llvm.org/doxygen/InitHeaderSearch_8cpp_source.html"
          >http://clang.llvm.org/doxygen/InitHeaderSearch_8cpp_source.html</link>. Basically what it
        does is that it looks for a file names <d:code>stdio.h</d:code> in the
          <d:code>INCLUDEPATH</d:code>. If that is found the content of that file is pasted here in
        our program.If you really want to see what happens then you can type <d:command>$clang -E
          nothing.c</d:command>. You will see lots of text scrolling on your screen. The
          <d:option>-E</d:option> switch tells <d:application>clang</d:application> that just
        preprocess the file, do not compile it, and send the resulting output to standard output (we
        will know about this more later), which happens to be your monitor in this case.</d:para>
      <d:para>Next line is <d:code>int main(int argc, char* argv[])</d:code>. Now this is very
        special function. Every complete executable(shared objects or dlls do not have main even
        though they are C programs) C program will have one main function unless you do assembly
        hacking. This function is where the programs start. The first word <d:code>int</d:code> is a
        keyword which stands for integer. This signifies the return type of function.
          <d:code>main</d:code> is the name of the function. Inside parenthesis you see <d:code>int
          argc</d:code> which tells how many arguments were passed to program. While <d:code>char*
          argv[]</d:code> is a pointer to array which we will see later. For now it holds all the
        arguments to the program.</d:para>
      <d:para>Next is a brace. The scope in C is determined by braces. Something outside any brace
        has global scope (we will see these later), something inside first level of brace has
        function or local scope. Something inside second or more level of braces have got that
        particular block scope. Scope here means that when there will be a closing brace that
        particular variable which is valid in that scope will cease to exist. However, we do not
        have to worry about that yet as we do not have any variable. Just note that a corresponding
        closing brace will be the end of main function.</d:para>
      <d:para>Next line is <d:code>return 0;</d:code> This means whoever has called
          <d:code>main()</d:code> will get a 0 as return is returning 0. In this case, receiver is
        the shell or operating system which has invoked the very program. The semicolon is called
        the terminator and used also on Java or C++ for example. The very requirement of semicolon
        is to terminate the statement and move on to next statement.</d:para>
      <d:para>However, the program shown does not do much. Let us write a program which has some
        more functionality and we can explore more of C. So here is a program which takes two
        integers as input from users and presents their sum as output. Here is the program:</d:para>
      <d:programlisting role="CLexer">// My second program
// Author: Shiv S. Dayal
// Description: It adds two numbers

#include &lt;stdio.h>

int main()
{
  int x=0, y=0, sum=0;

  printf("Please enter an integer:\n");
  scanf("%d", &amp;x);

  printf("Please enter another integer:\n");
  scanf("%d", &amp;y);

  sum = x + y;

  printf("%d + %d = %d\n", x, y, sum);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>shiv@shiv:~/book/code$ ./addition
Please enter an integer:
7
Please enter another integer:
8
7 + 8 = 15
shiv@shiv:~/book/code$</d:screen>
      <d:para>Note that <d:code>shiv@shiv:~/book/code$</d:code> is the prompt. The Makefile is also
        updated:</d:para>
      <d:programlisting role="MakefileLexer">check-syntax:
    clang -o nul -Wall -S $ (CHK_SOURCES)

nothing:nothing.c
    clang nothing.c -o nothing

addition:addition.c
    clang addition.c -o addition</d:programlisting>
      <d:para>You can choose <d:code>Tools->Compile</d:code> then enter <d:code>make -k
          addition</d:code> as make commands in the Emacs’s minibuffer and execute like
          <d:code>$./addition</d:code>.</d:para>
      <d:para>Let us discuss new lines one by one. The line <d:code>int x=0, y=0, z=0;</d:code> is
        declaration and definition or initialization of three ints. int keyword in C is used to
        represent integers. Now we have three integers with there values set to 0. Note that how the
        variables are separated by commas and terminated by semicolon(as we saw in last program
        also). We could have also written it like this:</d:para>
      <d:programlisting role="CLexer">int x;
int y;
int z;

x = 0;
y = 0;
z = 0;</d:programlisting>
      <d:para>or:</d:para>
      <d:programlisting role="CLexer">int x, y, z;

x = y = z = 0;</d:programlisting>
      <d:para>However, the first method is best and most preferred as it prevents use before
        definition. int is a data-type in C. <d:code>x, y,</d:code> and <d:code>z</d:code> are
        variables of type <d:code>int</d:code>. This means that the size of these variables will be
        same as <d:code>int</d:code>. Note that C is a statically typed language and all types have
        predefined memory requirements. In cour case, int requires 4 bytes on 32-bit
        systems.</d:para>
      <d:para>Now I will talk about <d:code>printf()</d:code> function. This function is declared in
          <d:code>stdio.h</d:code>. The prototype of <d:code>printf()</d:code> is</d:para>
      <d:programlisting role="CLexer">int printf(const char *restrict format, ...);</d:programlisting>
      <d:para>The first argument format is what we have in first two function calls. The second is a
          <d:code>...</d:code> which means it can take variable number of arguments known as
        variable-list. We have seen this in the third call.This means it will take a string with
        optional variable no. of arguments. The string is called the format-string and determines
        what can be printed with supplied arguments. These <d:code>...</d:code> are used to supply
        variable no. of arguments. In the first two <d:code>printf()</d:code> statements we just
        print the format-string so that is simple. However, in the last one, we have format as
          <d:code>%d</d:code> which signifies a decimal integer. The integers printed are in the
        same order in which they were supplied.</d:para>
      <d:para>Time for some input. <d:code>scanf()</d:code> is scan function which scans for
        keyboard input. As by now you know that <d:code>%d</d:code> is for decimal integer but we
        have not said <d:code>x</d:code> or <d:code>y</d:code>. The reason is <d:code>x</d:code> and
          <d:code>y</d:code> are values while <d:code>&amp;x</d:code> and <d:code>&amp;y</d:code>
        are the addresses of <d:code>x</d:code> and <d:code>y</d:code> in memory.
          <d:code>scanf()</d:code> needs the memory address to which it can write the contents to.
        You will see <d:code>&amp;</d:code> operator in action later when we deal with pointers.
        Just remember for now that to use a simple variable with <d:code>scanf()</d:code> requires
          <d:code>&amp;</d:code> before its name.</d:para>
      <d:para>Now I am going to take you on a tour of data types. Till now we have just seen only
          <d:code>int</d:code>. So onward to data types.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Data Types</title>
      <d:para>Why data types? What is the need? When everything is a voltage level why not just deal
        with 0s and 1s? The answer is simple. You need to abstract and segregate how much is
        required. For example, say you are given a sequence of 0s and 1s how much can you work with
        them. We as humans are not very versed with 0s and 1s. Also, say we encode character
          ‘<d:code>A</d:code>’ for 10101 will it be easy for you to see A or numbers. Also, numbers
        range from −∞ to ∞. Also, since C is statically typed the sizes of data types have to be
        known at compile time. There are four types of data types. Integral, floating-point, arrays
        and pointers. Here, I will deal with the two former types and leave latter two for later.
        The integral types are <d:code>char, short int, int, long</d:code> and <d:code>long
          long</d:code> and floating-point types are <d:code>float, double</d:code> and <d:code>long
          double. signed</d:code> and <d:code>unsigned</d:code> are sign modifiers which also
        modified the range of data types but do not affect their memory requirements. By default all
        basic data types are signed in nature and you must qualify you variables with unsigned if
        you want that behavior. <d:code>short</d:code> and <d:code>long</d:code> are modifiers for
        size which the data type occupies but I consider them as different types because memory
        requirements are different. The ranges of integral data types directly reflect their memory
        requirements and if you know how much memory they are going to occupy you can easily compute
        their ranges. The range of floating-point comes from IEEE specification. Clang at present
        does not support C99 floating-point specification at the time of this writing but rest
        assured they will st some point of time. However, I will present the C99 floating-point
        specification given by C99.</d:para>
      <d:para>Let us write a program to find out ranges for integral data types:</d:para>
      <d:programlisting role="CLexer">// My range program
// Author: Shiv S. Dayal
// Description: It gives ranges of integral data types

#include &lt;stdio.h>
#include &lt;limits.h>

int main()
{
  printf("Size of char is..........%d\n", sizeof(char));
  printf("Size of short int is.....%d\n", sizeof(short int));
  printf("Size of int is...........%d\n", sizeof(int));
  printf("Size of long is..........%d\n", sizeof(long));
  printf("Size of long long is.....%d\n", sizeof(long long));
  printf("Size of float is.........%d\n", sizeof(float));
  printf("Size of double is........%d\n", sizeof(double));
  printf("Size of long double is...%d\n", sizeof(long double));c

  return 0;
}</d:programlisting>
      <d:para>and the output will be:</d:para>
      <d:screen>Size of char is..........1
Size of short int is.....2
Size of int is...........4
Size of long is..........4
Size of long long is.....8
Size of float is.........4
Size of double is........8
Size of long double is...12</d:screen>
      <d:para>Based on this it is left as an exercise to reader to compute the ranges of these data
        types. Here I am giving the contents of limits.h for you to see limits of data types and
        check for yourself.</d:para>
      <d:programlisting role="CLexer">/* Copyright (C) 1991, 1992, 1996, 1997, 1998, 1999, 2000, 2005
Free Software Foundation, Inc.
This file is part of the GNU C Library.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.  */

/*
*      ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types &lt;limits.h>
*/

#ifndef _LIBC_LIMITS_H_
#define _LIBC_LIMITS_H_ 1

#include &lt;features.h>


/* Maximum length of any multibyte character in any locale.
 We define this value here since the gcc header does not define
 the correct value.  */
 #define MB_LEN_MAX      16


/* If we are not using GNU CC we have to define all the symbols ourself.
Otherwise use gcc's definitions (see below).  */
#if !defined __GNUC__ || __GNUC__ &lt; 2

/* We only protect from multiple inclusion here, because all the other
#include's protect themselves, and in GCC 2 we may #include_next through
multiple copies of this file before we get to GCC's.  */
# ifndef _LIMITS_H
#  define _LIMITS_H     1

#include &lt;bits/wordsize.h>

/* We don't have #include_next.
Define ANSI &lt;limits.h> for standard 32-bit words.  */

/* These assume 8-bit `char's, 16-bit `short int's,
and 32-bit `int's and `long int's.  */

/* Number of bits in a `char'.  */
#  define CHAR_BIT      8

/* Minimum and maximum values a `signed char' can hold.  */
#  define SCHAR_MIN     (-128)
#  define SCHAR_MAX     127

/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */
#  define UCHAR_MAX     255

/* Minimum and maximum values a `char' can hold.  */
#  ifdef __CHAR_UNSIGNED__
#   define CHAR_MIN     0
#   define CHAR_MAX     UCHAR_MAX
#  else
#   define CHAR_MIN     SCHAR_MIN
#   define CHAR_MAX     SCHAR_MAX
#  endif

/* Minimum and maximum values a `signed short int' can hold.  */
#  define SHRT_MIN      (-32768)
#  define SHRT_MAX      32767

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  */
#  define USHRT_MAX     65535

/* Minimum and maximum values a `signed int' can hold.  */
#  define INT_MIN       (-INT_MAX - 1)
#  define INT_MAX       2147483647

/* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  */
#  define UINT_MAX      4294967295U

/* Minimum and maximum values a `signed long int' can hold.  */
#  if __WORDSIZE == 64
#   define LONG_MAX     9223372036854775807L
#  else
#   define LONG_MAX     2147483647L
#  endif
#  define LONG_MIN      (-LONG_MAX - 1L)

/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */
#  if __WORDSIZE == 64
#   define ULONG_MAX    18446744073709551615UL
#  else
#   define ULONG_MAX    4294967295UL
#  endif

#  ifdef __USE_ISOC99

/* Minimum and maximum values a `signed long long int' can hold.  */
#   define LLONG_MAX    9223372036854775807LL
#   define LLONG_MIN    (-LLONG_MAX - 1LL)

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */
#   define ULLONG_MAX   18446744073709551615ULL

#  endif /* ISO C99 */

# endif /* limits.h  */
#endif  /* GCC 2.  */

#endif  /* !_LIBC_LIMITS_H_ */

/* Get the compiler's limits.h, which defines almost all the ISO constants.

We put this #include_next outside the double inclusion check because
it should be possible to include this file more than once and still get
the definitions from gcc's header.  */
#if defined __GNUC__ &amp;&amp; !defined _GCC_LIMITS_H_
/* `_GCC_LIMITS_H_' is what GCC's file defines.  */
# include_next &lt;limits.h>
#endif

/* The &lt;limits.h> files in some gcc versions don't define LLONG_MIN,
LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
ages are available.  */
#if defined __USE_ISOC99 &amp;&amp; defined __GNUC__
# ifndef LLONG_MIN
#  define LLONG_MIN     (-LLONG_MAX-1)
# endif
# ifndef LLONG_MAX
#  define LLONG_MAX     __LONG_LONG_MAX__
# endif
# ifndef ULLONG_MAX
#  define ULLONG_MAX    (LLONG_MAX * 2ULL + 1)
# endif
#endif

#ifdef  __USE_POSIX
/* POSIX adds things to &lt;limits.h>.  */
# include &lt;bits/posix1_lim.h>
#endif

#ifdef  __USE_POSIX2
# include &lt;bits/posix2_lim.h>
#endif

#ifdef  __USE_XOPEN
# include &lt;bits/xopen_lim.h>
#endif</d:programlisting>
      <d:para>Here, I have given <d:application>gcc</d:application>’s <d:code>limits.h</d:code> as
          <d:application>clang</d:application> includes that. For knowing exact implementation for
        floating-point implementation on your platform I recommend you to read <link
          xmlns="http://docbook.org/ns/docbook"
          xlink:href="http://en.wikipedia.org/wiki/IEEE_754-2008"
          >http://en.wikipedia.org/wiki/IEEE_754-2008</link>. It is not possible to present all the
        information in detail here and I do not want to give you partial information. :-) I
        recommend you to go through <link xmlns="http://docbook.org/ns/docbook"
          xlink:href="http://en.wikipedia.org/wiki/Single_precision"
          >http://en.wikipedia.org/wiki/Single_precision</link> and <link
          xmlns="http://docbook.org/ns/docbook"
          xlink:href="http://en.wikipedia.org/wiki/Double_precision"
          >http://en.wikipedia.org/wiki/Double_precision</link> in particular. The range of log
        double varies from compiler to compiler.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">New Data Types of C99</title>
      <d:para>There are some new data types introduced in C99. They are <d:code>_Bool,
          _Complex</d:code> and <d:code>_Imaginary</d:code>.</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Boolean Types</title>
        <d:para><d:code>_Bool</d:code> counts as an integral type and is used to represent boolean
          values. Here is <d:code>stdbool.h</d:code> for your quick reference.</d:para>
        <d:programlisting role="CLexer">/*===---- stdbool.h - Standard header for booleans -------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __STDBOOL_H
#define __STDBOOL_H

/* Don't define bool, true, and false in C++, except as a GNU extension. */
#ifndef __cplusplus
#define bool _Bool
#define true 1
#define false 0
#elif defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__)
/* Define _Bool, bool, false, true as a GNU extension. */
#define _Bool bool
#define bool  bool
#define false false
#define true  true
#endif

#define __bool_true_false_are_defined 1

#endif /* __STDBOOL_H */</d:programlisting>
        <d:para>As you can see from the definition <d:code>true</d:code> is 1 and
            <d:code>false</d:code> is 0. Any non-zero value is considered to be true. Here is a
          program demonstrating that.</d:para>
        <d:programlisting role="CLexer">// Boolean Program
// Author: Shiv S. Dayal
// Description: Demo of boolean data typec

#include &lt;stdio.h>
#include &lt;stdbool.h>

int main()
{
  bool bcpp      = 4;
  _Bool bc       = 5;
  bool True      = true;
  _Bool False    = false;
  bool bFalseCPP = -4;
  _Bool bFalseC  = -7;

  printf("%d %d %d %d %d %d\n", bcpp, bc, True, False, bFalseCPP, bFalseC);

  getchar();

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>1 1 1 0 1 1</d:screen>
        <d:para>Note that <d:code>true</d:code> and <d:code>false</d:code> are keywords while
            <d:code>True</d:code> and <d:code>False</d:code> are identifiers.</d:para>
        <d:para>Though I wanted to avoid dealing with this but since I am including header files
          verbatim I must give an explanation of <d:code>#define</d:code> pre-processor macro at
          least. I will touch it very little as it will be covered in more detail later.
            <d:code>#define</d:code> has two parameters though not as function arguments. Whenever
          the first part is encountered second will be replaced. Consider this example:</d:para>
        <d:programlisting role="CLexer">// Boolean Program
// Author: Shiv S. Dayal
// Description: Demo of boolean data type

#define MAX 7
int main()
{
  MAX;
  return 0;
}</d:programlisting>
        <d:para>Just do <d:command>$clang -E define.c</d:command> to see the magic. Note that
            <d:code>#define</d:code> parameters are not type safe. Compiler will just paste the
          contents. Notice how <d:code>MAX</d:code> is replaced by 7.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Complex Types</title>
        <d:para>For complex types, there is a system header <d:code>complex.h</d:code> which
          internally includes various other headers. However I am giving you the summary here. There
          are following <d:code>#define</d:code> macros:</d:para>
        <d:para><d:code>complex</d:code>: Expands to <d:code>_Complex</d:code>
          <d:code>_Complex_I</d:code>: Expands to a constant expression of type <d:code>const float
            _Complex</d:code> with the value of the imaginary.</d:para>
        <d:para><d:code>imaginary</d:code>: Expands to <d:code>_Imaginary</d:code>.
            <d:code>_Imaginary_I</d:code>: Expands to a constant expression of type <d:code>const
            float _Imaginary</d:code> with the value of the imaginary value.</d:para>
        <d:para><d:code>I</d:code>: Expands to either <d:code>_Imaginary_I</d:code> or
            <d:code>_Complex_I</d:code>. If <d:code>_Imaginary_I</d:code> is not defined,
            <d:code>I</d:code> expands to <d:code>_Complex_I</d:code>.</d:para>
        <d:para>Complex types are declared as given below:</d:para>
        <d:orderedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">
              <code>float complex fCompZ;</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>double complex dCompZ;</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long double ldCompZ;</code></para>
          </d:listitem>
        </d:orderedlist>
        <d:para>Now I will present a summary of library functions provided by
            <d:code>complex.h</d:code></d:para>
        <d:programlisting role="CLexer">//cabs, cabsf, cabsl - these compute and return absolute value
//of a complex number z

double cabs(double complex z);
float cabsf(float complex z);
long double cabsl(long double complex z);

//carg, cargf, cargl - these compute and return argument of a complex
//number z. The range of return value's range from one +ve pi radian
//to one -ve pi radian.

double carg(double complex z);
float cargf(float complex z);
long double cargl(long double complex z);

//cimag, cimagf, cimagl - these compute imaginary part of a complex
//number z and return that as a real number.

double cimag(double complex z);
float cimagf(float complex z);
long double cimagl(long double complex z);

//creal, crealf, creall - these compute real part of a complex
//number z and return the computed value.

double creal(double complex z);
float crealf(float complex z);
long double creall(long double complex z);

//conj, conjf, conjl - these functions compute the complex conjugate
//of z, by reversing the sign of its imaginary part and return the
//computed value.

double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);

//cproj, cprojf, cprojl - these functions compute a projection of z
// onto the Riemann sphere: z projects to z, except that all complex
//infinities (even those with one infinite part and one NaN (not a
//number) part) project to positive infinity on the real axis. If z
//has an infinite part, then cproj( z) shall be equivalent to:
//INFINITY + I * copysign(0.0, cimag(z))
//These functions return the computed value.

double complex cproj(double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex z);

//cexp, cexpf, cexpl - these functions shall compute the complex
//exponent of z, defined as e^z and return the computed value

double complex cexp(double complex z);
float complex cexpf(float complex z);
long double complex cexpl(long double complex z);

//clog, clogf, clogl - these functions compute the complex
//natural (base e) logarithm of z, with a branch cut along
//the negative real axis and return complex natural logarithm
//value, in a range of a strip mathematically unbounded along
//real axis and in the interval -ipi to +ipi along the
//imaginary axis.

double complex clog(double complex z);
float complex clogf(float complex z);
long double complex clogl(long double complex z);

//csqrt, csqrtf, csqrtl - these functions compute the complex
//square root of z, with a branch cut along the negative real
//axis and return the computed value in the range of the right
//half-plane (including the imaginary axis)

double complex csqrt(double complex z);
float complex csqrtf(float complex z);
long double complex csqrtl(long double complex z);

//cpow, cpowf, cpowl - these functions compute the complex
//power function x^y, with a branch cut for the first
//parameter along the negative real axis and return the
//computed value.

double complex cpow(double complex x, double complex y);
float complex cpowf(float complex x, float complex y);
long double complex cpowl(long double complex x,
long double complex y);

//csin, csinf, csinl - these functions compute the complex
//sine of z and return the computed value.

double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);

//ccos, ccosf, ccosl - these functions compute the complex
//cosine of z and return the computed value.

double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);

//ctan, ctanf, ctanl - these functions compute the complex
//tangent of z and return the computed value.

double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);

//casin, casinf, casinl - these functions compute the complex
//arc sine of z, with branch cuts outside the interval
//[-1, +1] along the real axis and return the computed value
//in the range of a strip mathematically unbounded along the
//imaginary axis and in the interval -0.5pi to +0.5pi radian
//inclusive along the real axis.

double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);

//cacos, cacosf, cacosl - these functions compute the complex
//arc cosine of z, with branch cuts outside the interval
//[-1, +1] along the real axis and return the computed value
//in the range of a strip mathematically unbounded along the
//imaginary axis and in the interval -0 to +pi radian
//inclusive along the real axis.

double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);

//catan, catanf, catanl - these functions compute the complex
//arc tangent of z, with branch cuts outside the interval
//[-i, +i] along the real axis and return the computed value
//in the range of a strip mathematically unbounded along the
//imaginary axis and in the interval -0.5pi to +0.5pi radian
//inclusive along the real axis.

double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);

//csinh, csinhf, csinhl - these functions compute the complex
//hyperbolic sine of z and return the comupted value.

double complex csinh(double complex z);
float complex csinhf(float complex z);
long double complex csinhl(long double complex z);

//ccosh, ccoshf, ccoshl - these functions shall compute the
//complex hyperbolic cosine of z and return the computed
//value

double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl(long double complex z);

//ctanh, ctanhf, ctanhl - these functions compute the
//complex hyperbolic tangent of z and return the computed
//value.

double complex ctanh(double complex z);
float complex ctanhf(float complex z);
long double complex ctanhl(long double complex z);

//casinh, casinhf, casinhl - these functions compute the
//complex arc hyperbolic sine of z, with branch cuts
//outside the interval [-i, +i] along the imaginary axis and
//return the complex arc hyperbolic sine value, in the range
//of a strip mathematically unbounded along the real axis
//and in the interval [-i0.5pi, +i0.5pi] along the imaginary
//axis.

double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);
cacosh, cacoshf, cacoshl - theese functions compute the

//complex arc hyperbolic cosine of z, with a branch cut at
//values less than 1 along the real axis and return the complex
//arc hyperbolic cosine value, in the range of a half-strip
//of non-negative values along the real axis and in the
//interval [-ipi, +ipi] along the imaginary axis.

double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);

//catanh, catanhf, catanhl - these functions shall compute the
//complex arc hyperbolic tangent of z, with branch cuts outside
//the interval [-1, +1] along the real axis and return the
//complex arc hyperbolic tangent value, in the range of a strip
//mathematically unbounded along the real axis and in the
//interval [-i0.5pi, +i0.5pi] along the imaginary axis.

double complex catanh(double complex z);
float complex catanhf(float complex z);
long double complex catanhl(long double complex z);</d:programlisting>
        <d:para>Hers is a small demo program which explains three functions:</d:para>
        <d:programlisting role="CLexer">// Complex Number Program
// Author: Shiv S. Dayal
// Description: Demo of complex data type

#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 4.0 + 3.0i;

  printf("Absolute value of z is %lf\n", cabs(z));

  double complex zConj = conj(z);
  printf("Imaghinary part of conjugate is now %lf\n", cimag(zConj));

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:programlisting>Absolute value of z is 5.000000
Imaghinary part of conjugate is now -3.000000</d:programlisting>
        <d:para>You must note that in Makefile you must compile it like <d:command>$clang complex.c
            -o complex -lm</d:command>. Note the <d:code>-lm</d:code> part. It tells to look for
          definition of these functions in Math library of C. Without it the program won’t compile.
          At this point I encourage you to further explore different functions presented in the
          summary. There are even more data types for integral type. I am sorry but I am unwrapping
          the layers one by one. These types are defined in <d:code>inttypes.h</d:code> and
            <d:code>stdint.h</d:code>. The types are <d:code>int8_t, int16_t, int32_t, uint8_t,
            uint16_t</d:code> and <d:code>uint32_t</d:code>. The numbers tell you how many bits each
          data type will occupy. The types without leading <d:code>u</d:code> are of signed type and
          the ones with it are of unsigned type. You can use the good old <d:code>%d</d:code> or
            <d:code>%i</d:code> for decimal integers and <d:code>%o</d:code> and <d:code>%x</d:code>
          for octals and hexes. Have a look at headers and try to decipher them.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook"><code>void</code> and <code>enum</code>
        Types</title>
      <d:para>There are these two types remianing. void type comprises an empty set of values; it is
        an incomplete type that cannot be completed. You cannot declare an array of
          <d:code>void</d:code>s. It is a generic type in the sense that any other pointer to any
        type can be converted to pointer type of void and vice-versa. It is a low level type and
        should be only used to convert data types from one type to another and sparingly. A type
        occupies one byte. Typically you never declare a variable of void type. It is used mostly
        for casting.</d:para>
      <d:para><d:code>enum</d:code> comprises a set of named integer constant values. Each distinct
        enumeration constitutes a different enumerated type. In C enums are very much equivalent to
        integers. You can do all operations of an enum on an enumeration member. An enumeration is
        is a set of values. It starts from zero by default and increments by one unless specifically
        specified. Consider the following example:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of enum

#include &lt;stdio.h>

int main()
{
  typedef enum {zero, one, two} enum1;
  typedef enum {alpha=-5, beta, gamma, theta=4, delta, omega} enum2;

  printf("zero = %d, one = %d, two=%d\n", zero, one, two);
  printf("alpha = %d, beta = %d, gamma=%d, theta=%d, delta=%d, omega=%d\n", \
          alpha, beta, gamma, theta, delta, omega);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>zero = 0, one = 1, two=2
alpha = -5, beta = -4, gamma=-3, tehta=4, delta=5, omega=6</d:screen>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Constants</title>
      <d:para>We have seen some variables now let us see some constants. There are five categories
        of constants: character, integer, floating-point, string, and enumeration constant. We will
        see enumeration constants later first we see remaining four types of constants. There are
        certain rules about constants. Commas and spaces are not allowed except for character and
        string constants. Their range cannot outgrow the range of there data type. For numeric type
        of stants they can have a leading (-)minus sign.</d:para>
      <d:para>Given below is an example:</d:para>
      <d:programlisting role="CLexer">// Integer constants
// Author: Shiv S. Dayal
// Description: Demo of integer constants

#include &lt;stdio.h>

int main()
{
  int decimal = 7;
  int octal = 06;
  int hex = 0xb;

  printf("%d %o %x\n", decimal, octal, hex);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>7 6 b</d:screen>
      <d:para>As you can see there are three different categories for integer constants: decimal
        constants (base 10), octal constants (base 8) and hexadecimal constants (base 16). Also, you
        must have noticed how a zero is prefixed before octal type and a zero and x for hexadecimal
        type. The <d:code>%d</d:code> format specifier is already known to you for signed decimals.
        However, now you know two more <d:code>%o</d:code> and <d:code>%x</d:code> for unsigned
        octal and unsigned hexadecimal respectively. For unsigned integer it is <d:code>%u</d:code>.
        There is one more format specifier which you may encounter for signed decimal and that is
          <d:code>%i</d:code>.</d:para>
      <d:para>Note that there is nothing for binary constants. I leave this as an exercise to you to
        convert a number in any base shown above to binary and print it. Also vice-versa that is
        take a input in binary and convert to these three. Later I will show you this
        program.</d:para>
      <d:para>Now let us move to floating-point constants. Again, I will explain using an
        example:</d:para>
      <d:programlisting role="CLexer">// Floating-point constants
// Author: Shiv S. Dayal
// Description: Demo of floating-point constants

#include &lt;stdio.h>

int main()
{
  float f = 7.5384589234;
  double d = 13.894578834538578234784;
  long double ld = 759.8263478234729402354028358208358230829304;

  printf("%f %lf, %Lf\n", f, d, ld);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:programlisting>7.538459 13.894579, 759.826348</d:programlisting>
      <d:para>We will learn to change precision later when we deal with format specifiers along with
        printf and all input/output family. Here also, you learn three format specifiers. Other are
          <d:code>%e</d:code> or <d:code>%E</d:code> for scientific notation of float family. Then
        there is <d:code>%g</d:code> or <d:code>%G</d:code> which uses shorter of
          <d:code>%e</d:code> and <d:code>%f</d:code> types.</d:para>
      <d:para>Now we move on to character and string type constants and as usual with a small
        program.</d:para>
      <d:programlisting role="CLexer">// Character constants
// Author: Shiv S. Dayal
// Description: Demo of character constants

#include &lt;stdio.h>

int main()
{
  char c = 'S';
  char* str ="Shiv S, Dayal";

  printf("%c %s\n", c, str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>S Shiv S, Dayal</d:screen>
      <d:para>As I had said that commas and blanks are not allowed in numeric types but you can see
        both are allowed on character and string types. Also, the string is a character pointer that
        is it can point to memory location where a character is stored. In this case the string is
        stored in an area of memory called stack. When memory is allocated the compiler knows how
        much has been allocated. For string there is something called null character represented by
          ‘<d:code>\0</d:code>’ which is used to terminate string. By using this mechanism the
        program knows where the string is terminating. It is treated in next section as well.A very
        interesting thing to be noted is char is considered to be an integral type. It is allowed to
        perform addition etc on char type. Till now you have learnt many format specifiers and have
        seen they all start with <d:code>%</d:code>. Think how will you print <d:code>%</d:code> on
        stdout. It is printed like <d:code>%%</d:code>. It was simple,wasn’t it? C program have got
        something called ASCII table which is a 7-bit character table values ranging from0 to 127.
        There is also something called escape sequences and it is worth to have a look at
        them.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Escape Sequences</title>
      <d:para>All escape sequences start with a leading <d:code>\</d:code> . Following table shows
          them:<table xmlns="http://docbook.org/ns/docbook" frame="border" class="centered"
          border="1">
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
	  <colgroup width="0*"/>
          <caption>Escape Sequences</caption>
          <thead>
            <tr bgcolor="#aaa">
              <th>Character</th>
              <th>Escape Sequences</th>
              <th>ASCII Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>null</td>
              <td>\0</td>
              <td>000</td>
            </tr>
            <tr>
              <td>bell (alert)</td>
              <td>\a</td>
              <td>007</td>
            </tr>
            <tr>
              <td>backspace</td>
              <td>\b</td>
              <td>008</td>
            </tr>
            <tr>
              <td>horizontal tab</td>
              <td>\t</td>
              <td>009</td>
            </tr>
            <tr>
              <td>newline(line feed)</td>
              <td>\n</td>
              <td>010</td>
            </tr>
            <tr>
              <td>vertical tab</td>
              <td>\v</td>
              <td>011</td>
            </tr>
            <tr>
              <td>form feed</td>
              <td>\f</td>
              <td>012</td>
            </tr>
            <tr>
              <td>carriage return</td>
              <td>\r</td>
              <td>013</td>
            </tr>
            <tr>
              <td>quotation mark (")</td>
              <td>\"</td>
              <td>034</td>
            </tr>
            <tr>
              <td>apostophe (')</td>
              <td>\'</td>
              <td>039</td>
            </tr>
            <tr>
              <td>question mark</td>
              <td>\?</td>
              <td>063</td>
            </tr>
            <tr>
              <td>backslash</td>
              <td>\\</td>
              <td>092</td>
            </tr>
          </tbody>
        </table></d:para>
      <d:para>Note that there is no space between two backslashes. Sphinx does not allow me to write
        four continuous backslashes. Now we will talk about all these one by one.
          <d:code>\0</d:code> which is also known as <d:code>NULL</d:code> is the string terminating
        character, as said previously, and must be present in string for it to terminate. For
        example, in our character constant program the str string is “<d:code>Shiv S.
        Dayal</d:code>”. So how many characters are there 13? Wrong 14! The <d:code>NULL</d:code>
        character is hidden. Even if we say <d:code>str=””;</d:code> then it will contain one
        character and that is this <d:code>NULL</d:code>. Many standard C functions rely on this
        presence of <d:code>NULL</d:code> and causes a lot of mess because of this. The bell escape
        sequence if for a bell from CPU. Let us write a program and see it in effect.</d:para>
      <d:programlisting role="CLexer">// Bell Program
// Author: Shiv S. Dayal
// Description: Demo of bell escape sequence

#include &lt;stdio.h>

int main()
{
  printf("hello\a");

  getchar();

  return 0;
}</d:programlisting>
      <d:para>The output of this program will be <d:code>hello</d:code> on stdout and an audible or
        visible bell as per settings of your shell. Notice the <d:code>getchar()</d:code> function
        which waits for input and reads a character from stdin. Next is backspace escape sequence.
        Let us see a program for its demo as well:</d:para>
      <d:programlisting role="CLexer">// Backspace Program
// Author: Shiv S. Dayal
// Description: Demo of backspace escape sequence

#include &lt;stdio.h>

int main()
{
  printf("h\b*e\b*l\b*l\b*o\b*\n");
  printf("\b");

  getchar();

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>*****</d:screen>
      <d:para>It is hello replaced by <d:code>*</d:code>. A minor modification in this program to
        replace the character as soon as key is pressed by some other character will turn it into a
        password program. Backspace escape sequence means when it is encountered the cursor moves to
        the previous position on the line in context. If active position of cursor is initial
        position then C99 standard does not specify the behavior of display device. However, the
        behavior on my system is that cursor remains at initial position. Check out on yours. The
        second <d:code>printf</d:code> function determines this behavior.</d:para>
      <d:para>Next we are going to deal with newline and horizontal tab escape sequences together as
        combined together they are used to format output in a beautiful fashion. The program is
        listed below:</d:para>
      <d:programlisting role="CLexer">// Newline and Horizontal tab program Program
// Author: Shiv S. Dayal
// Description: Demo of newline and horizontal tab escape sequence

#include &lt;stdio.h>

int main()
{
  printf("Before tab\tAftertab\n");
  printf("\nAfter newline\n");

  getchar();

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Before tab      Aftertab

After newline</d:screen>
      <d:para>Here I leave you to experiment with other escape sequences. Feel free to explore them.
        Try various combinations; let your creative juices flow.</d:para>
    </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="io/index.html" ?>
    <d:title>Console I/O</d:title>
    <d:para>What is I/O? I know you may be wondering what rubbish question? It is input/output.
      Well, yes you are right. However, i/o can be further categorized in several categories. First
      of them is console i/o, which is what we are concerned with. In console i/o your keyboard is
      input device or <d:code>stdin</d:code> file stream and display device or monitor is output
      device or <d:code>stdout</d:code> file stream. There is also also something called
        <d:code>stderr</d:code> which is standard error file stream. For historical reasons these
      are known as <d:code>FILE</d:code>, which, happens to be the data type for handling these
      streams. Then there are more different kind of i/o. In everyday usage you use mouse to handle
      GUI. Standard C99 does not have anything for mouse. For your hard disk i/o that is real files
      like our source code files and executable file same FILE stream is used. Network i/o is also
      there. There is an opengroup which specifies functions for network related functions. Some
      operating system like GNU/Linux are POSIX compatible which defines how network i/o will be
      used. Even a printer is a special output device, a camera input, speakers output, microphone
      input and so on. However, before we go on with i/o I would like to present C’s memory model
      which will be needed by our discussion of i/o related functions. However, if things do not
      make sense even then please go through it and come later to understand more.</d:para>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">C's Memory Model</title>
      <d:para>C programs use <d:hardware>RAM</d:hardware> as primary memory except when you use
        register keyword to request compiler to store variables in cpu register. C’s memory model is
        split into three area at a higher level. Data, Stack and Code Segment. Date is further split
        in three parts; initialized data segment, uninitialized data segment or BSS which is name
        after an ancient assembler Block Started by Symbol and heap. Initialized data segment
        contains initialized global variables and static variables. Here both global and local
        static variables are counted. For uninitialized data segment it is same as above just that
        the variables are not initialized explicitly but implicitly to zero. Next is heap. Heap is
        the largest area of memory used for dynamic memory allocation. As you will see later that
        you can manage heap using <d:code>malloc(), calloc(), realloc(),</d:code> and
          <d:code>free()</d:code>. Note that compiler does not manage memory allocated for you. You,
        the programmer, are responsible for allocating and freeing up memory in area. If heap gets
        full os will use virtual memory or swap space on hard disk. Objects allocated on heap
        persist across function calls. However, there are some very nasty problems, which, come in
        picture when you use heap. There are several of them. You may forget to allocate memory and
        want to dereference unallocated pointer. You may have initialized it to
          <d:code>NULL</d:code> and try to dereference that. You may allocate and free twice. You
        forgot to set pointer to <d:code>NULL</d:code> after freeing it. And last but not the least
        you loose all pointers to the memory area before you can free. The nature with this
        particular problem is that if your program is going to run for long time then it is going to
        consume more and more memory. Because of its nature it is known as memory leak. It is very
        difficult to detect such problems in code which does not run for long periods of time. Our
        friend valgrind will come to help up with this problem. When a memory leak happens it eats
        up <d:hardware>RAM</d:hardware> slowly and then operating system has to use virtual memory
        as explained above. In a nutshell, I will say that heap means you have to handle
        it.</d:para>
      <d:para>Stack is relatively simple. All non-static and non-register variables go on stack.
        Stack variables do not retain there value across function calls unless they are passed as
        pointers. Also, when they go out of scope, that is the scope in which they were declared
        ends, they will be kind of lost. The way in which stack frame moves the same area will be
        used for new variables. However, stack is very limited (compared to heap) and in deeply
        nested function calls or recursion (you will see these in Functions chapter) stack may get
        full and program may crash. The reason for crashing is that operating system will not use
        virtual memory but will do a segmentation fault in its place. GNU/Linux allow its users to
        modify the stack size by ulimit command. Note that stack and heap are adjacent in memory and
        grow in opposite direction.</d:para>
      <d:para>Code segment or text segment is an area where the executable instructions of program
        reside. It is typically constant and read-only area unless your system allows self-modifying
        code. Following diagram shows the memory layout.</d:para>
      <d:figure>
        <d:title>C's Memory Model</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="images/memmod.png"/>
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
      <d:para>In this chapter we will look at only those functions, which, allow us to do console
        i/o. We will begin with our familiar friends. Can you guess who are they? Yes! They are
          <d:code>printf</d:code> and <d:code>scanf</d:code>.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>printf</d:title>
      <d:para><d:code>printf</d:code> is a string based output function that is It writes character
        strings to <d:code>stdout</d:code>. The data which has to be written is formatted by format
        string as shown previously. After the format specifier it expects as many arguments as
        specified in format string. The characters which are not like, say <d:code>%d</d:code> for
        example, arecalled ordinary characters. These are simply copied to output stream, which, is
          <d:code>stdout</d:code> for <d:code>printf</d:code>. The <d:code>%d</d:code> like
        conversion charcaters are known as conversion specification or format specifiers. Each
        conversion specification should be augmented with one one argument. The results are
        undefined if there are insufficient arguments for the format. If extra arguments are given
        the excess arguments will be evaluated but are otherwise ignored. However, there is a big
        problem here! There is no type-safety.:-( In general compiler will warn you about it and
        you, the programmer, are responsible for giving correct format string, correct no. of
        correct type of arguments. Consider the following program for
        example:<d:programlisting role="CLexer">// printf demo
// Author: Shiv Shankar Dayal
// Description: printf demo

#include &lt;stdio.h>

int main()
{
  printf("%d %d\n", 3, 8);

  //do not mess it. undefined behavior
  printf("%d %d\n", 5);

  //extra arguments ignored
  printf("%d %d\n", 3, 5, "hello");

  //legal because char is integer type
  printf("%d\n", 's');

  //wrap around of integer as char
  printf("%c\n", 836);

  //do not mess with type-safety
  int i = printf("%d\n", "hello");
  prinf("%d\n", i);

  return 0;
}</d:programlisting>
        now that if you give the command like <d:code>clang printf.c</d:code> then you will be shown
        following warnings:
        <d:screen>printf.c:12:14: warning: more '%' conversions than data arguments [-Wformat]
        printf("%d %d\n", 5);
                 ~^
printf.c:15:26: warning: data argument not used by format string [-Wformat-extra-args]
        printf("%d %d\n", 3, 5, "hello");
             ~~~~~~~~~        ^
printf.c:24:19: warning: conversion specifies type 'int' but the argument has type
'char *' [-Wformat]
      int i = printf("%d\n", "hello");
                      ~^     ~~~~~~~
                      %s
3 warnings generated.</d:screen>
        Clearly this is not a good sign for any program. A program should compile cleanly. In our
        case compiler is generating binary even though there are warnings. You can make compiler
        generate more warnings by issuing a <d:code>-Wall</d:code> flag. You can also treat all
        warnings as errors by passing <d:code>-Werror</d:code> to compiler. These two options will
        ensure that your code has no warnings. Now let us move to output and try to understand it.
        The output on my system is as given below. It may differ on your system:
        <d:screen>3 8
5 8
3 5
115
D
134514119
10</d:screen> First
          <d:code>printf</d:code> is correct as expected. The second line causes undefined behavior.
        You may think it is the previous 8 but rest assured it is not guaranteed that it will always
        the case. Ii is <d:emphasis role="bold">UNDEFINED</d:emphasis>. Third printf is also fine in
        the sense that extra argument is ignored. Fourth and fifth are normal. Sixth is again a big
        problem. You are trying to print a decimal integer while argument is a character string.
        There is no way for compiler to determine that what should be printed which will fit on
        standards. Now we will have to take a look at all possible format specifier and their
        meanings. You have seen most of them so this is more for a reference. I have taken following
        from <d:link xlink:href="http://www3.opengroup.org">http://www3.opengroup.org</d:link> and
        modified to suit the book. In particular, I have omitted facts related to XSI specification. </d:para>
      <d:para>Each conversion specification starts with '<d:code>%</d:code>' character. After this
        following appear in sequence:</d:para>
      <d:itemizedlist>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">Zero or more flags, in any order, which modify
            the meaning of the conversion specification.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional minimum field width. If the
            converted value from argument has fewer characters (bytes) than the field width, it will
            be padded with spaces by default on left; it will be padded on right if the
            left-adjustment flag (‘-‘) is given to the field width. The field width takes the form
            of an asterisk or a decimal integer.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional precision that gives the minimum
            number of digits to appear for the <code>d, i, o, u, x</code> and <code>X</code>
            conversion specifiers; the number of digits to appear for radix character for the
              <code>a, A, e, E, f</code> and <code>F</code> conversion specifiers; the maximum
            number of significant digits for the <code>g</code> and <code>G</code> conversion
            specifiers; or the maximum number of bytes to be printed from a string in the s
            conversion specifiers. The precision takes form of a period (‘.’) followed either by an
            asterisk (‘*’), described below, or an optional decimal digit string, where a null digit
            string is treated as zero. If a precision appears with any other conversion specifier,
            the behavior is undefined.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional length modifier that specifies the
            size of the argument.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">A conversion specifier character that
            indicates the type of conversion to be applied.</para>
        </d:listitem>
      </d:itemizedlist>
      <d:para>A field width, or precision, or both, may be indicated by an asterisk(‘*’). In this
        case an argument of type int supplies the field width or precision. You, the programmer,
        will have to ensure that arguments specifying field, width or precision, or both appear in
        that order before the argument, if any to be converted. A negative field width is taken as a
        ‘-‘ flag followed a positive field width. A negative precision is taken as if the precision
        were omitted.</d:para>
      <d:para>The flag characters and their meanings are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">-</emphasis> The result of
        the conversion will be left-justified within the field. The conversion is right-justified if
        the flag is not specified.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">+</emphasis> The result of
        a signed conversion will always begin with a sign (‘+’ or ‘-‘). The conversion will begin
        with a sign only when a negative value is converted if this value is not specified.</d:para>
      <d:para>If the first character of a signed conversion is not a sign or if a signed conversion
        results in no characters, a will be prefixed to the result. This means that if the and ‘+’
        flags both appear, the flag will be ignored.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">#</emphasis> Specifies
        that the value is to be converted to an alternative form. For o conversion, it increases the
        precision (if necessary) to force the first digit of the result to be zero. For
          <d:code>x</d:code> or <d:code>X</d:code> conversion specifiers, a non-zero result will
        have <d:code>0x (0X)</d:code> prefixed to it. For <d:code>a, A, e, E, f, F, g</d:code> and
          <d:code>G</d:code> conversion specifiers, the result will always contain a radix
        character, even if no digits follow the radix character. Without this flag, a radix
        character appears in the result of these conversions only if a digit follows it.</d:para>
      <d:para>For 0 and <d:code>G</d:code> conversion specifiers, trailing zeros will not be removed
        from the result as they normally are. For other conversion specifiers the, the behavior is
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">UNDEFINED</emphasis>.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">0</emphasis> For
          <d:code>d, i, o, x, X, a, A, e, E, f, F, g</d:code> and <d:code>G</d:code> conversion
        specifiers, leading zeros (following any indication of sign or base) are used to pad to the
        field width; no space padding is performed. If the ‘0’ and ‘-‘ flags both appear, the ‘0’
        flag is ignored. For <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion
        specifiers, if a precision is specified, the ‘0’ flag is ignored.</d:para>
      <d:para>The length and their meanings are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">hh</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifiers
        applies to a <d:code>signed char</d:code> or <d:code>unsigned char</d:code> argument (the
        argument will have been promoted according to integer promotions, but its value will be
        converted to <d:code>signed char</d:code> or <d:code>unsigned char</d:code> before printing;
        or that a following n conversion specifier applies to a pointer to a <d:code>signed
          char</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">h</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>short</d:code> or <d:code>unsigned short</d:code> argument (the
        argument will have been promoted according to the integer promotions, but its value will be
        converted to <d:code>short</d:code> or <d:code>unsigned short</d:code> before printing); or
        that a following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>short</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">l</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>long</d:code> or <d:code>unsigned long</d:code> argument; that a
        following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>long</d:code> argument; that a following <d:code>c</d:code> conversion specifier
        applies to a <d:code>win_t</d:code> argument; that a following <d:code>s</d:code> conversion
        specifier applies to a <d:code>wchar_t</d:code> argument; or has not effect on a following
          <d:code>a, A, e, R, f, F, g</d:code> or <d:code>G</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">ll</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>long long</d:code> or <d:code>unsigned long long</d:code> argument;
        that a following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>long long</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">j</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to an <d:code>intmax_t</d:code> or <d:code>uintmax_t</d:code> argument; or that a
        following <d:code>n</d:code> conversion specifier applies to an <d:code>intmax_t</d:code>
        argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">z</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>size_t</d:code> or the corresponding signed integer type argument; or
        that a following <d:code>n</d:code> conversion specifier applies to a signed integer type
        corresponding to a <d:code>size_t</d:code> argument.</d:para>
      <d:para><d:code>t</d:code> Specifies that a following <d:code>d, i, o, u, x</d:code> and
          <d:code>X</d:code> conversion specifier applies to a <d:code>ptrdiff_t</d:code> or the
        corresponding <d:code>unsigned int</d:code> type argument; or that a following
          <d:code>n</d:code> conversion specifier applies to a unsigned integer type corresponding
        to a <d:code>ptrdiff_t</d:code> argument.</d:para>
      <d:para><d:code>L</d:code> Specifies that a following <d:code>a, A, e, E, f, F, g</d:code> and
          <d:code>G</d:code> conversion specifier applies to a <d:code>long double</d:code>
        argument.</d:para>
      <d:para>If a length modifier appears with any conversion specfier other than as specified
        above, the behavior is <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >UNDEFINED</emphasis>. You may have noted data types like <d:code>intmax_t,
          size_t</d:code> and <d:code>ptrdiff_t</d:code>, which you may not know and I have not told
        you about them. But do not worry in due course of time we will see them.</d:para>
      <d:para>The conversion specifiers and their meaning are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">d, i</emphasis> The
          <d:code>int</d:code> argument will be converted to a signed decimal in the style
          “[-]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be converted in fewer digits, it will be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">o</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned octal format in the style
          “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be represented in fewer digits, it will be expanded with leading zeros. The default
        precision is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">u</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned decimal format in the
        style “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be represented in fewer digits, it will be expanded with leading zeros. The default
        precision is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">x</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned decimal format in the
        style “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”; the
        letters “abcdef” are used. The precision specifiers specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer digits, it will be
        expanded with leading zeros. The default precision is 1. The result of converting zero with
        an explicit precision of zero will be no characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">X</emphasis> Equivalent to
        the x conversion specifier, except that letters "<d:code>ABCDEF</d:code>" are used instead
        of "<d:code>abcdef</d:code>".</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">f, F</emphasis> The
          <d:code>double</d:code> argument will be converted to decimal notation in the style
          “[-]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">ddd.ddd</emphasis>”,
        where the number of digits after the radix character is equal to the precision
        specification. If the precision is missing, it will be taken as 6; if the precision is
        explicitly zero and no ‘#’ flag is present, no radix character will appear. If a radix
        character appears, at least one digit appears before it. The low-order digit will be rounded
        in an implementation-defined manner.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity will be converted in one
        of the styles “[-]<d:code>inf</d:code>” or “[-]<d:code>infinity</d:code>” ; which style is
        implementation-defined. A double argument representing a NaN will be converted in one of the
        styles “[-]<d:code>nan</d:code>(<emphasis xmlns="http://docbook.org/ns/docbook"
          role="italic">n-char-sequence</emphasis>)” or “[-]<d:code>nan</d:code>”; which style, and
        the meaning of any n-char-sequence, is implementation-defined. The F conversion specifier
        produces "<d:code>INF</d:code>", "<d:code>INFINITY</d:code>" or "<d:code>NAN</d:code>"
        instead of "<d:code>inf</d:code>", "<d:code>infinity</d:code>" or "<d:code>nan</d:code>",
        respectively.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">e, E</emphasis> The
          <d:code>double</d:code> argument will be converted in the style “[-]<emphasis
          xmlns="http://docbook.org/ns/docbook" role="italic">d.ddde</emphasis>[<d:inlineequation>
          <mml:math>
            <mml:mo>±</mml:mo>
          </mml:math>
        </d:inlineequation>]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
          >dd</emphasis>”, where there is one digit before the radix character (which is non-zero if
        the argument is non-zero) and the number of digits after it is equal to the precision; if
        the precision is missing, it will be taken as 6; if the precision is zero and no ‘#’ flag is
        present, no radix character will appear. The low-order digit will be rounded in an
        implementation-defined manner. The E conversion specifier will produce a number with ‘E’
        instead of ‘e’ introducing the exponent. The exponent will always contain at least two
        digits. If the value is zero, the exponent will be zero.</d:para>
      <d:para>A double argument representing an infinity or NaN will be converted in the style of an
          <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">g, G</emphasis> The double
        argument will be converted in the style <d:code>f</d:code> or <d:code>e</d:code> (or in the
        style <d:code>F</d:code> or <d:code>E</d:code> in the case of a <d:code>G</d:code>
        conversion specifier), with the precision specifying the number of significant digits. If an
        explicit precision is zero, it will be taken as 1. The style used depends on the value
        converted; style <d:code>e</d:code> (or <d:code>E</d:code> ) will be used only if the
        exponent resulting from such a conversion is less than -4 or greater than or equal to the
        precision. Trailing zeros will be removed from the fractional portion of the result; a radix
        character will appear only if it is followed by a digit or a ‘<d:code>#</d:code>’ flag is
        present.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity or NaN will be converted
        in the style of an <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><d:code>a, A</d:code> A <d:code>double</d:code> argument representing a floating-point
        number will be converted in the style “[-]<emphasis xmlns="http://docbook.org/ns/docbook"
          role="italic">0xh.hhhhp</emphasis>(<d:inlineequation>
          <mml:math>
            <mml:mo>±</mml:mo>
          </mml:math>
        </d:inlineequation>)<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
          >d</emphasis>”, where there is one hexadecimal digit (which will be non-zero if the
        argument is a normalized floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is equal to the
        precision; if the precision is missing and <d:code>FLT_RADIX</d:code> is a power of 2, then
        the precision will be sufficient for an exact representation of the value; if the precision
        is missing and <d:code>FLT_RADIX</d:code> is not a power of 2, then the precision will be
        sufficient to distinguish values of type <d:code>double</d:code>, except that trailing zeros
        may be omitted; if the precision is zero and the ‘<d:code>#</d:code>’ flag is not specified,
        no decimal-point character will appear. The letters "<d:code>abcdef</d:code>" will be used
        for a conversion and the letters "<d:code>ABCDEF</d:code>" for A conversion. The
          <d:code>A</d:code> conversion specifier produces a number with ‘<d:code>X</d:code>’ and
          ‘<d:code>P</d:code>’ instead of ‘<d:code>x</d:code>’ and ‘<d:code>p</d:code>’. The
        exponent will always contain at least one digit, and only as many more digits as necessary
        to represent the decimal exponent of 2. If the value is zero, the exponent will be
        zero.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity or NaN will be converted
        in the style of an <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">c</emphasis> The <emphasis
          xmlns="http://docbook.org/ns/docbook" role="bold">int</emphasis> argument will be
        converted to an <d:code>unsigned char</d:code>, and the resulting byte will be written. If
        an <d:code>l</d:code> qualifier is present, the <d:code>wint_t</d:code> argument will be
        converted as if by an <d:code>ls</d:code> conversion specification with no precision and an
        argument that points to a two-element array of type <d:code>wchar_t</d:code>, the first
        element of which contains the <d:code>wint_t</d:code> argument to the <d:code>ls</d:code>
        conversion specification and the second element contains a null wide character.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">s</emphasis> The argument
        will be a pointer to an array of <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >char</emphasis>. Bytes from the array will be written up to (but not including) any
        terminating null byte. If the precision is specified, no more than that many bytes will be
        written. If the precision is not specified or is greater than the size of the array, the
        programmer will ensure that the array contains a null byte. Note that it is a big problem
        which causes <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">strcpy</emphasis>
        to be insecure. What is the char array does not have this null terminating character? We
        will see a safe implementation of <d:code>strcpy</d:code> later. Also,
          <d:code>strlen</d:code> suffers from this problem. Any function relying on null character
        will suffer from this. If an <d:code>l</d:code> qualifier is present, the argument will be a
        pointer to an array of type <d:code>wchar_t</d:code>. Wide characters from the array will be
        converted to characters (each as if by a call to the <d:code>wcrtomb()</d:code> function,
        with the conversion state described by an <d:code>mbstate_t</d:code> object initialized to
        zero before the first wide character is converted) up to and including a terminating null
        wide character. The resulting characters will be written up to (but not including) the
        terminating null character (byte). If no precision is specified, the programmer will ensure
        that the array contains a null wide character. If a precision is specified, no more than
        that many characters (bytes) will be written (including shift sequences, if any), and the
        array will contain a null wide character if, to equal the character sequence length given by
        the precision, the function would need to access a wide character one past the end of the
        array. In no case will a partial character be written.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">p</emphasis> The argument
        will be a pointer to <d:code>void</d:code>. The value of the pointer is converted to a
        sequence of printable characters, in an implementation-defined manner.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">n</emphasis> The argument
        will be a pointer to an <d:code>int</d:code> into which is written the number of bytes
        written to the output so far by this call to one of the fprintf() functions. No argument is
        converted.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">%</emphasis> Print a
          ‘<d:code>%</d:code>’ character; no argument is converted. The complete conversion
        specification will be <d:code>%%</d:code>.</d:para>
      <d:para>If a conversion specification does not match one of the above forms, the behavior is
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">UNDEFINED</emphasis>. If any
        argument is not the correct type for the corresponding conversion specification, the
        behavior is undefined. This is what happened to out string in <d:code>printf.c</d:code>
        shown above. In no case will a nonexistent or small field width cause truncation of a field;
        if the result of a conversion is wider than the field width, the field will be expanded to
        contain the conversion result. Characters generated by <d:code>fprintf()</d:code> and
          <d:code>printf()</d:code> are printed as if <d:code>fputc()</d:code> had been
        called.</d:para>
      <d:para>For the <d:code>a</d:code> and <d:code>A</d:code> conversion specifiers, if
          <d:code>FLT_RADIX</d:code> is a power of 2, the value will be correctly rounded to a
        hexadecimal floating number with the given precision. For <d:code>a</d:code> and
          <d:code>A</d:code> conversions, if <d:code>FLT_RADIX</d:code> is not a power of 2 and the
        result is not exactly representable in the given precision, the result should be one of the
        two adjacent numbers in hexadecimal floating style with the given precision, with the extra
        stipulation that the error should have a correct sign for the current rounding
        direction.</d:para>
      <d:para>For the <d:code>e, E, f, F, g</d:code> and <d:code>G</d:code> conversion specifiers,
        if the number of significant decimal digits is at most <d:code>DECIMAL_DIG</d:code>, then
        the result should be correctly rounded. If the number of significant decimal digits is more
        than <d:code>DECIMAL_DIG</d:code> but the source value is exactly representable with
          <d:code>DECIMAL_DIG</d:code> digits, then the result should be an exact representation
        with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
          <d:code>L &lt; U</d:code>, both having <d:code>DECIMAL_DIG</d:code> significant digits;
        the value of the resultant decimal string <d:code>D</d:code> should satisfy <d:code>L &lt;=
          D &lt;= U</d:code>, with the extra stipulation that the error should have a correct sign
        for the current rounding direction.</d:para>
      <d:para>Some of the capitalized words like <d:code>DECIMAL_DIG, FLT_RADIX</d:code> etc are
        macros defined in <d:code>float.h</d:code>. You should have a look at it. Now we will have
        one example and I will show you output but not explain it. Understanding the output is left
        as an exercise to you, the reader.</d:para>
      <d:programlisting role="CLexer">// Format Specifiers
// Author: Shiv S. Dayal
//Desciption: It is a demo of several format specifiers

#include&lt;stdio.h>

int main()
{
  int i   = 343456;
  float f = 123;
  long double ld = 78939.9347;

  printf("% d\n", i);
  printf("%+d\n", i);
  printf("%#o\n", i);
  printf("%#f\n", f);
  printf("%-08i\n", i);
  printf("%08i\n", i);
  printf("%8i\n", i);
  printf("%hhi\n", i);
  printf("%hi\n", i);
  printf("%li\n", i);
  printf("%lli\n", i);
  printf("%ji\n", i);
  printf("%zi\n", i);
  printf("%ti\n", i);
  printf("%8.8f\n", f);
  printf("%8.8Lf\n", ld);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen> 343456
+343456
01236640
123.000000
343456
00343456
  343456
-96
15776
343456
4638355772471066016
4638355772471066016
343456
343456
123.00000000
78939.93470000</d:screen>
<d:para>I suggest you to read the desciption of conversion specifiers
and experiment with various parameters to get different kind of
output.</d:para>
    </d:sect1>
    <d:sect1><d:title>scanf</d:title>
    <d:para><d:code>scanf()</d:code> is sister of
    <d:code>printf()</d:code>. They work in tandem. As its
    name says scan function it scans <d:code>stdin</d:code> or
    keyboard for input. Its signature is same as that of printf(). It
    raeds bytes from keyboard input, interprets them according to
    format string. It also expects a set of pointer arguments as
    opposed to values for <d:code>printf()</d:code>. The 
    pointers indicate where the interpreted data from the input will
    be stored. The result is <d:emphasis
    role="bold">UNDEFINED</d:emphasis>
    if there are less number of pointer arguments than the number of
    conversion specifers in format string. Excess arguments will be
    evaluated but ignored. The format string can have only white-space
    characters or an ordinary character (neither ‘<d:code>%</d:code>’
    nor a white-space character) or a conversion specification. Each
    conversion specification is introduced by ‘<d:code>%</d:code>’,
    after which the following appear in sequence.</d:para>
    <d:itemizedlist>
      <d:listitem>
	<d:para>An optoinal assignment suppressing character
	‘<d:code>*</d:code>’.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>An optional non-zero decimal integer that specifies
	the maximum field width</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>An option length modifier that specifies the size of
	the receiving object.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>A conversion specifier character that specifies the
	type of conversion to be applied. The valid conversion
	specifiers are described below.</d:para>
      </d:listitem>
    </d:itemizedlist>
    <d:para>A directive composed of one or more white-space characters
    will be executed by reading input until no more valid input can be
    read, or up to the first byte which is not a white-space character,
    which remains unread.</d:para>
    <d:para>A directive that is an ordinary character will be executed
    as follows: the next byte will be read from the input and compared
    with the byte that comprises the directive; if the comparison
    shows that they are not equivalent, the directive will fail, and
    the differing and subsequent bytes will remain unread. Similarly,
    if end-of-file, an encoding error, or a read error prevents a
    character from being read, the directive will fail.</d:para>
    <d:para>A directive that is a conversion specification defines a set
    of matching input sequences, as described below for each conversion
    character. A conversion specification will be executed in the
    following steps.</d:para>
    <d:para>Input white-space characters (as specified by
    <d:code>isspace()</d:code>) will be skipped, unless the conversion
    specification includes a <d:code>[, c, C</d:code> or
    <d:code>n</d:code> conversion specifier.</d:para>
    <d:para>An item will be read from the input, unless the conversion
    specification includes an n conversion specifier. An input item
    will be defined as the longest sequence of input bytes (up to any
    specified maximum field width, which may be measured in characters
    or bytes dependent on the conversion specifier) which is an
    initial subsequence of a matching sequence. The first byte, if
    any, after the input item will remain unread. If the length of the
    input item is 0, the execution of the conversion specification
    will fail; this condition is a matching failure, unless
    end-of-file, an encoding error, or a read error prevented input
    from the stream, in which case it is an input failure.</d:para>
    <d:para>Except in the case of a <d:code>%n</d:code> conversion
    specifier, the input item (or, in the case of a
    <d:code>%n</d:code> conversion specification, the count 
    of input bytes) will be converted to a type appropriate to the
    conversion character. If the input item is not a matching
    sequence, the execution of the conversion specification fails;
    this condition is a matching failure. Unless assignment
    suppression was indicated by a '<d:code>*</d:code>', the result of
    the conversion will be placed in the object pointed to by the
    first argument following the format argument that has not already
    received a conversion result if the conversion specification is
    introduced by <d:code>%</d:code>. If this object does not have an
    appropriate type, or if the result of the conversion cannot be
    represented in the space provided, the behavior is
    undefined.</d:para>
    <d:para>The length modifiers and their meanings are:</d:para>
    <d:para><d:emphasis role="bold">hh</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>signed char</d:code> or <d:code>unsigned
    char</d:code>.</d:para>
    <d:para><d:emphasis role="bold">h</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>short</d:code> or <d:code>unsigned
    short</d:code>.</d:para>
    <d:para><d:emphasis role="bold">l</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>long</d:code> or <d:code>unsigned long</d:code>; that a
    following <d:code>a, A, e, E, f, F, g</d:code> or
    <d:code>G</d:code> conversion specifier applies to an argument
    with type pointer to <d:code>double</d:code>; or that a following
    <d:code>c, s</d:code> or <d:code>[ conversion</d:code> specifier
    applies to an argument with type pointer to
    <d:code>wchar_t</d:code>.</d:para>
    <d:para><d:emphasis role="bold">j</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>intmax_t</d:code> or <d:code>uintmax_t</d:code>.</d:para>
    <d:para><d:emphasis role="bold">z</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to
    <d:code>size_t</d:code> or the corresponding <d:code>signed int</d:code>
    type.</d:para>
    <d:para><d:emphasis role="bold">t</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to
    <d:code>ptrdiff_t</d:code> or the corresponding <d:code>unsigned
    type</d:code>.</d:para>
    <d:para><d:emphasis role="bold">L</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to <d:code>long
    double</d:code>.</d:para>
    <d:para>If a length modifier appears with any conversion specifier other
    than as specified above, the bahavior is undefined. The following
    conversion specifiers are valid:</d:para>
    <d:para><d:emphasis role="bold">d</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 10 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">i</d:emphasis> Matches an optionally signed
    integer, whose format is the same as expected for the subject sequence of
    <d:code>strtol() with</d:code> 0 for the base argument. In the absence of a
    size modifier, the programmer will ensure that the corresponding argument
    is a pointer to <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">code</d:emphasis> Matches an optionally
    signed octal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 8 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to unsigned.</d:para>
    <d:para><d:emphasis role="bold">u</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 10 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">x</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 16 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">a, e, f, g</d:emphasis> Matches an
    optionally signed floating-point number, infinity, or NaN, whose format is
    the same as expected for the subject sequence of
    <d:code>strtod(). In</d:code> the absence of a size modifier, the
    programmer will ensure that the corresponding argument is a pointer to
    float.</d:para>
    <d:para>If the <d:code>printf() family</d:code> of functions generates
    character string representations for infinity and NaN (a symbolic entity
    encoded in floating-point format) to support IEEE Std 754-1985, the
    <d:code>scanf() family</d:code> of functions will recognize them as
    input.</d:para>
    <d:para><d:emphasis role="bold">s</d:emphasis> Matches a sequence of bytes
    that are not white-space characters. The programmer will ensure that the
    corresponding argument is a pointer to the initial byte of an array (will
    see them later) of <d:code>char, signed char</d:code> or <d:code>unsigned
    char</d:code> large enough to accept the sequence and a terminating null
    character code, which will be added automatically.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character will be converted to a wide character as if by a call to the
    <d:code>mbrtowc() function</d:code>, with the conversion state described by
    an <d:code>mbstate_t</d:code> object initialized to zero 
    before the first character is converted. The programmer will ensure that
    the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the sequence and the
    terminating null wide character, which will be added
    automatically.</d:para>
    <d:para><d:emphasis role="bold">c</d:emphasis> Matches a sequence of bytes
    of the number specified by the field width (1 if no field width is present
    in the conversion specification). The programmer will ensure that the
    corresponding argument is a pointer to the initial byte of an array of
    <d:code>char, signed char</d:code> or <d:code>unsigned char</d:code> large
    enough to accept the sequence. No null byte is added. The normal skip over
    white-space characters will be suppressed in this case.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character will be converted to a wide character as if by a call to the
    <d:code>mbrtowc() function</d:code>, with the conversion state described by
    an <d:code>mbstate_t</d:code> object initialized to zero 
    before the first character is converted. The programmer will ensure that
    the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the resulting sequence of
    wide characters. No null wide character is added.</d:para>
    <d:para><d:emphasis role="bold">p</d:emphasis> Matches an
    implementation-defined set of sequences, which shall be the same as the set
    of sequences that is produced by the %p conversion specification of the
    corresponding <d:code>printf() functions</d:code>. The application shall
    ensure that the corresponding argument is a pointer to a pointer to
    void. The interpretation of the input item is implementation-defined. If
    the input item is a value converted earlier during the same program
    execution, the pointer that results will compare equal to that value;
    otherwise, the behavior of the <d:code>%p</d:code> conversion specification
    is undefined.</d:para>
    <d:para><d:emphasis role="bold">[ </d:emphasis>Matches a non-empty sequence
    of bytes from a set of expected bytes (the scanset). The normal skip over
    white-space characters shall be suppressed in this case. The programmer
    will ensure that the corresponding argument is a pointer to the initial
    byte of an array of <d:code>char, signed char</d:code> or <d:code>unsigned
    char</d:code> large enough to accept the sequence and a terminating null
    byte, which shall be added automatically.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character in the sequence will be converted to a wide character as if by a
    call to the <d:code>mbrtowc() function</d:code>, 
    with the conversion state described by an <d:code>mbstate_t</d:code> object
    initialized to zero before the first character is converted. The programmer
    will ensure that the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the sequence and the
    terminating null wide character, which will be added
    automatically.</d:para>
    <d:para>The conversion specification includes all subsequent bytes in the format string up to
        and including the matching right square bracket ( '<d:code>]</d:code>' ). The bytes between
        the square brackets (the scanlist) comprise the scanset, unless the byte after the left
        square bracket is a circumflex ( '<d:code>^</d:code>^ ), in which case the scanset contains
        all bytes that do not appear in the scanlist between the circumflex and the right square
        bracket. If the conversion specification begins with "<d:code>[]</d:code>" or
          <d:code>"[^]"</d:code>, the right square bracket is included in the scanlist and the next
        right square bracket is the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that ends the conversion
        specification. If a '-' is in the scanlist and is not the first character, nor the second
        where the first character is a '<d:code>^</d:code>', nor the last character, the behavior is
        implementation-defined.</d:para>
      <d:para>The conversion specifiers <d:code>A, E, F, G</d:code> and <d:code>X</d:code> are also
        valid and shall be equivalent to <d:code>a, e, f, g</d:code> and <d:code>x</d:code>
        respectively.</d:para>
      <d:para>If end-of-file is encountered during input, conversion shall be terminated. If
        end-of-file occurs before any bytes matching the current conversion specification (except
        for <d:code>%n</d:code>) have been read (other than leading white-space characters, where
        permitted), execution of the current conversion specification will terminate with an input
        failure. Otherwise, unless execution of the current conversion specification is terminated
        with a matching failure, execution of the following conversion specification (if any) will
        be terminated with an input failure.</d:para>
      <d:para>Reaching the end of the string in <d:code>sscanf()</d:code> shall be equivalent to
        encountering end-of-file for <d:code>scanf()</d:code>. If conversion terminates on a
        conflicting input, the offending input is left unread in the input. Any trailing white space
        (including newlines) shall be left unread unless matched by a conversion specification. The
        success of literal matches and suppressed assignments is only directly determinable via the
          <d:code>%n</d:code> conversion specification.</d:para>
      <d:para>Time for some code. You have already seen many examples of <d:code>scanf</d:code> so I
        will just explain some concepts here. Consider the following program:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of string input

#include &lt;stdio.h>

int main()
{
  char str[128] = {0};

  scanf("%s", str);
  printf("You entered:\n%s\n", str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv.
You entered:
Hi!</d:screen>
      <d:para>It is certainly not the corect output. We had expected to see like: “Hi! My name is
        Shiv.”. What happend to input string after “Hi!”. Well, in a form given above for
          <d:code>scanf()</d:code> it will stop taking input after white-space for character
        strings. For numerics it does not matter as it does not match the format. For characters it
        is character-by-character so no confusion either. So what if you want to have the entire
        string including white-spaces. Use <d:code>[^n]</d:code> as given below:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Corrected demo of string input

#include &lt;stdio.h>

int main()
{
  char str[128] = {0};

  scanf("%[^\n]s", str);
  printf("You entered:\n%s\n", str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv.
You entered:
Hi! My name is Shiv.</d:screen>
      <d:para>What if you want to filter a string based on certain patterns. For example, a
        charcater string does not contain more that a single space, English alphabets, period and
        digits. To scan such a string you can define a pttern as program given below shows:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv. S Dayal
// Description: Demo of []

#include &lt;stdio.h>

int main()
{
  char c[100]={0};

  scanf("%[ A-Za-z0-9!.]", c);
  printf("%s\n", c);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv! My phone no. is 1234. %^$&amp;*
Hi! My name is Shiv! My phone no. is 1234.</d:screen>
      <d:para>There is also a major problem associated with input and that comes when you have
        characters involved. Consider the following program:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of scanf() function

#include &lt;stdio.h>

int main()
{
  int   i = 0;
  float f = 0.0;
  char  c1 = '\0';
  char  c2 = '\0';
  char  c3 = '\0';

  printf("Enter an integer, a float and three character one by one:\n");

  scanf("%d", &amp;i);
  scanf("%f", &amp;f);
  scanf("%c", &amp;c1);
  scanf("%c", &amp;c2);
  scanf("%c", &amp;c3);

  printf("You entered\n");
  printf("%d\n", i);
  printf("%f\n", f);
  printf("%c\n", c1);
  printf("%c\n", c2);
  printf("%c\n", c3);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>2
3.4
s
You entered
2
3.400000


s</d:screen>
      <d:para>What is happening here is that newline entered by our <d:code>RET</d:code> key is
        getting assigned to <d:code>c1</d:code> and <d:code>c3</d:code>. That is why the program
        accepted only second character. The enter after <d:code>float f;</d:code> was assigned to
          <d:code>c1</d:code> and the character entered to <d:code>c2</d:code> and then the RET
        newline to <d:code>c3</d:code>. There is a very simple way to recover from this:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of scanf() function

#include &lt;stdio.h>

int main()
{
  int   i = 0;
  float f = 0.0;
  char  c1 = '\0';
  char  c2 = '\0';
  char  c3 = '\0';

  printf("Enter an integer, a float and three character one by one:\n");
  scanf("%d", &amp;i);
  scanf("%f", &amp;f);
  scanf(" %c", &amp;c1);
  scanf(" %c", &amp;c2);
  scanf(" %c", &amp;c3);

  printf("%d\n", i);
  printf("%f\n", f);
  printf("%c\n", c1);
  printf("%c\n", c2);
  printf("%c\n", c3);

  return 0;
}</d:programlisting>
      <d:para>The whitespace character shown will eat up all the white-space given after the
        previous input. This concludes our discussion on <d:code>printf()</d:code> and
          <d:code>scanf()</d:code>. Now we will move to another set of i/o functions which take
        character string without filtering and print it to screen without filtering. What I am going
        to discuss are <d:code>gets(), fgets(), puts()</d:code> and
        <d:code>fputs()</d:code>.</d:para> 
  </d:sect1>
  <d:sect1>
    <d:title>Character String I/O Functions</d:title>
    <d:para>These functions are very simple compared to
    <d:code>printf()</d:code> and <d:code>scanf()</d:code>. They take a pointer
    to a character array or a character pointer and fill it with input or print
    it to monitor. Note that <d:code>gets()</d:code> and
    <d:code>puts()</d:code> work only with stdin and stdout respectively while
    <d:code>fgets()</d:code> and <d:code>fputs()</d:code> work with
    <d:code>FILE</d:code> streams. They can read and write to file streams that
    is. Here is a sample program:</d:para>
<d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description : Demo of string i/o
#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  char cStack[1024] = "";
  char *cHeap = (char*)malloc(sizeof(1024));

  gets(cStack);
  puts(cStack);

  cHeap = fgets(cHeap, 1024, stdin);
  fputs(cHeap, stdout);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>Hi!
Hi!
Hello!
Hello!</d:screen>
<d:para>First <d:code>"Hi!"</d:code> and <d:code>"Hello!"</d:code> are keyboard
inputs. Do not worry about array and pointer syntax at the moment. Just see the
difference between function calls. Their is a problem with
<d:code>gets()</d:code> that it can cause buffer overflow. If input is bigger
than 1024 bytes including the null terminator then buffer overflow will
happen. Note how you can prevent it with fgets() by specifying the number of
characters you want to read. Rest of input will be ignored by
<d:code>fgets()</d:code>. This is a security hole and therefore you should
never ever use <d:code>gets()</d:code>.</d:para>
<d:para>Time for single character input/output.</d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Single Character I/O</d:title>
    <d:para>There are several functions for single character i/o. They are
    <d:code>getc(), putc(), getchar(), putchar(), fgetc()</d:code> and
    <d:code>fputc()</d:code>. Apart from <d:code>getchar()</d:code> and
    <d:code>putchar()</d:code> rest can do any FILE stream-based i/o. Let us
    see them as they are mostly trivial.</d:para>
    <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Single character funciton demo
#include &lt;stdio.h>

int main()
{
  char c ='';

  c = getchar();
  putchar(c);

  c = getchar();
  putchar(c);

  c = fgetc(stdin);
  fputc(c, stdout);

  c = getchar();
  putchar(c);

  c = getc(stdin);
  putc(c, stdout);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>4
4
5
5
6
6</d:screen>
<d:para>The first 4, 5 and 6 were keyboard inputs. Note the use of extra
<d:code>getchar()</d:code> and <d:code>putchar()</d:code> to handle the
situation we faced during <d:code>scanf()</d:code>.</d:para>
<d:para>So we have seen many functions and programs for console i/o. File i/o
is still there and will be covered later. This chapter ends here. See you in
the next chapter with operators and expressions.:-)</d:para>
  </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="oae/index.html" ?>
      <d:title>Operators and Expressions</d:title>
      <d:para>Operators and expressions are in the core of every programming
      language. They form the major part of BNF grammar. They also decide how
      the syntax will look like. You as a programmer will spend considerable
      time using C operators. C has sevral type of operators like arithmetic
      operators, relational operators, bitwise operators, unary operators,
      logical operators to name some of them. Since C was first of very
      poopular structured general-pupose lnguages therefore many modern
      language use almost all the operators and supplement with their own. It
      is needless to say that to become a good programmar you must know all the
      operators of C and know where to use which one as it may decide
      performance, readability, simplicity of your code. Whenever you see array
      and pointer in following sections just plow through them. All will be
      clear soon.</d:para>
      <d:para>Whenever operators and expressions come in picture you may have a
      set of mixed data then to perform opration data is converted from one
      type to another. This is known as “Usual Arithmetic Conversion”, which I
      am going to tell you next.</d:para>
      <d:sect1>
	<d:title>Basic Operators</d:title>
	<d:para>There are five here. +, -, *, / and %. Please refer to chapter
	4 for their behavior. Let us see a simple example:</d:para>
	<d:programlisting role="CLexer">// Arithmetic operators
// Author: Shiv S. Dayal
// Description: Demo of arithmetic operators

#include &lt;stdio.h>

int main()
{
  int i = 10;
  float f= 6.45;
  char c = 'A';
  int iResult = 0;
  float fResult = 0.0;
  char cResult = '\0';

  cResult = c + i;
  printf("cResult = %c\n", cResult);
  cResult = cResult - 5;
  printf("cResult = %c\n", cResult);

  iResult = i - 10;
  printf("iResult = %d\n", iResult);
  iResult = i * c;
  printf("iResult = %d\n", iResult);
  iResult = (i + c)/3;
  printf("Result = %d\n", iResult);
  iResult = (i + c)%2;
  printf("iesult = %d\n", iResult);

  fResult = f * 2.12;
  printf("fesult = %f\n", fResult);
  fResult = f - i;
  printf("fesult = %f\n", fResult);
  fResult = f / 1.12;
  printf("fesult = %f\n", fResult);
  fResult = 1 % 3;
  printf("fesult = %f\n", fResult);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>cResult = K
cResult = F
iResult = 0
iResult = 650
Result = 25
iesult = 1
fesult = 13.674000
fesult = -3.550000
fesult = 5.758928
fesult = 1.000000</d:screen>
<d:para>First <d:code>cResult</d:code> is sum of <d:code>'A' + i</d:code> which
is <d:code>'K'</d:code> as <d:code>'K'</d:code> comes ten positions after A in
ASCII table. Then we subtract five and go back to F.</d:para>
<d:para>First <d:code>iReasult</d:code> is 10 - <d:code>i</d:code> where value
of <d:code>i</d:code> is 10 hence result is 0. Next we multiply it with
<d:code>i</d:code> which contains <d:code>'A'</d:code> who has got ASCII value
of 65 and result becomes 650. Then We take sum of <d:code>'A'</d:code> and
<d:code>i</d:code> and divide by 3 so the result is 25 as it is a division of
75 by 3. Next we use modulus operator and remainder is 1. Note that in case of
/ and % if denominator is zero the behavior is undefined.</d:para>
<d:para>Same way you can udnerstand floating-point operations. Note that you
cannot use modulus operator if either of the operands are floating-point
numbers as it will make no sense because of data type promotion rules. Here
data type promotion rule says smaller data types will be converted to bigger
data types. Also, if there is a data type on left side of assignment the result
of applying the operator to operands will be converted to the type of
that. chars are promoted to ints, ints are promoted to floats anf floats to
double. The point is that conversion will try to keep as much data as
possible.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Relational Operators</d:title>
	<d:para>There are four relational operators: &lt;, >, &lt;= and
	>=. Once again these are described in chapter 4. Let us see an
	example:</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of relational operator

#include &lt;stdio.h>
#include &lt;stdbool.h>

int main()
{
  int i = 4, j = 5;
  _Bool result = 0;

  result = i &lt; j;
  printf("%d\n", result);

  result = i > j;
  printf("%d\n", result);

  result = i &lt;= j;
  printf("%d\n", result);

  result = i >= j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>1
0
1
0</d:screen>
<d:para>Note that you should not apply these to floating-point data types as
they may not be represented correctly and two different entities have the same
internal representation.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Equality Operators</d:title>
	<d:para>There are two equlity operators == and !=. </d:para>
	<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of equality operator

#include &lt;stdio.h>
#include &lt;stdbool.h>
int main()
{
  int i = 4, j = 5;
  _Bool result = 0;

  result = i == j;
  printf("%d\n", result);

  result = i != j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>0
1</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Increment and Decrement Operators</d:title>
	<d:para>There is one increment and one decrement operator. ++ and
	--. Both come in two forms prefix and postfix. First we will see prefix
	versions then postfix ones. There is only one constraint on prefix
	operators of these and that is the operand of the prefix increment or
	decrement operator will have qualified or unqualified real or pointer
	type and will be a modifiable lvalue.</d:para>
	<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of increment decrement operators

#include &lt;stdio.h>

int main()
{
  float f = 7.123;

  printf("%f\n", ++f);
  printf("%f\n", --f);
  printf("%f\n", f++);
  printf("%f\n", f--);
  printf("%f\n", f);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>8.123000
7.123000
7.123000
8.123000
7.123000</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Logical Operators</d:title>
	<d:para>There are two such operators. &amp;&amp; logical AND and ||
	locical OR. Both the operators have the same constraints and it is that
	both the operands will have scalar type.</d:para>
	<d:para>The &amp;&amp; operator gives 1 if both the operands are
	non-zero else 0. The result type is int. It is different from bitwise
	&amp; operator in the sense that it guarantess left-to-right
	evaluation; if the second operand is evaluated, there is a sequence
	point between the evaluations of the first and second operands. If the
	first operand is 0 then the second operand is not evaluated. This is
	known as “short-circuit evaluation”.</d:para>
	<d:para>The || operator gives 1 if any of operands are non-zero else it
	gives 0. Same as logical AND operator and unlike bitwise | operator it
	guarantees left-to-right evaluation and same goes for sequence
	points. If first operand is non-zero, the second is not
	evaluated.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of logical AND &amp; OR operators

#include &lt;stdio.h>
#include &lt;stdbool.h>

int main()
{
  int i = 4, j = 5, k = 0;
  bool result;

  result = i&amp;&amp;j;
  printf("%d\n", result);

  result = i||j;
  printf("%d\n", result);

  result = k&amp;&amp;j;
  printf("%d\n", result);

  result = k||j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>1
1
0
1</d:screen>
<d:para>note the use of <d:code>bool</d:code> here instead of
<d:code>_Bool</d:code>.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Bitwise Operators</d:title>
	<d:para>There are three bitwise operators. &amp;, |, and ^. AND, OR and
	EX-OR respectively. OR is also called inclusive OR. These have the same
	contsraints and it is that operands should be integer types. The usual
	arithmetic conversions are performed on the operands.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of bitwise operators

#include &amp;stdio.h>
#include &amp;stdbool.h>

int main()
{
  int i = 4, j = 5;
  int result;

  result = i&amp;j;
  printf("%d\n", result);

  result = i|j;
  printf("%d\n", result);

  result = i^j;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>4
5
1</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Bitwise Shift Operators</d:title>
	<d:para>The constraint is same as other bitwise operators that operands
	should be integers. The integer promotions are performed on each of the
	operands. The type of the result if that of the promoted left
	operand. If the value of the right operand is negative or is greater
	than or equal to the width of the promoted left operand, the behavior
	is undefined.</d:para>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of shift operators

#include &lt;stdio.h>

int main()
{
  int i  = 4;
  char c ='A';
  int result;

  result = c&lt;&lt;i;
  printf("%d\n", result);

  result = c>>i;
  printf("%d\n", result);

  return 0;
}</d:programlisting>
      </d:sect1>
      <d:sect1>
	<d:title>Assignment Operators</d:title>
	<d:para>These are = *= /= %= += -= &lt;&lt;= >>= &amp;= ^= and |= The only
	constraint is that left operand should be modifiable lvalue. An
	assignment operator stores a value in the object designated by the left
	operand. An assignment expression has the value of the left operand
	after the assignment, but is not an lvalue. The type of an assignment
	expression is the type of the left operand unless the left operand has
	qualified type, in which case it is the unqualified version of the type
	of the left operand. The side effect of updating the stored value of
	the left operand is sequenced after the value computations of the left
	and right operands. The evaluations of the operands are
	unsequenced.</d:para>
<d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of compound assignments.

#include &lt;stdio.h>

int main()
{
  int i   = 3;
  int j   = 3;
  float f = 4.7;
  float result=0.0;

  result += i+f;
  printf("%f\n", result);

  result -= f;
  printf("%f\n", result);

  j &lt;&lt;= i;
  printf("%d\n", j);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>7.700000
3.000000
24</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Conditional Operators</d:title>
<d:programlisting role="CLexer">// Author : Shiv S. Dayal
// Description : Demo of conditional operator

#include &lt;stdio.h>

int main()
{
  int i = (4 &lt; 5)? 7:10;

  printf("%d\n", i);

  return 0;
}</d:programlisting>
<d:para>output is 7 as 4 is less than 5 which is true.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Comma Operator</d:title>
	<d:para>It is a very simple operator. The left operand of a comma
	operator is evaluated as a void expression; there is a sequence point
	between its evaluation and that of the right operand. Then the right
	operand is evaluated; the result has its type and value. A comma
	operator does not give an lvalue.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>sizeof Operator</d:title>
	<d:para>You have already see sizeof operator in second chapter when we
	saw sizes of data types. However here is the constraint: the sizeof
	operator will not be applied to an expression that has function type or
	an incomplete type, to the parenthesized name of such a type, or to an
	expression that designates a bit-field member.</d:para>
	<d:para>The sizeof operator yields the size (in bytes) of its operand,
	which may be an expression or the parenthesized name of a type. The
	size is determined from the type of the operand. The result is an
	integer. If the type of the operand is a variable length array type,
	the operand is evaluated; otherwise, the operand is not evaluated and
	the result is an integer constant.</d:para>
	<d:para>When applied to an operand that has type char, unsigned char,
	or signed char, (or a qualified version thereof) the result is 1. When
	applied to an operand that has array type, the result is the total
	number of bytes in the array. When applied to an operand that has
	structure or union type, the result is the total number of bytes in
	such an object, including internal and trailing padding.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Unary Arithmetic Operators</d:title>
	<d:para>We will see casting, array subscripting, function parenthes,
	address and indirection operators later at appropriate time. For now I
	am going to tell you about operator precedence and associativity and
	then about grouping parenthes. Given below is the table for operator
	precedence and associativity, however, you may not be familiar with few
	of them but later you will be:</d:para>
	<d:table frame="border" class="leftcenter"
          border="1">
	  <d:colgroup width="0*"/>
	  <d:colgroup width="0*"/>
          <d:caption>Priority and assiciativity table</d:caption>
          <d:thead>
            <d:tr bgcolor="#aaa">
              <d:th>Operators</d:th>
              <d:th>Associativity</d:th>
            </d:tr>
          </d:thead>
	  <d:tr>
	    <d:td>() [] . -> ++ – (postfix)</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>++ – + - (unary) ! ~ (types) * &amp; sizeof</d:td>
	    <d:td>right-to-left</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>* / %</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>+ - (Addition/Subtraction)</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&lt;&lt; >></d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&lt; > &lt;= >=</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>== !=</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&amp;</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>^</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>|</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>&amp;&amp;</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>||</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>Assignemnt operators</d:td>
	    <d:td>right-to-left</d:td>
	  </d:tr>
	  <d:tr>
	    <d:td>,</d:td>
	    <d:td>left-to-right</d:td>
	  </d:tr>
	</d:table>
      </d:sect1>
      <d:sect1>
	<d:title>Grouping parentheses</d:title>
	<d:para>Grouping parentheses are used to override operator precedence
	and group expressions. NEVER EVER try to memorize and rely on
	precedence of operators. Always use grouping parentheses. Till now I
	have shown very simple examples of operators; here are some complex
	ones:</d:para>
	<d:programlisting role="CLexer">// Author: Shiv Shankar Dayal
// Description: Demo of grouping parentheses

#include &lt;stdio.h>

int main()
{
  printf("%f\n", 5.2*(3.7+2.3));
  printf("%d\n", ((4&lt;5)||(7^5)));

  return 0;
}</d:programlisting>
<d:para>This small program shows you what can go wrong if you rely on
memory. It allows you do addition first and then multiplcation. Inner
parentheses are evaluated first then inner ones. This concludes our chapter on
operators and expressions. Next we focus on control statements and flow
statements.</d:para> 
      </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="cf/index.html" ?>
      <d:title>Control Flow</d:title>
      <d:para>There are three things you will learn in this chapter. Switching
      the path of execution in program depending upon program variables or
      states using control statements. Repeating a set of instructions using
      loops. Bypassing certain set of instructions in a loop and jump
      around. Collectively, these elements of C allow or enable you to take
      driver’s seat over the control over a C program. You will spend much of
      your programming time even in future using these basic elements. Let us
      begin with if-else without spending much time over boring stuff. Before
      we proceed I would like to tell you about storage classes of array and
      their scope. I could have covered it in second chapter but I did not want
      to scare you with too many things in itself.</d:para>
      <d:sect1>
	<d:title>Storage Classes</d:title>
	<d:para>In C99 variables can be declared at any point in class without
	breaking an expression. This was not possible in older C and you could
	only declare at start of function. There is <d:code>auto, register,
	static</d:code> and <d:code>extern</d:code>.</d:para>
	<d:para><d:code>auto</d:code> is the default storage class for local
	variables. Local variables are those that are inside any function or
	any control-flow statement block. You will perhaps never use auto
	explicitly. For examle, <d:code>auto int i; register</d:code> is the
	storage class which tell the compiler that this variable will be stored
	in a CPU register instead of RAM. It is mostly used for loop counters
	and to store small 32-bit or 64-bit variables in CPU register. For
	example, <d:code>register int i;</d:code></d:para>
	<d:para><d:code>static</d:code> is the default storage class for global
	variables though local variables can also be made static. local static
	variables persist across function calls that is their values do not
	change.</d:para>
	<d:para><d:code>extern</d:code> keyword allows global variables to
	become visible in other modules than itself.</d:para>
	<d:para>There are two more modifiers: <d:code>const</d:code> and
	<d:code>volatile</d:code>. As their names specify const makes a
	variable constant. That is you cannot change value of a variable
	declared as <d:code>const</d:code>. <d:code>volatile</d:code> is kind
	of opposite but not really opposite. What it does is that the programs
	other than the program itself where it has been declared are allowed to
	change it. This means that a variable can be a <d:code>const</d:code>
	as well as <d:code>volatile</d:code> at the same time.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>if else Statement</d:title>
	<d:para>An if-else statement may consist of only <d:code>if</d:code> or
	both <d:code>if</d:code> and <d:code>else</d:code> or
	<d:code>if</d:code> and <d:code>else if</d:code> or <d:code>if, else
	if</d:code> and <d:code>else</d:code>. An if-else statement must have
	<d:code>if</d:code> at the beginning, zeor or more <d:code>else
	if</d:code> may come after <d:code>if</d:code> or before
	<d:code>else</d:code> and <d:code>else</d:code> must come at
	end. <d:code>else if</d:code> and <d:code>else</d:code> are optional
	and may not come. Consider the following program:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>

int main()
{
  int i = 0, j= 0;

  printf("Please enter two integers i and j:\n");
  scanf("%d%d", &amp;i , &amp;j);

  if(i==4)
    printf("you entered 4 for i.\n");

  if(i==7)
  {
    printf("you entered 7 for i.\n");
    printf("I am happy for you.\n");
  }
  else
  {
    printf("You did not enter 7 for i.\n");
  }
  if(i==7)
  {
    printf("you entered 7 for i.\n");
    printf("I am happy for you.\n");
  }
  else if(j==8)
    printf("You entered 8 for i.\n");

  if(i==7)
    printf("you entered my lucky number.\n");
  else if((i==7) &amp;&amp;(j==8))
    printf("May god bless you!\n");
  else
    printf("You entered bad number.\n");

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Please enter two integers i and j:
4
6
you entered 4 for i.
You did not enter 7 for i.
You entered bad number.</d:screen>
<d:para>As you can see from first if sttatement that if you enter the value of
i as 4 then the printf will be executed and you will be able to see it. Note
that if there are multiple lines below if which you want to execute then you
must put them in a block using curly braces. If you just want to execute one
line then these curly braces are optional. Note that how you must use curly
braces if you have more than one line and you want to execute them. Also, see
the syntax for missing else and missing else if. One if-else can be nested
inside another for example see the following code:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>
#include &lt;string.h>

int main()
{
  char fName[128]={0}, lName[128]={0};

  printf("Enter your first name and last name in that order:\n");
  gets(fName);
  gets(lName);

  if(strcmp(fName, "Shiv") == 0)
  {
    if(strcmp(lName, "Dayal") == 0)
      printf("Your name is Shiv Dayal.\n");
  }
  else
  {
    printf("Your name is %s %s.\n", fName, lName);
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Enter your first name and last name in that order:
Shiv
Dayal
Your name is Shiv Dayal.</d:screen>
<d:para>another run:</d:para>
<d:screen>Enter your first name and last name in that order:
Richard
Stallman
Your name is Richard Stallman.</d:screen>
<d:para>when first if matches but else does not:</d:para>
<d:screen>Enter your first name and last name in that order:
Shiv
Stallman</d:screen>
<d:para>Note the usage of nested if-else. Also, note how
<d:code>strcmp</d:code> has been used to compare two strings and
<d:code>gets</d:code> to read the input. <d:code>gets</d:code> is dangerous but
it is simple that is why has been used here. You can read about it at the link
of opengroup. We will see this in more detail towards the end when we deal with
chapter named C Standard Library.</d:para>
<d:warning>
  <d:title>Assignment in if/else-if</d:title>
  <d:para>Always remember the expression inside if evaluates to a boolean so
  you should never do an ASSIGNMENT inside if and else if as it will always
  evaluate to what is assigned. It can render all your logic meaningless. C is
  not Python, where assignment inside if is not allowed. However, if you assign
  0 to some variable it will evaluate to <d:code>false</d:code>.</d:para>
</d:warning>
<d:sect2>
  <d:title>Dangling else Problem</d:title>
  <d:para>The <d:code>else</d:code> part has a property that it will cling to
  closest if. So the following piece of code may give you surprise:</d:para>
<d:programlisting role="CLexer">if(x==1)
  if(y>2)
    printf("foo\n");
else
  printf("bar\n");</d:programlisting>
<d:para>Now consider <d:code>x!=1</d:code> then you may think that bar will be
printed. However, that will not be the case. The else part clings to inner
if. This can be fixed by using curly braces.</d:para>
</d:sect2>
      </d:sect1>
      <d:sect1>
	<d:title>switch Statement</d:title>
	<d:para><d:code>switch</d:code> statement is kind of if-else
	replacement to simplify it. Usage of switch statement is to compare one
	expression with others, and then execute a series of sub-statements
	inside case and default based on the result of the comparisons. Note
	that switch statement takes only integers or integreal type as its
	argument and same is valid for its cases. Consider the following
	example:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of if-else statements.

#include &lt;stdio.h>

int main()
{
  int i  = 65;

  switch(i)
  {
    case 'A':
      printf("Value of i is 'A'.\n");
      break;
    case 'B':
      printf("Value of i is 'B'.\n");
      break;
    default:
      break;
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Value of i is 'A'.</d:screen>
<d:para>Notice the usage of <d:code>break</d:code>. It is used to terminate
execution once a match has been found for a particular case else what will
happen is shown below:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of switch statement.

#include &lt;stdio.h>

int main()
{
  int i  = 65;

  switch(i)
  {
    case 'A':
      printf("Value of i is 'A'.\n");
    case 'B':
      printf("Value of i is 'B'.\n");
    default:
      printf("Value of i is %c.\n", i);
      break;
    }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Value of i is 'A'.
Value of i is 'B'.
Value of i is A.</d:screen>
<d:para>This is also known as fall through of a <d:code>switch</d:code>
statement. Notice, the use of default that how it is analogous to
<d:code>else</d:code> statement. <d:code>switch</d:code> statements can also be
nested inside each other. However, node that lots of nesting is not good. At
most 2-3 levels are more than enough else you should look at alternative ways
of writing code.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>while Loop</d:title>
	<d:para>Of three loops I am first going to cover <d:code>while</d:code>
	loop. It is simplest of three. I will just give an example for you to
	understand.</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of while statement.

#include &lt;stdio.h>

int main()
{
  int i = 0;

  while(i &lt;= 10)
  {
    printf("%d * %2d = %4d\n", 2, i, 2*i);
    i++;
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>2 *  0 =    0
2 *  1 =    2
2 *  2 =    4
2 *  3 =    6
2 *  4 =    8
2 *  5 =   10
2 *  6 =   12
2 *  7 =   14
2 *  8 =   16
2 *  9 =   18
2 * 10 =   20</d:screen>
<d:para><d:code>while</d:code> loop just has one expression which is its
terminating condition. We have written <d:code>i&lt;=10</d:code> which is
terminating condition for our loop. The moment i will become greater than that
the loop will terminated. We are initializing our loop index to 0 and
incrementing within while loop. Note that you must use curly braces for body of
block of loop. If you have only one statement as body of loop then braces are
optional.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>do-while Loop</d:title>
	<d:para>It is very much similar to <d:code>while</d:code> loop but with
	a very subtle difference. Consider the following code:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of do while statement.

#include &lt;stdio.h>

int main()
{
  int i = 0;

  do {
    printf("I am Shiv.\n");
    i++;
  }while(i&lt;5);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>I am Shiv.
I am Shiv.
I am Shiv.
I am Shiv.
I am Shiv.</d:screen>
<d:para>Notice the semicolon at the end of while. Now time for that subtle
difference:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of do while statement.

#include &lt;stdio.h>

int main()
{
  int i = 10;

  do {
    printf("2 * 10 = 20\n");
    i++;
  }while(i&lt;5);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>2 * 10 = 20</d:screen>
<d:para>Notice how <d:code>do while</d:code> loop executes once even if the loop index is more than the terminating condition in the while part.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>for Loop</d:title>
	<d:para><d:code>for</d:code> loop is the last of loops and most
	versatile. It has three parts: initialization of loop counters,
	terminating condition, and loop index modification. If you declare a
	variable in the initialization part then that variable has just loop
	scope while for <d:code>while</d:code> and <d:code>do while</d:code>
	loop indices have at least outer block scope. This makes
	<d:code>for</d:code> loop better. Consider the following example for
	computing squares of numbers:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of for statement.

#include &lt;stdio.h>

int main()
{
  for(int i=1, j=1; (i&lt;=10)||(j&lt;=10); i++, j++)
    printf("%2d * %2d = %4d\n", i, j, i*j);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>1 *  1 =    1
2 *  2 =    4
3 *  3 =    9
4 *  4 =   16
5 *  5 =   25
6 *  6 =   36
7 *  7 =   49
8 *  8 =   64
9 *  9 =   81
10 * 10 =  100</d:screen>
<d:para>Notice how various things are coming in picture here: initialization,
terminating conditions loop counter incrementation and output formatting. Here
is how you can write an infinite for loop <d:code>for(;;)</d:code>. You can
write an infinite loop anywhere if your loop index counters are not getting
incremented/decremented properly or your termination condition is
incorrect. Also, always make sure that loop indices are initialized. As an
exercise you can try to implement this program using <d:code>while</d:code> and
<d:code>do while</d:code> loop. Last line of the above output is not having
first space properly.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>break and continue Statements</d:title>
	<d:para><d:code>break</d:code> statement breaks out of innermost
	<d:code>for, do, while</d:code> and <d:code>switch</d:code>
	statements. It terminates that loop. Consider for example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of break statement.

#include &lt;stdio.h>

int main()
{

  for(int i = 0;;i +=10)
  {
    if(i>100)
      break;
    printf("%d\n", i);
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>0
10
20
30
40
50
60
70
80
90
100</d:screen>
<d:para>Notice how the <d:code>for</d:code> loop is terminated once
<d:code>i</d:code> goes beyond 100 even though there is no terminating
condition. Try the same in <d:code>while</d:code> and <d:code>do-while</d:code>
loop and produce the same result.</d:para>
<d:para><d:code>continue</d:code> statement is slightly different than
<d:code>break</d:code> in the sense that it does not stop the execution of that
loop but simply does not execute remaining instructions of that block. Consider
for example:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of continue statement.

#include &lt;stdio.h>

int main()
{

  for(int i = 0;i&lt;=100;i +=10)
  {
    if(i==50)
      continue;
    printf("%d\n", i);
  }

  return 0;
}</d:programlisting>
and the output is:<d:screen>0
10
20
30
40
60
70
80
90
100</d:screen>
<d:para>Notice how 50 is missing from output.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>typedef and return Statements</d:title>
	<d:para><d:code>typedef</d:code> statement is used to define new types
	from existing types. For example:</d:para>
<d:programlisting role="CLexer">typedef char s8;
typedef unsigned char s8;
typedef short int s16;
typedef unsigned short int u16;</d:programlisting>
<d:para>You will be seeing its usage in function pointers, structures and
unions heavily.</d:para>
<d:para><d:code>return</d:code> statement is used to return from
function. Optionally you can return a value.</d:para>
      </d:sect1>
    </d:chapter>
    <d:chapter><?dbhtml filename="ap/index.html" ?>
      <d:title>Arrays and Pointers</d:title>
      <d:para>In this chapter I am going to tell you about two very powerful
	constructs of C programming; arrays and pointers. Arrays are what they
	are; array of some data type. There can be an array of any complete
	type. You cannot create an array of any incomplete type, therefore, an
	array of type void is not allowed. There are fixed arrays and also
	variable length arrays. C99 inroduced variable length arrays before
	that arrays were only of fixed length. However, you can increase the
	capacity of a fixed sized array using <d:code>realloc()</d:code>
	function. There is single-dimensional array and then there is
	multi-dimensional array. We will first go through single-dimensional
	array then multi-dimensional.
      </d:para>
      <d:sect1>
	<d:title>Single-Dimensional Array</d:title>
	<d:para>Let us first create a basic array and then see how to access it
	elements:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of array.

#include &lt;stdio.h>

int main()
{
  const int MAX = 8;
  //An initialized array
  int a[8] = {0};
  //An initialized array to 0
  int b[MAX];

  for(int i=0; i&lt;8; i++)
  {
    b[i] = i;
    printf("b[%d]=%d\n", i, b[i]);
  }

  for(int i=0; i&lt;8; i++)
  {
    printf("a[%d]=%d\n", i, a[i]);
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>b[0]=0
b[1]=1
b[2]=2
b[3]=3
b[4]=4
b[5]=5
b[6]=6
b[7]=7
a[0]=0
a[1]=0
a[2]=0
a[3]=0
a[4]=0
a[5]=0
a[6]=0
a[7]=0</d:screen>
<d:para>Here you see array subscripting operator in action. I have not covered
this particular operator in fourth chapter so it becomes my duty to explain it
here. There are two parts here one outside subscript and another outside. The
expression which is outside will have type “const pointer to object type”. This
means that array’s base address is fixed and cannot be changes. The expression
which is inside will have integer type. The result of these two has type
“type”. We will see pointer arithmetic with binary + operator in the pointers
section which is equivalent to subscript expression.</d:para>
<d:para>As you can see array a is fixed length array while array b is a
variable length array. You are not allowed to initialize variable length arrays
at the time of declaration. Notice that array indices do not start from 1 but
0. Never ever make the mistake of thinking that array indices start from 1. You
can also initialize an array as <d:code>a[]={1, 2, 3}; or a[3]={1, 2,
3};</d:code>. The array elements would be <d:code>a[0], a[1]</d:code> and
<d:code>a[2]</d:code> in both the cases. Notice how assignment is done to
elements of second array inside for loop one by one using the bracket operator
or subscripting operator. The array elements are always in sequence in
memory. A conceptual diagram is given below for first three elements of above
array. Here 1 means first element.</d:para>
      <d:figure>
        <d:title>An Array's Memory Diagram</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="images/arraydia.png"/>
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
<d:para>Array elements are always(not always but most commonly. It is so coomon
that I have used always.) accessed using their indices so order of retrieval is
<mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mtext>O(1)</mml:mtext>
</mml:math>.(This is known as big-O notation. You can find it in any Data
Structure and Algorithm book. If you wait you can find in my book as well but
you should not. :-)) The above program will not compile using old compilers
which do not support C99 standard like Turbo C++. Also, you may require to pass
the flag <d:code>-std=c99</d:code> to some versions of gcc. For variable length
arrays it is not necessary to declare the size in advance. Even, input to
program from other sources will do.</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of array.

#include &lt;stdio.h>

int main()
{
  int i=0;

  printf("Enter the value of i:\n");
  scanf("%d\n", &amp;i);

  char c[i];

  printf("Enter a string which contains one less no. of chars than i:\n");
  gets(c);
  puts(c);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Enter the value of i:
6
shiv
Enter a string which contains one less no. of chars than i:
shiv
shiv</d:screen>
<d:para>As you can see variable length array should be declared after the size
is known otherwise you may see strange output even though it is not compilation
error. For example you could have declaraed array immediately after
<d:code>i</d:code> but you will get some garbage output. The reason for this is
that at that point of time i contains garbage value. Also, note that array
indices are integers. Floating-point numbers or variables cannot be
indices.</d:para>
<d:para>Let us say you are writing a big piece of code and array is declared
somewhere and you want to know how many elemnets you can fill in the array or
what is the maximum size of array then you can use the following
program:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of array.

#include &lt;stdio.h>

int main()
{
  float f[10]={0.0};

  printf("Size of array f is %d.\n", sizeof(f)/sizeof(float));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Size of array f is 10.</d:screen>
<d:para>Now an experienced programmer may ask that if we can know the size of
array then why we do not have something like out of bounds exception of Java in
C. My answer to that is C was written in 1970 and Java in 1990. For example,
there are certain compilers with flags which help you detect this at
runtime.</d:para>
<d:para>Feel free to experiment with arrays. Do whatever you like. Remember the
more you will experiment the more you will learn. There are various ways in
which you can define character arrays. For example, <d:code>char c[6]={'h',
'e', 'l', 'l', 'o', '\0'};</d:code>. Remember, you must terminate a character
array with a null terminator. Another way to define the same is: <d:code>char
str[6] = "hello";</d:code>. In this example you do not need to add
'<d:code>\0</d:code>' explicitly as it is added automatically. Also, 6 is
optional here if you want you can ommit that. Of course second example is more
preferable. Note that if you declare an array of size m and data type size of
array is n bytes then the array will consume m*n bytes no matter what; even
when you are not using those bytes. Note that all these arrays are on stack
memory area. We will see how to allocate array on heap memory area once we have
studied pointers.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Multi-Dimensional Array</d:title>
	<d:para>Arrays can be n-dmensional. There is no limit on
	dimensions. You can allocate as much as your memory allows. We will
	begin with two-dimensional array. A two-dimensional array looks like a
	matrix. Say a two-dimensional array has m as one dimension and n as
	second diemnsion. Then total no. of elements will be m*n and size
	occupied is m*m*size of data type of array. There are various ways to
	initialize a two-dimensional array. Consider the following
	example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of two-dimensional array.

#include &lt;stdio.h>

int main()
{
  int a[2][2] = {{1,2},{3,4}};
  int b[2][2] = {1,2,3,4};

  //iterating over array
  for(int i=0;i&lt;2;i++)
  {
    for(int j=0;j&lt;2;j++)
      printf("%d ", a[i][j]);
    printf("\n");
  }
  for(int i=0;i&lt;2;i++)
  {
    for(int j=0;j&lt;2;j++)
      printf("%d ", b[i][j]);
    printf("\n");
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>1 2
3 4
1 2
3 4</d:screen>
<d:para>Same way you can have multi-dimensional array. I leave it up to you to
find applications of different arrays. For now, try multiplying two matrices,
doing a transpose, inverse of a matrix and printing a yearly calenday for any
year for example. With the current information given to you, you should be able
to do all these easily. As shown for array a it is not really a single array
but an array of array. How we can read this is array a has two arrays each of
which have two integers.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Pointers</d:title>
	<d:para>A pointer can store an address. A pointer of some type can
	store address of that type and a pointer to void can store address of
	any type.</d:para>
	<d:para>These are very interesting; considered to be one of the most
	powerful in the hands of capable programmer and most dangerous tool in
	the hands of an ignorant programmer. There are four standard library
	functions associated with them. All these are declared in <d:emphasis
	role="bold">stdlib.h</d:emphasis> which is part of standard c
	library. The functions are: <d:code>malloc(), calloc(),
	realloc()</d:code> and <d:code>free()</d:code>. Following is the
	contents of man pages verbatim,later in the program you can go to
	opengroup links as well. First signatures:</d:para>
<d:programlisting role="CLexer">void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);</d:programlisting>
<d:para>here <d:code>size_t</d:code> is the unsigned integer type of the result
of the sizeof operator. It is defined in <d:code>stddef.h</d:code>. And now
descriptions:</d:para>
<d:para><d:code>calloc()</d:code> allocates memory for an array of
<d:code>nmemb</d:code> elements of <d:code>size</d:code> bytes each and returns
a pointer to the allocated memory. The memory is set to zero. If
<d:code>nmemb</d:code> or size is 0, then <d:code>calloc()</d:code> returns
either <d:code>NULL</d:code>, or a unique pointer value that can later be
successfully passed to <d:code>free()</d:code>.</d:para>
<d:para><d:code>malloc()</d:code> allocates <d:code>size</d:code> bytes and
returns a pointer to the allocated memory. The memory is not cleared. If size
is 0, then <d:code>malloc()</d:code> returns either <d:code>NULL</d:code>, or a
unique pointer value that can later be successfully passed to
<d:code>free()</d:code>.</d:para>
<d:para><d:code>free()</d:code> frees the memory space pointed to by
<d:code>ptr</d:code>, which must have been returned by a previous call to
<d:code>malloc(), calloc()</d:code> or <d:code>realloc()</d:code>. Otherwise,
or if <d:code>free(ptr)</d:code> has already been called before, undefined
behavior occurs. If <d:code>ptr</d:code> is <d:code>NULL</d:code>, no operation
is performed.</d:para>
<d:para><d:code>realloc()</d:code> changes the size of the memory block pointed
to by <d:code>ptr</d:code> to <d:code>size</d:code> bytes. The contents will be
unchanged to the minimum of the old and new sizes; newly allocated memory will
be uninitialized. If <d:code>ptr</d:code> is <d:code>NULL</d:code>, then the
call is equivalent to <d:code>malloc(size)</d:code>, for all values of
<d:code>size</d:code>; if <d:code>size</d:code> is equal to zero, and
<d:code>ptr</d:code> is not <d:code>NULL</d:code>, then the call is equivalent
to <d:code>free(ptr)</d:code>. Unless <d:code>ptr</d:code> is
<d:code>NULL</d:code>, it must have been returned by an earlier call to
<d:code>malloc(), calloc()</d:code> or <d:code>realloc()</d:code>. If the area
pointed to was moved, a <d:code>free(ptr)</d:code> is done.</d:para>
<d:para>Let us consider a program:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int *p = NULL;

  p = (int*)malloc(sizeof(int)*8);

  for(int i=0;i&lt;8;i++)
  {
    *(p+i)=i;
    printf("Content at %dth location is %d.\n", i, *(p+i));
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Content at 0th location is 0.
Content at 1th location is 1.
Content at 2th location is 2.
Content at 3th location is 3.
Content at 4th location is 4.
Content at 5th location is 5.
Content at 6th location is 6.
Content at 7th location is 7.</d:screen>
<d:para>There are various ways to declare a simple pointer and initialize
it. For example:</d:para>
<d:programlisting role="CLexer">char *c;                           //Only declaration no initialization
c = NULL;                          //Initialization
void *p = NULL;                    //declaration and initialization
void *q = malloc(sizeof(void)*10); //Declare and allocate memory for 10</d:programlisting>
<d:para>On line number 15 and 16 you are seeing pointer arithmetic in previous
program. Consider array a declared in the first example. We could have iterated
in that example like <d:code>*(a+i)</d:code>.</d:para>
<d:para>A postfix expression followed by an expression in square brackets
<d:code>[]</d:code> is a subscripted designation of an element of an array
object. The definition of the subscript operator <d:code>[]</d:code> is that
<d:code>E1[E2]</d:code> is identical to
<d:code>(*((E1)+(E2)))</d:code>. Because of the conversion rules that apply to
the binary <d:code>+</d:code> operator, if <d:code>E1</d:code> is an array
object (equivalently, a pointer to the initial element of an array object) and
<d:code>E2</d:code> is an integer, <d:code>E1[E2]</d:code> designates the
<d:code>E2</d:code>-th element of of <d:code>E1</d:code> (counting from
zero).</d:para>
<d:para>I had not covered some portion of additive operators in the chapter of
operators and expression deliberately as I wanted to discuss them here. When an
expression that has integer type is added to or subtracted from a pointer, the
result has the type of the pointer operand. If the pointer operand points to an
element of an array object, and the array is large enough, the result points to
an element offset from the original element such that the difference of the
subscripts of the resulting and original array elements equals the integer
expression. In other words, if the expression <d:code>P</d:code> points to the
<d:code>i</d:code>-th element of an array object, the expressions
<d:code>(P)+N</d:code> (equivalently, <d:code>N+(P)</d:code>) and
<d:code>(P)-N</d:code> (where <d:code>N</d:code> has the value
<d:code>n</d:code>) point to, respectively, the <d:code>i+n</d:code>-th and
<d:code>i-n</d:code>-th elements of the array object, provided they
exist. Moreover, if the expression <d:code>P</d:code> points to the last
element of an array object, the expression <d:code>(P)+1</d:code> points one
past the last element of the array object, and if the expression
<d:code>Q</d:code> points one past the last element of an array object, the
expression <d:code>(Q)-1</d:code> points to the last element of the array
object. If both the pointer operand and the result point to elements of the
same array object, or one past the last element of the array object, the
evaluation will not produce an overflow; otherwise, the behavior is
undefined. If the result points one past the last element of the array object,
it will not be used as the operand of a unary <d:code>*</d:code> operator that
is evaluated.</d:para>
<d:para>When two pointers are subtracted, both shall point to elements of the
same array object, or one past the last element of the array object; the result
is the difference of the subscripts of the two array elements. The size of the
result is implementation-defined, and its type (a signed integer type) is
<d:code>ptrdiff_t</d:code> defined in the &lt;stddef.h> header. If the result
is not representable in an object of that type, the behavior is undefined. In
other words, if the expressions <d:code>P</d:code> and <d:code>Q</d:code> point
to, respectively, the <d:code>i</d:code>-th and <d:code>j</d:code>-th elements
of an array object, the expression <d:code>(P)-(Q)</d:code> has the value
<d:code>i-j</d:code> provided the value fits in an object of type
<d:code>ptrdiff_t</d:code>. Moreover, if the expression <d:code>P</d:code>
points either to an element of an array object or one past the last element of
an array object, and the expression <d:code>Q</d:code> points to the last
element of the same array object, the expression <d:code>((Q)+1)-(P)</d:code>
has the same value as <d:code>((Q)-(P))+1</d:code> and as
<d:code>-((P)-((Q)+1))</d:code>, and has the value zero if the expression
<d:code>P</d:code> points one past the last element of the array object, even
though the expression <d:code>(Q)+1</d:code> does not point to an element of
the array object.</d:para>
<d:para>You can also apply increment and decrement operators on pointers. I
will show you a reimplementation of previos program using increment
operators:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int *p = NULL;

  p = (int*)malloc(sizeof(int)*8);
  int *q = p;

  for(int i=0;i&lt;8;i++)
  {
    *(p+i)=i;
    printf("Content at %dth location is %d.\n", i, *(q++));
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Content at 0th location is 0.
Content at 1th location is 1.
Content at 2th location is 2.
Content at 3th location is 3.
Content at 4th location is 4.
Content at 5th location is 5.
Content at 6th location is 6.
Content at 7th location is 7.</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>Address and Indirection Operators</d:title>
	<d:para>As is the case with subscript operator and pointer arithmetic
	in the fourth chapter that I have delayed these two as well for I
	wanted to put them here. Whenever you declare a plain variable you have
	an address associated with it and that variable is an lvalue. Just to
	repeat an lvalue is a value whose address can be taken. To take the
	address of an lvalue you use the address operator which is &amp;. Now a
	pointer points to address of any value as we know so we can use address
	operator to get the address and use a pointer to store. There are
	several usage of storing an address. Most notable of those is
	pass-by-address which we will see in next chapter which will deal with
	functions. Let us say we take address of a variable and assign that to
	a pointer. Then if we change the value of the memory pointed to by the
	pointer then the variable whose address has been taken will get updated
	with this new value. Consider for example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int  i = 8;
  int *p = &amp;i;

  *p = 7;

  printf("i=%d *p=%d\n", i, *p);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>i=7 *p=7</d:screen>
<d:para>So you see the power of pointers that if you have an address you can
modify its contents. This is exacly what <d:code>scanf()</d:code> does. The
dereference operator or indirection operator or aterisk (<d:code>*</d:code>)
gives you value at address pointed to by pointer <d:code>o</d:code>. However,
if you want to change address of some varible like that ofi by doing something
like &amp;i=&amp;someOthervar; you cannot do that because address is not an
lvalue. However, you can pass address of a pointer variable to some other
function and use it using pointer to pointer notation which I will show you in
next chapter. As I have shown pointers are kind of equivalent to array except
the fact that they are on heap and sizeof operator will not work on
them. Consider this example:</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int  a[4] = {1,2,3,4};
  int* p    = a;
  int* q    = (int*)calloc(10, 4);

  for(int i=0; i&lt;4; i++)
    printf("i=%d *p=%d\n", i, *(p+i));

  printf("Size of a=%d\n", sizeof(a));
  printf("Size of p=%d\n", sizeof(p));
  printf("Size of q=%d\n", sizeof(q));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>i=0 *p=1
i=1 *p=2
i=2 *p=3
i=3 *p=4
Size of a=16
Size of p=4
Size of q=4</d:screen>
<d:para>Here <d:code>p</d:code> acts as pointer to array. You can have a
pointer to any kind of array. You can point to any element of array because
array elements are lvalues whose addresses can be taken and to initialize a
pointer alll you need is an address.</d:para>
<d:caution><d:title>Advice</d:title><d:para>Complex pointer arithmetic is best avoided. Be very
thoughtful that if you really really need it. Use loops to iterate
arrays. Multiple levels of indirection is also bad. Typically I have not seen
more than pointers to pointers. Now we will see array of
pointers.</d:para></d:caution> 
      </d:sect1>
      <d:sect1>
	<d:title>Arrays of Pointers</d:title>
	<d:para>Pointers are just like ordinary variables so we can as well create
	array of pointers. Consider following for example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  char* strArray[2]={"Hello", "Universe!"};

  for(int i=0; i&lt;2; i++)
    printf("%s\n", strArray[i]);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Hello
Universe!</d:screen>
<d:para>Note how the length of two array elements are different as they are
pointers. Let us do a more complex example.</d:para>
<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int* intArray[2];

  intArray[0] = (int*)calloc(3, sizeof(int));
  intArray[1] = (int*)calloc(2, sizeof(int));

  *intArray[0]     = 4;
  *(intArray[0]+1) = 5;
  *(intArray[0]+2) = 6;


  *intArray[1]     = 1;
  *(intArray[1]+1) = 2;

  for(int i=0; i&lt;3; i++)
  {
    printf("Memory location=%p Content=%d\n", intArray[0]+i, *(intArray[0]+i));
  }

  for(int i=0; i&lt;2; i++)
  {
    printf("Memory location=%p Content=%d\n", intArray[1]+i, *(intArray[1]+i));
  }

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Memory location=0x87d1008 Content=4
Memory location=0x87d100c Content=5
Memory location=0x87d1010 Content=6
Memory location=0x87d1018 Content=1
Memory location=0x87d101c Content=2</d:screen>
<d:para>Note missing four bytes between 6 and 1. Memory locations may be
different on your system. But see how messy pointer syntax can go even with
such simple code. Array to pointers are useful for containing variables of
dynamic size of same type.</d:para>
<d:para>Pointers to pointers are same as array of pointers. The only difference
is that you can dynamically modify the number of elements.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>Pointers of Pointers</d:title>
	<d:para>Consider the following example:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int** intPtr;

  intPtr = (int**)malloc(sizeof(sizeof(int*)*2));

  *intPtr = (int*)malloc(sizeof(int)*3);
  *(intPtr+1) = (int*)malloc(sizeof(int)*4);

  **intPtr     = 1;
  *(*intPtr+1) = 2;
  *(*intPtr+2) = 7;


  **(intPtr+1)      = 3;
  *(*(intPtr+1)+1)  = 5;
  *(*(intPtr+1)+2)  = 9;
  *(*(intPtr+1)+3)  = 11;

  for(int i=0; i&lt;3; i++)
    printf("Memory location=%p content=%d\n", *intPtr+i, *(*intPtr+i));

  for(int i=0; i&lt;4; i++)
    printf("Memory location=%p content=%d\n", *(intPtr+1)+i, *(*(intPtr+1)+i));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Memory location=0x9947018 content=1
Memory location=0x994701c content=2
Memory location=0x9947020 content=7
Memory location=0x9947028 content=3
Memory location=0x994702c content=5
Memory location=0x9947030 content=9
Memory location=0x9947034 content=11</d:screen>
<d:para>Again memory location may change on your system. As you can see how
things can get messy with pointers. Believe me you will hate this. Also, I do
not see any reason to use more than two levels of indirection. So you get the
idea. If you need dynamic no. of elements with dynamic content you are going to
use pointers to pointers.</d:para>
      </d:sect1>
      <d:sect1>
	<d:title>realloc() Function</d:title>
	<d:para>Once <d:code>malloc()</d:code> and <d:code>calloc()</d:code>
	allocate some memory you have that certain amount of memory available
	to you. When you have an array you have some memory but what if you
	want more later. <d:code>reallloc()</d:code> comes to rescue you. Here
	is a sample program:</d:para>
	<d:programlisting role="CLexer">//Author: Shiv S. Dayal
//Description : Demo of pointer.

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int *p = (int*)malloc(sizeof(int)*2);

  *p     = 5;
  *(p+1) = 7;

  printf("Original 1st element=%d\n", *p);
  printf("Original 2nd element=%d\n", *(p+1));

  p = (int*)realloc(p, sizeof(int)*4);

  *(p+2) = 9;
  *(p+3) = 11;

  printf("New 1st element=%d\n", *p);
  printf("New 2nd element=%d\n", *(p+1));
  printf("New 3rd element=%d\n", *(p+2));
  printf("New 4th element=%d\n", *(p+3));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Original 1st element=5
Original 2nd element=7
New 1st element=5
New 2nd element=7
New 3rd element=9
New 4th element=11</d:screen>
      </d:sect1>
      <d:sect1>
	<d:title>free() Function</d:title>
	<d:para>Whatever program we have written in this chapter related to
	dynamic memory allocation using <d:code>malloc()</d:code> etc are very
	bad code just because we are not releasing memory properly. Any call to
	memory allocation functions have to be matched with a corresponding
	<d:code>free()</d:code> call. The reason for this is that when all
	pointers to a memory area are lost and that memory is not freed then
	operating system cannot recycle that memory. In case of servers or long
	running processes this may eat up all the physical RAM and virtual
	memory and eventually freeze the system. To guard against such events
	you must macth all allocation calls with deallocation calls so that
	operating system can reclaim the freed memmory.</d:para> 
	<d:para>You must heed this warning given here with all of your
	focus. You got to handle heap that is dynamically allocated memory
	yourself. You allocate and you free it. If you miss you have a memory
	leak.</d:para>
	<d:warning><d:title>Warning</d:title>
	<d:para>You must free all memory you allocate.</d:para></d:warning>
      </d:sect1>
      <d:sect1>
	<d:title>Constness</d:title>
	<d:para>To make anything constant you need to associate const keyword
	with it. For example, <d:code>const int i; const float
	f;</d:code>. However, with pointers in picture scenarios change
	compared to two simple previous examples. When pointers are made
	constant there are two elements. First is the pointer itself and second
	is the value pointed to. Consider for example:</d:para>
	<d:programlisting role="CLexer">const int* i;  //constant pointer data is not
int* const i;  //constant data pointer is not
const int* const i; //both are const</d:programlisting>
<d:para>The way to read it is you draw a vertical line where asterisk(*) is
there and the value associated with const is constant. Whenever you need use a
constant freely. Try to use constants more and more. Also, prefre them to
following:</d:para>
<d:programlisting role="CLexer">#define MAX 10</d:programlisting>
<d:para>As told and shown to you it will replace <d:code>MAX</d:code> with 10
in the file everywhere without any concern of type-safety. Also, it does not
enter in the symbol table so while debugging you will not see
<d:code>MAX</d:code> anywhere. So instead you should use something
like:</d:para>
<d:programlisting role="CLexer">const int MAX=10;</d:programlisting>
<d:para>I will also like to say something about volatile variables. Beginners
are usually convinced that volatile variables cannot be declraed as const. Let
me iterate the definitions once again. A const variable cannot be modifed by
the program itself. A volatile variable can be modified by sources other than
the program itself. Hence, a const volatile variable cannot be modified by the
program but other sources can still modify it.</d:para>
      </d:sect1>
    </d:chapter>
    <xi:include href="functions.xml"/>
    <xi:include href="su.xml"/>
    <xi:include href="macros.xml"/>
    <xi:include href="std.xml"/>
    <d:index>
    <d:title>Index</d:title>
  </d:index>
</d:book>
