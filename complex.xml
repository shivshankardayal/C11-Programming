<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
    <?dbhtml filename="complex/index.html" ?>
    <d:title>Complex arithmetic &amp;lt;complex.h></d:title>
    <d:sect1>
      <d:title>Introduction</d:title>
      <d:para>The header <d:code>&amp;lt;complex.h></d:code> defines macros and
      declares functions that support complex arithmetic. Each synopsis
      specifies a family of functions consisting of a principal function with
      one or more <d:code>double complex</d:code> parameters and a
      <d:code>double complex</d:code> or <d:code>double</d:code> 
      return value; and other functions with the same name but with f and l
      suffixes which are corresponding functions with <d:code>float</d:code>
      and <d:code>long double</d:code> parameters and return values.</d:para>
      <d:para>The macro complex expands to <d:code>_Complex</d:code>; the macro
      <d:code>_Complex_I</d:code> expands to a constant expression of type
      <d:code>const float _Complex</d:code>, with the value of the imaginary
      unit.<d:footnote><d:para>The imaginary unit is a number
      <d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>i</mml:mi>
</mml:math></d:inlineequation> such that <d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:msup>
    <mml:mi>i</mml:mi>
    <mml:mn>2</mml:mn>
  </mml:msup>
  <mml:mo>=</mml:mo>
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mn>1</mml:mn>
</mml:math></d:inlineequation></d:para></d:footnote>.</d:para>
<d:para>The macro <d:code>I</d:code> expands to
<d:code>_Complex_I</d:code>.</d:para>
<d:para>Notwithstanding the provisions of reserved identifiers, a program may
undefine and perhaps then redefine the macros <d:code>complex</d:code> and
<d:code>I</d:code>.</d:para>
<d:para><d:emphasis role="bold">Forward references:</d:emphasis> IEC
60559-compatible complex arithmetic (annex G).</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>Conventions</d:title>
      <d:para>Values are interpreted as radians, not degrees. An implementation
      may set errno but is not required to.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>Branch Cuts</d:title>
      <d:para>Some of the functions below have branch cuts, across which the
      function is discontinuous. For implementations with a signed zero
      (including all IEC 60559 implementations) that follow the specifications
      of annex G, the sign of zero distinguishes one side of a cut from another
      so the function is continuous (except for format limitations) as the cut
      is approached from either side. For example, for the square root
      function, which has a branch cut along the negative real axis, the top of
      the cut, with imaginary part +0, maps to the positive imaginary axis, and
      the bottom of the cut, with imaginary part -0, maps to the negative
      imaginary axis.</d:para>
      <d:para>Implementations that do not support a signed zero (see annex F)
      cannot distinguish the sides of branch cuts. These implementations shall
      map a cut so the function is continuous as the cut is approached coming
      around the finite endpoint of the cut in a counter clockwise
      direction. (Branch cuts for the functions specified here have just one
      finite endpoint.) For example, for the square root function, coming
      counter clockwise around the finite endpoint of the cut along the
      negative real axis approaches the cut from above, so the cut maps to the
      positive imaginary axis.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>The CX_LIMITED_RANGE Pragma</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;complex.h>
#pragma STDC CX_LIMITED_RANGE on-off-switch</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The usual mathematical formulas for complex multiply, divide, and
absolute value are problematic because of their treatment of infinities and
because of undue overflow and underflow. The <d:code>CX_LIMITED_RANGE</d:code>
pragma can be used to inform the implementation that (where the state is “on”)
the usual mathematical formulas are acceptable.<d:footnote><d:para>The purpose
of the pragma is to allow the implementation to use the
formulas.</d:para></d:footnote> The pragma can occur either outside external
declarations or preceding all explicit declarations and statements inside a
compound statement. When outside external declarations, the pragma takes effect
from its occurrence until another <d:code>CX_LIMITED_RANGE</d:code> pragma is
encountered, or until the end of the translation unit. When inside a compound
statement, the pragma takes effect from its occurrence until another
<d:code>CX_LIMITED_RANGE</d:code> pragma is encountered (including within a
nested compound statement), or until the end of the compound statement; at the
end of a compound statement the state for the pragma is restored to its
condition just before the compound statement. If this pragma is used in any
other context, the behavior is undefined. The default state for the pragma is
“off”.</d:para>
</d:sect1>
<d:sect1>
  <d:title>Trigonometric functions</d:title>
  <d:sect2>
    <d:title>The cscos functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Descriptiotn</d:emphasis></d:para>
<d:para>The <d:code>cacos</d:code> functions compute the complex arc cosine of
<d:code>z</d:code>, with branch cuts outside the interval <d:code>[-1,
+1]</d:code> along the real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cacos</d:code> functions return the complex arc cosine value, in the range
of a strip mathematically unbounded along the imaginary axis and in the
interval [0, <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm</d:code>.</d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cacos()</d:code> function calculates the complex arc cosine
of <d:code>z</d:code>. If <d:code>y = cacos(z)</d:code>, then <d:code>z =
ccos(y)</d:code>. The real part of <d:code>y</d:code> is chosen in the interval
[0, <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>].</d:para>
<d:para>One has:</d:para>
<d:screen>cacos(z) = -i * clog(z + i * csqrt(1 - z * z))</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacos(z)]=%lf and Im[cacos(z)]=%lf\n", creal(cacos(z)), cimag(cacos(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like <d:code>clang filename.c -lm</d:code>. Execution gives
following output:</d:para>
<d:screen>Re[cacos(z)]=0.936812 and Im[cacos(z)]=-2.305509</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The casin functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>casin</d:code> functions compute the complex arc sine of
<d:code>z</d:code>, with branch cuts outside the interval [-1, +1] along the
real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions return the complex arc sine value, in
the range of a strip mathematically unbounded along the imaginary axis and in
the interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:screen>csin(z) = (exp(i * z) - exp(-i * z)) / (2 * i)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacsin(z)]=%lf and Im[cacsin(z)]=%lf\n", creal(casin(z)), cimag(casin(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like <d:code>clang filename.c -lm</d:code>. Execution gives
following output:</d:para>
<d:screen>Re[cacsin(z)]=0.633984 and Im[cacsin(z)]=2.305509</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The cstan functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>catan</d:code> functions compute the complex arc tangent of
<d:code>z</d:code>, with branch cuts outside the interval [-i, +i] along the
imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>catan</d:code> functions return the complex arc tangent
value, in the range 
of a strip mathematically unbounded along the imaginary axis and in the
interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML"> 
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm</d:code>.</d:para>
<d:para>The <d:code>catan()</d:code> function calculates the complex arc tangent of <d:code>z</d:code>. If <d:code>y = catan(z)</d:code>, then <d:code>z = ctan(y)</d:code>. The real part of <d:code>y</d:code> is chosen in the interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>].</d:para>
<d:para>One has:</d:para>
<d:screen>catan(z) = (clog(1 + i * z) - clog(1 - i * z)) / (2 * i)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cactan(z)]=%lf and Im[cactan(z)]=%lf\n", creal(catan(z)), cimag(catan(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like . Execution<d:code>clang filename.c -lm</d:code> gives
following output:</d:para>
<d:screen>Re[cactan(z)]=1.448307 and Im[cactan(z)]=0.158997</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The ccos functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ccos</d:code> functions compute the complex cosine of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ccos</d:code> functions return the complex cosine
value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm</d:code>.</d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The complex cosine function is defined as:</d:para>
<d:screen>ccos(z) = (exp(i * z) + exp(-i * z)) / 2</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ccos(z)]=%lf and Im[ccos(z)]=%lf\n", creal(ccos(z)), cimag(ccos(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ccos(z)]=-27.034946 and Im[ccos(z)]=-3.851153</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The csin functions</d:title>
    <d:para>Synopsis</d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions compute the complex sine of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Desciption</d:emphasis></d:para>
<d:para>The <d:code>csin</d:code> functions return the complex sine
value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm</d:code>.</d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The complex sine function is defined as:</d:para>
<d:screen>csin(z) = (exp(i * z) - exp(-i * z)) / (2 * i)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[csin(z)]=%lf and Im[csin(z)]=%lf\n", creal(csin(z)), cimag(csin(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[csin(z)]=3.853738 and Im[csin(z)]=-27.01681</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The ctan functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ctan</d:code> functions compute the complex tangent of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ctan</d:code> functions return the complex tangent
value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The complex tangent function is defined as:</d:para>
<d:screen>ctan(z) = csin(z) / ccos(z)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ctann(z)]=%lf and Im[ctan(z)]=%lf\n", creal(ctan(z)), cimag(ctan(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ctann(z)]=-0.000187 and Im[ctan(z)]=0.999356</d:screen>
  </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Hyperbolic functions</d:title>
      <d:sect2>
	<d:title>The cscosh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cacosh</d:code> functions compute the complex arc
hyperbolic cosine of <d:code>z</d:code>, with a branch cut at values less than
1 along the real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cacosh</d:code> functions return the complex arc hyperbolic
cosine value, in the range of a half-strip of non-negative values along the
real axis and in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cacosh()</d:code> function calculates the complex arc
hyperpolic cosine of <d:code>z</d:code>. If <d:code>y = cacosh(z)</d:code>,
then <d:code>z = ccosh(y)</d:code>. The imaginary part of <d:code>y</d:code> is
chosen in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>]. The real part of <d:code>y</d:code> is chosen
nonnegative.</d:para>
<d:para>One has:</d:para>
<d:screen>cacosh(z) = 2 * clog(csqrt((z + 1) / 2) + csqrt((z - 1) /
2))</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacosh(z)]=%lf and Im[cacosh(z)]=%lf\n", creal(cacosh(z)), cimag(cacosh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cacosh(z)]=2.305509 and Im[cacosh(z)]=0.93681</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The casinh function</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>casinh</d:code> functions compute the complex arc
hyperbolic sine of <d:code></d:code>, with branch cuts outside the interval
[-i, +i] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>casinh</d:code> functions return the complex arc hyperbolic
sine value, in the range of a strip mathematically unbounded along the real
axis and in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>casinh()</d:code> function calculates the complex arc
hyperbolic sine of <d:code>z</d:code>. If <d:code></d:code>, then <d:code>z =
csinh(y)</d:code>. The imaginary part of <d:code>y</d:code> is chosen in the
interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>].</d:para>
<d:para>One has:</d:para>
<d:screen>casinh(z) = clog(z + csqrt(z * z + 1))</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[casinh(z)]=%lf and Im[casinh(z)]=%lf\n", creal(casinh(z)), cimag(casinh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[casinh(z)]=2.299914 and Im[casinh(z)]=0.917617</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title></d:title>
      </d:sect2>
    </d:sect1>
</d:chapter>
