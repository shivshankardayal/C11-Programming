<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
    <?dbhtml filename="fenv/index.html" ?>
    <d:title>Floating-point environment &amp;lt;fenv.h></d:title>
    <d:para>The header &amp;lt;fenv.h> declares two types and several macros
    and functions to provide access to the floating-point environment. The
    floating-point environment refers collectively to any floating-point status
    flags and control modes supported by the
    implementation.<d:footnote><d:para>This header is designed to support the
    floating-point exception status flags and directed-rounding control modes
    required by IEC 60559, and other similar floating-point state
    information. Also it is designed to facilitate code portability among all
    systems.</d:para></d:footnote> A floating-point status flag is a system
    variable whose value is set (but never cleared) when a floating-point
    exception is raised, which occurs as a side effect of exceptional
    floating-point arithmetic to provide auxiliary information. A
    floating-point control mode is a system variable whose value may be set by
    the user to affect the subsequent behavior of floating-point
    arithmetic.</d:para>
    <d:para>Certain programming conventions support the intended model of use
    for the floating-point environment:<d:footnote><d:para>With these
    conventions, a programmer can safely assume default floating-point control
    modes (or be unaware of them). The responsibilities associated with
    accessing the floating-point environment fall on the programmer or program
    that does so explicitly.</d:para></d:footnote></d:para>
    <d:itemizedlist>
      <d:listitem>
	<d:para>a function call does not alter its caller's floating-point
	control modes, clear its caller’s floating-point status flags, nor
	depend on the state of its caller’s floating-point status flags unless
	the function is so documented;</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>a function call is assumed to require default floating-point
	control modes, unless its documentation promises otherwise;</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>a function call is assumed to have the potential for raising
	floating-point exceptions, unless its documentation promises
	otherwise.</d:para>
      </d:listitem>
    </d:itemizedlist>
    <d:para>The type <d:code>fenv_t</d:code> represents the entire
    floating-point environment.</d:para>
    <d:para>The type <d:code>fexcept_t</d:code> represents the floating-point
    status flags collectively, including any status the implementation
    associates with the flags.</d:para>
    <d:para>Each of the macros:</d:para>
    <d:blockquote><d:para>FE_DIVBYZERO FE_INEXACT FE_INVALID FE_OVERFLOW FE_UNDERFLOW</d:para></d:blockquote>
<d:para>is defined if and only if the implementation supports the
floating-point exception by means of the functions in
13.6.2.<d:footnote><d:para>The implementation supports an exception if there
are circumstances where a call to at least one of the functions in 13.6.2,
using the macro as the appropriate argument, will succeed. It is not necessary
for all the functions to succeed all the time.</d:para></d:footnote> Additional
implementation-defined floating-point exceptions, with macro definitions
beginning with <d:code>FE_</d:code> and an uppercase letter, may also be
specified by the implementation. The defined macros expand to integer constant
expressions with values such that bitwise <d:code>OR</d:code>s of all
combinations of the macros result in distinct values.</d:para>
<d:para>The macro <d:code>FE_ALL_EXCEPT</d:code> is simply the bitwise
<d:code>OR</d:code> of all floating-point exception macros defined by the
implementation. If no such macros are defined, <d:code>FE_ALL_EXCEPT</d:code>
shall be defined as 0.</d:para>
<d:para>Each of the macros:</d:para>
<d:screen>FE_DOWNWARD
FE_TONEAREST
FE_TOWARDZERO
FE_UPWARD</d:screen>
<d:para>is defined if and only if the implementation supports getting and
setting the represented rounding direction by means of the fegetround and
fesetround functions. Additional implementation-defined rounding directions,
with macro definitions beginning with FE_ and an uppercase letter, may also be
specified by the implementation. The defined macros expand to integer constant
expressions whose values are distinct nonnegative
values.<d:footnote><d:para>Even though the rounding direction macros may expand
to constants corresponding to the values of <d:code>FLT_ROUNDS</d:code>, they
are not required to do so.</d:para></d:footnote></d:para>
<d:para>The macro <d:code>FE_DFL_ENV</d:code> represents the default
floating-point environment - the one installed at program startup - and has
type "pointer to const-qualified <d:code>fenv_t</d:code>”. It can be used as an
argument to &amp;lt;fenv.h> functions that manage the floating-point
environment.</d:para>
<d:para>Additional implementation-defined environments, with macro definitions
beginning with <d:code>FE_</d:code> and an uppercase letter, and having type
"pointer to const-qualified <d:code>fenv_t</d:code>", may also be specified by
the implementation.</d:para>
<d:sect1>
  <d:title>The FENV_ACCESS pragma</d:title>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;fenv.h>
#pragma STDC FENV_ACCESS on-off-switch</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>FENV_ACCESS</d:code> pragma provides a means to inform the
implementation when a program might access the floating-point environment to
test floating-point status flags or run under non-default floating-point
control modes.<d:footnote><d:para>The purpose of the
<d:code>FENV_ACCESS</d:code> pragma is to allow certain optimizations that
could subvert flag tests and mode changes (e.g., global common subexpression
elimination, code motion, and constant folding). In general, if the state of
<d:code>FENV_ACCESS</d:code> is "off", the translator can assume that default
modes are in effect and the flags are not tested.</d:para></d:footnote> The
pragma shall occur either outside external declarations or preceding all
explicit declarations and statements inside a compound statement. When outside
external declarations, the pragma takes effect from its occurrence until
another <d:code>FENV_ACCESS</d:code>pragma is encountered, or until the end of
the translation unit. When inside a compound statement, the pragma takes effect
from its occurrence until another <d:code>FENV_ACCESS</d:code> pragma is
encountered (including within a nested compound statement), or until the end of
the compound statement; at the end of a compound statement the state for the
pragma is restored to its condition just before the compound statement. If this
pragma is used in any other context, the behavior is undefined. If part of a
program tests floating-point status flags, sets floating-point control modes,
or runs under non-default mode settings, but was translated with the state for
the <d:code>FENV_ACCESS</d:code> pragma "off", the behavior is undefined. The
default state ("on" or "off") for the pragma is implementation-defined. (When
execution passes from a part of the program translated with
<d:code>FENV_ACCESS</d:code> "off" to a part translated with
<d:code>FENV_ACCESS</d:code> "on", the state of the floating-point status flags
is unspecified and the floating-point control modes have their default
settings.)</d:para>
</d:sect1>
</d:chapter>
