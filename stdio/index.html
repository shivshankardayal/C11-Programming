<html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>Chapter 31. Input/Output &lt;stdio.h></title><link href="../../css/style.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL-NS Stylesheets V1.76.1" name="generator"/><link href="../index.html" rel="home" title="C Programming with C99"/><link href="../index.html" rel="up" title="C Programming with C99"/><link href="../stdint/index.html" rel="prev" title="Chapter 30. Integer types &lt;stdint.h>"/><link href="../ix01.html" rel="next" title="Index"/><script src="../css/analytics.js" type="text/javascript" xmlns:d="http://docbook.org/ns/docbook" xmlns:exsl="http://exslt.org/common" xmlns:fo="http://www.w3.org/1999/XSL/Format"></script></head><body alink="#0000FF" bgcolor="white" link="#0000FF" text="black" vlink="#840084"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Chapter 31. Input/Output &lt;stdio.h></th></tr><tr><td align="left" width="20%"><a accesskey="p" href="../stdint/index.html">Prev</a> </td><th align="center" width="60%"> </th><td align="right" width="20%"> <a accesskey="n" href="../ix01.html">Next</a></td></tr></table><hr/></div><div class="chapter" title="Chapter 31. Input/Output &lt;stdio.h>"><div class="titlepage"><div><div><h2 class="title"><a name="idp2675504"></a>Chapter 31. Input/Output &lt;stdio.h></h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="index.html#idp5460912">31.1. Introduction</a></span></dt><dt><span class="sect1"><a href="index.html#idp4988848">31.2. Streams</a></span></dt><dt><span class="sect1"><a href="index.html#idp6471200">31.3. Files</a></span></dt><dt><span class="sect1"><a href="index.html#idp6509824">31.4. Operations on files</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp6510560">31.4.1. The remove function</a></span></dt><dt><span class="sect2"><a href="index.html#idp6517328">31.4.2. The rename function</a></span></dt><dt><span class="sect2"><a href="index.html#idp6525344">31.4.3. The tmpfile function</a></span></dt><dt><span class="sect2"><a href="index.html#idp6536208">31.4.4. The tmpnam function</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp6548880">31.5. File acces functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp6549616">31.5.1. The fclose functions</a></span></dt><dt><span class="sect2"><a href="index.html#idp6557440">31.5.2. The fflush function</a></span></dt><dt><span class="sect2"><a href="index.html#idp6565520">31.5.3. The fopen function</a></span></dt><dt><span class="sect2"><a href="index.html#idp6591312">31.5.4. The freopen function</a></span></dt><dt><span class="sect2"><a href="index.html#idp6602672">31.5.5. The setbuf function</a></span></dt><dt><span class="sect2"><a href="index.html#idp6612480">31.5.6. The setvbuf function</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp6623248">31.6. Formatted input/output function</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp6625920">31.6.1. The fprintf function</a></span></dt></dl></dd></dl></div><div class="sect1" title="31.1. Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp5460912"></a>31.1. Introduction</h2></div></div></div><p>The header <code class="code">&lt;stdio.h></code> declares three types,
    several macros, and many functions for performing input and
    output.</p><p>The types declared are <code class="code">size_t</code> (described in Common
    definitions &lt;stddef.h>);</p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">FILE</code></p></blockquote></div><p>which is an object type capable of recording all the information
    needed to control a stream, including its file position indicator, a
    pointer to its associated buffer (if any), an error indicator that records
    whether a read/write error has occurred, and an end-of-file indicator that
    records whether the end of the file has been reached; and</p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">fpos_t</code></p></blockquote></div><p>which is an object type other than an array type capable of
    recording all the information needed to specify uniquely every position
    within a file.</p><p>The macros are NULL (described in Common definitions
    &lt;stddef.h>);</p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">_IOFBF</code></p><p><code class="code">_IOLBF</code></p><p><code class="code">_IONBF</code></p></blockquote></div><p>which expand to integer constant expressions with distinct values,
    suitable for use as the third argument to the <code class="code">setvbuf</code>
    function;</p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">BUFSIZ</code></p></blockquote></div><p>which expands to an integer constant expression that is the size of
    the buffer used by the <code class="code">setbuf</code> function;</p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">EOF</code></p></blockquote></div><p>which expands to an integer constant expression, with type int and
    a negative value, that is returned by several functions to indicate
    end-of-file, that is, no more input from a stream;</p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">FOPEN_MAX</code></p></blockquote></div><p>which expands to an integer constant expression that is the minimum 
    number of files that the implementation guarantees can be open
    simultaneously;</p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">FILENAME_MAX</code></p></blockquote></div><p>which expands to an integer constant expression that is the size
    needed for an array of char large enough to hold the longest file name
    string that the implementation guarantees can be
    opened;<sup>[<a class="footnote" href="#ftn.idp5194496" name="idp5194496">197</a>]</sup></p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">L_tmpnam</code></p></blockquote></div><p>which expands to an integer constant expression that is the size
    needed for an array of char large enough to hold a temporary file name
    string generated by the <code class="code">tmpnam</code> function;</p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">stderr</code></p><p><code class="code">stdin</code></p><p><code class="code">stdout</code></p></blockquote></div><p>which are expressions of type "pointer to <code class="code">FILE</code>"
    that point to the <code class="code">FILE</code> objects associated, respectively,
    with the standard error, input, and output streams.</p><p>The header <code class="code">&lt;wchar.h></code> declares a number of
    functions useful for wide character input and output. The wide character
    input/output functions described in that subclause provide operations
    analogous to most of those described here, except that the fundamental
    units internal to the program are wide characters. The external
    representation (in the file) is a sequence of "generalized" multibyte
    characters, as described further in Files.</p><p>The input/output functions are given the following collective
    terms:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <span class="italic">wide character input
	functions</span> - those functions described in Extended
	multibyte and wide character utilities &lt;wchar.h> that perform
	input into wide characters and wide strings: <code class="code">fgetwc, fgetws,
	getwc, getwchar, fwscanf, wscanf, vfwscanf</code> and
	<code class="code">vwscanf</code>.</p></li><li class="listitem"><p>The <span class="italic">wide character output
	functions</span> - those functions described in Extended
	multibyte and wide character utilities &lt;wchar.h> that perform
	output from wide characters and wide strings: <code class="code">fputwc, fputws,
	putwc, putwchar, fwprintf, wprintf, vfwprintf</code> and
	<code class="code">vwprintf</code>.</p></li><li class="listitem"><p>The <span class="italic">wide character input/output
	functions</span> the union of the <code class="code">ungetwc</code>
	function, the wide character input functions, and the wide character
	output functions.</p></li><li class="listitem"><p>The <span class="italic">byte input/output
	functions</span> - those functions described in this subclause
	that perform input/output: <code class="code">fgetc, fgets, fprintf, fputc, fputs,
	fread, fscanf, fwrite, getc, getchar, gets, perror, printf, putc,
	putchar, puts, scanf, ungetc, vfprintf, vfscanf, vprintf</code> and
	<code class="code">vscanf</code>.</p></li></ul></div></div><div class="sect1" title="31.2. Streams"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp4988848"></a>31.2. Streams</h2></div></div></div><p>Input and output, whether to or from physical devices such as
    terminals and tape drives, or whether to or from files supported on
    structured storage devices, are mapped into logical data streams, whose
    properties are more uniform than their various inputs and outputs. Two
    forms of mapping are supported, for text streams and for binary
    streams.<sup>[<a class="footnote" href="#ftn.idp4990224" name="idp4990224">198</a>]</sup></p><p>A text stream is an ordered sequence of characters composed into
    lines, each line consisting of zero or more characters plus a terminating
    new-line character. Whether the last line requires a terminating new-line
    character is implementation-defined. Characters may have to be added,
    altered, or deleted on input and output to conform to differing conventions
    for representing text in the host environment. Thus, there need not be a
    oneto- one correspondence between the characters in a stream and those in
    the external representation. Data read in from a text stream will
    necessarily compare equal to the data that were earlier written out to that
    stream only if: the data consist only of printing characters and the
    control characters horizontal tab and new-line; no new-line character is
    immediately preceded by space characters; and the last character is a
    new-line character. Whether space characters that are written out
    immediately before a new-line character appear when read in is
    implementation-defined.</p><p>A binary stream is an ordered sequence of characters that can
    transparently record internal data. Data read in from a binary stream shall
    compare equal to the data that were earlier written out to that stream,
    under the same implementation. Such a stream may, however, hav e an
    implementation-defined number of null characters appended to the end of the
    stream.</p><p>Each stream has an orientation. After a stream is associated with
    an external file, but before any operations are performed on it, the stream
    is without orientation. Once a wide character input/output function has
    been applied to a stream without orientation, the stream becomes a
    <span class="italic">wide-oriented</span> stream. Similarly,
    once a byte input/output function has been applied to a stream without
    orientation, the stream becomes a byte-oriented stream. Only a call to the
    <code class="code">freopen</code> function or the fwide function can otherwise alter
    the orientation of a stream. (A successful call to <code class="code">freopen</code>
    removes any orientation.)<sup>[<a class="footnote" href="#ftn.idp4995776" name="idp4995776">199</a>]</sup></p><p>Byte input/output functions shall not be applied to a wide-oriented
    stream and wide character input/output functions shall not be applied to a
    byte-oriented stream. The remaining stream operations do not affect, and
    are not affected by, a stream's orientation, except for the following
    additional restrictions:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Binary wide-oriented streams have the file-positioning
	restrictions ascribed to both text and binary streams.</p></li><li class="listitem"><p>For wide-oriented streams, after a successful call to a
	file-positioning function that leaves the file position indicator prior
	to the end-of-file, a wide character output function can overwrite a
	partial multibyte character; any file contents beyond the byte(s)
	written are henceforth indeterminate.</p></li></ul></div><p>Each wide-oriented stream has an associated
    <code class="code">mbstate_t</code> object that stores the current parse state of
    the stream. A successful call to fgetpos stores a representation of the
    value of this mbstate_t object as part of the value of the
    <code class="code">fpos_t</code> object. A later successful call to fsetpos using
    the same stored <code class="code">fpos_t</code> value restores the value of the
    associated <code class="code">mbstate_t</code> object as well as the position within
    the controlled stream.</p><p><span class="bold"><strong>Environmental limits</strong></span></p><p>An implementation shall support text files with lines containing at
    least 254 characters, including the terminating new-line character. The
    value of the macro <code class="code">BUFSIZ</code> shall be at least 256.</p></div><div class="sect1" title="31.3. Files"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp6471200"></a>31.3. Files</h2></div></div></div><p>A stream is associated with an external file (which may be a
    physical device) by opening a file, which may involve <span class="italic">creating</span> a new file. Creating an existing file
    causes its former contents to be discarded, if necessary. If a file can
    support positioning requests (such as a disk file, as opposed to a
    terminal), then a file position indicator associated with the stream is
    positioned at the start (character number zero) of the file, unless the
    file is opened with append mode in which case it is implementation-defined
    whether the file <span class="italic">position</span> indicator
    is initially positioned at the beginning or the end of the file. The file
    position indicator is maintained by subsequent reads, writes, and
    positioning requests, to facilitate an orderly progression through the
    file.</p><p>Binary files are not truncated, except as defined in The fopen
    function. Whether a write on a text stream causes the associated file to be
    truncated beyond that point is implementation-defined.</p><p>When a stream is <span class="italic">unbuffered</span>,
    characters are intended to appear from the source or at the destination as
    soon as possible. Otherwise characters may be accumulated and transmitted
    to or from the host environment as a block. When a stream is <span class="italic">fully buffered</span>, characters are intended to be 
    transmitted to or from the host environment as a block when a buffer is 
    filled. When a stream is <span class="italic">line
    buffered</span>, characters are intended to be transmitted to or from
    the host environment as a block when a new-line character is
    encountered. Furthermore, characters are intended to be transmitted as a
    block to the host environment when a buffer is filled, when input is
    requested on an unbuffered stream, or when input is requested on a line
    buffered stream that requires the transmission of characters from the host
    environment. Support for these characteristics is implementation-defined,
    and may be affected via the setbuf and setvbuf functions.</p><p>A file may be disassociated from a controlling stream by
    <code class="code">closing</code> the file. Output streams are flushed (any
    unwritten buffer contents are transmitted to the host environment) before
    the stream is disassociated from the file. The value of a pointer to a
    <code class="code">FILE</code> object is indeterminate after the associated file is
    closed (including the standard text streams). Whether a file of zero length
    (on which no characters have been written by an output stream) actually
    exists is implementation-defined.</p><p>The file may be subsequently reopened, by the same or another
    program execution, and its contents reclaimed or modified (if it can be
    repositioned at its start). If the <code class="code">main</code> function returns
    to its original caller, or if the <code class="code">exit</code> function is called,
    all open files are closed (hence all output streams are flushed) before
    program termination. Other paths to program termination, such as calling
    the abort function, need not close all files properly.</p><p>The address of the <code class="code">FILE</code> object used to control a
    stream may be significant; a copy of a <code class="code">FILE</code> object need
    not serve in place of the original.</p><p>At program startup, three text streams are predefined and need not
    be opened explicitly - <span class="italic">standard
    input</span> (for reading conventional input), <span class="italic">standard output</span> (for writing conventional
    output) and standard error (for writing diagnostic output). As initially
    opened, the <span class="italic">y</span> stream is not fully
    buffered; the standard input and standard output streams are fully buffered
    if and only if the stream can be determined not to refer to an interactive
    device.</p><p>Functions that open additional (nontemporary) files require a
    <span class="italic">file name</span>, which is a string. The
    rules for composing valid file names are implementation-defined. Whether
    the same file can be simultaneously open multiple times is also
    implementation-defined.</p><p>Although both text and binary wide-oriented streams are
    conceptually sequences of wide characters, the external file associated
    with a wide-oriented stream is a sequence of multibyte characters,
    generalized as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Multibyte encodings within files may contain embedded null
	bytes (unlike multibyte encodings valid for use internal to the
	program).</p></li><li class="listitem"><p>A file need not begin nor end in the initial shift
	state.<sup>[<a class="footnote" href="#ftn.idp6490656" name="idp6490656">200</a>]</sup></p></li></ul></div><p>Moreover, the encodings used for multibyte characters may differ
    among files. Both the nature and choice of such encodings are
    implementation-defined.</p><p>The wide character input functions read multibyte characters from
    the stream and convert them to wide characters as if they were read by
    successive calls to the <code class="code">fgetwc</code> function. Each conversion
    occurs as if by a call to the <code class="code">mbrtowc</code> function, with the
    conversion state described by the stream's own <code class="code">mbstate_t</code>
    object. The byte input functions read characters from the stream as if by
    successive calls to the <code class="code">fgetc</code> function.</p><p>The wide character output functions convert wide characters to
    multibyte characters and write them to the stream as if they were written
    by successive calls to the <code class="code">fputwc</code> function. Each
    conversion occurs as if by a call to the wcrtomb function, with the
    conversion state described by the stream's own <code class="code">mbstate_t</code>
    object. The byte output functions write characters to the stream as if by
    successive calls to the <code class="code">fputc</code> function.</p><p>In some cases, some of the byte input/output functions also perform
    conversions between multibyte characters and wide characters. These
    conversions also occur as if by calls to the <code class="code">mbrtowc</code> and
    <code class="code">wcrtomb</code> functions.</p><p>An <span class="italic">encoding error</span> occurs if
    the character sequence presented to the underlying <code class="code">mbrtowc</code>
    function does not form a valid (generalized) multibyte character, or if the
    code value passed to the underlying <code class="code">wcrtomb</code> does not
    correspond to a valid (generalized) multibyte character. The wide character
    input/output functions and the byte input/output functions store the value
    of the macro <code class="code">EILSEQ</code> in errno if and only if an encoding
    error occurs.</p><p><span class="bold"><strong>Enviromental limits</strong></span></p><p>The value of <code class="code">FOPEN_MAX</code> shall be at least eight,
    including the three standard text streams.</p><p><span class="bold"><strong>Forward references:</strong></span> the
    <code class="code">exit</code> function (The exit function), the
    <code class="code">fgetc</code> function (The fgetc function), the
    <code class="code">fopen</code> function (The fopen function), the
    <code class="code">fputc</code> function (The fputc function), the
    <code class="code">setbuf</code> function (The setbuf function), the
    <code class="code">setvbuf</code> function (The setvbuf function), the
    <code class="code">fgetwc</code> function (The fgetwc function), the
    <code class="code">fputwc</code> function (The fputwc function), conversion state
    (Extended multibyte/wide character conversion utilities), the
    <code class="code">mbrtowc</code> function (The mbrtowc function), the
    <code class="code">wcrtomb</code> function (The wcrtomb function)</p></div><div class="sect1" title="31.4. Operations on files"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp6509824"></a>31.4. Operations on files</h2></div></div></div><div class="sect2" title="31.4.1. The remove function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6510560"></a>31.4.1. The remove function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">remove</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">remove</code> function causes the file whose name
      is the string pointed to by filename to be no longer accessible by that
      name. A subsequent attempt to open that file using that name will fail,
      unless it is created anew. If the file is open, the behavior of the
      <code class="code">remove</code> function is implementation-defined.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">remove</code> function returns zero if the
      operation succeeds, nonzero if it fails.</p></div><div class="sect2" title="31.4.2. The rename function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6517328"></a>31.4.2. The rename function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">rename</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">rename</code> function causes the file whose name is the
string pointed to by old to be henceforth known by the name given by the string
pointed to by new. The file named old is no longer accessible by that name. If
a file named by the string pointed to by new exists prior to the call to the
<code class="code">rename</code> function, the behavior is
implementation-defined.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">rename</code> function returns zero if the operation
succeeds, nonzero if it fails,<sup>[<a class="footnote" href="#ftn.idp6523808" name="idp6523808">201</a>]</sup> in which case if the file existed previously it
is still known by its original name.</p></div><div class="sect2" title="31.4.3. The tmpfile function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6525344"></a>31.4.3. The tmpfile function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="nf">tmpfile</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">tmpfile</code> function creates a temporary binary file
that is different from any other existing file and that will automatically be
removed when it is closed or at program termination. If the program terminates
abnormally, whether an open temporary file is removed is
implementation-defined. The file is opened for update with "wb+" mode.</p><p><span class="bold"><strong>Recommended Practice</strong></span></p><p>It should be possible to open at least <code class="code">TMP_MAX</code>
temporary files during the lifetime of the program (this limit may be shared
with <code class="code">tmpnam</code>) and there should be no limit on the number
simultaneously open other than this limit and any limit on the number of open
files (<code class="code">FOPEN_MAX</code>).</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">tmpfile</code> function returns a pointer to the stream
of the file that it created. If the file cannot be created, the
<code class="code">tmpfile</code> function returns a null pointer.</p><p><code class="code">Forward references:</code> the <code class="code">fopen</code>
function (The fopen function).</p></div><div class="sect2" title="31.4.4. The tmpnam function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6536208"></a>31.4.4. The tmpnam function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">tmpnam</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">tmpnam</code> function generates a string that is a valid
file name and that is not the same as the name of an existing
file.<sup>[<a class="footnote" href="#ftn.idp6540224" name="idp6540224">202</a>]</sup> The function is
potentially capable of generating <code class="code">TMP_MAX</code> different strings,
but any or all of them may already be in use by existing files and thus not be
suitable return values.</p><p>The <code class="code">tmpnam</code> function generates a different string each
time it is called.</p><p>The implementation shall behave as if no library function calls the
<code class="code">tmpnam</code> function.</p><p><span class="bold"><strong>Returns</strong></span></p><p>If no suitable string can be generated, the <code class="code">tmpnam</code>
function returns a null pointer. Otherwise, if the argument is a null pointer,
the tmpnam function leaves its result in an internal static object and returns
a pointer to that object (subsequent calls to the tmpnam function may modify
the same object). If the argument is not a null pointer, it is assumed to point
to an array of at least <code class="code">L_tmpnam</code> chars; the
<code class="code">tmpnam</code> function writes its result in that array and returns
the argument as its value.</p><p><span class="bold"><strong>Environemental limits</strong></span></p><p>The value of the macro <code class="code">TMP_MAX</code> shall be at least
25.</p></div></div><div class="sect1" title="31.5. File acces functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp6548880"></a>31.5. File acces functions</h2></div></div></div><div class="sect2" title="31.5.1. The fclose functions"><div class="titlepage"><div><div><h3 class="title"><a name="idp6549616"></a>31.5.1. The fclose functions</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>A successful call to the <code class="code">fclose</code> function causes the
stream pointed to by stream to be flushed and the associated file to be
closed. Any unwritten buffered data for the stream are delivered to the host
environment to be written to the file; any unread buffered data are
discarded. Whether or not the call succeeds, the stream is disassociated from
the file and any buffer set by the <code class="code">setbuf</code> or
<code class="code">setvbuf</code> function is disassociated from the stream (and
deallocated if it was automatically allocated).</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">fclose</code> function returns zero if the stream was
successfully closed, or <code class="code">EOF</code> if any errors were
detected.</p></div><div class="sect2" title="31.5.2. The fflush function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6557440"></a>31.5.2. The fflush function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">fflush</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>If stream points to an output stream or an update stream in which the
most recent operation was not input, the <code class="code">fflush</code> function
causes any unwritten data for that stream to be delivered to the host
environment to be written to the file; otherwise, the behavior is
undefined.</p><p>If stream is a null pointer, the fflush function performs this flushing
action on all streams for which the behavior is defined above.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">fflush</code> function sets the error indicator for the
stream and returns EOF if a write error occurs, otherwise it returns
zero.</p><p><code class="code">Forward references:</code> the <code class="code">fopen</code>
function (The fopen function).</p></div><div class="sect2" title="31.5.3. The fopen function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6565520"></a>31.5.3. The fopen function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">fopen</code> function opens the file whose name is the
string pointed to by filename, and associates a stream with it.</p><p>The argument mode points to a string. If the string is one of the
following, the file is open in the indicated mode. Otherwise, the behavior is
undefined.<sup>[<a class="footnote" href="#ftn.idp6570176" name="idp6570176">203</a>]</sup></p><div class="blockquote"><blockquote class="blockquote"><p><code class="code">r</code> open test file for reading</p><p><code class="code">w</code> truncate zero length or create text file for writing</p><p><code class="code">a</code> append; open or create text file for writing at end-of-file</p><p><code class="code">rb</code> open binary file for reading</p><p><code class="code">wb</code> truncate to zero length or create binary file for writing</p><p><code class="code">ab</code> append; open or create binary file for writing at end-of-file</p><p><code class="code">r+</code> open text file for update (reading and writing)</p><p><code class="code">w+</code> truncate to zero length or create text file for update</p><p><code class="code">a+</code> append; open or create text file for update, writing at end-of-file</p><p><code class="code">r+b</code> or <code class="code">rb+</code> open binary file for update (reading and writing)</p><p><code class="code">w+b</code> or <code class="code">wb+</code> truncate to zero length or create binary file for update</p><p><code class="code">a+b</code> or <code class="code">ab+</code> append; open or create binary file for update, writing at end-of-file</p></blockquote></div><p>Opening a file with read mode ('<code class="code">r</code>' as the first
character in the mode argument) fails if the file does not exist or cannot be
read.</p><p>Opening a file with append mode ('<code class="code">a</code>' as the first
character in the mode argument) causes all subsequent writes to the file to be
forced to the then current end-of-file, regardless of intervening calls to the
fseek function. In some implementations, opening a binary file with append mode
('<code class="code">b</code>' as the second or third character in the above list of
mode argument values) may initially position the file position indicator for
the stream beyond the last data written, because of null character
padding.</p><p>When a file is opened with update mode ('<code class="code">+</code>' as the
second or third character in the above list of mode argument values), both
input and output may be performed on the associated stream. However, output
shall not be directly followed by input without an intervening call to the
<code class="code">fflush</code> function or to a file positioning function
(<code class="code">fseek, fsetpos</code> or <code class="code">rewind</code>), and input shall
not be directly followed by output without an intervening call to a file
positioning function, unless the input operation encounters
end-of-file. Opening (or creating) a text file with update mode may instead
open (or create) a binary stream in some implementations.</p><p>When opened, a stream is fully buffered if and only if it can be
determined not to refer to an interactive device. The error and end-of-file
indicators for the stream are cleared.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">fopen</code> function returns a pointer to the object
controlling the stream. If the open operation fails, fopen returns a null
pointer.</p><p><span class="bold"><strong>Forward references:</strong></span> file
positioning functions (File positioning functions).</p></div><div class="sect2" title="31.5.4. The freopen function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6591312"></a>31.5.4. The freopen function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="nf">freopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">mode</span><span class="p">,</span>
              <span class="kt">FILE</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">stream</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">freopen</code> function opens the file whose name is the
string pointed to by filename and associates the stream pointed to by stream
with it. The mode argument is used just as in the <code class="code">fopen</code>
function.<sup>[<a class="footnote" href="#ftn.idp6595920" name="idp6595920">204</a>]</sup></p><p>If filename is a null pointer, the <code class="code">freopen</code> function
attempts to change the mode of the stream to that specified by mode, as if the
name of the file currently associated with the stream had been used. It is
implementation-defined which changes of mode are permitted (if any), and under
what circumstances.</p><p>The <code class="code">freopen</code> function first attempts to close any file
that is associated with the specified stream. Failure to close the file is
ignored. The error and end-of-file indicators for the stream are
cleared.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">freopen</code> function returns a null pointer if the
open operation fails. Otherwise, <code class="code">freopen</code> returns the value of
stream.</p></div><div class="sect2" title="31.5.5. The setbuf function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6602672"></a>31.5.5. The setbuf function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">void</span> <span class="nf">setbuf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">buf</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>Except that it returns no value, the <code class="code">setbuf</code> function
is equivalent to the <code class="code">setvbuf</code> function invoked with the values
<code class="code">_IOFBF</code> for mode and <code class="code">BUFSIZ</code> for size, or (if
<code class="code">buf</code> is a null pointer), with the value <code class="code">_IONBF</code>
for mode.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">setbuf</code> function returns no value.</p><p><span class="bold"><strong>Forward references:</strong></span> the
<code class="code">setvbuf</code> function (The setvbuf function).</p></div><div class="sect2" title="31.5.6. The setvbuf function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6612480"></a>31.5.6. The setvbuf function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">setvbuf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">setvbuf</code> function may be used only after the stream
pointed to by stream has been associated with an open file and before any other
operation (other than an unsuccessful call to <code class="code">setvbuf</code>) is
performed on the stream. The argument mode determines how stream will be
buffered, as follows: <code class="code">_IOFBF</code> causes input/output to be fully
buffered; <code class="code">_IOLBF</code> causes input/output to be line buffered;
<code class="code">_IONBF</code> causes input/output to be unbuffered. If
<code class="code">buf</code> is not a null pointer, the array it points to may be used
instead of a buffer allocated by the <code class="code">setvbuf</code>
function<sup>[<a class="footnote" href="#ftn.idp6619552" name="idp6619552">205</a>]</sup> and the argument size specifies the size of the
array; otherwise, size may determine the size of a buffer allocated by the
<code class="code">setvbuf</code> function. The contents of the array at any time are
indeterminate.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">setvbuf</code> function returns zero on success, or
nonzero if an invalid value is given for mode or if the request cannot be
honored.</p></div></div><div class="sect1" title="31.6. Formatted input/output function"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp6623248"></a>31.6. Formatted input/output function</h2></div></div></div><p>The formatted input/output functions shall behave as if there is a
    sequence point after the actions associated with each
    specifier.<sup>[<a class="footnote" href="#ftn.idp6624416" name="idp6624416">206</a>]</sup></p><div class="sect2" title="31.6.1. The fprintf function"><div class="titlepage"><div><div><h3 class="title"><a name="idp6625920"></a>31.6.1. The fprintf function</h3></div></div></div><p><span class="bold"><strong>Synopsis</strong></span></p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">fprintf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</pre><p><span class="bold"><strong>Description</strong></span></p><p>The <code class="code">fprintf</code> function writes output to the stream
pointed to by stream, under control of the string pointed to by format that
specifies how subsequent arguments are converted for output. If there are
insufficient arguments for the format, the behavior is undefined. If the format
is exhausted while arguments remain, the excess arguments are evaluated (as
always) but are otherwise ignored. The <code class="code">fprintf</code> function
returns when the end of the format string is encountered.</p><p>The format shall be a multibyte character sequence, beginning and
ending in its initial shift state. The format is composed of zero or more
directives: ordinary multibyte characters (not <code class="code">%</code>), which are
copied unchanged to the output stream; and conversion pecifications, each of
which results in fetching zero or more subsequent arguments, converting them,
if applicable, according to the corresponding conversion specifier, and then
writing the result to the output stream.</p><p>Each conversion specification is introduced by the character
<code class="code">%</code>. After the <code class="code">%</code>, the following appear in
sequence:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Zero or more flags (in any order) that modify the meaning of the conversion specification.</p></li><li class="listitem"><p>An optional minimum field width. If the converted value has fewer
    characters than the field width, it is padded with spaces (by default) on
    the left (or right, if the left adjustment flag, described later, has been
    given) to the field width. The field width takes the form of an asterisk *
    (described later) or a nonnegative decimal integer.<sup>[<a class="footnote" href="#ftn.idp6635840" name="idp6635840">207</a>]</sup></p></li><li class="listitem"><p>An optional precision that gives the minimum number of digits to
    appear for the <code class="code">d, i, o, u, x</code> and <code class="code">X</code>
    conversions, the number of digits to appear after the decimal-point
    character for <code class="code">a, A, e, E, f</code> and <code class="code">F</code>
    conversions, the maximum number of significant digits for the
    <code class="code">g</code> and <code class="code">G</code> conversions, or the maximum
    number of bytes to be written for <code class="code">s</code> conversions. The
    precision takes the form of a period (.) followed either by an asterisk *
    (described later) or by an optional decimal integer; if only the period is
    specified, the precision is taken as zero. If a precision appears with any
    other conversion specifier, the behavior is undefined.</p></li><li class="listitem"><p>An optional length modifier that specifies the size of the
    argument.</p></li><li class="listitem"><p>A conversion specifier character that specifies the type of
    conversion to be applied.</p></li></ul></div><p>As noted above, a field width, or precision, or both, may be indicated
by an asterisk. In this case, an int argument supplies the field width or
precision. The arguments specifying field width, or precision, or both, shall
appear (in that order) before the argument (if any) to be converted. A negative
field width argument is taken as a - flag followed by a positive field width. A
negative precision argument is taken as if the precision were omitted.</p><p>The flag characters and their meanings are:</p><p>- The result of the conversion is left-justified within the field. (It
is right-justified if this flag is not specified.)</p><p>+ The result of a signed conversion always begins with a plus or minus
sign. (It begins with a sign only when a negative value is converted if this
flag is not specified.)<sup>[<a class="footnote" href="#ftn.idp6645680" name="idp6645680">208</a>]</sup></p><p><span class="italic">space</span> If the first character of
a signed conversion is not a sign, or if a signed conversion results in no
characters, a space is prefixed to the result. If the space and + flags both
appear, the space flag is ignored.</p><p># The result is converted to an "alternative form". For
<code class="code">o</code> conversion, it increases the precision, if and only if
necessary, to force the first digit of the result to be a zero (if the value
and precision are both 0, a single 0 is printed). For <code class="code">x</code> (or
<code class="code">X</code>) conversion, a nonzero result has <code class="code">0x</code> (or
<code class="code">0X</code>) prefixed to it. For <code class="code">a, A, e, E, f, F, g</code>
and <code class="code">G</code> conversions, the result of converting a floating-point
number always contains a decimal-point character, even if no digits follow
it. (Normally, a decimal-point character appears in the result of these
conversions only if a digit follows it.) For <code class="code">g</code> and
<code class="code">G</code> conversions, trailing zeros are not removed from the
result. For other conversions, the behavior is undefined.</p><p>0 For <code class="code">d, i, o, u, x, X, a, A, e, E, f, F, g</code> and
<code class="code">G</code> conversions, leading zeros (following any indication of sign
or base) are used to pad to the field width rather than performing space
padding, except when converting an infinity or NaN. If the 0 and - flags both
appear, the 0 flag is ignored. For <code class="code">d, i, o, u, x</code> and
<code class="code">X</code> conversions, if a precision is specified, the 0 flag is
ignored. For other conversions, the behavior is undefined.</p><p>The length modifiers and their meanings are:</p><p><code class="code">hh</code> Specifies that a following <code class="code">d, i, o, u,
x</code> or <code class="code">X</code> conversion specifier applies to a
<code class="code">signed char</code> or <code class="code">unsigned char</code> argument (the
argument will have been promoted according to the integer promotions, but its
value shall be converted to <code class="code">signed char</code> or <code class="code">unsigned
char</code> before printing); or that a following <code class="code">n</code>
conversion specifier applies to a pointer to a <code class="code">signed char</code>
argument.</p><p><code class="code">h</code> Specifies that a following <code class="code">d, i, o, u,
x</code> or <code class="code">X</code> conversion specifier applies to a
<code class="code">short int</code> or <code class="code">unsigned short int</code> argument (the
argument will have been promoted according to the integer promotions, but its
value shall be converted to <code class="code">short int</code> or <code class="code">unsigned
short int</code> before printing); or that a following <code class="code">n</code>
conversion specifier applies to a pointer to a <code class="code">short int</code>
argument.</p><p><code class="code">l</code> (ell) Specifies that a following <code class="code">d, i, o, u,
x</code> or <code class="code">X</code> conversion specifier applies to a <code class="code">long
int</code> or <code class="code">unsigned long int</code> argument; that a following
<code class="code">n</code> conversion specifier applies to a pointer to a <code class="code">long
int</code> argument; that a following c conversion specifier applies to a
<code class="code">wint_t</code> argument; that a following <code class="code">s</code>
conversion specifier applies to a pointer to a <code class="code">wchar_t</code>
argument; or has no effect on a following <code class="code">a, A, e, E, f, F, g</code>
or <code class="code">G</code> conversion specifier.</p><p><code class="code">ll</code> (ell-ell) Specifies that a following <code class="code">d, i,
o, u, x</code> or <code class="code">X</code> conversion specifier applies to a
<code class="code">long long int</code> or <code class="code">unsigned long long</code> int
argument; or that a following n conversion specifier applies to a pointer to a
<code class="code">long long int</code> argument.</p><p><code class="code">j</code> Specifies that a following <code class="code">d, i, o, u,
x</code> or <code class="code">X</code> conversion specifier applies to an
<code class="code">intmax_t</code> or <code class="code">uintmax_t</code> argument; or that a
following <code class="code">en</code> conversion specifier applies to a pointer to an
<code class="code">intmax_t</code> argument.</p><p><code class="code">z</code> Specifies that a following <code class="code">d, i, o, u,
x</code> or <code class="code">X</code> conversion specifier applies to a
<code class="code">size_t</code> or the corresponding signed integer type argument; or
that a following <code class="code">n</code> conversion specifier applies to a pointer
to a signed integer type corresponding to <code class="code">size_t</code>
argument.</p><p><code class="code">t</code> Specifies that a following <code class="code">d, i, o, u,
x</code> or <code class="code">X</code> conversion specifier applies to a
<code class="code">ptrdiff_t</code> or the corresponding unsigned integer type argument;
or that a following n conversion specifier applies to a pointer to a
<code class="code">ptrdiff_t</code> argument.</p><p><code class="code">L</code> Specifies that a following <code class="code">a, A, e, E, f, F,
g</code> or <code class="code">G</code> conversion specifier applies to a <code class="code">long
double</code> argument.</p><p>If a length modifier appears with any conversion specifier other than
as specified above, the behavior is undefined.</p><p>The conversion specifiers and their meanings are:</p><p><code class="code">d, i</code> The <code class="code">int</code> argument is converted to
signed decimal in the style <span class="italic">[-]dddd</span>. The
precision specifies the minimum number of digits to appear; if the value being
converted can be represented in fewer digits, it is expanded with leading
zeros. The default precision is 1. The result of converting a zero value with a
precision of zero is no characters.</p><p><code class="code">o, u, x, X</code> The <code class="code">unsigned int</code> argument
is converted to unsigned octal (o), unsigned decimal (u), or unsigned
hexadecimal notation (<code class="code">x</code> or <code class="code">X</code>) in the style
<code class="code">dddd</code>; the letters <code class="code">abcdef</code> are used for
<code class="code">y</code> conversion and the letters <code class="code">ABCDEF</code> for
<code class="code">X</code> conversion. The precision specifies the minimum number of
digits to appear; if the value being converted can be represented in fewer
digits, it is expanded with leading zeros. The default precision is 1. The
result of converting a zero value with a precision of zero is no
characters.</p><p><code class="code">f, F</code> A double argument representing a floating-point
number is converted to decimal notation in the style <span class="italic">[-]ddd.ddd</span>, where the number of digits after the
decimal-point character is equal to the precision specification. If the
precision is missing, it is taken as 6; if the precision is zero and the
<code class="code">#</code> flag is not specified, no decimal-point character
appears. If a decimal-point character appears, at least one digit appears
before it. The value is rounded to the appropriate number of digits.</p><p>A <code class="code">double</code> argument representing an infinity is
converted in one of the styles <span class="bold"><strong>[-]inf</strong></span> or
<span class="bold"><strong></strong></span> —- which style is
implementation-defined. A double argument representing a NaN is converted in
one of the styles <span class="bold"><strong>[-]nan</strong></span> or <span class="bold"><strong>[-]nan</strong></span> (<span class="italic">n-char-sequence</span>) — which style, and the
meaning of any n-char-sequence, is implementation-defined. The
<code class="code">F</code> conversion specifier produces <code class="code">INF, INFINITY</code>
or <code class="code">NAN</code> instead of <code class="code">inf, infinity</code> or
<code class="code">nan</code> respectively.<sup>[<a class="footnote" href="#ftn.idp6701984" name="idp6701984">209</a>]</sup></p><p><code class="code">e, E</code> A double argument representing a floating-point
number is converted in the style <span class="italic">[-]d.ddd</span> e<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>±</mo>
<mi>d</mi>
<mi>d</mi>
</math> , where there is one digit (which is nonzero if
the argument is nonzero) before the decimal-point character and the number of
digits after it is equal to the precision; if the precision is missing, it is
taken as 6; if the precision is zero and the <code class="code">#</code> flag is not
specified, no decimal-point character appears. The value is rounded to the
appropriate number of digits. The E conversion specifier produces a number with
E instead of e introducing the exponent. The exponent always contains at least
two digits, and only as many more digits as necessary to represent the
exponent. If the value is zero, the exponent is zero.</p><p>A <code class="code">double</code> argument representing an infinity or NaN is
converted in the style of an <code class="code">f</code> or <code class="code">F</code>
conversion specifier.</p><p><code class="code">g, G</code> A double argument representing a floating-point
number is converted in style <code class="code">f</code> or <code class="code">e</code> (or in
style <code class="code">F</code> or <code class="code">E</code> in the case of a
<code class="code">G</code> conversion specifier), depending on the value converted and
the precision. Let <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>P</mi>
</math> equal the precision if nonzero, 6 if the
precision is omitted, or 1 if the precision is zero. Then, if a conversion with
style <code class="code">E</code> would have an exponent of <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>X</mi>
</math>:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>P</mi>
<mo>></mo>
<mi>X</mi>
<mo>≥</mo>
<mo>−</mo>
<mn>4</mn>
</math>. the conversion is with style <code class="code">f</code>
(or <code class="code">F</code>) and precision <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>P</mi>
<mo>−</mo>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</math></p></li><li class="listitem"><p>otherwise, the conversion is with style <code class="code">e</code> (or
    <code class="code">E</code>) and precision <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>P</mi>
<mo>−</mo>
<mn>1</mn>
</math>.</p></li></ul></div><p>Finally, unless the <code class="code">#</code> flag is used, any trailing zeros
are removed from the fractional portion of the result and the decimal-point
character is removed if there is no fractional portion remaining.</p><p>A <code class="code">double</code> argument representing an infinity or NaN is
converted in the style of an <code class="code">f</code> or <code class="code">F</code>
conversion specifier.</p><p><code class="code">a, A</code> A <code class="code">double</code> argument representing a
floating-point number is converted in the style <span class="italic">[-]0xh.hhhh</span> <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>p</mi>
<mo>±</mo>
<mi>d</mi>
</math>, where there is one hexadecimal digit (which is
nonzero if the argument is a normalized floating-point number and is otherwise
unspecified) before the decimal-point character<sup>[<a class="footnote" href="#ftn.idp6736656" name="idp6736656">210</a>]</sup> nd the number of hexadecimal digits after it
is equal to the precision; if the precision is missing and
<code class="code">FLT_RADIX</code> is a power of 2, then the precision is sufficient
for an exact representation of the value; if the precision is missing and
<code class="code">FLT_RADIX</code> is not a power of 2, then the precision is
sufficient to distinguish<sup>[<a class="footnote" href="#ftn.idp6738528" name="idp6738528">211</a>]</sup> values of type double, except that trailing
zeros may be omitted; if the precision is zero and the <code class="code">#</code> flag
is not specified, no decimal-point character appears. The letters abcdef are
used for a conversion and the letters <code class="code">ABCDEF</code> for A
conversion. The A conversion specifier produces a number with
<code class="code">X</code> and <code class="code">P</code> instead of <code class="code">x</code> and
<code class="code">p</code>. The exponent always contains at least one digit, and only
as many more digits as necessary to represent the decimal exponent of 2. If the
value is zero, the exponent is zero. A double argument representing an infinity
or NaN is converted in the style of an <code class="code">f</code> or <code class="code">F</code>
conversion specifier.</p><p><code class="code">c</code> If no <code class="code">l</code> length modifier is present,
the <code class="code">int</code> argument is converted to an <code class="code">unsigned
char</code>, and the resulting character is written.</p><p>If an <code class="code">l</code> length modifier is present, the
<code class="code">wint_t</code> argument is converted as if by an <code class="code">ls</code>
conversion specification with no precision and an argument that points to the
initial element of a two-element array of <code class="code">wchar_t</code>, the first
element containing the <code class="code">wint_t</code> argument to the
<code class="code">lc</code> conversion specification and the second a null wide
character.</p><p><code class="code">s</code> If no <code class="code">l</code> length modifier is present,
the argument shall be a pointer to the initial element of an array of character
type.<sup>[<a class="footnote" href="#ftn.idp6760752" name="idp6760752">212</a>]</sup> Characters from the array are written up to
(but not including) the terminating null character. If the precision is
specified, no more than that many bytes are written. If the precision is not
specified or is greater than the size of the array, the array shall contain a
null character.</p><p>If an <code class="code">l</code> length modifier is present, the argument shall
be a pointer to the initial element of an array of <code class="code">wchar_t</code>
type. Wide characters from the array are converted to multibyte characters
(each as if by a call to the <code class="code">wcrtomb</code> function, with the
conversion state described by an <code class="code">mbstate_t</code> object initialized
to zero before the first wide character is converted) up to and including a
terminating null wide character. The resulting multibyte characters are written
up to (but not including) the terminating null character (byte). If no
precision is specified, the array shall contain a null wide character. If a
precision is specified, no more than that many bytes are written (including
shift sequences, if any), and the array shall contain a null wide character if,
to equal the multibyte character sequence length given by the precision, the
function would need to access a wide character one past the end of the
array. In no case is a partial multibyte character
written.<sup>[<a class="footnote" href="#ftn.idp6764768" name="idp6764768">213</a>]</sup></p><p><code class="code">p</code> The argument shall be a pointer to
<code class="code">void</code>. The value of the pointer is converted to a sequence of
printing characters, in an implementation-defined manner.</p><p><code class="code">n</code> The argument shall be a pointer to signed integer
into which is written the number of characters written to the output stream so
far by this call to fprintf. No argument is converted, but one is consumed. If
the conversion specification includes any flags, a field width, or a precision,
the behavior is undefined.</p><p><code class="code">%</code> A <code class="code">%</code> character is written. No
argument is converted. The complete conversion specification shall be
<code class="code">%%</code>.</p><p>If a conversion specification is invalid, the behavior is undefined. If
any argument is not the correct type for the corresponding conversion
specification, the behavior is undefined.</p><p>In no case does a nonexistent or small field width cause truncation of
a field; if the result of a conversion is wider than the field width, the field
is expanded to contain the conversion result.</p><p>For a and A conversions, if <code class="code">FLT_RADIX</code> is a power of 2,
the value is correctly rounded to a hexadecimal floating number with the given
precision.</p><p><span class="bold"><strong>Recommended practice</strong></span></p><p>For <code class="code">a</code> and <code class="code">A</code> conversions, if
<code class="code">FLT_RADIX</code> is not a power of 2 and the result is not exactly
representable in the given precision, the result should be one of the two
adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current
rounding direction.</p><p>For <code class="code">e, E, f, F, g</code> and <code class="code">G</code> conversions,
if the number of significant decimal digits is at most
<code class="code">DECIMAL_DIG</code>, then the result should be correctly
rounded.<sup>[<a class="footnote" href="#ftn.idp6776352" name="idp6776352">214</a>]</sup> If the number of significant decimal digits is more
than <code class="code">DECIMAL_DIG</code> but the source value is exactly representable
with <code class="code">DECIMAL_DIG</code> digits, then the result should be an exact
representation with trailing zeros. Otherwise, the source value is bounded by
two adjacent decimal strings <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>L</mi>
<mo><</mo>
<mi>U</mi>
</math>, both having <code class="code">DECIMAL_DIG</code>
significant digits; the value of the resultant decimal string <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>D</mi>
</math> should satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>L</mi>
<mo>≤</mo>
<mi>D</mi>
<mo>≤</mo>
<mi>U</mi>
</math>, with the extra stipulation that the error
should have a correct sign for the current rounding direction.</p><p><span class="bold"><strong>Returns</strong></span></p><p>The <code class="code">fprintf</code> function returns the number of characters
transmitted, or a negative value if an output or encoding error
occurred.</p><p><span class="bold"><strong>Environmental limits</strong></span></p><p>The number of characters that can be produced by any single conversion
shall be at least 4095.</p><p>EXAMPLE 1 To print a date and time in the form "Sunday, July 3, 10:02"
followed by <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>π</mi>
</math> to five decimal places: </p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;math.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cm">/* ... */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">weekday</span><span class="p">,</span> <span class="o">*</span><span class="n">month</span><span class="p">;</span> <span class="c1">// pointers to strings</span>
<span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;%s, %s %d, %.2d:%.2d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="n">weekday</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;pi = %.5f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">atan</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
</pre></div>
</pre><p>EXAMPLE 2 In this example, multibyte characters do not have a
state-dependent encoding, and the members of the extended character set that
consist of more than one byte each consist of exactly two bytes, the first of
which is denoted here by a and the second by an uppercase letter.</p><p><span class="bold"><strong>Forward references:</strong></span> conversion
state (Extended multibyte/wide character conversion utilities), the
<code class="code">wcrtomb</code> function (The wcrtomb function).</p></div></div><div class="footnotes"><br/><hr align="left" width="100"/><div class="footnote"><p><sup>[<a class="para" href="#idp5194496" id="ftn.idp5194496">197</a>] </sup>If the implementation imposes no practical limit
    on the length of file name strings, the value of
    <code class="code">FILENAME_MAX</code> should instead be the recommended size of an
    array intended to hold a file name string. Of course, file name string
    contents are subject to other system-specific constraints; therefore all
    possible strings of length <code class="code">FILENAME_MAX</code> cannot be expected
    to be opened successfully.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4990224" id="ftn.idp4990224">198</a>] </sup>An implementation need not distinguish between
    text streams and binary streams. In such an implementation, there need be
    no new-line characters in a text stream nor any limit to the length of a
    line.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4995776" id="ftn.idp4995776">199</a>] </sup>The three predefined streams
    <code class="code">stdin, stdout</code> and <code class="code">stderr</code> are unoriented
    at program startup.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6490656" id="ftn.idp6490656">200</a>] </sup>Setting the file position indicator to
	end-of-file, as with <code class="code">fseek(file, 0, SEEK_END)</code>, has
	undefined behavior for a binary stream (because of possible trailing
	null characters) or for any stream with state-dependent encoding that
	does not assuredly end in the initial shift
	state.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6523808" id="ftn.idp6523808">201</a>] </sup>Among the reasons the
implementation may cause the <code class="code">rename</code> function to fail are that
the file is open or that it is necessary to copy its contents to effectuate its
renaming.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6540224" id="ftn.idp6540224">202</a>] </sup>Files created using strings generated by the tmpnam
function are temporary only in the sense that their names should not collide
with those generated by conventional naming rules for the implementation. It is
still necessary to use the remove function to remove such files when their use
is ended, and before program termination.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6570176" id="ftn.idp6570176">203</a>] </sup>If the string begins with one of the above
sequences, the implementation might choose to ignore the remaining characters,
or it might use them to select different kinds of a file (some of which might
not conform to the properties in Streams).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6595920" id="ftn.idp6595920">204</a>] </sup>The primary use of the <code class="code">freopen</code>
function is to change the file associated with a standard text stream
(<code class="code">stderr, stdin</code> or <code class="code">stdout</code>), as those
identifiers need not be modifiable lvalues to which the value returned by the
fopen function may be assigned.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6619552" id="ftn.idp6619552">205</a>] </sup>The buffer has to have a lifetime at least as great
as the open stream, so the stream should be closed before a buffer that has
automatic storage duration is deallocated upon block
exit.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6624416" id="ftn.idp6624416">206</a>] </sup>The <code class="code">fprintf</code> functions
    perform writes to memory for the <code class="code">%n</code>
    specifier.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6635840" id="ftn.idp6635840">207</a>] </sup>Note
    that 0 is taken as a flag, not as the beginning of a field
    width.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6645680" id="ftn.idp6645680">208</a>] </sup>The results of all floating
conversions of a negative zero, and of negative values that round to zero,
include a minus sign.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6701984" id="ftn.idp6701984">209</a>] </sup>When applied to infinite
and NaN values, the -, + and space flag characters have their usual meaning;
the # and 0 flag characters have no effect.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6736656" id="ftn.idp6736656">210</a>] </sup>Binary
implementations can choose the hexadecimal digit to the left of the
decimal-point character so that subsequent digits align to nibble (4-bit)
boundaries.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6738528" id="ftn.idp6738528">211</a>] </sup>The precision <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>p</mi>
</math> is sufficient to
distinguish values of the source type if <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<msup>
<mn>16</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
<mo>−</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>></mo>
<msup>
<mi>b</mi>
<mi>n</mi>
</msup>
</math> where
<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>b</mi>
</math> is <code class="code">FLT_RADIX</code> and
<math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>n</mi>
</math> is the number of base-b digits in the
significand of the source type. A smaller <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>p</mi>
</math> might suffice depending on the implementation’s
scheme for determining the digit to the left of the decimal-point
character.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6760752" id="ftn.idp6760752">212</a>] </sup>No special provisions are made for multibyte
characters.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6764768" id="ftn.idp6764768">213</a>] </sup>Redundant shift sequences may result if multibyte
characters have a state-dependent encoding.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp6776352" id="ftn.idp6776352">214</a>] </sup>For binary-to-decimal conversion, the result
format’s values are the numbers representable with the given format
specifier. The number of significant digits is determined by the format
specifier, and in the case of fixed-point conversion by the source value as
well.</p></div></div></div><div class="navfooter"><hr/><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="../stdint/index.html">Prev</a> </td><td align="center" width="20%"> </td><td align="right" width="40%"> <a accesskey="n" href="../ix01.html">Next</a></td></tr><tr><td align="left" valign="top" width="40%">Chapter 30. Integer types &lt;stdint.h> </td><td align="center" width="20%"><a accesskey="h" href="../index.html">Home</a></td><td align="right" valign="top" width="40%"> Index</td></tr></table></div><p style="text-align: center;" xmlns:d="http://docbook.org/ns/docbook" xmlns:exsl="http://exslt.org/common" xmlns:fo="http://www.w3.org/1999/XSL/Format">© 2010, 2013 Shiv S. Dayal. <a href="http://libreprogramming.org">libreprogramming.org</a>.
    GNU FDL license is applicable where not stated.</p></body></html>