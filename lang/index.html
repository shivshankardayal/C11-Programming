<html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>Chapter 4. Language</title><link href="../../css/style.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL-NS Stylesheets V1.76.1" name="generator"/><link href="../index.html" rel="home" title="C Programming with C99"/><link href="../index.html" rel="up" title="C Programming with C99"/><link href="../env/index.html" rel="prev" title="Chapter 3. Environment"/><link href="../basics/index.html" rel="next" title="Chapter 5. Basics of C"/><script src="../css/analytics.js" type="text/javascript" xmlns:d="http://docbook.org/ns/docbook" xmlns:exsl="http://exslt.org/common" xmlns:fo="http://www.w3.org/1999/XSL/Format"></script></head><body alink="#0000FF" bgcolor="white" link="#0000FF" text="black" vlink="#840084"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Chapter 4. Language</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="../env/index.html">Prev</a> </td><th align="center" width="60%"> </th><td align="right" width="20%"> <a accesskey="n" href="../basics/index.html">Next</a></td></tr></table><hr/></div><div class="chapter" title="Chapter 4. Language"><div class="titlepage"><div><div><h2 class="title"><a name="idp1376400"></a>Chapter 4. Language</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="index.html#idp876848">4.1. Notation</a></span></dt><dt><span class="sect1"><a href="index.html#idp872320">4.2. Conceptes</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp873120">4.2.1. Scope of Identifiers</a></span></dt><dt><span class="sect2"><a href="index.html#idp1051840">4.2.2. Linkage of identifiers</a></span></dt><dt><span class="sect2"><a href="index.html#idp3289712">4.2.3. Name Spaces of the Identifiers</a></span></dt><dt><span class="sect2"><a href="index.html#idp3301568">4.2.4. Storage duration of objects</a></span></dt><dt><span class="sect2"><a href="index.html#idp3324832">4.2.5. Types</a></span></dt><dt><span class="sect2"><a href="index.html#idp3434384">4.2.6. Representation of Types</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp3435232">4.2.6.1. General</a></span></dt><dt><span class="sect3"><a href="index.html#idp3487872">4.2.6.2. Integer Types</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp3524336">4.2.7. Compatible and Composite Types</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp3535776">4.3. Conversion</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp3538960">4.3.1. Arithmetics Operands</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp3539696">4.3.1.1. Booleans, Characters and Integers</a></span></dt><dt><span class="sect3"><a href="index.html#idp3567680">4.3.1.2. Boolean Type</a></span></dt><dt><span class="sect3"><a href="index.html#idp3569680">4.3.1.3. Signed and Unsigned Integers</a></span></dt><dt><span class="sect3"><a href="index.html#idp3573872">4.3.1.4. Real Floating and Integer</a></span></dt><dt><span class="sect3"><a href="index.html#idp3578352">4.3.1.5. Real Floating Types</a></span></dt><dt><span class="sect3"><a href="index.html#idp3585040">4.3.1.6. Complex Types</a></span></dt><dt><span class="sect3"><a href="index.html#idp3586672">4.3.1.7. Real and Complex</a></span></dt><dt><span class="sect3"><a href="index.html#idp3588656">4.3.1.8. Usual Arithmetic Conversion</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp3610336">4.3.2. Other Operands</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp3611184">4.3.2.1. Lvalues, Arrays and Function
            Designators</a></span></dt><dt><span class="sect3"><a href="index.html#idp3631200">4.3.2.2. void</a></span></dt><dt><span class="sect3"><a href="index.html#idp3634304">4.3.2.3. Pointers</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="index.html#idp3648560">4.4. Lexical Elements</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp3663440">4.4.1. Keywords</a></span></dt><dt><span class="sect2"><a href="index.html#idp3666800">4.4.2. Identifiers</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp3667648">4.4.2.1. General</a></span></dt><dt><span class="sect3"><a href="index.html#idp3679152">4.4.2.2. Predefined Identifiers</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp3689504">4.4.3. Universal Character Names</a></span></dt><dt><span class="sect2"><a href="index.html#idp3697360">4.4.4. Constants</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp3701184">4.4.4.1. Integer Constants</a></span></dt><dt><span class="sect3"><a href="index.html#idp3746944">4.4.4.2. Floating Constants</a></span></dt><dt><span class="sect3"><a href="index.html#idp3764160">4.4.4.3. Enumeration Constants</a></span></dt><dt><span class="sect3"><a href="index.html#idp3767280">4.4.4.4. Character Constants</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp3801248">4.4.5. String Literals</a></span></dt><dt><span class="sect2"><a href="index.html#idp3818272">4.4.6. Punctuators</a></span></dt><dt><span class="sect2"><a href="index.html#idp3827200">4.4.7. Header Names</a></span></dt><dt><span class="sect2"><a href="index.html#idp3835776">4.4.8. Preprocessing Numbers</a></span></dt><dt><span class="sect2"><a href="index.html#idp3841392">4.4.9. Comments</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp3847808">4.5. Expressions</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp3874768">4.5.1. Primary Expressions</a></span></dt><dt><span class="sect2"><a href="index.html#idp3881136">4.5.2. Postfix Operators</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp3881984">4.5.2.1. Array Subscripting</a></span></dt><dt><span class="sect3"><a href="index.html#idp3921632">4.5.2.2. Function Calls</a></span></dt><dt><span class="sect3"><a href="index.html#idp3943536">4.5.2.3. Structures and union members</a></span></dt><dt><span class="sect3"><a href="index.html#idp3964896">4.5.2.4. Postfix increment and decrement
            operators</a></span></dt><dt><span class="sect3"><a href="index.html#idp3972576">4.5.2.5. Compound literals</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp4002736">4.5.3. Unary Operators</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp4003584">4.5.3.1. Prefix increment and decrement
            operators</a></span></dt><dt><span class="sect3"><a href="index.html#idp4011904">4.5.3.2. Address and indirection operators</a></span></dt><dt><span class="sect3"><a href="index.html#idp4033056">4.5.3.3. Unary arithmetic operators</a></span></dt><dt><span class="sect3"><a href="index.html#idp4044656">4.5.3.4. The sizeof operator</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp4060976">4.5.4. Cast operators</a></span></dt><dt><span class="sect2"><a href="index.html#idp4069584">4.5.5. Multiplicative operators</a></span></dt><dt><span class="sect2"><a href="index.html#idp4079808">4.5.6. Additive operators</a></span></dt><dt><span class="sect2"><a href="index.html#idp4114624">4.5.7. Bitwise shift operators</a></span></dt><dt><span class="sect2"><a href="index.html#idp4161184">4.5.8. Relational operators</a></span></dt><dt><span class="sect2"><a href="index.html#idp4176144">4.5.9. Equality operators</a></span></dt><dt><span class="sect2"><a href="index.html#idp4192416">4.5.10. Bitwise AND operator</a></span></dt><dt><span class="sect2"><a href="index.html#idp4196976">4.5.11. Bitwise exlusive OR operator</a></span></dt><dt><span class="sect2"><a href="index.html#idp4201568">4.5.12. Bitwise inclusive OR operator</a></span></dt><dt><span class="sect2"><a href="index.html#idp4206160">4.5.13. Logical AND operator</a></span></dt><dt><span class="sect2"><a href="index.html#idp4212592">4.5.14. Logical OR operator</a></span></dt><dt><span class="sect2"><a href="index.html#idp4218576">4.5.15. Conditional operator</a></span></dt><dt><span class="sect2"><a href="index.html#idp4238080">4.5.16. Assignment operators</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp4243008">4.5.16.1. Simple Assignment</a></span></dt><dt><span class="sect3"><a href="index.html#idp4269152">4.5.16.2. Compound assignments</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp4276288">4.5.17. Comma operator</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp4283344">4.6. Constant expressions</a></span></dt><dt><span class="sect1"><a href="index.html#idp4309952">4.7. Declarations</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp4322528">4.7.1. Storage-class specifiers</a></span></dt><dt><span class="sect2"><a href="index.html#idp4333856">4.7.2. Type specifiers</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp4372864">4.7.2.1. Structure and union specifiers</a></span></dt><dt><span class="sect3"><a href="index.html#idp4418576">4.7.2.2. Enumeration specifiers</a></span></dt><dt><span class="sect3"><a href="index.html#idp4431440">4.7.2.3. Tags</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp4468480">4.7.3. Type qualifiers</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp4488256">4.7.3.1. Formal definition of restrict</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp4533264">4.7.4. Function specifiers</a></span></dt><dt><span class="sect2"><a href="index.html#idp4554288">4.7.5. Declarators</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp4570224">4.7.5.1. Pointer declarators</a></span></dt><dt><span class="sect3"><a href="index.html#idp4583616">4.7.5.2. Array declarators</a></span></dt><dt><span class="sect3"><a href="index.html#idp4613328">4.7.5.3. Function declarators (including
            prototypes)</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp4659952">4.7.6. Type names</a></span></dt><dt><span class="sect2"><a href="index.html#idp4669824">4.7.7. Type definitions</a></span></dt><dt><span class="sect2"><a href="index.html#idp4707024">4.7.8. Initialization</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp4785536">4.8. Statements and blocks</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp4794624">4.8.1. Labeled statements</a></span></dt><dt><span class="sect2"><a href="index.html#idp4803088">4.8.2. Compound statement</a></span></dt><dt><span class="sect2"><a href="index.html#idp4806352">4.8.3. Expressions and null statements</a></span></dt><dt><span class="sect2"><a href="index.html#idp4817168">4.8.4. Selection statements</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp4820192">4.8.4.1. The <code class="code">if</code> statement</a></span></dt><dt><span class="sect3"><a href="index.html#idp4826656">4.8.4.2. The <code class="code">switch</code> statement</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp4850288">4.8.5. Iteration statements</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp4855824">4.8.5.1. The <code class="code">while</code> statement</a></span></dt><dt><span class="sect3"><a href="index.html#idp4857824">4.8.5.2. The <code class="code">do</code> statement</a></span></dt><dt><span class="sect3"><a href="index.html#idp4859824">4.8.5.3. The <code class="code">for</code> statement</a></span></dt></dl></dd><dt><span class="sect2"><a href="index.html#idp4872544">4.8.6. Jump statements</a></span></dt><dd><dl><dt><span class="sect3"><a href="index.html#idp4874848">4.8.6.1. The <code class="code">goto</code> statement</a></span></dt><dt><span class="sect3"><a href="index.html#idp4888176">4.8.6.2. The <code class="code">continue</code> statement</a></span></dt><dt><span class="sect3"><a href="index.html#idp4896992">4.8.6.3. The <code class="code">break</code> statement</a></span></dt><dt><span class="sect3"><a href="index.html#idp4902752">4.8.6.4. The <code class="code">return</code> statement</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="index.html#idp4914448">4.9. External definitions</a></span></dt><dd><dl><dt><span class="sect2"><a href="index.html#idp4923840">4.9.1. Function definitions</a></span></dt><dt><span class="sect2"><a href="index.html#idp4949248">4.9.2. External object definitions</a></span></dt></dl></dd><dt><span class="sect1"><a href="index.html#idp4959216">4.10. Preprocessing directives</a></span></dt></dl></div><p>This is going to be meat of the book. This chapter is mapped with chapter 6 of
      specification. This will almost cover entire language. If you are already proficient in any
      programming language you must read it. However for it might be too involving without much
      introduction to language. I would recommend to skip and come back later. I could have put this
      later but then the flow of specification would have been broken.</p><div class="sect1" title="4.1. Notation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp876848"></a>4.1. Notation</h2></div></div></div><p>In the syntax notation used in this clause, syntactic categories (nonterminals) are
        indicated by italic type, and literal words and character set members (terminals) by
          <span class="bold"><strong>bold</strong></span> type. A colon
        (:) following a nonterminal introduces its definition. Alternative definitions are listed on
        separate lines, except when prefaced by the words “one of”. An optional symbol is indicated
        by the subscript “opt”, so that</p><pre class="screen"><math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
              <mi>e</mi>
              <mi>x</mi>
              <mi>p</mi>
              <mi>r</mi>
              <mi>e</mi>
              <mi>s</mi>
              <mi>s</mi>
              <mi>i</mi>
              <mi>o</mi>
              <msub>
                <mi>n</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>o</mi>
                  <mi>p</mi>
                  <mi>t</mi>
                </mrow>
              </msub>
            </math></pre><p>indicates an optional expression enclosed in braces.</p><p>When syntactic categories are referred to in the main text, they are not italicized
        and words are separated by spaces instead of hyphens.</p><p>A summary of the language syntax is given in annex A.</p></div><div class="sect1" title="4.2. Conceptes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp872320"></a>4.2. Conceptes</h2></div></div></div><div class="sect2" title="4.2.1. Scope of Identifiers"><div class="titlepage"><div><div><h3 class="title"><a name="idp873120"></a>4.2.1. Scope of Identifiers</h3></div></div></div><p>An identifier can denote an object; a function; a tag or a member of a structure,
          union, or enumeration; a typedef name; a label name; a macro name; or a macro parameter.
          The same identifier can denote different entities at different points in the program. A
          member of an enumeration is called an <span class="italic">enumeration constant</span>. Macro names and macro parameters are not
          considered further here, because prior to the semantic phase of program translation any
          occurrences of macro names in the source file are replaced by the preprocessing token
          sequences that constitute their macro definitions.</p><p>The interesting part is “The same identifier can denote different entities at
          different points in the program.”. This can happen if the identifer is in different
          scopes.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>For each different entity that an identifier designates, the identifier is visible
          (i.e., can be used) only within a region of program text called its scope. Different
          entities designated by the same identifier either have different scopes, or are in
          different name spaces. There are four kinds of scopes: function, file, block, and function
          prototype. (A function prototype is a declaration of a function that declares the types of
          its parameters.)</p><p>For example; consider following program:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span> <span class="c1">//uses file scope</span>

  <span class="n">i</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span> <span class="c1">//uses function scope</span>

  <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span> <span class="c1">//uses block scope</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">25
24
27</pre><p>A label name is the only kind of identifier that has function scope. It can be used
          (in a goto statement) anywhere in the function in which it appears, and is declared
          implicitly by its syntactic appearance (followed by a : and a statement).</p><p>For example, consider following program:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

  <span class="nl">ONE:</span>  <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
          <span class="k">goto</span> <span class="n">TWO</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
          <span class="k">goto</span> <span class="n">ONE</span><span class="p">;</span>
        <span class="p">}</span>
  <span class="nl">TWO:</span> <span class="p">;</span>
  <span class="c1">//TWO: goto MAIN; //will cause error</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>
  <span class="c1">//goto MAIN; //will cause error</span>
  <span class="c1">//MAIN: ; //will cause error</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>Every other identifier has scope determined by the placement of its declaration (in
          a declarator or type specifier). If the declarator or type specifier that declares the
          identifier appears outside of any block or list of parameters, the identifier has
            <span class="italic">file scope</span>,
          which terminates at the end of the translation unit. If the declarator or type specifier
          that declares the identifier appears inside a block or within the list of parameter
          declarations in a function definition, the identifier has <span class="italic">block scope</span>, which
          terminates at the end of the associated block. If the declarator or type specifier that
          declares the identifier appears within the list of parameter declarations in a function
          prototype (not part of a function definition), the identifier has function <span class="italic">prototype scope</span>, which
          terminates at the end of the function declarator. If an identifier designates two
          different entities in the same name space, the scopes might overlap. If so, the scope of
          one entity (the <span class="italic">inner
            scope</span>) will be a strict subset of the scope of the other entity (the
            <span class="italic">outer scope</span>).
          Within the inner scope, the identifier designates the entity declared in the inner scope;
          the entity declared in the outer scope is <span class="italic">hidden</span> (and not visible) within the inner scope. For example,
          consider the following program:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//identifier j not available in this function</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//printf(&quot;%d&quot;, i); not available outside inner scope will cause error</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">5</pre><p>Unless explicitly stated otherwise, where International Standard uses the term
          “identifier” to refer to some entity (as opposed to the syntactic construct), it refers to
          the entity in the relevant name space whose declaration is visible at the point the
          identifier occurs.</p><p>Two identifiers have the same scope if and only if their scopes terminate at the
          same point.</p><p>Structure, union, and enumeration tags have scope that begins just after the
          appearance of the tag in a type specifier that declares the tag. Each enumeration constant
          has scope that begins just after the appearance of its defining enumerator in an
          enumerator list. Any other identifier has scope that begins just after the completion of
          its declarator.</p><p>For example, consider the following program:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">STRUCT</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">STRUCT</span> <span class="o">*</span><span class="n">s1</span><span class="p">;</span> <span class="c1">//just a pointer so can be delared</span>
  <span class="k">struct</span> <span class="n">STRUCT</span> <span class="n">s2</span><span class="p">;</span>  <span class="c1">//object therefore incomplete type error</span>
<span class="p">}</span><span class="n">S</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="n">S</span><span class="p">;</span> <span class="c1">//type S is has file scope</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">S</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//s has function scope</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p><span class="bold"><strong>Forward
            references:</strong></span> declarations (Declarations), function calls (Function calls),
          function definitions (Function definitions), identifiers (Identifiers), name spaces of
          identifiers (Name Spaces of the Identifiers), macro replacement (Macro Replacement),
          source file inclusion (Source File Inclusion), statements (Statements and
          blocks).</p></div><div class="sect2" title="4.2.2. Linkage of identifiers"><div class="titlepage"><div><div><h3 class="title"><a name="idp1051840"></a>4.2.2. Linkage of identifiers</h3></div></div></div><p>An identifier declared in different scopes or in the same scope more than once can
          be made to refer to the same object or function by a process called linkage.<sup>[<a class="footnote" href="#ftn.idp1053136" name="idp1053136">16</a>]</sup>There are three kinds of linkage: external, internal, and none.</p><p>In the set of translation units and libraries that constitutes an entire program,
          each declaration of a particular identifier with <span class="italic">external linkage</span> denotes
          the same object or function. Within one translation unit, each declaration of an
          identifier with internal linkage denotes the same object or function. Each declaration of
          an identifier with no linkage denotes a unique entity.</p><p>For example, consider the following program:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//external scope</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// int i=0; same problem</span>
  <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//can declare j as j has internal scope</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// int i=0; will give redeclaration error</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

  <span class="n">f</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>If the declaration of a file scope identifier for an object or a function contains
          the storage-class specifier static, the identifier has <span class="italic">internal linkage</span>.<sup>[<a class="footnote" href="#ftn.idp1058512" name="idp1058512">17</a>]</sup></p><p>For example, consider the following program:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//internal scope not visible outside file</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// int i=0; same problem</span>
  <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//can declare j as j has internal scope</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// int i=0; will give redeclaration error</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

  <span class="n">f</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>For an identifier declared with the storage-class specifier <code class="code">extern</code>
          in a scope in which a prior declaration of that identifier is visible,<sup>[<a class="footnote" href="#ftn.idp1061728" name="idp1061728">18</a>]</sup>if the prior declaration specifies internal or external linkage, the linkage
          of the identifier at the later declaration is the same as the linkage specified at the
          prior declaration. If no prior declaration is visible, or if the prior declaration
          specifies no linkage, then the identifier has external linkage.</p><p>For example, consider the following programs:</p><pre class="CLexer"><div class="highlight"><pre><span class="c1">//test.c</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//external scope not visible outside file</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">f</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><pre class="CLexer"><div class="highlight"><pre><span class="c1">//test1.c</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</pre><p>compile them like <code class="code">gcc test.c test1.c -o out</code>.</p><p>The output is:</p><pre class="screen">0
0</pre><p>If the declaration of an identifier for a function has no storage-class specifier,
          its linkage is determined exactly as if it were declared with the storage-class specifier
            <code class="code">extern</code>. If the declaration of an identifier for an object has file
          scope and no storage-class specifier, its linkage is external.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">//external linkage can be called from other files</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="c1">//external linkage can be called from other files</span>
<span class="p">{</span>
  <span class="c1">//do something here</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>The following identifiers have no linkage: an identifier declared to be anything
          other than an object or a function; an identifier declared to be a function parameter; a
          block scope identifier for an object declared without the storage-class specifier
          extern.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="c1">//i has no linkage</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="c1">//no linkage</span>
    <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>If, within a translation unit, the same identifier appears with both internal and
          external linkage, the behavior is undefined.</p><p><span class="bold"><strong>Forward
            references:</strong></span> declarations (Declarations), expressions (Expressions), external
          definitions (External definitions), statements (Statements and blocks).</p></div><div class="sect2" title="4.2.3. Name Spaces of the Identifiers"><div class="titlepage"><div><div><h3 class="title"><a name="idp3289712"></a>4.2.3. Name Spaces of the Identifiers</h3></div></div></div><p>If more than one declaration of a particular identifier is visible at any point in a
          translation unit, the syntactic context disambiguates uses that refer to different
          entities. Thus, there are separate <span class="italic">name spaces</span> for various categories of identifiers, as
          follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="italic">label
                names</span> (disambiguated by the syntax of the label declaration and
              use);</p></li><li class="listitem"><p>the tags of structures, unions, and
              enumerations (disambiguated by following any<sup>[<a class="footnote" href="#ftn.idp3294720" name="idp3294720">19</a>]</sup>of the keywords <code class="code">struct, union</code> or <code class="code">enum</code>);</p></li><li class="listitem"><p>all other identifiers, called <code class="code">ordinary
                identifiers</code> (declared in ordinary declarators or as enumeration
              constants).</p></li></ul></div><p>For example, consider the following</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">struct</span> <span class="n">S</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">U</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">END</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">S</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">U</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">S</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">U</span> <span class="n">u</span><span class="p">;</span>

  <span class="n">s</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">u</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

  <span class="k">goto</span> <span class="n">END</span><span class="p">;</span>
  <span class="nl">END:</span> <span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p><span class="bold"><strong>Forward
            references:</strong></span> enumeration specifiers (Enumeration specifiers), labeled
          statements (Labeled statements), structure and union specifiers (Structure and union
          specifiers), structure and union members (Structure and union members), tags (Tags), the
          goto statement (The goto statement).</p></div><div class="sect2" title="4.2.4. Storage duration of objects"><div class="titlepage"><div><div><h3 class="title"><a name="idp3301568"></a>4.2.4. Storage duration of objects</h3></div></div></div><p>An object has a <span class="italic">storage duration</span> that determines its lifetime. There are three storage
          durations: static, automatic, and allocated. Allocated storage is described in <span class="italic">Memory management
            functions</span>.</p><p>The <span class="italic">lifetime</span> of an object is the portion of program execution during which
          storage is guaranteed to be reserved for it. An object exists, has a constant address,<sup>[<a class="footnote" href="#ftn.idp3305952" name="idp3305952">20</a>]</sup> and retains its last-stored value throughout its lifetime.<sup>[<a class="footnote" href="#ftn.idp3307120" name="idp3307120">21</a>]</sup> If an object is referred to outside of its lifetime, the behavior is
          undefined. The value of a pointer becomes indeterminate when the object it points to
          reaches the end of its lifetime.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>

    <span class="n">p</span><span class="o">=&amp;</span><span class="n">i</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//printf(&quot;%d\n&quot;, i) //will cause error</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="c1">//dangerous because i is dead</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">4 4
4</pre><p>Note that even though 4 has been printed for <code class="code">*p</code> that is because
          stack has not been touched. Make some function calls between brace and printf and most
          probably 4 will be overwritten.</p><p>An object whose identifier is declared with external or internal linkage, or with
          the storage-class specifier <code class="code">static</code> has <span class="italic">static storage duration</span>.
          Its lifetime is the entire execution of the program and its stored value is initialized
          only once, prior to program startup.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>
  <span class="n">f</span><span class="p">();</span>
  <span class="n">f</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">0
1
2</pre><p>An object whose identifier is declared with no linkage and without the storage-class
          specifier <code class="code">static</code> has <span class="italic">automatic storage duration</span>.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>
  <span class="n">f</span><span class="p">();</span>
  <span class="n">f</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">0
0
0</pre><p>For such an object that does not have a variable length array type, its lifetime
          extends from entry into the block with which it is associated until execution of that
          block ends in any way. (Entering an enclosed block or calling a function suspends, but
          does not end, execution of the current block.) If the block is entered recursively, a new
          instance of the object is created each time. The initial value of the object is
          indeterminate. If an initialization is specified for the object, it is performed each time
          the declaration is reached in the execution of the block; otherwise, the value becomes
          indeterminate each time the declaration is reached.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
  <span class="n">n</span><span class="o">++</span><span class="p">;</span>
  <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">0
0
0
0</pre><p>For such an object that does have a variable length array type, its lifetime extends
          from the declaration of the object until execution of the program leaves the scope of the declaration.<sup>[<a class="footnote" href="#ftn.idp3321984" name="idp3321984">22</a>]</sup> If the scope is entered recursively, a new instance of the object is created
          each time. The initial value of the object is indeterminate.</p><p><span class="bold"><strong>Forward
            references:</strong></span> statements (Statements and blocks), function calls (Function
          calls), declarators (Declarators), array declarators (Array declarators), initialization
          (Initialization).</p></div><div class="sect2" title="4.2.5. Types"><div class="titlepage"><div><div><h3 class="title"><a name="idp3324832"></a>4.2.5. Types</h3></div></div></div><p>The meaning of a value stored in an object or returned by a function is determined
          by the <span class="italic">type</span> of
          the expression used to access it. (An identifier declared to be an object is the simplest
          such expression; the type is specified in the declaration of the identifier.) Types are
          partitioned into <span class="italic">object
            types</span> (types that fully describe objects), <span class="italic">function types</span> (types
          that describe functions), and <span class="italic">incomplete types</span> (types that describe objects but lack
          information needed to determine their sizes).</p><p>An object declared as type <code class="code">_Bool</code> is large enough to store the
          values 0 and 1.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">_Bool</span> <span class="n">b</span><span class="o">=</span><span class="mi">23</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">_Bool</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">1 1</pre><p>Note that size of 1 byte which means whatever nonzero value we assign will be
          converted to 1 implicitly.</p><p>An object declared as type char is large enough to store any member of the basic
          execution character set. If a member of the basic execution character set is stored in a
            <code class="code">char</code> object, its value is guaranteed to be nonnegative. If any other
          character is stored in a char object, the resulting value is implementation-defined but
          shall be within the range of values that can be represented in that type.</p><p>First let us see how big is <code class="code">char</code>:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is 1. Now let us see what we can store in it.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;conio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="k">register</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="n">i</span><span class="o">&lt;</span><span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>It will show lots of non-printable characters as well. Run it as
            <span class="command"><strong>./a.out|od -c</strong></span> and maximum possible characters will be
          shown.</p><p>There are five standard <span class="italic">signed integer types</span>, designated as <code class="code">signed char, short
            int, int, long int</code> and <code class="code">long long int</code>. (These and other types
          may be designated in several additional ways, as described in Type specifiers.) There may
          also be implementation-defined <span class="italic">extended signed integer types</span>.<sup>[<a class="footnote" href="#ftn.idp3341456" name="idp3341456">23</a>]</sup> The standard and extended signed integer types are collectively called
          signed integer types.<sup>[<a class="footnote" href="#ftn.idp3342544" name="idp3342544">24</a>]</sup></p><p>An object declared as type signed char occupies the same amount of storage as a
          “plain” char object. A “plain” int object has the natural size suggested by the
          architecture of the execution environment (large enough to contain any value in the range
            <code class="code">INT_MIN</code> to <code class="code">INT_MAX</code> as defined in the header
            <code class="code"><limits.h></code>).</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;limits.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">-2147483648 2147483647</pre><p>which is much much greater than -127 and 128 possible for our 1 byte
          character.</p><p>For each of the signed integer types, there is a corresponding (but different)
          unsigned integer type (designated with the keyword <code class="code">unsigned</code>) that uses
          the same amount of storage (including sign information) and has the same alignment
          requirements. The type <code class="code">_Bool</code> and the <span class="italic">unsigned integer types</span>
          that correspond to the standard signed integer types are the standard unsigned integer
          types. The unsigned integer types that correspond to the extended signed integer types are
          the extended unsigned integer types. The standard and extended unsigned integer types are
          collectively called <span class="italic">unsigned
            integer types</span>.<sup>[<a class="footnote" href="#ftn.idp3351312" name="idp3351312">25</a>]</sup></p><p>The standard signed integer types and standard unsigned integer types are
          collectively called the <span class="italic">standard integer types</span>, the extended signed integer types and extended
          unsigned integer types are collectively called the <span class="italic">extended integer
          types</span>.</p><p>For any two integer types with the same signedness and different integer conversion
          rank (see Booleans, Characters and Integers), the range of values of the type with smaller
          integer conversion rank is a subrange of the values of the other type.</p><p>The range of nonnegative values of a signed integer type is a subrange of the
          corresponding unsigned integer type, and the representation of the same value in each type
          is the same.<sup>[<a class="footnote" href="#ftn.idp3355840" name="idp3355840">26</a>]</sup> A computation involving unsigned operands can never overflow, because a
          result that cannot be represented by the resulting unsigned integer type is reduced modulo
          the number that is one greater than the largest value that can be represented by the
          resulting type.</p><p>There are three real <span class="italic">floating types</span>, designated as <code class="code">float, double</code> and
            <code class="code">long double</code>. The set of values of the type <code class="code">float</code> is a
          subset of the set of values of the type <code class="code">double</code>; the set of values of the
          type <code class="code">double</code> is a subset of the set of values of the type <code class="code">long
            double</code>.</p><p>There are three <span class="italic">complex types</span>, designated as <code class="code">float _Complex, double
            _Complex,</code> and <code class="code">long double _Complex</code>. The real floating and
          complex types are collectively called the <span class="italic">floating types</span>.</p><p>For each floating type there is a <span class="italic">corresponding real type</span>, which is always a real floating type.
          For real floating types, it is the same type. For complex types, it is the type given by
          deleting the keyword <code class="code">_Complex</code> from the type name.</p><p>Each complex type has the same representation and alignment requirements as an array
          type containing exactly two elements of the corresponding real type; the first element is
          equal to the real part, and the second element to the imaginary part, of the complex
          number.</p><p>The type <code class="code">char</code>, the signed and unsigned integer types, and the
          floating types are collectively called the <span class="italic">basic types</span>. Even if the implementation defines two or more
          basic types to have the same representation, they are nevertheless different types.<sup>[<a class="footnote" href="#ftn.idp3368960" name="idp3368960">27</a>]</sup></p><p>The three types <code class="code">char, signed char</code> and <code class="code">unsigned
            char</code> are collectively called the <span class="italic">character types</span>. The
          implementation shall define <code class="code">char</code> to have the same range, representation,
          and behavior as either <code class="code">signed char</code> or <code class="code">unsigned char</code>.<sup>[<a class="footnote" href="#ftn.idp3373664" name="idp3373664">28</a>]</sup></p><p>An <span class="italic">enumeration</span> comprises a set of named integer constant values. Each distinct
          enumeration constitutes a different <span class="italic">enumerated type</span>.</p><p>The type <code class="code">char</code>, the signed and unsigned integer types, and the
          enumerated types are collectively called <span class="italic">integer types</span>. The integer and real floating types are
          collectively called <span class="italic">real
            types</span>.</p><p>Integer and floating types are collectively called <span class="italic">arithmetic types</span>. Each
          arithmetic type belongs to one <span class="italic">type domain</span>: the <span class="italic">real type domain</span>
          comprises the real types, the <span class="italic">complex type domain</span> comprises the complex types.</p><p>The <code class="code">void</code> type comprises an empty set of values; it is an incomplete
          type that cannot be completed.</p><p>Any number of <span class="italic">derived
            types</span> can be constructed from the object, function, and incomplete types, as
          follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>An <span class="italic">array
                type</span> describes a contiguously allocated nonempty set of objects with a
              particular member object type, called the <span class="italic">element
                type</span>.<sup>[<a class="footnote" href="#ftn.idp3389664" name="idp3389664">29</a>]</sup>Array types are characterized by their element type and by the number of
              elements in the array. An array type is said to be derived from its element type, and
              if its element type is <span class="italic">T</span>, the array type is
              sometimes called “array of <span class="italic">T</span>”. The construction of
              an array type from an element type is called “array type derivation”.</p></li><li class="listitem"><p>A <span class="italic">structure
                type</span> describes a sequentially allocated nonempty set of member objects
              (and, in certain circumstances, an incomplete array), each of which has an optionally
              specified name and possibly distinct type.</p></li><li class="listitem"><p>A <span class="italic">union
                type</span> describes an overlapping nonempty set of member objects, each of
              which has an optionally specified name and possibly distinct type.</p></li><li class="listitem"><p>A <span class="italic">function
                type</span> describes a function with specified return type. A function type is
              characterized by its return type and the number and types of its parameters. A
              function type is said to be derived from its return type, and if its return type is
                <span class="italic">T</span>, the function type is sometimes called
              “function returning <span class="italic">T</span>”. The construction of a
              function type from a return type is called “function type derivation”.</p></li><li class="listitem"><p>A pointer type may be derived from a
              function type, an object type, or an incomplete type, called the referenced type. A
              pointer type describes an object whose value provides a reference to an entity of the
              referenced type. A pointer type derived from the referenced type <span class="italic">T</span> is sometimes called “pointer to <span class="italic">T</span>”. The construction of a pointer type from a referenced type is called
              “pointer type derivation”.</p></li></ul></div><p>These methods of constructing derived types can be applied recursively. What this
          mean is you can have structures of structrues of structures and so on. Similarly, you can
          have array of array of array and so on. And you can have array of array of array of such
          structures of structures of structures ... .</p><p>Arithmetic types and pointer types are collectively called <span class="italic">scalar types</span>. Array and
          structure types are collectively called <span class="italic">aggregate types</span>.<sup>[<a class="footnote" href="#ftn.idp3406032" name="idp3406032">30</a>]</sup></p><p>An array type of unknown size is an incomplete type. It is completed, for an
          identifier of that type, by specifying the size in a later declaration (with internal or
          external linkage). A structure or union type of unknown content (as described in Tags) is
          an incomplete type. It is completed, for all declarations of that type, by declaring the
          same structure or union tag with its defining content later in the same scope.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="n">S</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//incomplete type at this moment</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="n">S</span><span class="p">;</span> <span class="c1">//type completed here</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>Array, function, and pointer types are collectively called <span class="italic">derived declarator types</span>.
          A <span class="italic">declarator type
            derivation</span> from a type <span class="italic">T</span> is the construction of a derived declarator type from
            <span class="italic">T</span> by the
          application of an array-type, a function-type, or a pointer-type derivation to <span class="italic">T</span>.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="n">S</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="n">S</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">S</span> <span class="n">s1</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">s1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">S</span> <span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">)()</span>
<span class="p">{</span>
  <span class="n">S</span> <span class="n">s2</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">s2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="n">S</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>A type is characterized by its <span class="italic">type category</span>, which is either the outermost derivation of a
          derived type (as noted above in the construction of derived type), or the type itself if
          the type consists of no derived types.</p><p>Any type so far mentioned is an unqualified type. Each unqualified type has several
          qualified versions of its type,<sup>[<a class="footnote" href="#ftn.idp3416352" name="idp3416352">31</a>]</sup> corresponding to the combinations of one, two, or all three of the
            <code class="code">const, volatile</code> and <code class="code">restrict</code> qualifiers. The qualified
          or unqualified versions of a type are distinct types that belong to the same type category
          and have the same representation and alignment requirements.<sup>[<a class="footnote" href="#ftn.a" name="a">32</a>]</sup> A derived type is not qualified by the qualifiers (if any) of the type from
          which it is derived.</p><p>A pointer to void shall have the same representation and alignment requirements as a
          pointer to a character type.<sup>[<a class="footnoteref" href="index.html#ftn.a">32</a>]</sup> Similarly, pointers to qualified
          or unqualified versions of compatible types shall have the same representation and
          alignment requirements. All pointers to structure types shall have the same representation
          and alignment requirements as each other. All pointers to union types shall have the same
          representation and alignment requirements as each other. Pointers to other types need not
          have the same representation or alignment requirements.</p></div><div class="sect2" title="4.2.6. Representation of Types"><div class="titlepage"><div><div><h3 class="title"><a name="idp3434384"></a>4.2.6. Representation of Types</h3></div></div></div><div class="sect3" title="4.2.6.1. General"><div class="titlepage"><div><div><h4 class="title"><a name="idp3435232"></a>4.2.6.1. General</h4></div></div></div><p>The representations of all types are unspecified except as stated in this
            subclause.</p><p>Except for bit-fields, objects are composed of contiguous sequences of one or more
            bytes, the number, order, and encoding of which are either explicitly specified or
            implementation-defined.</p><p>Values stored in unsigned bit-fields and objects of type <code class="code">unsigned
              char</code> shall be represented using a pure binary notation.<sup>[<a class="footnote" href="#ftn.idp3438080" name="idp3438080">33</a>]</sup></p><p>Values stored in non-bit-field objects of any other object type consist of
              <span class="italic">n x</span>
<code class="code">CHAR_BIT</code> bits, where n is the size of an object of that type, in bytes.
            The value may be copied into an object of type unsigned char <span class="italic">[n]</span> (e.g., by memcpy);
            the resulting set of bytes is called the object representation of the value. Values
            stored in bit-fields consist of <span class="italic">m</span> bits, where m is the size specified for the bit-field. The
            object representation is the set of <span class="italic">m</span> bits the bit-field comprises in the addressable storage
            unit holding it. Two values (other than NaNs) with the same object representation
            compare equal, but values that compare equal may have different object
            representations.</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">char</span>   <span class="n">c</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
  <span class="kt">int</span>    <span class="n">i</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span><span class="n">S</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">S</span> <span class="n">s</span><span class="p">;</span>

  <span class="n">s</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
  <span class="n">s</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">0 -3</pre><p>Consider the following program:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span>    <span class="n">i</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="n">S</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">S</span> <span class="n">s</span><span class="p">;</span>

  <span class="n">s</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>what do you think the output will be? 0 to 1 that is what my gut feeling tells me
            but I am wrong. With <span class="italic">N</span> bits the range of integer is <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mo>−</mo>
<msup>
<mn>2</mn>
<mi>N</mi>
</msup>
<mo>−</mo>
<mn>1</mn>
</math> to <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>N</mi>
<mo>−</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>−</mo>
<mo>−</mo>
<mn>1</mn>
</math>. This evaluates to -1 to 0. So any even no. stored in 1 bits field
            is 0 and any odd no. is -1. Useful for finding odd and even numbers eh?</p><p>The output is:</p><pre class="screen">-1</pre><p>Certain object representations need not represent a value of the object type. If
            the stored value of an object has such a representation and is read by an lvalue
            expression that does not have character type, the behavior is undefined. If such a
            representation is produced by a side effect that modifies all or any part of the object
            by an lvalue expression that does not have character type, the behavior is undefined.<sup>[<a class="footnote" href="#ftn.idp3468496" name="idp3468496">34</a>]</sup> Such a representation is called a <span class="italic">trap
              representation</span>.</p><p>There are two places where trap representation has been talked about in the
            specification. First is parity bits on numeric types which are visible to software. This
            is given in footnote 44 of n1124.pdf at page no. 38. Second is negative zeros in
            non-twos-complement architecture, given on page 39.</p><p>When a value is stored in an object of structure or union type, including in a
            member object, the bytes of the object representation that correspond to any padding
            bytes take unspecified values.<sup>[<a class="footnote" href="#ftn.idp3471776" name="idp3471776">35</a>]</sup> The value of a structure or union object is never a trap representation,
            even though the value of a member of the structure or union object may be a trap
            representation.</p><p>When a value is stored in a member of an object of union type, the bytes of the
            object representation that do not correspond to that member but do correspond to other
            members take unspecified values. What this means is that say you have two members where
            one is of <span class="italic">m</span> bytes and another of <span class="italic">n</span> bytes and <span class="italic">m>n</span>.
            Then if you assign value to one having <span class="italic">n</span> bytes
            then <span class="italic">m - n</span> bytes will have unspecified
            value.</p><p>Where an operator is applied to a value that has more than one object
            representation, which object representation is used shall not affect the value of the result.<sup>[<a class="footnote" href="#ftn.idp3477936" name="idp3477936">36</a>]</sup> Where a value is stored in an object using a type that has more than one
            object representation for that value, it is unspecified which representation is used,
            but a trap representation shall not be generated.</p><p>For example, char is integral type. Therefore all operations of integers can be
            done on characters.</p><p><span class="bold"><strong>Forward references:</strong></span> declarations
            (Declarations), expressions (Expressions), lvalues, arrays, and function designators
            (Other Operands).</p></div><div class="sect3" title="4.2.6.2. Integer Types"><div class="titlepage"><div><div><h4 class="title"><a name="idp3487872"></a>4.2.6.2. Integer Types</h4></div></div></div><p>For unsigned integer types other than unsigned char, the bits of the object
            representation shall be divided into two groups: value bits and padding bits (there need
            not be any of the latter). If there are <span class="italic">N</span> value
            bits, each bit shall represent a different power of 2 between 1 and <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>N</mi>
<mo>−</mo>
<mn>1</mn>
</mrow>
</msup>
</math>, so that objects of that type shall be capable of representing
            values from 0 to <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>N</mi>
<mo>−</mo>
<mn>1</mn>
</mrow>
</msup>
</math> using a pure binary representation; this shall be known as the value
            representation. The values of any padding bits are unspecified. <sup>[<a class="footnote" href="#ftn.idp3498352" name="idp3498352">37</a>]</sup></p><p>For signed integer types, the bits of the object representation shall be divided
            into three groups: value bits, padding bits, and the sign bit. There need not be any
            padding bits; there shall be exactly one sign bit. Each bit that is a value bit shall
            have the same value as the same bit in the object representation of the corresponding
            unsigned type (if there are <span class="italic">M</span> value bits in the
            signed type and <span class="italic">N</span> in the unsigned type, then
              <span class="italic">M <= N</span>). If the sign bit is zero, it shall
            not affect the resulting value. If the sign bit is one, the value shall be modified in
            one of the following ways:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>the corresponding value with sign bit 0 is negated <span class="italic">(sign and magnitude);</span></p></li><li class="listitem"><p>the sign bit has the value <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<msup>
<mn>2</mn>
<mi>N</mi>
</msup>
</math>
<span class="italic">(two's complement);</span></p></li><li class="listitem"><p>the sign bit has the value <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<msup>
<mn>2</mn>
<mi>N</mi>
</msup>
<mo>−</mo>
<mn>1</mn>
</math>
<span class="italic">(ones' complement).</span></p></li></ul></div><p>Which of these applies is implementation-defined, as is whether the value with
            sign bit 1 and all value bits zero (for the first two), or with sign bit and all value
            bits 1 (for one’s complement), is a trap representation or a normal value. In the case
            of sign and magnitude and one's complement, if this representation is a normal value it
            is called a negative zero.</p><p>If the implementation supports negative zeros, they shall be generated only
            by:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>the &, |, ^, ~, <<, and >> operators with arguments that produce
                such a value;</p></li><li class="listitem"><p>the +, -, *, /, and % operators where one argument is a negative zero and the
                result is zero;</p></li><li class="listitem"><p>compound assignment operators based on the above cases.</p></li></ul></div><p>It is unspecified whether these cases actually generate a negative zero or a
            normal zero, and whether a negative zero becomes a normal zero when stored in an
            object.</p><p>If the implementation does not support negative zeros, the behavior of the &,
            |, ^, ~, <<, and >> operators with arguments that would produce such a value is
            undefined.</p><p>The values of any padding bits are unspecified.<sup>[<a class="footnote" href="#ftn.idp3519904" name="idp3519904">38</a>]</sup> A valid (non-trap) object representation of a signed integer type where
            the sign bit is zero is a valid object representation of the corresponding unsigned
            type, and shall represent the same value. For any integer type, the object
            representation where all the bits are zero shall be a representation of the value zero
            in that type.</p><p>The <span class="italic">precision</span> of an integer type is the
            number of bits it uses to represent values, excluding any sign and padding bits. The
              <span class="italic">width</span> of an integer type is the same but
            including any sign bit; thus for unsigned integer types the two values are the same,
            while for signed integer types the width is one greater than the precision.</p></div></div><div class="sect2" title="4.2.7. Compatible and Composite Types"><div class="titlepage"><div><div><h3 class="title"><a name="idp3524336"></a>4.2.7. Compatible and Composite Types</h3></div></div></div><p>Two types have compatible type if their types are the same. Additional rules for
          determining whether two types are compatible are described in Type specifiers for type
          specifiers, in Type qualifiers for type qualifiers, and in Declarators for declarators.<sup>[<a class="footnote" href="#ftn.idp3525632" name="idp3525632">39</a>]</sup> Moreover, two structure, union, or enumerated types declared in separate
          translation units are compatible if their tags and members satisfy the following
          requirements: If one is declared with a tag, the other shall be declared with the same
          tag. If both are complete types, then the following additional requirements apply: there
          shall be a one-to-one correspondence between their members such that each pair of
          corresponding members are declared with compatible types, and such that if one member of a
          corresponding pair is declared with a name, the other member is declared with the same
          name. For two structures, corresponding members shall be declared in the same order. For
          two structures or unions, corresponding bit-fields shall have the same widths. For two
          enumerations, corresponding members shall have the same values.</p><p>All declarations that refer to the same object or function shall have compatible
          type; otherwise, the behavior is undefined.</p><p>A <span class="italic">composite type</span> can be constructed from two
          types that are compatible; it is a type that is compatible with both of the two types and
          satisfies the following conditions:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If one type is an array of known constant size, the composite type is an array
              of that size; otherwise, if one type is a variable length array, the composite type is
              that type.</p></li><li class="listitem"><p>If only one type is a function type with a parameter type list (a function
              prototype), the composite type is a function prototype with the parameter type
              list.</p></li><li class="listitem"><p>If both types are function types with parameter type lists, the type of each
              parameter in the composite parameter type list is the composite type of the
              corresponding parameters.</p></li></ul></div><p>These rules apply recursively to the types from which the two types are
          derived.</p><p>For an identifier with internal or external linkage declared in a scope in which a
          prior declaration of that identifier is visible,<sup>[<a class="footnote" href="#ftn.idp3534160" name="idp3534160">40</a>]</sup> if the prior declaration specifies internal or external linkage, the type of
          the identifier at the later declaration becomes the composite type.</p></div></div><div class="sect1" title="4.3. Conversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp3535776"></a>4.3. Conversion</h2></div></div></div><p>Several operators convert operand values from one type to another automatically. This
        subclause specifies the result required from such an implicit conversion, as well as those
        that result from a cast operation (an explicit conversion). The list in 4.3.1.8 summarizes
        the conversions performed by most ordinary operators; it is supplemented as required by the
        discussion of each operator in 4.5.</p><p>Conversion of an operand value to a compatible type causes no change to the value or
        the representation.</p><p><span class="bold"><strong>Forward references:</strong></span> cast operators (Cast
        operators).</p><div class="sect2" title="4.3.1. Arithmetics Operands"><div class="titlepage"><div><div><h3 class="title"><a name="idp3538960"></a>4.3.1. Arithmetics Operands</h3></div></div></div><div class="sect3" title="4.3.1.1. Booleans, Characters and Integers"><div class="titlepage"><div><div><h4 class="title"><a name="idp3539696"></a>4.3.1.1. Booleans, Characters and Integers</h4></div></div></div><p>Every integer type has an <span class="italic">integer conversion
              rank</span> defined as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>No two signed integer types shall have the same rank, even if they have the
                same representation.</p></li><li class="listitem"><p>The rank of a signed integer type shall be greater than the rank of any signed
                integer type with less precision.</p></li><li class="listitem"><p>The rank of <code class="code">long long int</code> shall be greater than the rank of
                  <code class="code">long int</code>, which shall be greater than the rank of
                  <code class="code">int</code>, which shall be greater than the rank of <code class="code">short
                  int</code>, which shall be greater than the rank of <code class="code">signed
                char</code>.</p></li><li class="listitem"><p>The rank of any unsigned integer type shall equal the rank of the
                corresponding signed integer type, if any.</p></li><li class="listitem"><p>The rank of any standard integer type shall be greater than the rank of any
                extended integer type with the same width. The rank of <code class="code">char</code> shall
                equal the rank of <code class="code">signed char</code> and <code class="code">unsigned
                char</code>.</p></li><li class="listitem"><p>The rank of <code class="code">_Bool</code> shall be less than the rank of all other
                standard integer types.</p></li><li class="listitem"><p>The rank of any enumerated type shall equal the rank of the compatible integer
                type (see Enumeration specifiers).</p></li><li class="listitem"><p>The rank of any extended signed integer type relative to another extended
                signed integer type with the same precision is implementation-defined, but still
                subject to the other rules for determining the integer conversion rank.</p></li><li class="listitem"><p>For all integer types <code class="code">T1, T2,</code> and <code class="code">T3</code>, if
                  <code class="code">T1</code> has greater rank than <code class="code">T2</code> and
                  <code class="code">T2</code> has greater rank than <code class="code">T3</code>, then
                  <code class="code">T1</code> has greater rank than <code class="code">T3</code>.</p></li></ul></div><p>The following may be used in an expression wherever an int or unsigned int may be
            used:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>An object or expression with an integer
                type whose integer conversion rank is less than or equal to the rank of
                  <code class="code">int</code> and <code class="code">unsigned int</code>.</p></li><li class="listitem"><p>A bit-field of type <code class="code">_Bool, int,
                  signed int,</code> or <code class="code">unsigned int</code>.</p></li></ul></div><p>If an int can represent all values of the original type, the value is converted to
            an int; otherwise, it is converted to an unsigned int. These are called the integer promotions.<sup>[<a class="footnote" href="#ftn.idp3564288" name="idp3564288">41</a>]</sup> All other types are unchanged by the integer promotions.</p><p>The integer promotions preserve value including sign. As discussed earlier,
            whether a “plain” char is treated as signed is implementation-defined.</p><p><span class="bold"><strong>Forward
              references:</strong></span> enumeration specifiers (Enumeration specifiers), structure and
            union specifiers (Structure and union specifiers).</p></div><div class="sect3" title="4.3.1.2. Boolean Type"><div class="titlepage"><div><div><h4 class="title"><a name="idp3567680"></a>4.3.1.2. Boolean Type</h4></div></div></div><p>When any scalar value is converted to <code class="code">_Bool</code>, the result is 0 if
            the value compares equal to 0; otherwise, the result is 1.</p></div><div class="sect3" title="4.3.1.3. Signed and Unsigned Integers"><div class="titlepage"><div><div><h4 class="title"><a name="idp3569680"></a>4.3.1.3. Signed and Unsigned Integers</h4></div></div></div><p>When a value with integer type is converted to another integer type other than
              <code class="code">_Bool</code>, if the value can be represented by the new type, it is
            unchanged.</p><p>Otherwise, if the new type is unsigned, the value is converted by repeatedly
            adding or subtracting one more than the maximum value that can be represented in the new
            type until the value is in the range of the new type.<sup>[<a class="footnote" href="#ftn.idp3572096" name="idp3572096">42</a>]</sup></p><p>Otherwise, the new type is signed and the value cannot be represented in it;
            either the result is implementation-defined or an implementation-defined signal is
            raised.</p></div><div class="sect3" title="4.3.1.4. Real Floating and Integer"><div class="titlepage"><div><div><h4 class="title"><a name="idp3573872"></a>4.3.1.4. Real Floating and Integer</h4></div></div></div><p>When a finite value of real floating type is converted to an integer type other
            than <code class="code">_Bool</code>, the fractional part is discarded (i.e., the value is
            truncated toward zero). If the value of the integral part cannot be represented by the
            integer type, the behavior is undefined.<sup>[<a class="footnote" href="#ftn.idp3575744" name="idp3575744">43</a>]</sup></p></div><div class="sect3" title="4.3.1.5. Real Floating Types"><div class="titlepage"><div><div><h4 class="title"><a name="idp3578352"></a>4.3.1.5. Real Floating Types</h4></div></div></div><p>When a <code class="code">float</code> is promoted to <code class="code">double</code> or
              <code class="code">long double</code>, or a <code class="code">double</code> is promoted to <code class="code">long
              double</code>, its value is unchanged. When a <code class="code">double</code> is demoted to
              <code class="code">float</code>, a l<code class="code">ong double</code> is demoted to
              <code class="code">double</code> or <code class="code">float</code>, or a value being represented in
            greater precision and range than required by its semantic type (see Usual Arithmetic
            Conversions) is explicitly converted to its semantic type, if the value being converted
            can be represented exactly in the new type, it is unchanged. If the value being
            converted is in the range of values that can be represented but cannot be represented
            exactly, the result is either the nearest higher or nearest lower representable value,
            chosen in an implementation-defined manner. If the value being converted is outside the
            range of values that can be represented, the behavior is undefined.</p></div><div class="sect3" title="4.3.1.6. Complex Types"><div class="titlepage"><div><div><h4 class="title"><a name="idp3585040"></a>4.3.1.6. Complex Types</h4></div></div></div><p>When a value of complex type is converted to another complex type, both the real
            and imaginary parts follow the conversion rules for the corresponding real
            types.</p></div><div class="sect3" title="4.3.1.7. Real and Complex"><div class="titlepage"><div><div><h4 class="title"><a name="idp3586672"></a>4.3.1.7. Real and Complex</h4></div></div></div><p>When a value of real type is converted to a complex type, the real part of the
            complex result value is determined by the rules of conversion to the corresponding real
            type and the imaginary part of the complex result value is a positive zero or an
            unsigned zero. When a value of complex type is converted to a real type, the imaginary
            part of the complex value is discarded and the value of the real part is converted
            according to the conversion rules for the corresponding real type.</p></div><div class="sect3" title="4.3.1.8. Usual Arithmetic Conversion"><div class="titlepage"><div><div><h4 class="title"><a name="idp3588656"></a>4.3.1.8. Usual Arithmetic Conversion</h4></div></div></div><p>Many operators that expect operands of arithmetic type cause conversions and yield
            result types in a similar way. The purpose is to determine a <span class="italic">common real typ</span>e for
            the operands and result. For the specified operands, each operand is converted, without
            change of type domain, to a type whose corresponding real type is the common real type.
            Unless explicitly stated otherwise, the common real type is also the corresponding real
            type of the result, whose type domain is the type domain of the operands if they are the
            same, and complex otherwise. This pattern is called the <span class="italic">usual arithmetic
              conversions</span>:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>First, if the corresponding real type of
                either operand is long double, the other operand is converted, without change of
                type domain, to a type whose corresponding real type is <code class="code">long
                double</code>.</p></li><li class="listitem"><p>Otherwise, if the corresponding real type
                of either operand is double, the other operand is converted, without change of type
                domain, to a type whose corresponding real type is <code class="code">double</code>.</p></li><li class="listitem"><p>Otherwise, if the corresponding real type
                of either operand is float, the other operand is converted, without change of type
                domain, to a type whose corresponding real type is <code class="code">float</code>.<sup>[<a class="footnote" href="#ftn.idp3597200" name="idp3597200">44</a>]</sup></p></li><li class="listitem"><p>Otherwise, the integer promotions are
                performed on both operands. Then the following rules are applied to the promoted
                operands:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>If both operands have the same type,
                    then no further conversion is needed.</p></li><li class="listitem"><p>Otherwise, if both operands have
                    signed integer types or both have unsigned integer types, the operand with the
                    type of lesser integer conversion rank is converted to the type of the operand
                    with greater rank.</p></li><li class="listitem"><p>Otherwise, if the operand that has
                    unsigned integer type has rank greater or equal to the rank of the type of the
                    other operand, then the operand with signed integer type is converted to the
                    type of the operand with unsigned integer type.</p></li><li class="listitem"><p>Otherwise, if the type of the operand
                    with signed integer type can represent all of the values of the type of the
                    operand with unsigned integer type, then the operand with unsigned integer type
                    is converted to the type of the operand with signed integer type.</p></li><li class="listitem"><p>Otherwise, both operands are converted
                    to the unsigned integer type corresponding to the type of the operand with
                    signed integer type.</p></li></ul></div></li></ul></div><p>The values of floating operands and of the results of floating expressions may be
            represented in greater precision and range than that required by the type; the types are
            not changed thereby.<sup>[<a class="footnote" href="#ftn.idp3608944" name="idp3608944">45</a>]</sup></p></div></div><div class="sect2" title="4.3.2. Other Operands"><div class="titlepage"><div><div><h3 class="title"><a name="idp3610336"></a>4.3.2. Other Operands</h3></div></div></div><div class="sect3" title="4.3.2.1. Lvalues, Arrays and Function Designators"><div class="titlepage"><div><div><h4 class="title"><a name="idp3611184"></a>4.3.2.1. Lvalues, Arrays and Function
            Designators</h4></div></div></div><p>An <span class="italic">lvalue</span>
            is an expression with an object type or an incomplete type other than
              <code class="code">void</code>;<sup>[<a class="footnote" href="#ftn.idp3613712" name="idp3613712">46</a>]</sup> if an lvalue does not designate an object when it is evaluated, the
            behavior is undefined. When an object is said to have a particular type, the type is
            specified by the lvalue used to designate the object. A <span class="italic">modifiable lvalue</span> is an
            lvalue that does not have array type, does not have an incomplete type, does not have a
            const-qualified type, and if it is a structure or union, does not have any member
            (including, recursively, any member or element of all contained aggregates or unions)
            with a const-qualified type.</p><p>Except when it is the operand of the <code class="code">sizeof</code> operator, the unary
            & operator, the ++ operator, the – operator, or the left operand of the . operator
            or an assignment operator, an lvalue that does not have array type is converted to the
            value stored in the designated object (and is no longer an lvalue). If the lvalue has
            qualified type, the value has the unqualified version of the type of the lvalue;
            otherwise, the value has the type of the lvalue. If the lvalue has an incomplete type
            and does not have array type, the behavior is undefined.</p><p>Except when it is the operand of the <code class="code">sizeof</code> operator or the unary
            & operator, or is a string literal used to initialize an array, an expression that
            has type “array of type” is converted to an expression with type “pointer to type” that
            points to the initial element of the array object and is not an lvalue. If the array
            object has register storage class, the behavior is undefined.</p><p>A <span class="italic">function
              designator</span> is an expression that has function type. Except when it is the
            operand of the <code class="code">sizeof</code> operator<sup>[<a class="footnote" href="#ftn.idp3624944" name="idp3624944">47</a>]</sup> or the unary & operator, a function designator with type “function
            returning type” is converted to an expression that has type “pointer to function
            returning type”.</p><p>For example, consider following:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>
  <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)();</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)();</span>
  <span class="p">(</span><span class="o">**</span><span class="n">f</span><span class="p">)();</span>
  <span class="p">(</span><span class="o">***</span><span class="n">f</span><span class="p">)();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>and the output is:</p><pre class="screen">Hello
Hello
Hello
Hello
Hello</pre><p><span class="bold"><strong>Forward
              references:</strong></span> address and indirection operators (Address and indirection
            operators), assignment operators (Assignment operators), common definitions
              <code class="code"><stddef.h></code> (Common definitions <code class="code"><stddef.h></code>),
            initialization (Initialization), postfix increment and decrement operators (Postfix
            increment and decrement operators), prefix increment and decrement operators (Prefix
            increment and decrement operators), the sizeof operator (The sizeof operator), structure
            and union members (Structure and union members).</p></div><div class="sect3" title="4.3.2.2. void"><div class="titlepage"><div><div><h4 class="title"><a name="idp3631200"></a>4.3.2.2. void</h4></div></div></div><p>The (nonexistent) value of a <span class="italic">void expression</span> (an expression that has type void) shall not
            be used in any way, and implicit or explicit conversions (except to
              <code class="code">void</code>) shall not be applied to such an expression. If an expression of
            any other type is evaluated as a void expression, its value or designator is discarded.
            (A void expression is evaluated for its side effects.)</p></div><div class="sect3" title="4.3.2.3. Pointers"><div class="titlepage"><div><div><h4 class="title"><a name="idp3634304"></a>4.3.2.3. Pointers</h4></div></div></div><p>A pointer to void may be converted to or from a pointer to any incomplete or
            object type. A pointer to any incomplete or object type may be converted to a pointer to
              <code class="code">void</code> and back again; the result shall compare equal to the original
            pointer.</p><p>For any qualifier q, a pointer to a non-q-qualified type may be converted to a
            pointer to the q-qualified version of the type; the values stored in the original and
            converted pointers shall compare equal.</p><p>An integer constant expression with the value 0, or such an expression cast to
            type <code class="code">void *</code>, is called a <span class="italic">null pointer constant</span>.<sup>[<a class="footnote" href="#ftn.idp3638592" name="idp3638592">48</a>]</sup> If a null pointer constant is converted to a pointer type, the resulting
            pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any
            object or function.</p><p>Conversion of a null pointer to another pointer type yields a null pointer of that
            type. Any two null pointers shall compare equal.</p><p>An integer may be converted to any pointer type. Except as previously specified,
            the result is implementation-defined, might not be correctly aligned, might not point to
            an entity of the referenced type, and might be a trap representation.<sup>[<a class="footnote" href="#ftn.idp3641904" name="idp3641904">49</a>]</sup></p><p>Any pointer type may be converted to an integer type. Except as previously
            specified, the result is implementation-defined. If the result cannot be represented in
            the integer type, the behavior is undefined. The result need not be in the range of
            values of any integer type.</p><p>A pointer to an object or incomplete type may be converted to a pointer to a
            different object or incomplete type. If the resulting pointer is not correctly aligned<sup>[<a class="footnote" href="#ftn.idp3644176" name="idp3644176">50</a>]</sup> for the pointed-to type, the behavior is undefined. Otherwise, when
            converted back again, the result shall compare equal to the original pointer. When a
            pointer to an object is converted to a pointer to a character type, the result points to
            the lowest addressed byte of the object. Successive increments of the result, up to the
            size of the object, yield pointers to the remaining bytes of the object.</p><p>A pointer to a function of one type may be converted to a pointer to a function of
            another type and back again; the result shall compare equal to the original pointer. If
            a converted pointer is used to call a function whose type is not compatible with the
            pointed-to type, the behavior is undefined.</p><p><span class="bold"><strong>Forward
              references:</strong></span> cast operators (Cast operators), equality operators (Equality
            operators), integer types capable of holding object pointers (Integer types capable of
            holding object pointers), simple assignment (Simple assignment).</p></div></div></div><div class="sect1" title="4.4. Lexical Elements"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp3648560"></a>4.4. Lexical Elements</h2></div></div></div><p><span class="bold"><strong>Constraint</strong></span></p><p>Each preprocessing token that is converted to a token shall have the lexical form of a
        keyword, an identifier, a constant, a string literal, or a punctuator.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A <span class="italic">token</span> is
        the minimal lexical element of the language in translation phases 7 and 8. The categories of
        tokens are: keywords, identifiers, constants, string literals, and punctuators. A
        preprocessing token is the minimal lexical element of the language in translation phases 3
        through 6. The categories of preprocessing tokens are: header names, identifiers,
        preprocessing numbers, character constants, string literals, punctuators, and single
        non-white-space characters that do not lexically match the other preprocessing token categories.<sup>[<a class="footnote" href="#ftn.idp3653600" name="idp3653600">51</a>]</sup> If a ‘ or a ” character matches the last category, the behavior is undefined.
        Preprocessing tokens can be separated by white space; this consists of comments (described
        later), or white-space characters (space, horizontal tab, new-line, vertical tab, and
        form-feed), or both. As described in Preprocessing Directives, in certain circumstances
        during translation phase 4, white space (or the absence thereof) serves as more than
        preprocessing token separation. White space may appear within a preprocessing token only as
        part of a header name or between the quotation characters in a character constant or string
        literal.</p><p>If the input stream has been parsed into preprocessing tokens up to a given character,
        the next preprocessing token is the longest sequence of characters that could constitute a
        preprocessing token. There is one exception to this rule: a header name preprocessing token
        is only recognized within a <code class="code">#include</code> preprocessing directive, and within
        such a directive, a sequence of characters that could be either a header name or a string
        literal is recognized as the former.</p><p>EXAMPLE 1 The program fragment <code class="code">1Ex</code> is parsed as a preprocessing
        number token (one that is not a valid floating or integer constant token), even though a
        parse as the pair of preprocessing tokens 1 and <code class="code">Ex</code> might produce a valid
        expression (for example, if <code class="code">Ex</code> were a macro defined as +1). Similarly, the
        program fragment <code class="code">1E1</code> is parsed as a preprocessing number (one that is a
        valid floating constant token), whether or not <code class="code">E</code> is a macro name.</p><p>EXAMPLE 2 The program fragment <code class="code">x+++++y</code> is parsed as <code class="code">x ++ ++ +
          y</code>, which violates a constraint on increment operators, even though the parse
          <code class="code">x ++ + ++ y</code> might yield a correct expression.</p><p><span class="bold"><strong>Forward
          references:</strong></span> character constants (Character constants), comments (Comments),
        expressions (Expressions), floating constants (Floating Constants), header names (Header
        names), macro replacement (Macro Replacement), postfix increment and decrement operators
        (Postfix increment and decrement operators), prefix increment and decrement operators
        (Prefix increment and decrement operators), preprocessing directives (Preprocessing
        Directives), preprocessing numbers (Preprocessing numbers), string literals (String
        literals).</p><div class="sect2" title="4.4.1. Keywords"><div class="titlepage"><div><div><h3 class="title"><a name="idp3663440"></a>4.4.1. Keywords</h3></div></div></div><p>List of keywords are given in Environmental considerations</p><p>The keywords token (case sensitive) are reserved (in translation phases 7 and 8) for
          use as keywords, and shall not be used otherwise. The keyword <code class="code">_Imaginary</code>
          is reserved for specifying imaginary types.<sup>[<a class="footnote" href="#ftn.idp3665696" name="idp3665696">52</a>]</sup></p></div><div class="sect2" title="4.4.2. Identifiers"><div class="titlepage"><div><div><h3 class="title"><a name="idp3666800"></a>4.4.2. Identifiers</h3></div></div></div><div class="sect3" title="4.4.2.1. General"><div class="titlepage"><div><div><h4 class="title"><a name="idp3667648"></a>4.4.2.1. General</h4></div></div></div><p>The characterset for ideantifiers is given in The C Character Set.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>An identifier is a sequence of nondigit characters (including the underscore _,
            the lowercase and uppercase Latin letters, and other characters) and digits, which
            designates one or more entities as described in Scope of Identifiers. Lowercase and
            uppercase letters are distinct. There is no specific limit on the maximum length of an
            identifier.</p><p>Each universal character name in an identifier shall designate a character whose
            encoding in ISO/IEC 10646 falls into one of the ranges specified in annex D.<sup>[<a class="footnote" href="#ftn.idp3671232" name="idp3671232">53</a>]</sup> The initial character shall not be a universal character name designating
            a digit. An implementation may allow multibyte characters that are not part of the basic
            source character set to appear in identifiers; which characters and their correspondence
            to universal character names is implementation-defined.</p><p>When preprocessing tokens are converted to tokens during translation phase 7, if a
            preprocessing token could be converted to either a keyword or an identifier, it is
            converted to a keyword.</p><p><span class="bold"><strong>Implementation
              Limits</strong></span></p><p>As discussed in Translation limits, an implementation may limit the number of
            significant initial characters in an identifier; the limit for an <span class="italic">external name</span> (an
            identifier that has external linkage) may be more restrictive than that for an <span class="italic">internal name</span> (a macro
            name or an identifier that does not have external linkage). The number of significant
            characters in an identifier is implementation-defined.</p><p>Any identifiers that differ in a significant character are different identifiers.
            If two identifiers differ only in nonsignificant characters, the behavior is
            undefined.</p><p><span class="bold"><strong>Forward
              references:</strong></span> universal character names (Universal character names), macro
            replacement (Macro Replacement).</p></div><div class="sect3" title="4.4.2.2. Predefined Identifiers"><div class="titlepage"><div><div><h4 class="title"><a name="idp3679152"></a>4.4.2.2. Predefined Identifiers</h4></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>The identifier “__func__” shall be implicitly declared by the translator as if,
            immediately following the opening brace of each function definition, the
            declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__func__</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;function-name&quot;</span><span class="p">;</span>
</pre></div>
</pre><p>appeared, where <span class="italic">function-name</span> is the name of the lexically-enclosing function.<sup>[<a class="footnote" href="#ftn.idp3683488" name="idp3683488">54</a>]</sup> This name is encoded as if the implicit declaration had been written in
            the source character set and then translated into the execution character set as
            indicated in translation phase 5.</p><p>EXAMPLE Consider the code fragment:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">void</span> <span class="nf">myfunc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
  <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</pre><p>Each time the function is called, it will print to the standard output
            stream:</p><pre class="screen">myfunc</pre><p><span class="bold"><strong>Forward
              references:</strong></span> function definitions (Function definitions).</p></div></div><div class="sect2" title="4.4.3. Universal Character Names"><div class="titlepage"><div><div><h3 class="title"><a name="idp3689504"></a>4.4.3. Universal Character Names</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A universal character name shall not specify a character whose short identifier is
          less than 00A0 other than 0024 ($), 0040 (@), or 0060 (‘), nor one in the range D800
          through DFFF inclusive.<sup>[<a class="footnote" href="#ftn.idp3691808" name="idp3691808">55</a>]</sup></p><p><span class="bold"><strong>Description</strong></span></p><p>Universal character names may be used in identifiers, character constants, and
          string literals to designate characters that are not in the basic character set.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The universal character name \Unnnnnnnn designates the character whose eight-digit
          short identifier (as specified by ISO/IEC 10646) is nnnnnnnn.<sup>[<a class="footnote" href="#ftn.idp3695888" name="idp3695888">56</a>]</sup> Similarly, the universal character name \unnnn designates the character
          whose four-digit short identifier is nnnn (and whose eight-digit short identifier is
          0000nnnn).</p></div><div class="sect2" title="4.4.4. Constants"><div class="titlepage"><div><div><h3 class="title"><a name="idp3697360"></a>4.4.4. Constants</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The value of a constant shall be in the range of representable values for its
          type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>Each constant has a type, determined by its form and value, as detailed
          later.</p><div class="sect3" title="4.4.4.1. Integer Constants"><div class="titlepage"><div><div><h4 class="title"><a name="idp3701184"></a>4.4.4.1. Integer Constants</h4></div></div></div><p><span class="bold"><strong>Description</strong></span></p><p>An integer constant begins with a digit, but has no period or exponent part. It
            may have a prefix that specifies its base and a suffix that specifies its type.</p><p>A decimal constant begins with a nonzero digit and consists of a sequence of
            decimal digits. An octal constant consists of the prefix 0 optionally followed by a
            sequence of the digits 0 through 7 only. A hexadecimal constant consists of the prefix
            0x or 0X followed by a sequence of the decimal digits and the letters a (or A) through f
            (or F) with values 10 through 15 respectively.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The value of a decimal constant is computed base 10; that of an octal constant,
            base 8; that of a hexadecimal constant, base 16. The lexically first digit is the most
            significant.</p><p>The type of an integer constant is the first of the corresponding list in which
            its value can be represented.</p><table border="1" class="dynamic" frame="void" id="idp3706464"><colgroup width="100px"></colgroup><colgroup width="200px"></colgroup><colgroup width="200px"></colgroup><thead><tr bgcolor="#aaa">
<th>Suffix</th>
<th>Decimal Constant</th>
<th>Octal or Hexadecimal Constant</th>
</tr></thead><tbody><tr>
<td>none</td>
<td>
<p><code class="code">int</code></p>
<p><code class="code">long int</code></p>
<p><code class="code">long long int</code></p>
</td>
<td>
<p><code class="code">int</code></p>
<p><code class="code">unsigned int</code></p>
<p><code class="code">long int</code></p>
<p><code class="code">unsigned long int</code></p>
<p><code class="code">long long int</code></p>
<p><code class="code">unsigned long long int</code></p>
</td>
</tr><tr>
<td><code class="code">u</code> or <code class="code">U</code></td>
<td>
<p><code class="code">unsigned int</code></p>
<p><code class="code">unsigned long int</code></p>
<p><code class="code">unsigned long long int</code></p>
</td>
<td>
<p><code class="code">unsigned int</code></p>
<p><code class="code">unsigned long int</code></p>
<p><code class="code">unsigned long long int</code></p>
</td>
</tr><tr>
<td><code class="code">l</code> or <code class="code">L</code></td>
<td>
<p><code class="code">long int</code></p>
<p><code class="code">long long int</code></p>
</td>
<td>
<p><code class="code">long int</code></p>
<p><code class="code">unsigned long int</code></p>
<p><code class="code">long long int</code></p>
<p><code class="code">unsigned long long int</code></p>
</td>
</tr><tr>
<td>
<p>Both <code class="code">u</code> or <code class="code">U</code></p>
<p>and <code class="code">l</code> or <code class="code">L</code></p>
</td>
<td>
<p><code class="code">unsigned long int</code></p>
<p><code class="code">unsigned long long int</code></p>
</td>
<td>
<p><code class="code">unsigned long int</code></p>
<p><code class="code">unsigned long long int</code></p>
</td>
</tr><tr>
<td><code class="code">ll</code> or <code class="code">LL</code></td>
<td><code class="code">long long int</code></td>
<td>
<p><code class="code">long long int</code></p>
<p><code class="code">unsigned long long int</code></p>
</td>
</tr><tr>
<td>
<p>Both <code class="code">u</code> or <code class="code">U</code></p>
<p>and <code class="code">ll</code> or <code class="code">L</code>
</p>
</td>
<td><code class="code">unsigned long long int</code></td>
<td><code class="code">unsigned long long int</code></td>
</tr></tbody></table><p>If an integer constant cannot be represented by any type in its list, it may have
            an extended integer type, if the extended integer type can represent its value. If all
            of the types in the list for the constant are signed, the extended integer type shall be
            signed. If all of the types in the list for the constant are unsigned, the extended
            integer type shall be unsigned. If the list contains both signed and unsigned types, the
            extended integer type may be signed or unsigned.</p></div><div class="sect3" title="4.4.4.2. Floating Constants"><div class="titlepage"><div><div><h4 class="title"><a name="idp3746944"></a>4.4.4.2. Floating Constants</h4></div></div></div><p><span class="bold"><strong>Description</strong></span></p><p>A floating constant has a <span class="italic">significand</span> part that may be followed by an <span class="italic">exponent</span> part and a
              <span class="italic">suffix</span> that
            specifies its type. The components of the significand part may include a digit sequence
            representing the whole-number part, followed by a period (.), followed by a digit
            sequence representing the fraction part. The components of the exponent part are an
              <code class="code">e, E, p</code> or <code class="code">P</code> followed by an exponent consisting of
            an optionally signed digit sequence. Either the whole-number part or the fraction part
            has to be present; for decimal floating constants, either the period or the exponent
            part has to be present.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The significand part is interpreted as a (decimal or hexadecimal) rational number;
            the digit sequence in the exponent part is interpreted as a decimal integer. For decimal
            floating constants, the exponent indicates the power of 10 by which the significand part
            is to be scaled. For hexadecimal floating constants, the exponent indicates the power of
            2 by which the significand part is to be scaled. For decimal floating constants, and
            also for hexadecimal floating constants when <code class="code">FLT_RADIX</code> is not a power
            of 2, the result is either the nearest representable value, or the larger or smaller
            representable value immediately adjacent to the nearest representable value, chosen in
            an implementation-defined manner. For hexadecimal floating constants when
              <code class="code">FLT_RADIX</code> is a power of 2, the result is correctly rounded.</p><p>An unsuffixed floating constant has type <code class="code">double</code>. If suffixed by
            the letter <code class="code">f</code> or <code class="code">F</code>, it has type <code class="code">float</code>.
            If suffixed by the letter <code class="code">l</code> or <code class="code">L</code>, it has type
              <code class="code">long double</code>. </p><p>Floating constants are converted to internal format as if at translation-time. The
            conversion of a floating constant shall not raise an exceptional condition or a
            floating- point exception at execution time.</p><p><span class="bold"><strong>Recommended
              Practice</strong></span></p><p>The implementation should produce a diagnostic message if a hexadecimal constant
            cannot be represented exactly in its evaluation format; the implementation should then
            proceed with the translation of the program.</p><p>The translation-time conversion of floating constants should match the
            execution-time conversion of character strings by library functions, such as strtod,
            given matching inputs suitable for both conversions, the same result format, and default
            execution-time rounding.<sup>[<a class="footnote" href="#ftn.idp3762928" name="idp3762928">57</a>]</sup></p></div><div class="sect3" title="4.4.4.3. Enumeration Constants"><div class="titlepage"><div><div><h4 class="title"><a name="idp3764160"></a>4.4.4.3. Enumeration Constants</h4></div></div></div><p>An identifier declared as an enumeration constant has type
            <code class="code">int</code>.</p><p><span class="bold"><strong>Forward
              references:</strong></span> enumeration specifiers (Enumeration specifiers).</p></div><div class="sect3" title="4.4.4.4. Character Constants"><div class="titlepage"><div><div><h4 class="title"><a name="idp3767280"></a>4.4.4.4. Character Constants</h4></div></div></div><p><span class="bold"><strong>Description</strong></span></p><p>An integer character constant is a sequence of one or more multibyte characters
            enclosed in single-quotes, as in <code class="code">'x'</code>. A wide character constant is the
            same, except prefixed by the letter <code class="code">L</code>. With a few exceptions detailed
            later, the elements of the sequence are any members of the source character set; they
            are mapped in an implementation-defined manner to members of the execution character
            set.</p><p>The single-quote ‘, the double-quote ”, the question-mark ?, the backslash \, and
            arbitrary integer values are representable according to the following table of escape
            sequences:</p><div class="literallayout"><p>    single quote                     '       \\'<br/>
    double quote                    "      \\"<br/>
    question mark                  ?      \\?<br/>
    backslash                         \\      \\\\<br/>
    octal character                  \\o    octal digits<br/>
    hexadecimal character       \\x    hexadecimal digits</p></div><p>The double-quote ” and question-mark ? are representable either by themselves or
            by the escape sequences \” and \?, respectively, but the single-quote ‘ and the
            backslash \ shall be represented, respectively, by the escape sequences \’ and
            \\.</p><p>The octal digits that follow the backslash in an octal escape sequence are taken
            to be part of the construction of a single character for an integer character constant
            or of a single wide character for a wide character constant. The numerical value of the
            octal integer so formed specifies the value of the desired character or wide
            character.</p><p>The hexadecimal digits that follow the backslash and the letter x in a hexadecimal
            escape sequence are taken to be part of the construction of a single character for an
            integer character constant or of a single wide character for a wide character constant.
            The numerical value of the hexadecimal integer so formed specifies the value of the
            desired character or wide character.</p><p>Each octal or hexadecimal escape sequence is the longest sequence of characters
            that can constitute the escape sequence.</p><p>In addition, characters not in the basic character set are representable by
            universal character names and certain nongraphic characters are representable by escape
            sequences consisting of the backslash \ followed by a lowercase letter: <code class="code">\a, \b,
              \f, \n, \r, \t,</code> and <code class="code">\v</code>.<sup>[<a class="footnote" href="#ftn.idp3776608" name="idp3776608">58</a>]</sup></p><p><span class="bold"><strong>Constraints</strong></span></p><p>The value of an octal or hexadecimal escape sequence shall be in the range of
            representable values for the type <code class="code">unsigned char</code> for an integer
            character constant, or the unsigned type corresponding to <code class="code">wchar_t</code> for a
            wide character constant.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>An integer character constant has type <code class="code">int</code>. The value of an
            integer character constant containing a single character that maps to a single-byte
            execution character is the numerical value of the representation of the mapped character
            interpreted as an integer. The value of an integer character constant containing more
            than one character (e.g., '<code class="code">ab</code>'), or containing a character or escape
            sequence that does not map to a single-byte execution character, is
            implementation-defined. If an integer character constant contains a single character or
            escape sequence, its value is the one that results when an object with type
              <code class="code">char</code> whose value is that of the single character or escape sequence
            is converted to type <code class="code">int</code>.</p><p>A wide character constant has type <code class="code">wchar_t</code>, an integer type
            defined in the <code class="code"><stddef.h></code> header. The value of a wide character
            constant containing a single multibyte character that maps to a member of the extended
            execution character set is the wide character corresponding to that multibyte character,
            as defined by the <code class="code">mbtowc</code> function, with an implementation-defined
            current locale. The value of a wide character constant containing more than one
            multibyte character, or containing a multibyte character or escape sequence not
            represented in the extended execution character set, is implementation-defined.</p><p>EXAMPLE 1 The construction '<code class="code">\0</code>' is commonly used to represent the
            null character.</p><p>EXAMPLE 2 Consider implementations that use two’s-complement representation for
            integers and eight bits for objects that have type <code class="code">char</code>. In an
            implementation in which type <code class="code">char</code> has the same range of values as
              <code class="code">signed char</code>, the integer character constant '<code class="code">\xFF</code>'
            has the value <code class="code">-1</code>; if type <code class="code">char</code> has the same range of
            values as <code class="code">unsigned char</code>, the character constant '<code class="code">\xFF</code>'
            has the value <code class="code">+255</code>.</p><p>EXAMPLE 3 Even if eight bits are used for objects that have type char, the
            construction '<code class="code">\x123</code>' specifies an integer character constant containing
            only one character, since a hexadecimal escape sequence is terminated only by a
            non-hexadecimal character. To specify an integer character constant containing the two
            characters whose values are '<code class="code">\x12</code>' and '<code class="code">3</code>', the
            construction '<code class="code">\0223</code>' may be used, since an octal escape sequence is
            terminated after three octal digits. (The value of this two-character integer character
            constant is implementation-defined.)</p><p>EXAMPLE 4 Even if <code class="code">12</code> or more bits are used for objects that have
            type <code class="code">wchar_t</code>, the construction <code class="code">L'\1234'</code> specifies the
            implementation-defined value that results from the combination of the values
              <code class="code">0123</code> and '<code class="code">4</code>'.</p><p><span class="bold"><strong>Forward
              references:</strong></span> common definitions <code class="code"><stddef.h></code> (Common
            definitions <code class="code"><stddef.h></code>), the <code class="code">mbtowc</code> function (The
              <code class="code">mbtowc</code> function).</p></div></div><div class="sect2" title="4.4.5. String Literals"><div class="titlepage"><div><div><h3 class="title"><a name="idp3801248"></a>4.4.5. String Literals</h3></div></div></div><p><span class="bold"><strong>Description</strong></span></p><p>A character <span class="italic">string
            literal</span> is a sequence of zero or more multibyte characters enclosed in
          double-quotes, as in “<code class="code">xyz</code>”. A <code class="code">wide string literal</code> is the
          same, except prefixed by the letter <code class="code">L</code>. The same considerations apply to
          each element of the sequence in a character string literal or a wide string literal as if
          it were in an integer character constant or a wide character constant, except that the
          single-quote ' is representable either by itself or by the escape sequence
            <code class="code">\'</code>, but the double-quote <code class="code">"</code> shall be represented by the
          escape sequence <code class="code">\"</code>.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>In translation phase 6, the multibyte character sequences specified by any sequence
          of adjacent character and wide string literal tokens are concatenated into a single
          multibyte character sequence. If any of the tokens are wide string literal tokens, the
          resulting multibyte character sequence is treated as a wide string literal; otherwise, it
          is treated as a character string literal.</p><p>In translation phase 7, a byte or code of value zero is appended to each multibyte
          character sequence that results from a string literal or literals.66) The multibyte
          character sequence is then used to initialize an array of static storage duration and
          length just sufficient to contain the sequence. For character string literals, the array
          elements have type <code class="code">char</code>, and are initialized with the individual bytes of
          the multibyte character sequence; for wide string literals, the array elements have type
            <code class="code">wchar_t</code>, and are initialized with the sequence of wide characters
          corresponding to the multibyte character sequence, as defined by the
            <code class="code">mbstowcs</code> function with an implementation-defined current locale. The
          value of a string literal containing a multibyte character or escape sequence not
          represented in the execution character set is implementation-defined.</p><p>It is unspecified whether these arrays are distinct provided their elements have the
          appropriate values. If the program attempts to modify such an array, the behavior is
          undefined.</p><p>EXAMPLE This pair of adjacent character string literals:</p><pre class="screen">"\x12" "3"</pre><p>produces a single character string literal containing the two characters whose
          values are '<code class="code">\x12</code>' and '<code class="code">3</code>', because escape sequences are
          converted into single members of the execution character set just prior to adjacent string
          literal concatenation.</p><p><span class="bold"><strong>Forward
            references:</strong></span> common definitions <code class="code"><stddef.h></code> (Common
          definitions <code class="code"><stddef.h></code>), the <code class="code">mbstowcs</code> function (The
            <code class="code">mbstowcs</code> function).</p></div><div class="sect2" title="4.4.6. Punctuators"><div class="titlepage"><div><div><h3 class="title"><a name="idp3818272"></a>4.4.6. Punctuators</h3></div></div></div><p>These are one of:</p><pre class="screen">[ ] ( ) { } . -> ++ -- & * + - ~ ! / % << >> < > <= > ? : ; ... = *= /=
%= += -= <<= , # ## <: :> <% %> %: %:%: == >>= != &= ^ | ^= &&  || |=</pre><p>A punctuator is a symbol that has independent syntactic and semantic significance.
          Depending on context, it may specify an operation to be performed (which in turn may yield
          a value or a function designator, produce a side effect, or some combination thereof) in
          which case it is known as an <span class="italic">operator</span> (other forms of operator also exist in some contexts). An operand
          is an entity on which an operator acts.</p><p>In all aspects of the language, the six tokens<sup>[<a class="footnote" href="#ftn.idp3822144" name="idp3822144">59</a>]</sup></p><pre class="screen"><: :> <% %> %: %:%:</pre><p>behave, respectively, the same as the six tokens:</p><pre class="screen">[ ] { } # ##</pre><p>except for their spelling.<sup>[<a class="footnote" href="#ftn.idp3824752" name="idp3824752">60</a>]</sup></p><p><span class="bold"><strong>Forward
            references:</strong></span> expressions (Expressions), declarations (Declarations),
          preprocessing directives (Preprocessing Directives), statements (Statements and
          blocks).</p></div><div class="sect2" title="4.4.7. Header Names"><div class="titlepage"><div><div><h3 class="title"><a name="idp3827200"></a>4.4.7. Header Names</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>The sequences in both forms of header names are mapped in an implementation-defined
          manner to headers or external source file names as specified in Source File
          Inclusion.</p><p>If the characters ', \, ", // or /* occur in the sequence between the < and >
          delimiters, the behavior is undefined. Similarly, if the characters ', \, // or /* occur
          in the sequence between the " delimiters, the behavior is undefined.<sup>[<a class="footnote" href="#ftn.idp3830160" name="idp3830160">61</a>]</sup> A header name preprocessing token is recognized only within a
            <code class="code">#include</code> preprocessing directive.</p><p>EXAMPLE The following sequence of characters:</p><pre class="CLexer"><div class="highlight"><pre><span class="mh">0x3</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span><span class="mf">1e2</span>
<span class="cp">#include &lt;1/a.h&gt;</span>
<span class="cp">#define const.member@$</span>
</pre></div>
</pre><p>forms the following sequence of preprocessing tokens (with each individual
          preprocessing token delimited by a { on the left and a } on the right).</p><pre class="CLexer"><div class="highlight"><pre><span class="p">{</span><span class="mh">0x3</span><span class="p">}{</span><span class="o">&lt;</span><span class="p">}{</span><span class="mi">1</span><span class="p">}{</span><span class="o">/</span><span class="p">}{</span><span class="n">a</span><span class="p">}{.}{</span><span class="n">h</span><span class="p">}{</span><span class="o">&gt;</span><span class="p">}{</span><span class="mf">1e2</span><span class="p">}</span>
<span class="p">{</span><span class="err">#</span><span class="p">}{</span><span class="n">include</span><span class="p">}</span> <span class="p">{</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span><span class="p">}</span>
<span class="p">{</span><span class="err">#</span><span class="p">}{</span><span class="n">define</span><span class="p">}</span> <span class="p">{</span><span class="k">const</span><span class="p">}{.}{</span><span class="n">member</span><span class="p">}{</span><span class="err">@</span><span class="p">}{</span><span class="err">$</span><span class="p">}</span>
</pre></div>
</pre><p><span class="bold"><strong>Forward
            references:</strong></span> source file inclusion (Source File Inclusion).</p></div><div class="sect2" title="4.4.8. Preprocessing Numbers"><div class="titlepage"><div><div><h3 class="title"><a name="idp3835776"></a>4.4.8. Preprocessing Numbers</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A preprocessing number begins with a digit optionally preceded by a period (.) and
          may be followed by valid identifier characters and the character sequences <code class="code">e+, e-,
            E+, E-, p+, p-, P</code>+ or <code class="code">P-</code>.</p><p>Preprocessing number tokens lexically include all floating and integer constant
          tokens.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A preprocessing number does not have type or a value; it acquires both after a
          successful conversion (as part of translation phase 7) to a floating constant token or an
          integer constant token.</p></div><div class="sect2" title="4.4.9. Comments"><div class="titlepage"><div><div><h3 class="title"><a name="idp3841392"></a>4.4.9. Comments</h3></div></div></div><p>Except within a character constant, a string literal, or a comment, the characters
            <code class="code">/*</code> introduce a comment. The contents of such a comment are examined
          only to identify multibyte characters and to find the characters <code class="code">*/</code> that
          terminate it.<sup>[<a class="footnote" href="#ftn.idp3843648" name="idp3843648">62</a>]</sup></p><p>Except within a character constant, a string literal, or a comment, the characters
            <code class="code">//</code> ntroduce a comment that includes all multibyte characters up to, but
          not including, the next new-line character. The contents of such a comment are examined
          only to identify multibyte characters and to find the terminating new-line
          character.</p><p>EXAMPLE</p><pre class="CLexer"><div class="highlight"><pre><span class="s">&quot;a//b&quot;</span>                      <span class="c1">// four-character string literal</span>
<span class="cp">#include &quot;</span><span class="c1">//e&quot;              // undefined behavior</span>
<span class="c1">// */                       // comment, not syntax error</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">g</span><span class="cm">/**/</span><span class="o">/</span><span class="n">h</span><span class="p">;</span>                <span class="c1">// equivalent to f = g / h;</span>
<span class="c1">//\</span>
<span class="c1">i();                        // part of a two-line comment</span>
<span class="o">/</span>\
<span class="o">/</span> <span class="n">j</span><span class="p">();</span>                      <span class="c1">// part of a two-line comment</span>
<span class="cp">#define glue(x,y) x##y</span>
<span class="n">glue</span><span class="p">(</span><span class="o">/</span><span class="p">,</span><span class="o">/</span><span class="p">)</span> <span class="n">k</span><span class="p">();</span>              <span class="c1">// syntax error, not comment</span>
<span class="cm">/*//*/</span> <span class="n">l</span><span class="p">();</span>                 <span class="c1">// equivalent to l();</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="c1">//**/o</span>
<span class="o">+</span> <span class="n">p</span><span class="p">;</span>                        <span class="c1">// equivalent to m = n + p;</span>
</pre></div>
</pre></div></div><div class="sect1" title="4.5. Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp3847808"></a>4.5. Expressions</h2></div></div></div><p>An expression is a sequence of operators and operands that specifies computation of a
        value, or that designates an object or a function, or that generates side effects, or that
        performs a combination thereof.</p><p>Between the previous and next sequence point an object shall have its stored value
        modified at most once by the evaluation of an expression. Furthermore, the prior value shall
        be read only to determine the value to be stored.<sup>[<a class="footnote" href="#ftn.idp3849824" name="idp3849824">63</a>]</sup></p><p>The grouping of operators and operands is indicated by the syntax.<sup>[<a class="footnote" href="#ftn.idp3853008" name="idp3853008">64</a>]</sup> Except as specified later (for the function-call <code class="code">(), &&, ||,
          ?:</code> and comma operators), the order of evaluation of subexpressions and the order
        in which side effects take place are both unspecified.</p><p>Some operators (the unary operator <code class="code">~</code>, and the binary operators
          <code class="code"><<, >>, &, ^</code> and <code class="code">|</code>, collectively described as
        bitwise operators) are required to have operands that have integer type. These operators
        yield values that depend on the internal representations of integers, and have
        implementation-defined and undefined aspects for signed types. If an exceptional condition
        occurs during the evaluation of an expression (that is, if the result is not mathematically
        defined or not in the range of representable values for its type), the behavior is
        undefined.</p><p>The effective type of an object for an access to its stored value is the declared type
        of the object, if any.<sup>[<a class="footnote" href="#ftn.idp3858864" name="idp3858864">65</a>]</sup> If a value is stored into an object having no declared type through an lvalue
        having a type that is not a character type, then the type of the lvalue becomes the
        effective type of the object for that access and for subsequent accesses that do not modify
        the stored value. If a value is copied into an object having no declared type using memcpy
        or memmove or is copied as an array of character type, then the effective type of the
        modified object for that access and for subsequent accesses that do not modify the value is
        the effective type of the object from which the value is copied, if it has one. For all
        other accesses to an object having no declared type, the effective type of the object is
        simply the type of the lvalue used for the access.</p><p>An object shall have its stored value accessed only by an lvalue expression that has
        one of the following types:<sup>[<a class="footnote" href="#ftn.idp3861152" name="idp3861152">66</a>]</sup></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>a type compatible with the effective type of
              the object,</p></li><li class="listitem"><p>a qualified version of a type compatible
              with the effective type of the object,</p></li><li class="listitem"><p>a type that is the signed or unsigned type
              corresponding to the effective type of the object,</p></li><li class="listitem"><p>a type that is the signed or unsigned type
              corresponding to a qualified version of the effective type of the object,</p></li><li class="listitem"><p>an aggregate or union type that includes one
              of the aforementioned types among its members (including, recursively, a member of a
              subaggregate or contained union), or</p></li><li class="listitem"><p>a character type.</p></li></ul></div><p>A floating expression may be <code class="code">contracted</code>, that is, evaluated as though
        it were an atomic operation, thereby omitting rounding errors implied by the source code and
        the expression evaluation method.<sup>[<a class="footnote" href="#ftn.idp3869904" name="idp3869904">67</a>]</sup> The <code class="code">FP_CONTRACT</code> pragma in <code class="code"><math.h></code>
        provides a way to disallow contracted expressions. Otherwise, whether and how expressions
        are contracted is implementation-defined.<sup>[<a class="footnote" href="#ftn.idp3871904" name="idp3871904">68</a>]</sup></p><p><span class="bold"><strong>Forward
          references:</strong></span> the <code class="code">FP_CONTRACT</code> pragma (The FP_CONTRACT pragma),
        copying functions (Copying functions).</p><div class="sect2" title="4.5.1. Primary Expressions"><div class="titlepage"><div><div><h3 class="title"><a name="idp3874768"></a>4.5.1. Primary Expressions</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>An identifier is a primary expression, provided it has been declared as designating
          an object (in which case it is an lvalue) or a function (in which case it is a function designator).<sup>[<a class="footnote" href="#ftn.idp3877040" name="idp3877040">69</a>]</sup></p><p>A constant is a primary expression. Its type depends on its form and value, as
          detailed in Constants.</p><p>A string literal is a primary expression. It is an lvalue with type as detailed in
          String literals.</p><p>A parenthesized expression is a primary expression. Its type and value are identical
          to those of the unparenthesized expression. It is an lvalue, a function designator, or a
          void expression if the unparenthesized expression is, respectively, an lvalue, a function
          designator, or a void expression.</p><p><span class="bold"><strong>Forward
            references:</strong></span> declarations (Declarations).</p></div><div class="sect2" title="4.5.2. Postfix Operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp3881136"></a>4.5.2. Postfix Operators</h3></div></div></div><div class="sect3" title="4.5.2.1. Array Subscripting"><div class="titlepage"><div><div><h4 class="title"><a name="idp3881984"></a>4.5.2.1. Array Subscripting</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>One of the expressions shall have type “pointer to object type”, the other
            expression shall have integer type, and the result has type “type”.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A postfix expression followed by an expression in square brackets
              <code class="code">[]</code> is a subscripted designation of an element of an array object. The
            definition of the subscript operator <code class="code">[]</code> is that <code class="code">E1[E2]</code>
            is identical to <code class="code">(*((E1)+(E2)))</code>. Because of the conversion rules that
            apply to the binary + operator, if <code class="code">E1</code> is an array object (equivalently,
            a pointer to the initial element of an array object) and <code class="code">E2</code> is an
            integer, <code class="code">E1[E2]</code> designates the <code class="code">E2</code>-th element of
              <code class="code">E1</code> (counting from zero).</p><p>Successive subscript operators designate an element of a multidimensional array
            object. If E is an <span class="italic">n</span>-dimensional array <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>(n</mi>
<mtext> </mtext>
<mo>≥</mo>
<mtext> </mtext>
<mn>2)</mn>
</math> with dimensions <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>i</mi>
<mtext> </mtext>
<mo>∗</mo>
<mtext> </mtext>
<mi>j</mi>
<mtext> </mtext>
<mo>∗</mo>
<mtext> </mtext>
<mo>.</mo>
<mtext> </mtext>
<mo>.</mo>
<mtext> </mtext>
<mo>.</mo>
<mtext> </mtext>
<mo>∗</mo>
<mtext> </mtext>
<mi>k</mi>
</math>, then <code class="code">E</code> (used as other than an lvalue) is converted
            to a pointer to an <code class="code">(n - 1)</code>-dimensional array with dimensions <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>j</mi>
<mtext> </mtext>
<mo>∗</mo>
<mtext> </mtext>
<mo>.</mo>
<mtext> </mtext>
<mo>.</mo>
<mtext> </mtext>
<mo>.</mo>
<mtext> </mtext>
<mo>∗</mo>
<mtext> </mtext>
<mi>k</mi>
</math>. If the unary <code class="code">*</code> operator is applied to this pointer
            explicitly, or implicitly as a result of subscripting, the result is the pointed-to
              <code class="code">(n - 1)</code>-dimensional array, which itself is converted into a pointer
            if used as other than an lvalue. It follows from this that arrays are stored in
            row-major order (last subscript varies fastest).</p><p>EXAMPLE Consider the array object defined by the declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">5</span><span class="p">];</span>
</pre></div>
</pre><p>Here <code class="code">x</code> is a <code class="code">3 ∗ 5</code> array of ints; more precisely,
              <code class="code">x</code> is an array of three element objects, each of which is an array of
            five ints. In the expression <code class="code">x[i]</code> which is equivalent to
              <code class="code">(*((x)+(i))), x</code> is first converted to a pointer to the initial array
            of five ints. Then i is adjusted according to the type of <code class="code">x</code>, which
            conceptually entails multiplying <code class="code">i</code> by the size of the object to which
            the pointer points, namely an array of five int objects. The results are added and
            indirection is applied to yield an array of five ints. When used in the expression
              <code class="code">x[i][j]</code> that array is in turn converted to a pointer to the first of
            the ints, so <code class="code">x[i][j]</code> yields an <code class="code">int</code>.</p><p><span class="bold"><strong>Forward
              references:</strong></span> additive operators (Additive operators), address and
            indirection operators (Address and indirection operators), array declarators (Array
            declarators).</p></div><div class="sect3" title="4.5.2.2. Function Calls"><div class="titlepage"><div><div><h4 class="title"><a name="idp3921632"></a>4.5.2.2. Function Calls</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The expression that denotes the called function<sup>[<a class="footnote" href="#ftn.idp3923760" name="idp3923760">70</a>]</sup> shall have type pointer to function returning void or returning an object
            type other than an array type.</p><p>If the expression that denotes the called function has a type that includes a
            prototype, the number of arguments shall agree with the number of parameters. Each
            argument shall have a type such that its value may be assigned to an object with the
            unqualified version of the type of its corresponding parameter.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A postfix expression followed by parentheses () containing a possibly empty,
            comma- separated list of expressions is a function call. The postfix expression denotes
            the called function. The list of expressions specifies the arguments to the
            function.</p><p>An argument may be an expression of any object type. In preparing for the call to
            a function, the arguments are evaluated, and each parameter is assigned the value of the
            corresponding argument.<sup>[<a class="footnote" href="#ftn.idp3927968" name="idp3927968">71</a>]</sup></p><p>If the expression that denotes the called function has type pointer to function
            returning an object type, the function call expression has the same type as that object
            type, and has the value determined as specified in The return statement. Otherwise, the
            function call has type void. If an attempt is made to modify the result of a function
            call or to access it after the next sequence point, the behavior is undefined.</p><p>If the expression that denotes the called function has a type that does not
            include a prototype, the integer promotions are performed on each argument, and
            arguments that have type float are promoted to double. These are called the default
              <span class="italic">argument
              promotions</span>. If the number of arguments does not equal the number of
            parameters, the behavior is undefined. If the function is defined with a type that
            includes a prototype, and either the prototype ends with an ellipsis (, ...) or the
            types of the arguments after promotion are not compatible with the types of the
            parameters, the behavior is undefined. If the function is defined with a type that does
            not include a prototype, and the types of the arguments after promotion are not
            compatible with those of the parameters after promotion, the behavior is undefined,
            except for the following cases:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>one promoted type is a signed integer
                type, the other promoted type is the corresponding unsigned integer type, and the
                value is representable in both types;</p></li><li class="listitem"><p>both types are pointers to qualified or
                unqualified versions of a character type or <code class="code">void</code>.</p></li></ul></div><p>converted, as if by assignment, to the types of the corresponding parameters,
            taking the type of each parameter to be the unqualified version of its declared type.
            The ellipsis notation in a function prototype declarator causes argument type conversion
            to stop after the last declared parameter. The default argument promotions are performed
            on trailing arguments.</p><p>No other conversions are performed implicitly; in particular, the number and types
            of arguments are not compared with those of the parameters in a function definition that
            does not include a function prototype declarator.</p><p>If the function is defined with a type that is not compatible with the type (of
            the expression) pointed to by the expression that denotes the called function, the
            behavior is undefined.</p><p>The order of evaluation of the function designator, the actual arguments, and
            subexpressions within the actual arguments is unspecified, but there is a sequence point
            before the actual call.</p><p>Recursive function calls shall be permitted, both directly and indirectly through
            any chain of other functions.</p><p>EXAMPLE In the function call</p><pre class="CLexer"><div class="highlight"><pre><span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">[</span><span class="n">f1</span><span class="p">()])</span> <span class="p">(</span><span class="n">f2</span><span class="p">(),</span> <span class="n">f3</span><span class="p">()</span> <span class="o">+</span> <span class="n">f4</span><span class="p">())</span>
</pre></div>
</pre><p>the functions <code class="code">f1, f2, f3</code> and <code class="code">f4</code> may be called in
            any order. All side effects have to be completed before the function pointed to by
              <code class="code">pf[f1()]</code> is called.</p><p><span class="bold"><strong>Forward
              references:</strong></span> function declarators (including prototypes) (Function
            declarators (including prototypes)), function definitions (Function definitions), the
            return statement (The return statement), simple assignment (Simple assignment).</p></div><div class="sect3" title="4.5.2.3. Structures and union members"><div class="titlepage"><div><div><h4 class="title"><a name="idp3943536"></a>4.5.2.3. Structures and union members</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The first operand of the <code class="code">.</code> operator shall have a qualified or
            unqualified structure or union type, and the second operand shall name a member of that
            type.</p><p>The first operand of the <code class="code">-></code> operator shall have type “pointer to
            qualified or unqualified structure” or “pointer to qualified or unqualified union”, and
            the second operand shall name a member of the type pointed to.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A postfix expression followed by the <code class="code">.</code> operator and an identifier
            designates a member of a structure or union object. The value is that of the named
            member, and is an lvalue if the first expression is an lvalue. If the first expression
            has qualified type, the result has the so-qualified version of the type of the
            designated member. \</p><p>A postfix expression followed by the <code class="code">-></code> operator and an
            identifier designates a member of a structure or union object. The value is that of the
            named member of the object to which the first expression points, and is an lvalue.<sup>[<a class="footnote" href="#ftn.idp3950688" name="idp3950688">72</a>]</sup> If the first expression is a pointer to a qualified type, the result has
            the so-qualified version of the type of the designated member.</p><p>One special guarantee is made in order to simplify the use of unions: if a union
            contains several structures that share a common initial sequence (see below), and if the
            union object currently contains one of these structures, it is permitted to inspect the
            common initial part of any of them anywhere that a declaration of the complete type of
            the union is visible. Two structures share a <span class="italic">common initial sequence</span>
            if corresponding members have compatible types (and, for bit-fields, the same widths)
            for a sequence of one or more initial members.</p><p>EXAMPLE 1 If <code class="code">f</code> is a function returning a structure or union, and
              <code class="code">x</code> is a member of that structure or union, <code class="code">f().x</code> is a
            valid postfix expression but is not an lvalue.</p><p>EXAMPLE 2 In:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">s</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">s</span> <span class="n">s</span><span class="p">;</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">s</span> <span class="n">cs</span><span class="p">;</span>
<span class="k">volatile</span> <span class="k">struct</span> <span class="n">s</span> <span class="n">vs</span><span class="p">;</span>
</pre></div>
</pre><p>the various members have the types:</p><pre class="CLexer"><div class="highlight"><pre><span class="n">s</span><span class="p">.</span><span class="n">i</span>   <span class="kt">int</span>
<span class="n">s</span><span class="p">.</span><span class="n">ci</span>  <span class="k">const</span> <span class="kt">int</span>
<span class="n">cs</span><span class="p">.</span><span class="n">i</span>  <span class="k">const</span> <span class="kt">int</span>
<span class="n">cs</span><span class="p">.</span><span class="n">ci</span> <span class="k">const</span> <span class="kt">int</span>
<span class="n">vs</span><span class="p">.</span><span class="n">i</span>  <span class="k">volatile</span> <span class="kt">int</span>
<span class="n">vs</span><span class="p">.</span><span class="n">ci</span> <span class="k">volatile</span> <span class="k">const</span> <span class="kt">int</span>
</pre></div>
</pre><p>EXAMPLE 3 The following is a valid fragment:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">union</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">alltypes</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">intnode</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">ni</span><span class="p">;</span>
  <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">doublenode</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">nf</span><span class="p">;</span>
<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="n">u</span><span class="p">.</span><span class="n">nf</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">u</span><span class="p">.</span><span class="n">nf</span><span class="p">.</span><span class="n">doublenode</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">n</span><span class="p">.</span><span class="n">alltypes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">nf</span><span class="p">.</span><span class="n">doublenode</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="cm">/* ... */</span>
</pre></div>
</pre><p>The following is not a valid fragment (because the union type is not visible
            within function <code class="code">f</code>):</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">t1</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">m</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">t2</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">m</span><span class="p">;</span> <span class="p">};</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="k">struct</span> <span class="n">t1</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">t2</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">p2</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">t1</span> <span class="n">s1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">t2</span> <span class="n">s2</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
  <span class="cm">/* ... */</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">s1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">s2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</pre><p><span class="bold"><strong>Forward
              references:</strong></span> address and indirection operators (Address and indirection
            operators), structure and union specifiers (Structure and union specifiers).</p></div><div class="sect3" title="4.5.2.4. Postfix increment and decrement operators"><div class="titlepage"><div><div><h4 class="title"><a name="idp3964896"></a>4.5.2.4. Postfix increment and decrement
            operators</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The operand of the postfix increment or decrement operator shall have qualified or
            unqualified real or pointer type and shall be a modifiable lvalue.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The result of the postfix <code class="code">++</code> operator is the value of the
            operand. After the result is obtained, the value of the operand is incremented. (That
            is, the value 1 of the appropriate type is added to it.) See the discussions of additive
            operators and compound assignment for information on constraints, types, and conversions
            and the effects of operations on pointers. The side effect of updating the stored value
            of the operand shall occur between the previous and the next sequence point.</p><p>The postfix <code class="code">--</code> operator is analogous to the postfix
              <code class="code">++</code> operator, except that the value of the operand is decremented
            (that is, the value 1 of the appropriate type is subtracted from it).</p><p><span class="bold"><strong>Forward
              references:</strong></span> additive operators (Additive operators), compound assignment
            (Compound assignment).</p></div><div class="sect3" title="4.5.2.5. Compound literals"><div class="titlepage"><div><div><h4 class="title"><a name="idp3972576"></a>4.5.2.5. Compound literals</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The type name shall specify an object type or an array of unknown size, but not a
            variable length array type.</p><p>No initializer shall attempt to provide a value for an object not contained within
            the entire unnamed object specified by the compound literal.</p><p>If the compound literal occurs outside the body of a function, the initializer
            list shall consist of constant expressions.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A postfix expression that consists of a parenthesized type name followed by a
            brace- enclosed list of initializers is a <span class="italic">compound literal</span>. It
            provides an unnamed object whose value is given by the initializer list.<sup>[<a class="footnote" href="#ftn.idp3978368" name="idp3978368">73</a>]</sup></p><p>If the type name specifies an array of unknown size, the size is determined by the
            initializer list as specified in Initialization, and the type of the compound literal is
            that of the completed array type. Otherwise (when the type name specifies an object
            type), the type of the compound literal is that specified by the type name. In either
            case, the result is an lvalue.</p><p>The value of the compound literal is that of an unnamed object initialized by the
            initializer list. If the compound literal occurs outside the body of a function, the
            object has static storage duration; otherwise, it has automatic storage duration
            associated with the enclosing block.</p><p>All the semantic rules and constraints for initializer lists in Initialization are
            applicable to compound literals.<sup>[<a class="footnote" href="#ftn.idp3981456" name="idp3981456">74</a>]</sup></p><p>String literals, and compound literals with const-qualified types, need not
            designate distinct objects.<sup>[<a class="footnote" href="#ftn.idp3982816" name="idp3982816">75</a>]</sup></p><p>EXAMPLE 1 The file scope definition</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">[]){</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</pre></div>
</pre><p>initializes p to point to the first element of an array of two ints, the first
            having the value two and the second, four. The expressions in this compound literal are
            required to be constant. The unnamed object has static storage duration.</p><p>EXAMPLE 2 In contrast, in</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="cm">/*...*/</span>
  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">[</span><span class="mi">2</span><span class="p">]){</span><span class="o">*</span><span class="n">p</span><span class="p">};</span>
  <span class="cm">/*...*/</span>
<span class="p">}</span>
</pre></div>
</pre><p><code class="code">p</code> is assigned the address of the first element of an array of two
            ints, the first having the value previously pointed to by <code class="code">p</code> and the
            second, zero. The expressions in this compound literal need not be constant. The unnamed
            object has automatic storage duration.</p><p>EXAMPLE 3 Initializers with designations can be combined with compound literals.
            Structure objects created using compound literals can be passed to functions without
            depending on member order:</p><pre class="CLexer"><div class="highlight"><pre><span class="n">drawline</span><span class="p">((</span><span class="k">struct</span> <span class="n">point</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">},</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">point</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">});</span>
</pre></div>
</pre><p>Or, if drawline instead expected pointers to struct point:</p><pre class="CLexer"><div class="highlight"><pre><span class="n">drawline</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span> <span class="n">point</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">},</span>
<span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span> <span class="n">point</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">});</span>
</pre></div>
</pre><p>EXAMPLE 4 A read-only compound literal can be specified through constructions
            like:</p><pre class="CLexer"><div class="highlight"><pre><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="p">[]){</span><span class="mf">1e0</span><span class="p">,</span> <span class="mf">1e1</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">,</span> <span class="mf">1e3</span><span class="p">,</span> <span class="mf">1e4</span><span class="p">,</span> <span class="mf">1e5</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">}</span>
</pre></div>
</pre><p>EXAMPLE 5 The following three expressions have different meanings:</p><pre class="CLexer"><div class="highlight"><pre><span class="s">&quot;/tmp/fileXXXXXX&quot;</span>
<span class="p">(</span><span class="kt">char</span> <span class="p">[]){</span><span class="s">&quot;/tmp/fileXXXXXX&quot;</span><span class="p">}</span>
<span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">[]){</span><span class="s">&quot;/tmp/fileXXXXXX&quot;</span><span class="p">}</span>
</pre></div>
</pre><p>The first always has static storage duration and has type array of char, but need
            not be modifiable; the last two have automatic storage duration when they occur within
            the body of a function, and the first of these two is modifiable.</p><p>EXAMPLE 6 Like string literals, const-qualified compound literals can be placed
            into read-only memory and can even be shared. For example,</p><pre class="CLexer"><div class="highlight"><pre><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">[]){</span><span class="s">&quot;abc&quot;</span><span class="p">}</span> <span class="o">==</span> <span class="s">&quot;abc&quot;</span>
</pre></div>
</pre><p>might yield 1 if the literals’ storage is shared.</p><p>EXAMPLE 7 Since compound literals are unnamed, a single compound literal cannot
            specify a circularly linked object. For example, there is no way to write a
            self-referential compound literal that could be used as the function argument in place
            of the named object endless_zeros below:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">int_list</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">car</span><span class="p">;</span> <span class="k">struct</span> <span class="n">int_list</span> <span class="o">*</span><span class="n">cdr</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">int_list</span> <span class="n">endless_zeros</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endless_zeros</span><span class="p">};</span>
<span class="n">eval</span><span class="p">(</span><span class="n">endless_zeros</span><span class="p">);</span>
</pre></div>
</pre><p>EXAMPLE 8 Each compound literal creates only a single object in a given
            scope:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">s</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="p">};</span>
<span class="kt">int</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">s</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">again:</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">s</span><span class="p">){</span> <span class="n">j</span><span class="o">++</span> <span class="p">});</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="n">q</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>The function <code class="code">f()</code> always returns the value 1.</p><p>Note that if an iteration statement were used instead of an explicit goto and a
            labeled statement, the lifetime of the unnamed object would be the body of the loop
            only, and on entry next time around <code class="code">p</code> would have an indeterminate
            value, which would result in undefined behavior.</p><p><span class="bold"><strong>Forward
              references:</strong></span> type names (Type names), initialization
            (Initialization).</p></div></div><div class="sect2" title="4.5.3. Unary Operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4002736"></a>4.5.3. Unary Operators</h3></div></div></div><div class="sect3" title="4.5.3.1. Prefix increment and decrement operators"><div class="titlepage"><div><div><h4 class="title"><a name="idp4003584"></a>4.5.3.1. Prefix increment and decrement
            operators</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The operand of the prefix increment or decrement operator shall have qualified or
            unqualified real or pointer type and shall be a modifiable lvalue.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The value of the operand of the prefix <code class="code">++</code> operator is
            incremented. The result is the new value of the operand after incrementation. The
            expression <code class="code">++E</code> is equivalent to <code class="code">(E+=1)</code>. See the
            discussions of additive operators and compound assignment for information on onstraints,
            types, side effects, and conversions and the effects of operations on pointers.</p><p>The prefix <code class="code">--</code> operator is analogous to the prefix
              <code class="code">++</code> operator, except that the value of the operand is
            decremented.</p><p><span class="bold"><strong>Forward
              references:</strong></span> additive operators (Additive operators), compound assignment
            (Compound assignment).</p></div><div class="sect3" title="4.5.3.2. Address and indirection operators"><div class="titlepage"><div><div><h4 class="title"><a name="idp4011904"></a>4.5.3.2. Address and indirection operators</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The operand of the unary <code class="code">&</code> operator shall be either a
            function designator, the result of a <code class="code">[]</code> or unary <code class="code">*</code>
            operator, or an lvalue that designates an object that is not a bit-field and is not
            declared with the register storage-class specifier.</p><p>The operand of the unary <code class="code">*</code> operator shall have pointer
            type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The unary <code class="code">&</code> operator yields the address of its operand. If
            the operand has type “type”, the result has type “pointer to type”. If the operand is
            the result of a unary <code class="code">*</code> operator, neither that operator nor the
              <code class="code">&</code> operator is evaluated and the result is as if both were
            omitted, except that the constraints on the operators still apply and the result is not
            an lvalue. Similarly, if the operand is the result of a <code class="code">[]</code> operator,
            neither the <code class="code">&</code> operator nor he unary <code class="code">*</code> that is
            implied by the <code class="code">[]</code> is evaluated and the result is as if the
              <code class="code">&</code> operator were removed and the <code class="code">[]</code> operator were
            changed to a <code class="code">+</code> operator. Otherwise, the result is a pointer to the
            object or function designated by its operand.</p><p>The unary <code class="code">*</code> operator denotes indirection. If the operand points
            to a function, the result is a function designator; if it points to an object, the
            result is an lvalue designating the object. If the operand has type “pointer to type”,
            the result has type “type”. If an invalid value has been assigned to the pointer, the
            behavior of the unary <code class="code">*</code> operator is undefined.<sup>[<a class="footnote" href="#ftn.idp4024768" name="idp4024768">76</a>]</sup></p><p><span class="bold"><strong>Forward
              references:</strong></span> storage-class specifiers (Storage-class specifiers), structure
            and union specifiers (Structure and union specifiers).</p></div><div class="sect3" title="4.5.3.3. Unary arithmetic operators"><div class="titlepage"><div><div><h4 class="title"><a name="idp4033056"></a>4.5.3.3. Unary arithmetic operators</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The operand of the unary <code class="code">+</code> or <code class="code">-</code> operator shall
            have arithmetic type; of the <code class="code">-</code> operator, integer type; of the
              <code class="code">!</code> operator, scalar type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The result of the unary <code class="code">+</code> operator is the value of its (promoted)
            operand. The integer promotions are performed on the operand, and the result has the
            promoted type.</p><p>The result of the unary <code class="code">-</code> operator is the negative of its
            (promoted) operand. The integer promotions are performed on the operand, and the result
            has the promoted type.</p><p>The result of the <code class="code">~</code> operator is the bitwise complement of its
            (promoted) operand (that is, each bit in the result is set if and only if the
            corresponding bit in the converted operand is not set). The integer promotions are
            performed on the operand, and the result has the promoted type. If the promoted type is
            an unsigned type, the expression <code class="code">~E</code> is equivalent to the maximum value
            representable in that type minus <code class="code">E</code>.</p><p>The result of the logical negation operator <code class="code">!</code> is 0 if the value
            of its operand compares unequal to 0, 1 if the value of its operand compares equal to 0.
            The result has type int. The expression <code class="code">!E</code> is equivalent to
              <code class="code">(0==E)</code>.</p></div><div class="sect3" title="4.5.3.4. The sizeof operator"><div class="titlepage"><div><div><h4 class="title"><a name="idp4044656"></a>4.5.3.4. The sizeof operator</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The <code class="code">sizeof</code> operator shall not be applied to an expression that
            has function type or an incomplete type, to the parenthesized name of such a type, or to
            an expression that designates a bit-field member.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The <code class="code">sizeof</code> operator yields the size (in bytes) of its operand,
            which may be an expression or the parenthesized name of a type. The size is determined
            from the type of the operand. The result is an integer. If the type of the operand is a
            variable length array type, the operand is evaluated; otherwise, the operand is not
            evaluated and the result is an integer constant.</p><p>When applied to an operand that has type <code class="code">char, unsigned char</code> or
              <code class="code">signed char</code>, (or a qualified version thereof) the result is 1. When
            applied to an operand that has array type, the result is the total number of bytes in
            the array.<sup>[<a class="footnote" href="#ftn.idp4051184" name="idp4051184">77</a>]</sup> When applied to an operand that has structure or union type, the result is
            the total number of bytes in such an object, including internal and trailing
            padding.</p><p>The value of the result is implementation-defined, and its type (an unsigned
            integer type) is <code class="code">size_t</code>, defined in <code class="code"><stddef.h></code> (and
            other headers).</p><p>EXAMPLE 1 A principal use of the sizeof operator is in communication with routines
            such as storage allocators and I/O systems. A storage-allocation function might accept a
            size (in bytes) of an object to allocate and return a pointer to void. For
            example:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>
</pre></div>
</pre><p>The implementation of the alloc function should ensure that its return value is
            aligned suitably for conversion to a pointer to double.</p><p>EXAMPLE 2 Another use of the <code class="code">sizeof</code> operator is to compute the
            number of elements in an array:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">sizeof</span> <span class="n">array</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</pre><p>In this example, the size of a variable length array is computed and returned from
            a function:</p><pre class="CLexer"><div class="highlight"><pre><span class="cp">#include &lt;stddef.h&gt;</span>
<span class="kt">size_t</span> <span class="nf">fsize3</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>     <span class="c1">// variable length array</span>
  <span class="k">return</span> <span class="k">sizeof</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// execution time sizeof</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">fsize3</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// fsize3 returns 13</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p><span class="bold"><strong>Forward
              references:</strong></span> common definitions <stddef.h> (Common definitions
            <stddef.h>), declarations (Declarations), structure and union specifiers (Structure
            and union specifiers), type names (Type names), array declarators (Array
            declarators).</p></div></div><div class="sect2" title="4.5.4. Cast operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4060976"></a>4.5.4. Cast operators</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Unless the type name specifies a <code class="code">void</code> type, the type name shall
          specify qualified or unqualified scalar type and the operand shall have scalar
          type.</p><p>Conversions that involve pointers, other than where permitted by the constraints of
          Simple assignment, shall be specified by means of an explicit cast.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>Preceding an expression by a parenthesized type name converts the value of the
          expression to the named type. This construction is called a cast.<sup>[<a class="footnote" href="#ftn.idp4065792" name="idp4065792">78</a>]</sup> A cast that specifies no conversion has no effect on the type or value of an expression.<sup>[<a class="footnote" href="#ftn.idp4066896" name="idp4066896">79</a>]</sup></p><p><span class="bold"><strong>Forward
            references:</strong></span> equality operators (Equality operators), function declarators
          (including prototypes) (Function declarators (including prototypes)), simple assignment
          (Simple assignment), type names (Type names).</p></div><div class="sect2" title="4.5.5. Multiplicative operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4069584"></a>4.5.5. Multiplicative operators</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Each of the operands shall have arithmetic type. The operands of the
            <code class="code">%</code> operator shall have integer type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The usual arithmetic conversions are performed on the operands.</p><p>The result of the binary <code class="code">*</code> operator is the product of the
          operands.</p><p>The result of the <code class="code">/</code> operator is the quotient from the division of
          the first operand by the second; the result of the <code class="code">%</code> operator is the
          remainder. In both operations, if the value of the second operand is zero, the behavior is
          undefined.</p><p>When integers are divided, the result of the <code class="code">/</code> operator is the
          algebraic quotient with any fractional part discarded.<sup>[<a class="footnote" href="#ftn.idp4077184" name="idp4077184">80</a>]</sup> If the quotient <code class="code">a/b</code> is representable, the expression
            <code class="code">(a/b)*b + a%b</code> shall equal <code class="code">a</code>.</p></div><div class="sect2" title="4.5.6. Additive operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4079808"></a>4.5.6. Additive operators</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>For addition, either both operands shall have arithmetic type, or one operand shall
          be a pointer to an object type and the other shall have integer type. (Incrementing is
          equivalent to adding 1.)</p><p>For subtraction, one of the following shall hold:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>both operands have arithmetic type;</p></li><li class="listitem"><p>both operands are pointers to qualified or
              unqualified versions of compatible object types; or</p></li><li class="listitem"><p>the left operand is a pointer to an object
              type and the right operand has integer type.</p></li></ul></div><p>(Decrementing is equivalent to subtracting 1.)</p><p><span class="bold"><strong>Semantics</strong></span></p><p>If both operands have arithmetic type, the usual arithmetic conversions are
          performed on them.</p><p>The result of the binary <span class="bold"><strong>+</strong></span> operator is the sum of the operands.</p><p>The result of the binary <span class="bold"><strong>-</strong></span> operator is the difference resulting from the subtraction of the second
          operand from the first.</p><p>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the stype of the object as its element type.</p><p>When an expression that has integer type is added to or subtracted from a pointer,
          the result has the type of the pointer operand. If the pointer operand points to an
          element of an array object, and the array is large enough, the result points to an element
          offset from the original element such that the difference of the subscripts of the
          resulting and original array elements equals the integer expression. In other words, if
          the expression <code class="code">P</code> points to the <code class="code">i</code>-th element of an array
          object, the expressions <code class="code">(P)+N</code> (equivalently, <code class="code">N+(P))</code> and
            <code class="code">(P)-N</code> (where <code class="code">N</code> has the value <code class="code">n</code>) point
          to, respectively, the <code class="code">i+n</code>-th and <code class="code">i-n</code>-th elements of the
          array object, provided they exist. Moreover, if the expression <code class="code">P</code> points
          to the last element of an array object, the expression <code class="code">(P)+1</code> points one
          past the last element of the array object, and if the expression <code class="code">Q</code> points
          one past the last element of an array object, the expression <code class="code">(Q)-1</code> points
          to the last element of the array object. If both the pointer operand and the result point
          to elements of the same array object, or one past the last element of the array object,
          the evaluation shall not produce an overflow; otherwise, the behavior is undefined. If the
          result points one past the last element of the array object, it shall not be used as the
          operand of a unary <code class="code">*</code> operator that is evaluated.</p><p>When two pointers are subtracted, both shall point to elements of the same array
          object, or one past the last element of the array object; the result is the difference of
          the subscripts of the two array elements. The size of the result is
          implementation-defined, and its type (a signed integer type) is <code class="code">ptrdiff_t</code>
          defined in the <code class="code"><stddef.h></code> header. If the result is not representable
          in an object of that type, the behavior is undefined. In other words, if the expressions
            <code class="code">P</code> and <code class="code">Q</code> point to, respectively, the
          <code class="code">i</code>-th and <code class="code">j</code>-th elements of an array object, the
          expression <code class="code">(P)-(Q)</code> has the value <code class="code">i-j</code> provided the value
          fits in an object of type <code class="code">ptrdiff_t</code>. Moreover, if the expression
            <code class="code">P</code> points either to an element of an array object or one past the last
          element of an array object, and the expression <code class="code">Q</code> points to the last
          element of the same array object, the expression <code class="code">((Q)+1)-(P)</code> has the same
          value as <code class="code">((Q)-(P))+1</code> and as <code class="code">-((P)-((Q)+1))</code>, and has the
          value zero if the expression <code class="code">P</code> points one past the last element of the
          array object, even though the expression <code class="code">(Q)+1</code> does not point to an
          element of the array object.<sup>[<a class="footnote" href="#ftn.idp4108176" name="idp4108176">81</a>]</sup></p><p>EXAMPLE Pointer arithmetic is well defined with pointers to variable length array
          types.</p><pre class="CLexer"><div class="highlight"><pre><span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">];</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// p == &amp;a[0]</span>
  <span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// p == &amp;a[1]</span>
  <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>    <span class="c1">// a[1][2] == 99</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>       <span class="c1">// n == 1</span>
<span class="p">}</span>
</pre></div>
</pre><p>If array a in the above example were declared to be an array of known constant size,
          and pointer <code class="code">p</code> were declared to be a pointer to an array of the same known
          constant size (pointing to <code class="code">a</code>), the results would be the same.</p><p><span class="bold"><strong>Forward
            references:</strong></span> array declarators (Array declarators), common definitions
          <stddef.h> (Common definitions <stddef.h>).</p></div><div class="sect2" title="4.5.7. Bitwise shift operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4114624"></a>4.5.7. Bitwise shift operators</h3></div></div></div><p><span class="bold"><strong>Constraint</strong></span></p><p>Each of the operands shall have integer type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The integer promotions are performed on each of the operands. The type of the result
          is that of the promoted left operand. If the value of the right operand is negative or is
          greater than or equal to the width of the promoted left operand, the behavior is
          undefined.</p><p>The result of <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
<mo><<</mo>
<mi>E</mi>
<mn>2</mn>
</math>is <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
</math> left-shifted <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>2</mn>
</math> bit positions; vacated bits are filled with zeros. If <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
</math> has an unsigned type, the value of the result is <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
<mtext> </mtext>
<mo>∗</mo>
<mtext> </mtext>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>E</mi>
<mn>2</mn>
</mrow>
</msup>
</math>, reduced modulo one more than the maximum value representable in the
          result type. If <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
</math> has a signed type and nonnegative value, and <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
<mtext> </mtext>
<mo>∗</mo>
<mtext> </mtext>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>E</mi>
<mn>2</mn>
</mrow>
</msup>
</math> is representable in the result type, then that is the resulting value;
          otherwise, the behavior is undefined.</p><p>The result of <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
<mo>>></mo>
<mi>E</mi>
<mn>2</mn>
</math> is <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
</math> right-shifted <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>2</mn>
</math> bit positions. If <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
</math> has an unsigned type or if <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
</math> has a signed type and a nonnegative value, the value of the result is
          the integral part of the quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>E</mi>
<mn>2</mn>
</mrow>
</msup>
</math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mi>E</mi>
<mn>1</mn>
</math> has a signed type and a negative value, the resulting value is
          implementation-defined.</p></div><div class="sect2" title="4.5.8. Relational operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4161184"></a>4.5.8. Relational operators</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>One of the following shall hold:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>both operands have real type;</p></li><li class="listitem"><p>both operands are pointers to qualified or unqualified versions of compatible
              object types; or</p></li><li class="listitem"><p>both operands are pointers to qualified or unqualified versions of compatible
              incomplete types.</p></li></ul></div><p><span class="bold"><strong>Semantics</strong></span></p><p>If both of the operands have arithmetic type, the usual arithmetic conversions are
          performed.</p><p>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the type of the object as its element type.</p><p>When two pointers are compared, the result depends on the relative locations in the
          address space of the objects pointed to. If two pointers to object or incomplete types
          both point to the same object, or both point one past the last element of the same array
          object, they compare equal. If the objects pointed to are members of the same aggregate
          object, pointers to structure members declared later compare greater than pointers to
          members declared earlier in the structure, and pointers to array elements with larger
          subscript values compare greater than pointers to elements of the same array with lower
          subscript values. All pointers to members of the same union object compare equal. If the
          expression <code class="code">P</code> points to an element of an array object and the expression
            <code class="code">Q</code> points to the last element of the same array object, the pointer
          expression <code class="code">Q+1</code> compares greater than <code class="code">P</code>. In all other
          cases, the behavior is undefined.</p><p>Each of the operators <code class="code"><</code> (less than), <code class="code">></code> (greater
          than), <code class="code"><=</code> (less than or equal to), and <code class="code">>=</code> (greater
          than or equal to) shall yield 1 if the specified relation is true and 0 if it is false.<sup>[<a class="footnote" href="#ftn.idp4174016" name="idp4174016">82</a>]</sup></p></div><div class="sect2" title="4.5.9. Equality operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4176144"></a>4.5.9. Equality operators</h3></div></div></div><p>Constraints</p><p>One of the following shall hold:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>both operands have arithmetic type;</p></li><li class="listitem"><p>both operands are pointers to qualified or unqualified versions of compatible
              types;</p></li><li class="listitem"><p>one operand is a pointer to an object or incomplete type and the other is a
              pointer to a qualified or unqualified version of void; or</p></li><li class="listitem"><p>one operand is a pointer and the other is a null pointer constant.</p></li></ul></div><p><span class="bold"><strong>Semantics</strong></span></p><p>The <code class="code">==</code> (equal to) and <code class="code">!=</code> (not equal to) operators
          are analogous to the relational operators except for their lower precedence. <sup>[<a class="footnote" href="#ftn.idp4184224" name="idp4184224">83</a>]</sup> Each of the operators yields 1 if the specified relation is true and 0 if it
          is false. The result has type <code class="code">int</code>. For any pair of operands, exactly one
          of the relations is true.</p><p>If both of the operands have arithmetic type, the usual arithmetic conversions are
          performed. Values of complex types are equal if and only if both their real parts are
          equal and also their imaginary parts are equal. Any two values of arithmetic types from
          different type domains are equal if and only if the results of their conversions to the
          (complex) result type determined by the usual arithmetic conversions are equal.</p><p>Otherwise, at least one operand is a pointer. If one operand is a pointer and the
          other is a null pointer constant, the null pointer constant is converted to the type of
          the pointer. If one operand is a pointer to an object or incomplete type and the other is
          a pointer to a qualified or unqualified version of <code class="code">void</code>, the former is
          converted to the type of the latter.</p><p>Two pointers compare equal if and only if both are null pointers, both are pointers
          to the same object (including a pointer to an object and a subobject at its beginning) or
          function, both are pointers to one past the last element of the same array object, or one
          is a pointer to one past the end of one array object and the other is a pointer to the
          start of a different array object that happens to immediately follow the first array
          object in the address space.<sup>[<a class="footnote" href="#ftn.idp4190240" name="idp4190240">84</a>]</sup></p><p>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the type of the object as its element type.</p></div><div class="sect2" title="4.5.10. Bitwise AND operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp4192416"></a>4.5.10. Bitwise AND operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Each of the operands shall have integer type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The usual arithmetic conversions are performed on the operands. The result of the
          binary <code class="code">&</code> operator is the bitwise AND of the operands (that is, each
          bit in the result is set if and only if each of the corresponding bits in the converted
          operands is set).</p></div><div class="sect2" title="4.5.11. Bitwise exlusive OR operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp4196976"></a>4.5.11. Bitwise exlusive OR operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Each of the operands shall have integer type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The usual arithmetic conversions are performed on the operands. The result of the
            <code class="code">^</code> operator is the bitwise exclusive OR of the operands (that is, each
          bit in the result is set if and only if exactly one of the corresponding bits in the
          converted operands is set).</p></div><div class="sect2" title="4.5.12. Bitwise inclusive OR operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp4201568"></a>4.5.12. Bitwise inclusive OR operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Each of the operands shall have integer type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The usual arithmetic conversions are performed on the operands. The result of the
            <code class="code">|</code> operator is the bitwise inclusive OR of the operands (that is, each
          bit in the result is set if and only if at least one of the corresponding bits in the
          converted operands is set).</p></div><div class="sect2" title="4.5.13. Logical AND operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp4206160"></a>4.5.13. Logical AND operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Each of the operands shall have scalar type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The <code class="code">&&</code> operator shall yield 1 if both of its operands
          compare unequal to 0; otherwise, it yields 0. The result has type
          <code class="code">int</code>.</p><p>Unlike the bitwise binary <code class="code">&</code> operator, the
            <code class="code">&&</code> operator guarantees left-to-right evaluation; there is a
          sequence point after the evaluation of the first operand. If the first operand compares
          equal to 0, the second operand is not evaluated.</p></div><div class="sect2" title="4.5.14. Logical OR operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp4212592"></a>4.5.14. Logical OR operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Each of the operands shall have scalar type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The <code class="code">||</code> operator shall yield 1 if either of its operands compare
          unequal to 0; otherwise, it yields 0. The result has type <code class="code">int</code>. Unlike the
          bitwise <code class="code">|</code> operator, the <code class="code">||</code> operator guarantees
          left-to-right evaluation; there is a sequence point after the evaluation of the first
          operand. If the first operand compares unequal to 0, the second operand is not
          evaluated.</p></div><div class="sect2" title="4.5.15. Conditional operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp4218576"></a>4.5.15. Conditional operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The first operand shall have scalar type. One of the following shall hold for the
          second and third operands:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>both operands have arithmetic type;</p></li><li class="listitem"><p>both operands have the same structure or
              union type;</p></li><li class="listitem"><p>both operands have void type;</p></li><li class="listitem"><p>both operands are pointers to qualified or
              unqualified versions of compatible types;</p></li><li class="listitem"><p>one operand is a pointer and the other is a
              null pointer constant; or</p></li><li class="listitem"><p>one operand is a pointer to an object or
              incomplete type and the other is a pointer to a qualified or unqualified version of
              void.</p></li></ul></div><p><span class="bold"><strong>Semantics</strong></span></p><p> The first operand is evaluated; there is a sequence point after its evaluation. The
          second operand is evaluated only if the first compares unequal to 0; the third operand is
          evaluated only if the first compares equal to 0; the result is the value of the second or
          third operand (whichever is evaluated), converted to the type described below.<sup>[<a class="footnote" href="#ftn.idp4229392" name="idp4229392">85</a>]</sup> If an attempt is made to modify the result of a conditional operator or to
          access it after the next sequence point, the behavior is undefined.</p><p>If both the second and third operands have arithmetic type, the result type that
          would be determined by the usual arithmetic conversions, were they applied to those two
          operands, is the type of the result. If both the operands have structure or union type,
          the result has that type. If both operands have void type, the result has <code class="code">void</code> type.</p><p>If both the second and third operands are pointers or one is a null pointer constant
          and the other is a pointer, the result type is a pointer to a type qualified with all the
          type qualifiers of the types pointed-to by both operands. Furthermore, if both operands
          are pointers to compatible types or to differently qualified versions of compatible types,
          the result type is a pointer to an appropriately qualified version of the composite type;
          if one operand is a null pointer constant, the result has the type of the other operand;
          otherwise, one operand is a pointer to <code class="code">void</code> or a qualified version of
            <code class="code">void</code>, in which case the result type is a pointer to an appropriately
          qualified version of <code class="code">void</code>.</p><p>EXAMPLE The common type that results when the second and third operands are pointers
          is determined in two independent stages. The appropriate qualifiers, for example, do not
          depend on whether the two pointers have compatible types.</p><p>Given the declarations</p><pre class="CLexer"><div class="highlight"><pre><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">c_vp</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">vp</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">c_ip</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">int</span> <span class="o">*</span><span class="n">v_ip</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">c_cp</span><span class="p">;</span>
</pre></div>
</pre><p>the third column in the following table is the common type that is the result of a
          conditional expression in which the first two columns are the second and third operands
          (in either order):</p><pre class="CLexer"><div class="highlight"><pre><span class="n">c_vp</span> <span class="n">c_ip</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span>
<span class="n">v_ip</span> <span class="mi">0</span>    <span class="k">volatile</span> <span class="kt">int</span> <span class="o">*</span>
<span class="n">c_ip</span> <span class="n">v_ip</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="o">*</span>
<span class="n">vp</span>   <span class="n">c_cp</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span>
<span class="n">ip</span>   <span class="n">c_ip</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span>
<span class="n">vp</span>   <span class="n">ip</span>   <span class="kt">void</span> <span class="o">*</span>
</pre></div>
</pre></div><div class="sect2" title="4.5.16. Assignment operators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4238080"></a>4.5.16. Assignment operators</h3></div></div></div><p><span class="bold"><strong>Contraints</strong></span></p><p>An assignment operator shall have a modifiable lvalue as its left operand.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>An assignment operator stores a value in the object designated by the left operand.
          An assignment expression has the value of the left operand after the assignment, but is
          not an lvalue. The type of an assignment expression is the type of the left operand unless
          the left operand has qualified type, in which case it is the unqualified version of the
          type of the left operand. The side effect of updating the stored value of the left operand
          shall occur between the previous and the next sequence point.</p><p>The order of evaluation of the operands is unspecified. If an attempt is made to
          modify the result of an assignment operator or to access it after the next sequence point,
          the behavior is undefined.</p><div class="sect3" title="4.5.16.1. Simple Assignment"><div class="titlepage"><div><div><h4 class="title"><a name="idp4243008"></a>4.5.16.1. Simple Assignment</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>One of the following shall hold:<sup>[<a class="footnote" href="#ftn.idp4245120" name="idp4245120">86</a>]</sup></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>the left operand has qualified or
                unqualified arithmetic type and the right has arithmetic type;</p></li><li class="listitem"><p>the left operand has a qualified or
                unqualified version of a structure or union type compatible with the type of the
                right;</p></li><li class="listitem"><p>both operands are pointers to qualified or
                unqualified versions of compatible types, and the type pointed to by the left has
                all the qualifiers of the type pointed to by the right;</p></li><li class="listitem"><p>one operand is a pointer to an object or
                incomplete type and the other is a pointer to a qualified or unqualified version of
                void, and the type pointed to by the left has all the qualifiers of the type pointed
                to by the right;</p></li><li class="listitem"><p>the left operand is a pointer and the
                right is a null pointer constant; or</p></li><li class="listitem"><p>the left operand has type
                  <code class="code">_Bool</code> and the right is a pointer.</p></li></ul></div><p><span class="bold"><strong>Semantics</strong></span></p><p>In simple assignment (=), the value of the right operand is converted to the type
            of the assignment expression and replaces the value stored in the object designated by
            the left operand.</p><p>If the value being stored in an object is read from another object that overlaps
            in any way the storage of the first object, then the overlap shall be exact and the two
            objects shall have qualified or unqualified versions of a compatible type; otherwise,
            the behavior is undefined.</p><p>EXAMPLE 1 In the program fragment</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="p">())</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="cm">/* ... */</span>
</pre></div>
</pre><p>the int value returned by the function may be truncated when stored in the
              <code class="code">char</code>, and then converted back to <code class="code">int</code> width prior to
            the comparison. In an implementation in which “plain” <code class="code">char</code> has the same
            range of values as <code class="code">unsigned char</code> (and <code class="code">char</code> is narrower
            than <code class="code">int</code>), the result of the conversion cannot be negative, so the
            operands of the comparison can never compare equal. Therefore, for full portability, the
            variable c should be declared as <code class="code">int</code>.</p><p>EXAMPLE 2 In the fragment:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">l</span><span class="p">;</span>
<span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">i</span><span class="p">);</span>
</pre></div>
</pre><p>the value of <code class="code">i</code> is converted to the type of the assignment
            expression <code class="code">c = i</code>, that is, <code class="code">char</code> type. The value of the
            expression enclosed in parentheses is then converted to the type of the outer assignment
            expression, that is, <code class="code">long int</code> type.</p><p>EXAMPLE 3 Consider the fragment:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">cpp</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
<span class="n">cpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>   <span class="c1">// constraint violation</span>
<span class="o">*</span><span class="n">cpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>  <span class="c1">// valid</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// valid</span>
</pre></div>
</pre><p>The first assignment is unsafe because it would allow the following valid code to
            attempt to change the value of the <code class="code">const</code> object
            <code class="code">c</code>.</p></div><div class="sect3" title="4.5.16.2. Compound assignments"><div class="titlepage"><div><div><h4 class="title"><a name="idp4269152"></a>4.5.16.2. Compound assignments</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>For the operators <code class="code">+=</code> and <code class="code">-=</code> only, either the
            left operand shall be a pointer to an object type and the right shall have integer type,
            or the left operand shall have qualified or unqualified arithmetic type and the right
            shall have arithmetic type.</p><p>For the other operators, each operand shall have arithmetic type consistent with
            those allowed by the corresponding binary operator.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A compound assignment of the form <code class="code">E1 op = E2</code> differs from the
            simple assignment expression <code class="code">E1 = E1 op (E2)</code> only in that the lvalue
              <code class="code">E1</code> is evaluated only once.</p></div></div><div class="sect2" title="4.5.17. Comma operator"><div class="titlepage"><div><div><h3 class="title"><a name="idp4276288"></a>4.5.17. Comma operator</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The left operand of a comma operator is evaluated as a void expression; there is a
          sequence point after its evaluation. Then the right operand is evaluated; the result has
          its type and value.<sup>[<a class="footnote" href="#ftn.idp4278576" name="idp4278576">87</a>]</sup> If an attempt is made to modify the result of a comma operator or to access
          it after the next sequence point, the behavior is undefined.</p><p>EXAMPLE As indicated by the syntax, the comma operator (as described in this
          subclause) cannot appear in contexts where a comma is used to separate items in a list
          (such as arguments to functions or lists of initializers). On the other hand, it can be
          used within a parenthesized expression or within the second expression of a conditional
          operator in such contexts. In the function call:</p><pre class="programlisting">f(a, (t=3, t+2), c)</pre><p>the function has three arguments, the second of which has the value 5.</p><p><span class="bold"><strong>Forward
            references:</strong></span> initialization (Initialization).</p></div></div><div class="sect1" title="4.6. Constant expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp4283344"></a>4.6. Constant expressions</h2></div></div></div><p><span class="bold"><strong>Description</strong></span></p><p>A constant expression can be evaluated during translation rather than runtime, and
        accordingly may be used in any place that a constant may be.</p><p><span class="bold"><strong>Constraints</strong></span></p><p>Constant expressions shall not contain assignment, increment, decrement,
        function-call, or comma operators, except when they are contained within a subexpression
        that is not evaluated.<sup>[<a class="footnote" href="#ftn.idp4287168" name="idp4287168">88</a>]</sup></p><p>Each constant expression shall evaluate to a constant that is in the range of
        representable values for its type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>An expression that evaluates to a constant is required in several contexts. If a
        floating expression is evaluated in the translation environment, the arithmetic precision
        and range shall be at least as great as if the expression were being evaluated in the
        execution environment.</p><p>An <span class="italic">integer constant
          expression</span><sup>[<a class="footnote" href="#ftn.idp4291792" name="idp4291792">89</a>]</sup> shall have integer type and shall only have operands that are integer
        constants, enumeration constants, character constants, <code class="code">sizeof</code> expressions
        whose results are integer constants, and floating constants that are the immediate operands
        of casts. Cast operators in an integer constant expression shall only convert arithmetic
        types to integer types, except as part of an operand to the <code class="code">sizeof</code>
        operator.</p><p>More latitude is permitted for constant expressions in initializers. Such a constant
        expression shall be, or evaluate to, one of the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>an arithmetic constant expression,</p></li><li class="listitem"><p>a null pointer constant,</p></li><li class="listitem"><p>an address constant, or</p></li><li class="listitem"><p>an address constant for an object type plus or
            minus an integer constant expression.</p></li></ul></div><p>An <span class="italic">arithmetic constant
          expression</span> shall have arithmetic type and shall only have operands that are
        integer constants, floating constants, enumeration constants, character constants, and
        sizeof expressions. Cast operators in an arithmetic constant expression shall only convert
        arithmetic types to arithmetic types, except as part of an operand to a
          <code class="code">sizeof</code> operator whose result is an integer constant.</p><p>An <span class="italic">address
          constant</span> is a null pointer, a pointer to an lvalue designating an object of
        static storage duration, or a pointer to a function designator; it shall be created
        explicitly using the unary <code class="code">&</code> operator or an integer constant cast to
        pointer type, or implicitly by the use of an expression of array or function type. The
        array-subscript <code class="code">[]</code> and member-access <code class="code">.</code> and
          <code class="code">-></code> operators, the address <code class="code">&</code> and indirection
          <code class="code">*</code> unary operators, and pointer casts may be used in the creation of an
        address constant, but the value of an object shall not be accessed by use of these
        operators.</p><p>An implementation may accept other forms of constant expressions.</p><p>The semantic rules for the evaluation of a constant expression are the same as for
        nonconstant expressions.<sup>[<a class="footnote" href="#ftn.idp4307168" name="idp4307168">90</a>]</sup></p><p><span class="bold"><strong>Forward
          references:</strong></span> array declarators (Array declarators), initialization
        (Initialization).</p></div><div class="sect1" title="4.7. Declarations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp4309952"></a>4.7. Declarations</h2></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A declaration shall declare at least a declarator (other than the parameters of a
        function or the members of a structure or union), a tag, or the members of an
        enumeration.</p><p>If an identifier has no linkage, there shall be no more than one declaration of the
        identifier (in a declarator or type specifier) with the same scope and in the same name
        space, except for tags as specified in Tags.</p><p>All declarations in the same scope that refer to the same object or function shall
        specify compatible types.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A declaration specifies the interpretation and attributes of a set of identifiers. A
        definition of an identifier is a declaration for that identifier that:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>for an object, causes storage to be reserved
            for that object;</p></li><li class="listitem"><p>for a function, includes the function body;<sup>[<a class="footnote" href="#ftn.idp4317232" name="idp4317232">91</a>]</sup></p></li><li class="listitem"><p>for an enumeration constant or typedef name,
            is the (only) declaration of the identifier.</p></li></ul></div><p>The declaration specifiers consist of a sequence of specifiers that indicate the
        linkage, storage duration, and part of the type of the entities that the declarators denote.
        The init- declarator-list is a comma-separated sequence of declarators, each of which may
        have additional type information, or an initializer, or both. The declarators contain the
        identifiers (if any) being declared.</p><p>If an identifier for an object is declared with no linkage, the type for the object
        shall be complete by the end of its declarator, or by the end of its init-declarator if it
        has an initializer; in the case of function parameters (including in prototypes), it is the
        adjusted type (see Function declarators (including prototypes)) that is required to be
        complete.</p><p><span class="bold"><strong>Forward
          references:</strong></span> declarators (Declarators), enumeration specifiers (Enumeration
        specifiers), initialization (Initialization).</p><div class="sect2" title="4.7.1. Storage-class specifiers"><div class="titlepage"><div><div><h3 class="title"><a name="idp4322528"></a>4.7.1. Storage-class specifiers</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>At most, one storage-class specifier may be given in the declaration specifiers in a
          declaration.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The typedef specifier is called a “storage-class specifier” for syntactic
          convenience only; it is discussed in Type definitions. The meanings of the various
          linkages and storage durations were discussed in Linkages of identifiers and Storage
          duration of objects.</p><p>A declaration of an identifier for an object with storage-class specifier
            <code class="code">register</code> suggests that access to the object be as fast as possible. The
          extent to which such suggestions are effective is implementation-defined.<sup>[<a class="footnote" href="#ftn.idp4327520" name="idp4327520">92</a>]</sup></p><p>The declaration of an identifier for a function that has block scope shall have no
          explicit storage-class specifier other than <code class="code">extern</code>.</p><p>If an aggregate or union object is declared with a storage-class specifier other
          than <code class="code">typedef</code>, the properties resulting from the storage-class specifier,
          except with respect to linkage, also apply to the members of the object, and so on
          recursively for any aggregate or union member objects.</p><p><span class="bold"><strong>Forward
            references:</strong></span> type definitions (Type definitions).</p></div><div class="sect2" title="4.7.2. Type specifiers"><div class="titlepage"><div><div><h3 class="title"><a name="idp4333856"></a>4.7.2. Type specifiers</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>At least one type specifier shall be given in the declaration specifiers in each
          declaration, and in the specifier-qualifier list in each struct declaration and type name.
          Each list of type specifiers shall be one of the following sets (delimited by commas, when
          there is more than one set on a line); the type specifiers may occur in any order,
          possibly intermixed with the other declaration specifiers.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">void</code></p></li><li class="listitem"><p><code class="code">char</code></p></li><li class="listitem"><p><code class="code">signed char</code></p></li><li class="listitem"><p><code class="code">unsigned char</code></p></li><li class="listitem"><p><code class="code">short, signed short, short int</code>
              or <code class="code">signed short int</code></p></li><li class="listitem"><p><code class="code">unsigned short</code> or
                <code class="code">unsigned short int</code></p></li><li class="listitem"><p><code class="code">int, signed</code> or <code class="code">signed
                int</code></p></li><li class="listitem"><p><code class="code">unsigned</code> or <code class="code">unsigned
                int</code></p></li><li class="listitem"><p><code class="code">long, signed long, long int</code> or
                <code class="code">signed long int</code></p></li><li class="listitem"><p><code class="code">unsigned long</code> or <code class="code">unsigned
                long int</code></p></li><li class="listitem"><p><code class="code">long long, signed long long, long long
                int</code> or <code class="code">signed long long int</code></p></li><li class="listitem"><p><code class="code">unsigned long long</code> or
                <code class="code">unsigned long long int</code></p></li><li class="listitem"><p><code class="code">float</code></p></li><li class="listitem"><p><code class="code">double</code></p></li><li class="listitem"><p><code class="code">long double</code></p></li><li class="listitem"><p><code class="code">_Bool</code></p></li><li class="listitem"><p><code class="code">float _Complex</code></p></li><li class="listitem"><p><code class="code">double _Complex</code></p></li><li class="listitem"><p><code class="code">long double _Complex</code></p></li><li class="listitem"><p><code class="code">struct</code> or <code class="code">union</code>
              specifier</p></li><li class="listitem"><p><code class="code">enum</code> specifier</p></li><li class="listitem"><p><code class="code">typedef</code> name </p></li></ul></div><p>The type specifier <code class="code">_Complex</code> shall not be used if the implementation
          does not provide complex types.<sup>[<a class="footnote" href="#ftn.idp4367440" name="idp4367440">93</a>]</sup></p><p><span class="bold"><strong>Semantics</strong></span></p><p>Specifiers for structures, unions, and enumerations are discussed in Structure and
          union specifiers through Tags. Declarations of typedef names are discussed in Type
          definitions. The characteristics of the other types are discussed in Types.</p><p>Each of the comma-separated sets designates the same type, except that for
          bit-fields, it is implementation-defined whether the specifier int designates the same
          type as <code class="code">signed int</code> or the same type as <code class="code">unsigned
          int</code>.</p><p><span class="bold"><strong>Forward
            references:</strong></span> enumeration specifiers (Enumeration specifiers), structure and
          union specifiers (Structure and union specifiers), tags (Tags), type definitions (Type
          definitions).</p><div class="sect3" title="4.7.2.1. Structure and union specifiers"><div class="titlepage"><div><div><h4 class="title"><a name="idp4372864"></a>4.7.2.1. Structure and union specifiers</h4></div></div></div><p>A structure or union shall not contain a member with incomplete or function type
            (hence, a structure shall not contain an instance of itself, but may contain a pointer
            to an instance of itself), except that the last member of a structure with more than one
            named member may have incomplete array type; such a structure (and any union containing,
            possibly recursively, a member that is such a structure) shall not be a member of a
            structure or an element of an array.</p><p>The expression that specifies the width of a bit-field shall be an integer
            constant expression with a nonnegative value that does not exceed the width of an object
            of the type that would be specified were the colon and expression omitted. If the value
            is zero, the declaration shall have no declarator.</p><p>A bit-field shall have a type that is a qualified or unqualified version of
              <code class="code">_Bool, signed int, unsigned int</code> or some other implementation-defined
            type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>As discussed in Types, a structure is a type consisting of a sequence of members,
            whose storage is allocated in an ordered sequence, and a union is a type consisting of a
            sequence of members whose storage overlap.</p><p>Structure and union specifiers have the same form.</p><p>The presence of a struct-declaration-list in a struct-or-union-specifier declares
            a new type, within a translation unit. The struct-declaration-list is a sequence of
            declarations for the members of the structure or union. If the struct-declaration-list
            contains no named members, the behavior is undefined. The type is incomplete until after
            the <code class="code">}</code> that terminates the list.</p><p>A member of a structure or union may have any object type other than a variably
            modified type.<sup>[<a class="footnote" href="#ftn.idp4380272" name="idp4380272">94</a>]</sup> In addition, a member may be declared to consist of a specified number of
            bits (including a sign bit, if any). Such a member is called a <span class="italic">bit-field</span>;<sup>[<a class="footnote" href="#ftn.idp4382320" name="idp4382320">95</a>]</sup> its width is preceded by a colon.</p><p>A bit-field is interpreted as a signed or unsigned integer type consisting of the
            specified number of bits.<sup>[<a class="footnote" href="#ftn.idp4384368" name="idp4384368">96</a>]</sup> If the value 0 or 1 is stored into a nonzero-width bit-field of type
              <code class="code">_Bool</code>, the value of the bit-field shall compare equal to the value
            stored.</p><p>An implementation may allocate any addressable storage unit large enough to hold a
            bit- field. If enough space remains, a bit-field that immediately follows another
            bit-field in a structure shall be packed into adjacent bits of the same unit. If
            insufficient space remains, whether a bit-field that does not fit is put into the next
            unit or overlaps adjacent units is implementation-defined. The order of allocation of
            bit-fields within a unit (high-order to low-order or low-order to high-order) is
            implementation-defined. The alignment of the addressable storage unit is
            unspecified.</p><p>A bit-field declaration with no declarator, but only a colon and a width,
            indicates an unnamed bit-field.<sup>[<a class="footnote" href="#ftn.idp4388560" name="idp4388560">97</a>]</sup>As a special case, a bit-field structure member with a width of 0 indicates
            that no further bit-field is to be packed into the unit in which the previous bit-
            field, if any, was placed.</p><p>Each non-bit-field member of a structure or union object is aligned in an
            implementation- defined manner appropriate to its type.</p><p>Within a structure object, the non-bit-field members and the units in which
            bit-fields reside have addresses that increase in the order in which they are declared.
            A pointer to a structure object, suitably converted, points to its initial member (or if
            that member is a bit-field, then to the unit in which it resides), and vice versa. There
            may be unnamed padding within a structure object, but not at its beginning.</p><p>The size of a union is sufficient to contain the largest of its members. The value
            of at most one of the members can be stored in a union object at any time. A pointer to
            a union object, suitably converted, points to each of its members (or if a member is a
            bit- field, then to the unit in which it resides), and vice versa.</p><p>There may be unnamed padding at the end of a structure or union.</p><p>As a special case, the last element of a structure with more than one named member
            may have an incomplete array type; this is called a <span class="italic">flexible array member</span>.
            In most situations, the flexible array member is ignored. In particular, the size of the
            structure is as if the flexible array member were omitted except that it may have more
            trailing padding than the omission would imply. However, when a <code class="code">.</code> (or
              <code class="code">-></code>) operator has a left operand that is (a pointer to) a structure
            with a flexible array member and the right operand names that member, it behaves as if
            that member were replaced with the longest array (with the same element type) that would
            not make the structure larger than the object being accessed; the offset of the array
            shall remain that of the flexible array member, even if this would differ from that of
            the replacement array. If this array would have no elements, it behaves as if it had one
            element but the behavior is undefined if any attempt is made to access that element or
            to generate a pointer one past it.</p><p>EXAMPLE After the declaration:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">s</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="kt">double</span> <span class="n">d</span><span class="p">[];</span> <span class="p">};</span>
</pre></div>
</pre><p>the structure struct s has a flexible array member d. A typical way to use this
            is:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="cm">/* some value */</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">s</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">double</span> <span class="p">[</span><span class="n">m</span><span class="p">]));</span>
</pre></div>
</pre><p>and assuming that the call to malloc succeeds, the object pointed to by p behaves,
            for most purposes, as if p had been declared as:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="kt">double</span> <span class="n">d</span><span class="p">[</span><span class="n">m</span><span class="p">];</span> <span class="p">}</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</pre></div>
</pre><p>(there are circumstances in which this equivalence is broken; in particular, the
            offsets of member d might not be the same).</p><p>Following the above declaration:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">s</span> <span class="n">t1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>         <span class="c1">// valid</span>
<span class="k">struct</span> <span class="n">s</span> <span class="n">t2</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span> <span class="mf">4.2</span> <span class="p">}};</span> <span class="c1">// invalid</span>
<span class="n">t1</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>                    <span class="c1">// valid</span>
<span class="n">t1</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.2</span><span class="p">;</span>               <span class="c1">// might be undefined behavior</span>
</pre></div>
</pre><p>The initialization of <code class="code">t2</code> is invalid (and violates a constraint)
            because <code class="code">struct s</code> is treated as if it did not contain member
              <code class="code">d</code>. The assignment to <code class="code">t1.d[0]</code> is probably undefined
            behavior, but it is possible that</p><pre class="CLexer"><div class="highlight"><pre><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span>
</pre></div>
</pre><p>in which case the assignment would be legitimate. Nevertheless, it cannot appear
            in strictly conforming code. After the further declaration:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">ss</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="p">};</span>
<span class="n">the</span> <span class="n">expressions</span><span class="o">:</span>
<span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ss</span><span class="p">)</span>
<span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</pre><p>are always equal to 1.</p><p>If <code class="code">sizeof (double)</code> is 8, then after the following code is
            executed:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">s</span> <span class="o">*</span><span class="n">s1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">s</span> <span class="o">*</span><span class="n">s2</span><span class="p">;</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">64</span><span class="p">);</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">46</span><span class="p">);</span>
</pre></div>
</pre><p>and assuming that the calls to <code class="code">malloc</code> succeed, the objects
            pointed to by <code class="code">s1</code> and <code class="code">s2</code> behave, for most purposes, as
            if the identifiers had been declared as:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="kt">double</span> <span class="n">d</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="p">}</span> <span class="o">*</span><span class="n">s1</span><span class="p">;</span>
<span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="kt">double</span> <span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="p">}</span> <span class="o">*</span><span class="n">s2</span><span class="p">;</span>
</pre></div>
</pre><p>Following the further successful assignments:</p><pre class="CLexer"><div class="highlight"><pre><span class="n">s1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
</pre></div>
</pre><p>they then behave as if the declarations were:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="kt">double</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="p">}</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="o">*</span><span class="n">s2</span><span class="p">;</span>
</pre></div>
</pre><p>and:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">double</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
<span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// valid</span>
<span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>         <span class="c1">// valid</span>
<span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">s2</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// valid</span>
<span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>         <span class="c1">// undefined behavior</span>
</pre></div>
</pre><p>The assignment:</p><pre class="programlisting">*s1 = *s2;</pre><p>only copies the member <code class="code">n</code>; if any of the array elements are within
            the first <code class="code">sizeof (struct s)</code> bytes of the structure, they might be
            copied or simply overwritten with indeterminate values.</p><p><span class="bold"><strong>Forward
              references:</strong></span> tags (Tags).</p></div><div class="sect3" title="4.7.2.2. Enumeration specifiers"><div class="titlepage"><div><div><h4 class="title"><a name="idp4418576"></a>4.7.2.2. Enumeration specifiers</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The expression that defines the value of an enumeration constant shall be an
            integer constant expression that has a value representable as an
            <code class="code">int</code>.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The identifiers in an enumerator list are declared as constants that have type int
            and may appear wherever such are permitted.<sup>[<a class="footnote" href="#ftn.idp4422800" name="idp4422800">98</a>]</sup> An enumerator with = defines its enumeration constant as the value of the
            constant expression. If the first enumerator has no =, the value of its enumeration
            constant is 0. Each subsequent enumerator with no = defines its enumeration constant as
            the value of the constant expression obtained by adding 1 to the value of the previous
            enumeration constant. (The use of enumerators with = may produce enumeration constants
            with values that duplicate other values in the same enumeration.) The enumerators of an
            enumeration are also known as its members.</p><p>Each enumerated type shall be compatible with char, a signed integer type, or an
            unsigned integer type. The choice of type is implementation-defined,<sup>[<a class="footnote" href="#ftn.idp4425088" name="idp4425088">99</a>]</sup> but shall be capable of representing the values of all the members of the
            enumeration. The enumerated type is incomplete until after the } that terminates the
            list of enumerator declarations.</p><p>The following fragment:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">enum</span> <span class="n">hue</span> <span class="p">{</span> <span class="n">chartreuse</span><span class="p">,</span> <span class="n">burgundy</span><span class="p">,</span> <span class="n">claret</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">winedark</span> <span class="p">};</span>
<span class="k">enum</span> <span class="n">hue</span> <span class="n">col</span><span class="p">,</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
<span class="n">col</span> <span class="o">=</span> <span class="n">claret</span><span class="p">;</span>
<span class="n">cp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span> <span class="o">!=</span> <span class="n">burgundy</span><span class="p">)</span>
<span class="cm">/* ... */</span>
</pre></div>
</pre><p>makes <code class="code">hue</code> the tag of an enumeration, and then declares
              <code class="code">col</code> as an object that has that type and <code class="code">cp</code> as a
            pointer to an object that has that type. The enumerated values are in the set <code class="code">{
              0, 1, 20, 21 }</code>.</p><p><span class="bold"><strong>Forward
              references:</strong></span> tags (Tags).</p></div><div class="sect3" title="4.7.2.3. Tags"><div class="titlepage"><div><div><h4 class="title"><a name="idp4431440"></a>4.7.2.3. Tags</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A specific type shall have its content defined at most once.</p><p>A type specifier of the form:</p><pre class="programlisting">enum *identifier*</pre><p>without an enumerator list shall only appear after the type it specifies is
            complete.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>All declarations of structure, union, or enumerated types that have the same scope
            and use the same tag declare the same type. The type is incomplete<sup>[<a class="footnote" href="#ftn.idp4436576" name="idp4436576">100</a>]</sup> until the closing brace of the list defining the content, and complete
            thereafter.</p><p>Two declarations of structure, union, or enumerated types which are in different
            scopes or use different tags declare distinct types. Each declaration of a structure,
            union, or enumerated type which does not include a tag declares a distinct
            type.</p><p>A type specifier of the form:</p><pre class="programlisting">struct-or-union identifier(optional) { struct-declaration-list }</pre><p>or:</p><pre class="programlisting">enum identifier { enumerator-list }</pre><p>or:</p><pre class="programlisting">enum identifier { enumerator-list , }</pre><p>declares a structure, union, or enumerated type. The list defines the <span class="italic">structure content, union
              content</span> or <span class="italic">enumeration content</span>. If an identifier is provided,<sup>[<a class="footnote" href="#ftn.idp4443728" name="idp4443728">101</a>]</sup> the type specifier also declares the identifier to be the tag of that
            type.</p><p>A declaration of the form:</p><pre class="programlisting">struct-or-union identifier ;</pre><p>specifies a structure or union type and declares the identifier as a tag of that
              type.<sup>[<a class="footnote" href="#ftn.b" name="b">102</a>]</sup></p><p>If a type specifier of the form:</p><pre class="programlisting">struct-or-union identifier</pre><p>occurs other than as part of one of the above forms, and no other declaration of
            the identifier as a tag is visible, then it declares an incomplete structure or union
            type, and declares the identifier as the tag of that type.<sup>[<a class="footnoteref" href="index.html#ftn.b">102</a>]</sup></p><p>If a type specifier of the form:</p><pre class="programlisting">struct-or-union identifier</pre><p>or:</p><pre class="programlisting">enum specifier</pre><p>occurs other than as part of one of the above forms, and a declaration of the
            identifier as a tag is visible, then it specifies the same type as that other
            declaration, and does not redeclare the tag.</p><p>EXAMPLE 1 This mechanism allows declaration of a self-referential
            structure.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">tnode</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</pre><p>specifies a structure that contains an integer and two pointers to objects of the
            same type. Once this declaration has been given, the declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">tnode</span> <span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
</pre></div>
</pre><p>declares <code class="code">s</code> to be an object of the given type and
              <code class="code">sp</code> to be a pointer to an object of the given type. With these
            declarations, the expression <code class="code">sp->left</code> refers to the <code class="code">left struct
              tnode</code> pointer of the object to which sp points; the expression
              <code class="code">s.right->count</code> designates the count member of the <code class="code">right
              struct tnode</code> pointed to from <code class="code">s</code>.</p><p>The following alternative formulation uses the typedef mechanism:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="n">TNODE</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tnode</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">TNODE</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">TNODE</span> <span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
</pre></div>
</pre><p>EXAMPLE 2 To illustrate the use of prior declaration of a tag to specify a pair of
            mutually referential structures, the declarations</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">s1</span> <span class="p">{</span> <span class="k">struct</span> <span class="n">s2</span> <span class="o">*</span><span class="n">s2p</span><span class="p">;</span> <span class="cm">/* ... */</span> <span class="p">};</span> <span class="c1">// D1</span>
<span class="k">struct</span> <span class="n">s2</span> <span class="p">{</span> <span class="k">struct</span> <span class="n">s1</span> <span class="o">*</span><span class="n">s1p</span><span class="p">;</span> <span class="cm">/* ... */</span> <span class="p">};</span> <span class="c1">// D2</span>
</pre></div>
</pre><p>specify a pair of structures that contain pointers to each other. Note, however,
            that if <code class="code">s2</code> were already declared as a tag in an enclosing scope, the
            declaration <code class="code">D1</code> would refer to it, not to the tag <code class="code">s2</code>
            declared in <code class="code">D2</code>. To eliminate this context sensitivity, the
            declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">s2</span><span class="p">;</span>
</pre></div>
</pre><p>may be inserted ahead of <code class="code">D1</code>. This declares a new tag
              <code class="code">s2</code> in the inner scope; the declaration <code class="code">D2</code> then
            completes the specification of the new type.</p><p><span class="bold"><strong>Forward
              references:</strong></span> declarators (Declarators), array declarators (Array
            declarators), type definitions (Type definitions).</p></div></div><div class="sect2" title="4.7.3. Type qualifiers"><div class="titlepage"><div><div><h3 class="title"><a name="idp4468480"></a>4.7.3. Type qualifiers</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Types other than pointer types derived from object or incomplete types shall not be
          restrict-qualified.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The properties associated with qualified types are meaningful only for expressions
          that are lvalues.<sup>[<a class="footnote" href="#ftn.idp4472176" name="idp4472176">103</a>]</sup></p><p>If the same qualifier appears more than once in the same <span class="italic">specifier-qualifier-list</span>,
          either directly or via one or more typedefs, the behavior is the same as if it appeared
          only once. If an attempt is made to modify an object defined with a const-qualified type
          through use of an lvalue with non-const-qualified type, the behavior is
          undefined.</p><p>If an attempt is made to refer to an object defined with a volatile-qualified type
          through use of an lvalue with non-volatile-qualified type, the behavior is undefined.<sup>[<a class="footnote" href="#ftn.idp4475808" name="idp4475808">104</a>]</sup></p><p>An object that has volatile-qualified type may be modified in ways unknown to the
          implementation or have other unknown side effects. Therefore any expression referring to
          such an object shall be evaluated strictly according to the rules of the abstract machine,
          as described in Program Execution. Furthermore, at every sequence point the value last
          stored in the object shall agree with that prescribed by the abstract machine, except as
          modified by the unknown factors mentioned previously.<sup>[<a class="footnote" href="#ftn.idp4477744" name="idp4477744">105</a>]</sup> What constitutes an access to an object that has volatile-qualified type is
          implementation-defined.</p><p>An object that is accessed through a restrict-qualified pointer has a special
          association with that pointer. This association, defined in Formal definition of restrict
          below, requires that all accesses to that object use, directly or indirectly, the value of
          that particular pointer.<sup>[<a class="footnote" href="#ftn.idp4480304" name="idp4480304">106</a>]</sup> The intended use of the <code class="code">restrict</code> qualifier (like the
            <code class="code">register</code> storage class) is to promote optimization, and deleting all
          instances of the qualifier from all preprocessing translation units composing a conforming
          program does not change its meaning (i.e., observable behavior).</p><p>If the specification of an array type includes any type qualifiers, the element type
          is so- qualified, not the array type. If the specification of a function type includes any
          type qualifiers, the behavior is undefined.<sup>[<a class="footnote" href="#ftn.idp4483200" name="idp4483200">107</a>]</sup></p><p>For two qualified types to be compatible, both shall have the identically qualified
          version of a compatible type; the order of type qualifiers within a list of specifiers or
          qualifiers does not affect the specified type.</p><p>EXAMPLE 1 An object declared</p><pre class="CLexer"><div class="highlight"><pre><span class="k">extern</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">real_time_clock</span><span class="p">;</span>
</pre></div>
</pre><p>may be modifiable by hardware, but cannot be assigned to, incremented, or
          decremented.</p><p>EXAMPLE 2 The following declarations and expressions illustrate the behavior when
          type qualifiers modify an aggregate type:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">const</span> <span class="k">struct</span> <span class="n">s</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">mem</span><span class="p">;</span> <span class="p">}</span> <span class="n">cs</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">s</span> <span class="n">ncs</span><span class="p">;</span> <span class="c1">// the object ncs is modifiable</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
<span class="k">const</span> <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}};</span> <span class="c1">// array of array of const int</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>

<span class="n">ncs</span> <span class="o">=</span> <span class="n">cs</span><span class="p">;</span>       <span class="c1">// valid</span>
<span class="n">cs</span> <span class="o">=</span> <span class="n">ncs</span><span class="p">;</span>       <span class="c1">// violates modifiable lvalue constraint for =</span>
<span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ncs</span><span class="p">.</span><span class="n">mem</span><span class="p">;</span>  <span class="c1">// valid</span>
<span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cs</span><span class="p">.</span><span class="n">mem</span><span class="p">;</span>   <span class="c1">// violates type constraints for =</span>
<span class="n">pci</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cs</span><span class="p">.</span><span class="n">mem</span><span class="p">;</span>  <span class="c1">// valid</span>
<span class="n">pi</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>      <span class="c1">// nvalid: a[0] has type &quot;const int *&quot;</span>
</pre></div>
</pre><div class="sect3" title="4.7.3.1. Formal definition of restrict"><div class="titlepage"><div><div><h4 class="title"><a name="idp4488256"></a>4.7.3.1. Formal definition of restrict</h4></div></div></div><p>Let <code class="code">D</code> be a declaration of an ordinary identifier that provides a
            means of designating an object <code class="code">P</code> as a restrict-qualified pointer to
            type <code class="code">T</code>.</p><p>If <code class="code">D</code> appears inside a block and does not have storage class
              <code class="code">extern</code>, let <code class="code">B</code> denote the block. If
              <code class="code">D</code> appears in the list of parameter declarations of a function
            definition, let <code class="code">B</code> denote the associated block. Otherwise, let
              <code class="code">B</code> denote the block of main (or the block of whatever function is
            called at program startup in a freestanding environment).</p><p>In what follows, a pointer expression <code class="code">E</code> is said to be based on
            object <code class="code">P</code> if (at some sequence point in the execution of
              <code class="code">B</code> prior to the evaluation of <code class="code">E</code>) modifying
              <code class="code">P</code> to point to a copy of the array object into which it formerly
            pointed would change the value of <code class="code">E</code>.<sup>[<a class="footnote" href="#ftn.idp4497664" name="idp4497664">108</a>]</sup> Note that “based” is defined only for expressions with pointer
            types.</p><p>During each execution of <code class="code">B</code>, let <code class="code">L</code> be any lvalue
            that has <code class="code">&L</code> based on <code class="code">P</code>. If L is used to access the
            value of the object <code class="code">X</code> that it designates, and <code class="code">X</code> is
            also modified (by any means), then the following requirements apply: <code class="code">T</code>
            shall not be const-qualified. Every other lvalue used to access the value of
              <code class="code">X</code> shall also have its address based on <code class="code">P</code>. Every
            access that modifies <code class="code">X</code> shall be considered also to modify
              <code class="code">P</code>, for the purposes of this subclause. If <code class="code">P</code> is
            assigned the value of a pointer expression <code class="code">E</code> that is based on another
            restricted pointer object <code class="code">P2</code>, associated with block
            <code class="code">B2</code>, then either the execution of <code class="code">B2</code> shall begin before
            the execution of <code class="code">B</code>, or the execution of <code class="code">B2</code> shall end
            prior to the assignment. If these requirements are not met, then the behavior is
            undefined.</p><p>Here an execution of <code class="code">B</code> means that portion of the execution of the
            program that would correspond to the lifetime of an object with scalar type and
            automatic storage duration ssociated with <code class="code">B</code>.</p><p>A translator is free to ignore any or all aliasing implications of uses of
            restrict.</p><p>EXAMPLE 1 The file scope declarations</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">b</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">c</span><span class="p">[];</span>
</pre></div>
</pre><p>assert that if an object is accessed using one of <code class="code">a, b</code> or
              <code class="code">c</code>, and that object is modified anywhere in the program, then it is
            never accessed using either of the other two.</p><p>EXAMPLE 2 The function parameter declarations in the following example</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>assert that, during each execution of the function, if an object is accessed
            through one of the pointer parameters, then it is not also accessed through the
            other.</p><p>The benefit of the restrict qualifiers is that they enable a translator to make an
            effective dependence analysis of function <code class="code">f</code> without examining any of
            the calls of <code class="code">f</code> in the program. The cost is that the programmer has to
            examine all of those calls to ensure that none give undefined behavior. For example, the
            second call of <code class="code">f</code> in <code class="code">g</code> has undefined behavior because
            each of <code class="code">d[1]</code> through <code class="code">d[49]</code> is accessed through both
              <code class="code">p</code> and <code class="code">q</code>.</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="n">f</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">50</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// valid</span>
  <span class="n">f</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// undefined behavior</span>
<span class="p">}</span>
</pre></div>
</pre><p>EXAMPLE 3 The function parameter declarations</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">h</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</pre><p>illustrate how an unmodified object can be aliased through two restricted
            pointers. In particular, if <code class="code">a</code> and <code class="code">b</code> are disjoint
            arrays, a call of the form <code class="code">h(100, a, b, b)</code> has defined behavior,
            because array <code class="code">b</code> is not modified within function
            <code class="code">h</code>.</p><p>EXAMPLE 4 The rule limiting assignments between restricted pointers does not
            distinguish between a function call and an equivalent nested block. With one exception,
            only “outer-to-inner” assignments between restricted pointers declared in nested blocks
            have defined behavior.</p><pre class="CLexer"><div class="highlight"><pre><span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">p1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">q1</span><span class="p">;</span>
  <span class="n">p1</span> <span class="o">=</span> <span class="n">q1</span><span class="p">;</span> <span class="c1">// undefined behavior</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span> <span class="c1">// valid</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">q1</span><span class="p">;</span> <span class="c1">// valid</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">q2</span><span class="p">;</span>                <span class="c1">// undefined behavior</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">q2</span><span class="p">;</span>                <span class="c1">// undefined behavior</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</pre><p>The one exception allows the value of a restricted pointer to be carried out of
            the block in which it (or, more precisely, the ordinary identifier used to designate it)
            is declared when that block finishes execution. For example, this permits
              <code class="code">new_vector</code> to return a <code class="code">vector</code>.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="kt">float</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">v</span><span class="p">;</span> <span class="p">}</span> <span class="n">vector</span><span class="p">;</span>
<span class="n">vector</span> <span class="nf">new_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">vector</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">t</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">t</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">float</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre></div></div><div class="sect2" title="4.7.4. Function specifiers"><div class="titlepage"><div><div><h3 class="title"><a name="idp4533264"></a>4.7.4. Function specifiers</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Function specifiers shall be used only in the declaration of an identifier for a
          function.</p><p>An <code class="code">inline</code> definition of a function with external linkage shall not
          contain a definition of a modifiable object with static storage duration, and shall not
          contain a reference to an identifier with internal linkage.</p><p>In a hosted environment, the inline function specifier shall not appear in a
          declaration of <code class="code">main</code>.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A function declared with an <code class="code">inline</code> function specifier is an
            <span class="italic">inline
          function</span>. The function specifier may appear more than once; the behavior is the
          same as if it appeared only once. Making a function an inline function suggests that calls
          to the function be as fast as possible.<sup>[<a class="footnote" href="#ftn.idp4540464" name="idp4540464">109</a>]</sup> The extent to which such suggestions are effective is implementation-defined.<sup>[<a class="footnote" href="#ftn.idp4542112" name="idp4542112">110</a>]</sup></p><p>Any function with internal linkage can be an inline function. For a function with
          external linkage, the following restrictions apply: If a function is declared with an
            <code class="code">inline</code> function specifier, then it shall also be defined in the same
          translation unit. If all of the file scope declarations for a function in a translation
          unit include the <code class="code">inline</code> function specifier without
            <code class="code">extern</code>, then the definition in that translation unit is an <span class="italic">inline definition</span>. An
          inline definition does not provide an external definition for the function, and does not
          forbid an external definition in another translation unit. An inline definition provides
          an alternative to an external definition, which a translator may use to implement any call
          to the function in the same translation unit. It is unspecified whether a call to the
          function uses the inline definition or the external definition.<sup>[<a class="footnote" href="#ftn.idp4546528" name="idp4546528">111</a>]</sup></p><p>EXAMPLE The declaration of an inline function with external linkage can result in
          either an external definition, or a definition available for use only within the
          translation unit. A file scope declaration with extern creates an
            <code class="code">external</code> definition. The following example shows an entire translation
          unit.</p><pre class="CLexer"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">double</span> <span class="nf">fahr</span><span class="p">(</span><span class="kt">double</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="mf">9.0</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="mf">5.0</span> <span class="o">+</span> <span class="mf">32.0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">double</span> <span class="nf">cels</span><span class="p">(</span><span class="kt">double</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">))</span> <span class="o">/</span> <span class="mf">9.0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">double</span> <span class="nf">fahr</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="c1">// creates an external definition</span>
<span class="kt">double</span> <span class="nf">convert</span><span class="p">(</span><span class="kt">int</span> <span class="n">is_fahr</span><span class="p">,</span> <span class="kt">double</span> <span class="n">temp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* A translator may perform inline substitutions */</span>
  <span class="k">return</span> <span class="n">is_fahr</span> <span class="o">?</span> <span class="n">cels</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">:</span> <span class="n">fahr</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</pre><p>Note that the definition of <code class="code">fahr</code> is an external definition because
            <code class="code">fahr</code> is also declared with <code class="code">extern</code>, but the definition
          of <code class="code">cels</code> is an inline definition. Because <code class="code">cels</code> has
          external linkage and is referenced, an external definition has to appear in another
          translation unit (see External definitions); the inline definition and the external
          definition are distinct and either may be used for the call.</p><p><span class="bold"><strong>Forward
            references:</strong></span> function definitions (Function definitions).</p></div><div class="sect2" title="4.7.5. Declarators"><div class="titlepage"><div><div><h3 class="title"><a name="idp4554288"></a>4.7.5. Declarators</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>Each declarator declares one identifier, and asserts that when an operand of the
          same form as the declarator appears in an expression, it designates a function or object
          with the scope, storage duration, and type indicated by the declaration
          specifiers.</p><p>A <span class="italic">full
            declarator</span> is a declarator that is not part of another declarator. The end of
          a full declarator is a sequence point. If the nested sequence of declarators in a full
          declarator contains a variable length array type, the type specified by the full
          declarator is said to be <span class="italic">variably modified</span>.</p><p>In the following subclauses, consider a declaration:</p><pre class="programlisting">T D1</pre><p>where <code class="code">T</code> contains the declaration specifiers that specify a type
            <code class="code">T</code> (such as <code class="code">int</code>) and <code class="code">D1</code> is a
          declarator that contains an identifier ident. The type specified for the identifier ident
          in the various forms of declarator is described inductively using this notation. If, in
          the declaration "<code class="code">T D1</code>", <code class="code">D1</code> has the form:</p><pre class="programlisting">identifier</pre><p>then the type specified for ident is <code class="code">T</code>. If, in the declaration
            "<code class="code">T D1</code>", <code class="code">D1</code> has the form:</p><pre class="programlisting">( D )</pre><p>then ident has the type specified by the declaration “<code class="code">T D</code>”. Thus, a
          declarator in parentheses is identical to the unparenthesized declarator, but the binding
          of complicated declarators may be altered by parentheses.</p><p><span class="bold"><strong>Implementation
            limits</strong></span></p><p>As discussed in Translation limits, an implementation may limit the number of
          pointer, array, and function declarators that modify an arithmetic, structure, union, or
          incomplete type, either directly or via one or more typedefs.</p><p><span class="bold"><strong>Forward
            references:</strong></span> array declarators (Array declarators), type definitions (Type
          definitions).</p><div class="sect3" title="4.7.5.1. Pointer declarators"><div class="titlepage"><div><div><h4 class="title"><a name="idp4570224"></a>4.7.5.1. Pointer declarators</h4></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>If, in the declaration "<code class="code">T D1</code>", <code class="code">D1</code> has the
            form:</p><pre class="programlisting">* type-qualifier-listopt D</pre><p>and the type specified for ident in the declaration "<code class="code">T D</code>" is
            “derived-declarator-type-list <code class="code">T</code>”, then the type specified for ident is
            “derived-declarator-type-list type-qualifier-list pointer to <code class="code">T</code>”. For
            each type qualifier in the list, ident is a so-qualified pointer.</p><p>For two pointer types to be compatible, both shall be identically qualified and
            both shall be pointers to compatible types.</p><p>EXAMPLE The following pair of declarations demonstrates the difference between a
            “variable pointer to a constant value” and a “constant pointer to a variable
            value”.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ptr_to_constant</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">constant_ptr</span><span class="p">;</span>
</pre></div>
</pre><p>The contents of any object pointed to by <code class="code">ptr_to_constant</code> shall
            not be modified through that pointer, but <code class="code">ptr_to_constant</code> itself may be
            changed to point to another object. Similarly, the contents of the int pointed to by
              <code class="code">constant_ptr</code> may be modified, but <code class="code">constant_ptr</code>
            itself shall always point to the same location. The declaration of the constant pointer
              <code class="code">constant_ptr</code> may be clarified by including a definition for the type
            “pointer to <code class="code">int</code>”.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="o">*</span><span class="n">int_ptr</span><span class="p">;</span>
<span class="k">const</span> <span class="n">int_ptr</span> <span class="n">constant_ptr</span><span class="p">;</span>
</pre></div>
</pre><p>declares <code class="code">constant_ptr</code> as an object that has type “const-qualified
            pointer to <code class="code">int</code>”.</p></div><div class="sect3" title="4.7.5.2. Array declarators"><div class="titlepage"><div><div><h4 class="title"><a name="idp4583616"></a>4.7.5.2. Array declarators</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>In addition to optional type qualifiers and the keyword <code class="code">static</code>,
            the <code class="code">[</code> and <code class="code">]</code> may delimit an expression or
              <code class="code">*</code>. If they delimit an expression (which specifies the size of an
            array), the expression shall have an integer type. If the expression is a constant
            expression, it shall have a value greater than zero. The element type shall not be an
            incomplete or function type. The optional type qualifiers and the keyword
              <code class="code">static</code> shall appear only in a declaration of a function parameter
            with an array type, and then only in the outermost array type derivation.</p><p>Only an ordinary identifier (as defined in 6.2.3) with both block scope or
            function prototype scope and no linkage shall have a variably modified type. If an
            identifier is declared to be an object with static storage duration, it shall not have a
            variable length array type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>If, in the declaration "<code class="code">T D1</code>", <code class="code">D1</code> has one of the
            forms:</p><pre class="programlisting">D[ type-qualifier-listopt assignment-expressionopt ]
D[ static type-qualifier-list(opt) assignment-expression ]
D[ type-qualifier-list static assignment-expression ]
D[ type-qualifier-listopt * ]</pre><p>and the type specified for ident in the declaration "<code class="code">T D</code>" is
            “derived-declarator-type-list <code class="code">T</code>”, then the type specified for ident is
            “derived-declarator-type-list array of <code class="code">T</code>”.<sup>[<a class="footnote" href="#ftn.idp4594128" name="idp4594128">112</a>]</sup> (See Function declarators (including prototypes) for the meaning of the
            optional type qualifiers and the keyword <code class="code">static</code>.)</p><p>If the size is not present, the array type is an incomplete type. If the size is *
            instead of being an expression, the array type is a variable length array type of
            unspecified size, which can only be used in declarations with function prototype scope;<sup>[<a class="footnote" href="#ftn.idp4596384" name="idp4596384">113</a>]</sup> such arrays are nonetheless complete types. If the size is an integer
            constant expression and the element type has a known constant size, the array type is
            not a variable length array type; otherwise, the array type is a variable length array
            type.</p><p>If the size is an expression that is not an integer constant expression: if it
            occurs in a declaration at function prototype scope, it is treated as if it were
            replaced by *; otherwise, each time it is evaluated it shall have a value greater than
            zero. The size of each instance of a variable length array type does not change during
            its lifetime. Where a size expression is part of the operand of a
              <code class="code">sizeof</code> operator and changing the value of the size expression would
            not affect the result of the operator, it is unspecified whether or not the size
            expression is evaluated.</p><p>For two array types to be compatible, both shall have compatible element types,
            and if both size specifiers are present, and are integer constant expressions, then both
            size specifiers shall have the same constant value. If the two array types are used in a
            context which requires them to be compatible, it is undefined behavior if the two size
            specifiers evaluate to unequal values.</p><p>EXAMPLE 1</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">float</span> <span class="n">fa</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="o">*</span><span class="n">afp</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
</pre></div>
</pre><p>declares an array of <code class="code">float</code> numbers and an array of pointers to
              <code class="code">float</code> numbers.</p><p>EXAMPLE 2 Note the distinction between the declarations</p><pre class="CLexer"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">y</span><span class="p">[];</span>
</pre></div>
</pre><p>The first declares <code class="code">x</code> to be a pointer to <code class="code">int</code>; the
            second declares <code class="code">y</code> to be an array of int of unspecified size (an
            incomplete type), the storage for which is defined elsewhere.</p><p>EXAMPLE 3 The following declarations demonstrate the compatibility rules for
            variably modified types.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">fcompat</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">6</span><span class="p">][</span><span class="n">m</span><span class="p">];</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">4</span><span class="p">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="mi">6</span><span class="p">][</span><span class="n">m</span><span class="p">];</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>               <span class="c1">// invalid: not compatible because 4 != 6</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>               <span class="c1">// compatible, but defined behavior only if</span>
                       <span class="c1">// n == 6 and m == n+1</span>
<span class="p">}</span>
</pre></div>
</pre><p>EXAMPLE 4 All declarations of variably modified (VM) types have to be at either
            block scope or function prototype scope. Array objects declared with the
              <code class="code">static</code> or <code class="code">extern</code> storage-class specifier cannot have
            a variable length array (VLA) type. However, an object declared with the
              <code class="code">static</code> storage-class specifier can have a VM type (that is, a pointer
            to a VLA type). Finally, all identifiers declared with a VM type have to be ordinary
            identifiers and cannot, therefore, be members of structures or unions.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                  <span class="c1">// invalid: file scope VLA</span>
<span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>                      <span class="c1">// invalid: file scope VM</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p2</span><span class="p">)[</span><span class="n">n</span><span class="p">];</span>           <span class="c1">// valid: file scope but not VM</span>
<span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">fvla</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">C</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">m</span><span class="p">]);</span> <span class="c1">// valid: VLA with prototype scope</span>
<span class="kt">void</span> <span class="nf">fvla</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">C</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">m</span><span class="p">])</span>  <span class="c1">// valid: adjusted to auto pointer to VLA</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">VLA</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">m</span><span class="p">];</span>         <span class="c1">// valid: block scope typedef VLA</span>

  <span class="k">struct</span> <span class="n">tag</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)[</span><span class="n">n</span><span class="p">];</span>                   <span class="c1">// invalid: y not ordinary identifier</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>                      <span class="c1">// invalid: z not ordinary identifier</span>
  <span class="p">};</span>
  <span class="kt">int</span> <span class="n">D</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>                      <span class="c1">// valid: auto VLA</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">E</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>               <span class="c1">// invalid: static block scope VLA</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">F</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>               <span class="c1">// invalid: F has linkage and is VLA</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)[</span><span class="n">m</span><span class="p">];</span>                   <span class="c1">// valid: auto pointer to VLA</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)[</span><span class="n">m</span><span class="p">];</span>            <span class="c1">// invalid: r has linkage and points to VLA</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">)[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">B</span><span class="p">;</span>       <span class="c1">// valid: q is a static block pointer to VLA</span>
<span class="p">}</span>
</pre></div>
</pre><p><span class="bold"><strong>Forward
              references:</strong></span> function declarators (Function declarators (including
            prototypes)), function definitions (Function definitions), initialization
            (Initialization).</p></div><div class="sect3" title="4.7.5.3. Function declarators (including prototypes)"><div class="titlepage"><div><div><h4 class="title"><a name="idp4613328"></a>4.7.5.3. Function declarators (including
            prototypes)</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A function declarator shall not specify a return type that is a function type or
            an array type.</p><p>The only storage-class specifier that shall occur in a parameter declaration is
              <code class="code">register</code>.</p><p>An identifier list in a function declarator that is not part of a definition of
            that function shall be empty.</p><p>After adjustment, the parameters in a parameter type list in a function declarator
            that is part of a definition of that function shall not have incomplete type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>If, in the declaration "<code class="code">T D1</code>", <code class="code">D1</code> has the
            form:</p><pre class="programlisting">D( parameter-type-list )</pre><p>or:</p><pre class="programlisting">D( identifier-listopt )</pre><p>and the type specified for ident in the declaration "T D" is
            “derived-declarator-type-list T”, then the type specified for ident is
            “derived-declarator-type-list function returning T”.</p><p>A parameter type list specifies the types of, and may declare identifiers for, the
            parameters of the function.</p><p>A declaration of a parameter as “array of type” shall be adjusted to “qualified
            pointer to type”, where the type qualifiers (if any) are those specified within the [
            and ] of the array type derivation. If the keyword <code class="code">static</code> also appears
            within the <code class="code">[</code> and <code class="code">]</code> of the array type derivation, then
            for each call to the function, the value of the corresponding actual argument shall
            provide access to the first element of an array with at least as many elements as
            specified by the size expression.</p><p>A declaration of a parameter as “function returning type” shall be adjusted to
            “pointer to function returning type”, as in Other Operands.</p><p>If the list terminates with an ellipsis (, ...), no information about the number
            or types of the parameters after the comma is supplied.<sup>[<a class="footnote" href="#ftn.idp4626080" name="idp4626080">114</a>]</sup></p><p>The special case of an unnamed parameter of type void as the only item in the list
            specifies that the function has no parameters.</p><p>If, in a parameter declaration, an identifier can be treated either as a typedef
            name or as a parameter name, it shall be taken as a typedef name.</p><p>If the function declarator is not part of a definition of that function,
            parameters may have incomplete type and may use the <code class="code">[*]</code> notation in
            their sequences of declarator specifiers to specify variable length array
            types.</p><p>The storage-class specifier in the declaration specifiers for a parameter
            declaration, if present, is ignored unless the declared parameter is one of the members
            of the parameter type list for a function definition.</p><p>An identifier list declares only the identifiers of the parameters of the
            function. An empty list in a function declarator that is part of a definition of that
            function specifies that the function has no parameters. The empty list in a function
            declarator that is not part of a definition of that function specifies that no
            information about the number or types of the parameters is supplied.</p><p>For two function types to be compatible, both shall specify compatible return
            types. Moreover, the parameter type lists, if both are present, shall agree in the
            number of parameters and in use of the ellipsis terminator; corresponding parameters
            shall have compatible types. If one type has a parameter type list and the other type is
            specified by a function declarator that is not part of a function definition and that
            contains an empty identifier list, the parameter list shall not have an ellipsis
            terminator and the type of each parameter shall be compatible with the type that results
            from the application of the default argument promotions. If one type has a parameter
            type list and the other type is specified by a function definition that contains a
            (possibly empty) identifier list, both shall agree in the number of parameters, and the
            type of each prototype parameter shall be compatible with the type that results from the
            application of the default argument promotions to the type of the corresponding
            identifier. (In the determination of type compatibility and of a composite type, each
            parameter declared with function or array type is taken as having the adjusted type and
            each parameter declared with qualified type is taken as having the unqualified version
            of its declared type.)<sup>[<a class="footnote" href="#ftn.idp4632720" name="idp4632720">115</a>]</sup></p><p>EXAMPLE 1 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">),</span> <span class="o">*</span><span class="n">fip</span><span class="p">(),</span> <span class="p">(</span><span class="o">*</span><span class="n">pfi</span><span class="p">)();</span>
</pre></div>
</pre><p>declares a function <code class="code">f</code> with no parameters returning an
              <code class="code">int</code>, a function <code class="code">fip</code> with no parameter specification
            returning a pointer to an <code class="code">int</code>, and a pointer <code class="code">pfi</code> to a
            function with no parameter specification returning an <code class="code">int</code>. It is
            especially useful to compare the last two. The binding of <code class="code">*fip()</code> is
              <code class="code">*(fip())</code>, so that the declaration suggests, and the same construction
            in an expression requires, the calling of a function <code class="code">fip</code>, and then
            using indirection through the pointer result to yield an <code class="code">int</code>. In the
            declarator <code class="code">(*pfi)()</code>, the extra parentheses are necessary to indicate
            that indirection through a pointer to a function yields a function designator, which is
            then used to call the function; it returns an <code class="code">int</code>. If the declaration
            occurs outside of any function, the identifiers have file scope and external linkage. If
            the declaration occurs inside a function, the identifiers of the functions
              <code class="code">f</code> and <code class="code">fip</code> have block scope and either internal or
            external linkage (depending on what file scope declarations for these identifiers are
            visible), and the identifier of the pointer <code class="code">pfi</code> has block scope and no
            linkage.</p><p>EXAMPLE 2 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">apfi</span><span class="p">[</span><span class="mi">3</span><span class="p">])(</span><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
</pre></div>
</pre><p>declares an array <code class="code">apfi</code> of three pointers to functions returning
              <code class="code">int</code>. Each of these functions has two parameters that are pointers to
              <code class="code">int</code>. The identifiers <code class="code">x</code> and <code class="code">y</code> are
            declared for descriptive purposes only and go out of scope at the end of the declaration
            of <code class="code">apfi</code>.</p><p>EXAMPLE 3 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fpfi</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">),</span> <span class="kt">int</span><span class="p">))(</span><span class="kt">int</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</pre><p>declares a function <code class="code">fpfi</code> that returns a pointer to a function
            returning an <code class="code">int</code>. The function <code class="code">fpfi</code> has two
            parameters: a pointer to a function returning an <code class="code">int</code> (with one
            parameter of type <code class="code">long int</code>), and an <code class="code">int</code>. The pointer
            returned by <code class="code">fpfi</code> points to a function that has one <code class="code">int</code>
            parameter and accepts zero or more additional arguments of any type.</p><p>EXAMPEL 4 The following prototype has a variably modified parameter.</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">addscalar</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>
<span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="o">+</span><span class="mi">300</span><span class="p">],</span> <span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">308</span><span class="p">];</span>
  <span class="n">addscalar</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mf">2.17</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">addscalar</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="o">+</span><span class="mi">300</span><span class="p">],</span> <span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="o">+</span><span class="mi">300</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
     <span class="c1">// a is a pointer to a VLA with n*m+300 elements</span>
     <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>EXAMPLE 5 The following are all compatible function prototype
            declarators.</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">double</span> <span class="nf">maximum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">]);</span>
<span class="kt">double</span> <span class="nf">maximum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="o">*</span><span class="p">][</span><span class="o">*</span><span class="p">]);</span>
<span class="kt">double</span> <span class="nf">maximum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[</span> <span class="p">][</span><span class="o">*</span><span class="p">]);</span>
<span class="kt">double</span> <span class="nf">maximum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="o">*</span><span class="p">][</span><span class="n">m</span><span class="p">]);</span>
</pre></div>
</pre><p>as are:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span> <span class="p">(</span><span class="o">*</span><span class="kr">restrict</span> <span class="n">a</span><span class="p">)[</span><span class="mi">5</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span>  <span class="n">a</span><span class="p">[</span><span class="kr">restrict</span><span class="p">][</span><span class="mi">5</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span>  <span class="n">a</span><span class="p">[</span><span class="kr">restrict</span> <span class="mi">3</span><span class="p">][</span><span class="mi">5</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span>  <span class="n">a</span><span class="p">[</span><span class="kr">restrict</span> <span class="k">static</span> <span class="mi">3</span><span class="p">][</span><span class="mi">5</span><span class="p">]);</span>
</pre></div>
</pre><p>(Note that the last declaration also specifies that the argument corresponding to
            a in any call to <code class="code">f</code> must be a non-null pointer to the first of at least
            three arrays of 5 doubles, which the others do not.)</p><p><span class="bold"><strong>Forward
              references:</strong></span> function definitions (Function definitions), type names (Type
            names).</p></div></div><div class="sect2" title="4.7.6. Type names"><div class="titlepage"><div><div><h3 class="title"><a name="idp4659952"></a>4.7.6. Type names</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>In several contexts, it is necessary to specify a type. This is accomplished using a
            <span class="italic">type name</span>,
          which is syntactically a declaration for a function or an object of that type that omits
          the identifier.<sup>[<a class="footnote" href="#ftn.idp4663072" name="idp4663072">116</a>]</sup></p><p>EXAMPLE The constructions:</p><pre class="programlisting">(a) int
(b) int *
(c) int *[3]
(d) int (*)[3]
(e) int (*)[*]
(f) int *()
(g) int(*)(void)
(h) int (*const [])(unsigned int, ...)</pre><p>name respectively the types (a) <code class="code">int</code>, (b) pointer to int, (c) array
          of three pointers to <code class="code">int</code>, (d) pointer to an array of three
            <code class="code">int</code>s, (e) pointer to a variable length array of an unspecified number
          of <code class="code">int</code>s, (f) function with no parameter specification returning a pointer
          to <code class="code">int</code>, (g) pointer to function with no parameters returning an
            <code class="code">int</code>, and (h) array of an unspecified number of constant pointers to
          functions, each with one parameter that has type <code class="code">unsigned int</code> and an
          unspecified number of other parameters, returning an <code class="code">int</code>.</p></div><div class="sect2" title="4.7.7. Type definitions"><div class="titlepage"><div><div><h3 class="title"><a name="idp4669824"></a>4.7.7. Type definitions</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>If a typedef name specifies a variably modified type then it shall have block
          scope.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>In a declaration whose storage-class specifier is <code class="code">typedef</code>, each
          declarator defines an identifier to be a typedef name that denotes the type specified for
          the identifier in the way described in Declarators. Any array size expressions associated
          with variable length array declarators are evaluated each time the declaration of the
          typedef name is reached in the order of execution. A <code class="code">typedef</code> declaration
          does not introduce a new type, only a synonym for the type so specified. That is, in the
          following declarations:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">T</span> <span class="n">type_ident</span><span class="p">;</span>
<span class="n">type_ident</span> <span class="n">D</span><span class="p">;</span>
</pre></div>
</pre><p><code class="code">type_ident</code> is defined as a typedef name with the type specified by
          the declaration specifiers in <code class="code">T</code> (known as <span class="italic">T</span> ), and the identifier
          in <code class="code">D</code> has the type “<span class="italic">derived-declarator-type-list T</span>” where the <span class="italic">derived-declarator-type-list</span> is specified by the declarators of
            <code class="code">D</code>. A typedef name shares the same name space as other identifiers
          declared in ordinary declarators.</p><p>EXAMPLE 1 After</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">MILES</span><span class="p">,</span> <span class="n">KLICKSP</span><span class="p">();</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">double</span> <span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">;</span> <span class="p">}</span> <span class="n">range</span><span class="p">;</span>
</pre></div>
</pre><p>the constructions:</p><pre class="CLexer"><div class="highlight"><pre><span class="n">MILES</span> <span class="n">distance</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">KLICKSP</span> <span class="o">*</span><span class="n">metricp</span><span class="p">;</span>
<span class="n">range</span> <span class="n">x</span><span class="p">;</span>
<span class="n">range</span> <span class="n">z</span><span class="p">,</span> <span class="o">*</span><span class="n">zp</span><span class="p">;</span>
</pre></div>
</pre><p>are all valid declarations. The type of <code class="code">distance</code> is
            <code class="code">int</code>, that of <code class="code">metricp</code> is “pointer to function with no
          parameter specification returning <code class="code">int</code>”, and that of <code class="code">x</code>
          and <code class="code">z</code> is the specified structure; <code class="code">zp</code> is a pointer to
          such a structure. The object distance has a type compatible with any other int
          object.</p><p>EXAMPLE 2 After the declarations</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s1</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span> <span class="n">t1</span><span class="p">,</span> <span class="o">*</span><span class="n">tp1</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s2</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span> <span class="n">t2</span><span class="p">,</span> <span class="o">*</span><span class="n">tp2</span><span class="p">;</span>
</pre></div>
</pre><p>type <code class="code">t1</code> and the type pointed to by <code class="code">tp1</code> are
          compatible. Type <code class="code">t1</code> is also compatible with type <code class="code">struct
            s1</code>, but not compatible with the types <code class="code">struct s2</code>,
            <code class="code">t2</code> the type pointed to by <code class="code">tp2</code> or
          <code class="code">int</code>.</p><p>The following obscure constructions</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">plain</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tag</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">t</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">t</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
  <span class="n">plain</span> <span class="n">r</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</pre><p>declare a typedef name <code class="code">t</code> with type <code class="code">signed int</code>, a
          typedef name <code class="code">plain</code> with type <code class="code">int</code> and a structure with
          three bit-field members, one named <code class="code">t</code> that contains values in the range
            <code class="code">[0, 15]</code>, an unnamed const- qualified bit-field which (if it could be
          accessed) would contain values in either the range <code class="code">[-15, +15]</code> or
            <code class="code">[-16, +15]</code>, and one named <code class="code">r</code> that contains values in
          one of the ranges <code class="code">[0, 31], [-15, +15]</code> or <code class="code">[-16, +15]</code>.
          (The choice of range is implementation-defined.) The first two bit-field declarations
          differ in that unsigned is a type specifier (which forces <code class="code">t</code> to be the
          name of a structure member), while const is a type qualifier (which modifies
            <code class="code">t</code> which is still visible as a typedef name). If these declarations are
          followed in an inner scope by</p><pre class="CLexer"><div class="highlight"><pre><span class="n">t</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span> <span class="p">(</span><span class="n">t</span><span class="p">));</span>
<span class="kt">long</span> <span class="n">t</span><span class="p">;</span>
</pre></div>
</pre><p>then a function <code class="code">f</code> is declared with type “function returning signed
          int with one unnamed parameter with type pointer to function returning <code class="code">signed
            int</code> with one unnamed parameter with type <code class="code">signed int</code>”, and an
          identifier t with type <code class="code">long int</code>.</p><p>EXAMPLE 4 On the other hand, typedef names can be used to improve code readability.
          All three of the following declarations of the <code class="code">signal</code> function specify
          exactly the same type, the first without making use of any typedef names.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">void</span> <span class="nf">fv</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="n">pfv</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">fv</span> <span class="o">*</span><span class="nf">signal</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">fv</span> <span class="o">*</span><span class="p">);</span>
<span class="n">pfv</span> <span class="nf">signal</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">pfv</span><span class="p">);</span>
</pre></div>
</pre><p>EXAMPLE 5 If a typedef name denotes a variable length array type, the length of the
          array is fixed at the time the typedef name is defined, not each time it is used:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">copyt</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>      <span class="c1">// B is n ints, n evaluated now</span>

  <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">B</span> <span class="n">a</span><span class="p">;</span>                   <span class="c1">// a is n ints, n without += 1</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>              <span class="c1">// a and b are different sizes</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</pre></div><div class="sect2" title="4.7.8. Initialization"><div class="titlepage"><div><div><h3 class="title"><a name="idp4707024"></a>4.7.8. Initialization</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>No initializer shall attempt to provide a value for an object not contained within
          the entity being initialized.</p><p>The type of the entity to be initialized shall be an array of unknown size or an
          object type that is not a variable length array type.</p><p>All the expressions in an initializer for an object that has static storage duration
          shall be constant expressions or string literals.</p><p>If the declaration of an identifier has block scope, and the identifier has external
          or internal linkage, the declaration shall have no initializer for the
          identifier.</p><p>If a designator has the form <code class="code">[</code><span class="italic">constant-expression</span><code class="code">]</code> then the current object (defined
          below) shall have array type and the expression shall be an integer constant
          expression.</p><p>If the array is of unknown size, any nonnegative value is valid. If a designator has
          the form <span class="italic">.identifier</span> then the current object (defined below) shall have structure or
          union type and the identifier shall be the name of a member of that type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>An initializer specifies the initial value stored in an object.</p><p>Except where explicitly stated otherwise, for the purposes of this subclause unnamed
          members of objects of structure and union type do not participate in initialization.
          Unnamed members of structure objects have indeterminate value even after
          initialization.</p><p>If an object that has automatic storage duration is not initialized explicitly, its
          value is indeterminate. If an object that has static storage duration is not initialized
          explicitly, then:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>if it has pointer type, it is initialized to
              a null pointer;</p></li><li class="listitem"><p>if it has arithmetic type, it is initialized
              to (positive or unsigned) zero;</p></li><li class="listitem"><p>if it is an aggregate, every member is
              initialized (recursively) according to these rules;</p></li><li class="listitem"><p>if it is a union, the first named member is
              initialized (recursively) according to these rules.</p></li></ul></div><p>The initializer for a scalar shall be a single expression, optionally enclosed in
          braces. The initial value of the object is that of the expression (after conversion); the
          same type constraints and conversions as for simple assignment apply, taking the type of
          the scalar to be the unqualified version of its declared type.</p><p>The rest of this subclause deals with initializers for objects that have aggregate
          or union type.</p><p>The initializer for a structure or union object that has automatic storage duration
          shall be either an initializer list as described below, or a single expression that has
          compatible structure or union type. In the latter case, the initial value of the object,
          including unnamed members, is that of the expression.</p><p>An array of character type may be initialized by a character string literal,
          optionally enclosed in braces. Successive characters of the character string literal
          (including the terminating null character if there is room or if the array is of unknown
          size) initialize the elements of the array.</p><p>An array with element type compatible with <code class="code">wchar_t</code> may be
          initialized by a wide string literal, optionally enclosed in braces. Successive wide
          characters of the wide string literal (including the terminating null wide character if
          there is room or if the array is of unknown size) initialize the elements of the
          array.</p><p>Otherwise, the initializer for an object that has aggregate or union type shall be a
          brace-enclosed list of initializers for the elements or named members.</p><p>Each brace-enclosed initializer list has an associated current object. When no
          designations are present, subobjects of the current object are initialized in order
          according to the type of the current object: array elements in increasing subscript order,
          structure members in declaration order, and the first named member of a union.<sup>[<a class="footnote" href="#ftn.idp4727616" name="idp4727616">117</a>]</sup> In contrast, a designation causes the following initializer to begin
          initialization of the subobject described by the designator. Initialization then continues
          forward in order, beginning with the next subobject after that described by the designator.<sup>[<a class="footnote" href="#ftn.idp4729088" name="idp4729088">118</a>]</sup></p><p>Each designator list begins its description with the current object associated with
          the closest surrounding brace pair. Each item in the designator list (in order) specifies
          a particular member of its current object and changes the current object for the next
          designator (if any) to be that member.<sup>[<a class="footnote" href="#ftn.idp4730768" name="idp4730768">119</a>]</sup> The current object that results at the end of the designator list is the
          subobject to be initialized by the following initializer.</p><p>The initialization shall occur in initializer list order, each initializer provided
          for a particular subobject overriding any previously listed initializer for the same subobject;<sup>[<a class="footnote" href="#ftn.idp4732624" name="idp4732624">120</a>]</sup> all subobjects that are not initialized explicitly shall be initialized
          implicitly the same as objects that have static storage duration.</p><p>If the aggregate or union contains elements or members that are aggregates or
          unions, these rules apply recursively to the subaggregates or contained unions. If the
          initializer of a subaggregate or contained union begins with a left brace, the
          initializers enclosed by that brace and its matching right brace initialize the elements
          or members of the subaggregate or the contained union. Otherwise, only enough initializers
          from the list are taken to account for the elements or members of the subaggregate or the
          first member of the contained union; any remaining initializers are left to initialize the
          next element or member of the aggregate of which the current subaggregate or contained
          union is a part.</p><p>If there are fewer initializers in a brace-enclosed list than there are elements or
          members of an aggregate, or fewer characters in a string literal used to initialize an
          array of known size than there are elements in the array, the remainder of the aggregate
          shall be initialized implicitly the same as objects that have static storage
          duration.</p><p>If an array of unknown size is initialized, its size is determined by the largest
          indexed element with an explicit initializer. At the end of its initializer list, the
          array no longer has incomplete type.</p><p>The order in which any side effects occur among the initialization list expressions
          is unspecified.<sup>[<a class="footnote" href="#ftn.idp4737008" name="idp4737008">121</a>]</sup></p><p>EXAMPLE 1 Provided that <complex.h> has been #included, the declarations</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">3.5</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">complex</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">I</span><span class="p">;</span>
</pre></div>
</pre><p>define and initialize <code class="code">i</code> with the value 3 and <code class="code">c</code>
          with the value 5. 0 + i3. 0.</p><p>EXAMPLE 2 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
</pre></div>
</pre><p>defines and initializes <code class="code">x</code> as a one-dimensional array object that
          has three elements, as no size was specified and there are three initializers.</p><p>EXAMPLE 3 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span> <span class="p">},</span>
      <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span> <span class="p">},</span>
      <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span> <span class="p">},</span>
<span class="p">};</span>
</pre></div>
</pre><p>is a definition with a fully bracketed initialization: <code class="code">1, 3,</code> and
            <code class="code">5</code> initialize the first row of <code class="code">y</code> (the array object
            <code class="code">y[0]</code>), namely <code class="code">y[0][0], y[0][1]</code> and
            <code class="code">y[0][2]</code>. Likewise the next two lines initialize <code class="code">y[1]</code>
          and <code class="code">y[2]</code>. The initializer ends early, so <code class="code">y[3]</code> is
          initialized with zeros. Precisely the same effect could have been achieved by</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span>
<span class="p">};</span>
</pre></div>
</pre><p>The initializer for <code class="code">y[0]</code> does not begin with a left brace, so three
          items from the list are used. Likewise the next three are taken successively for
            <code class="code">y[1]</code> and <code class="code">y[2]</code>.</p><p>EXAMPLE 4 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">z</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">3</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">4</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</pre><p>initializes the first column of <code class="code">z</code> as specified and initializes the
          rest with zeros.</p><p>EXAMPLE 5 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span> <span class="n">w</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">},</span> <span class="mi">2</span> <span class="p">};</span>
</pre></div>
</pre><p>is a definition with an inconsistently bracketed initialization. It defines an array
          with two element structures: <code class="code">w[0].a[0]</code> is 1 and
            <code class="code">w[1].a[0]</code> is 2; all the other elements are zero.</p><p>EXAMPLE 6 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">short</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="mi">1</span> <span class="p">},</span>
        <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
        <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</pre><p>contains an incompletely but consistently bracketed initialization. It defines a
          three-dimensional array object: <code class="code">q[0][0][0]</code> is 1,
            <code class="code">q[1][0][0]</code> is 2, <code class="code">q[1][0][1]</code> is 3, and 4, 5, and 6
          initialize <code class="code">q[2][0][0], q[2][0][1]</code> and <code class="code">q[2][1][0]</code>,
          respectively; all the rest are zero. The initializer for <code class="code">q[0][0]</code> does not
          begin with a left brace, so up to six items from the current list may be used. There is
          only one, so the values for the remaining five elements are initialized with zero.
          Likewise, the initializers for <code class="code">q[1][0]</code> and <code class="code">q[2][0]</code> do
          not begin with a left brace, so each uses up to six items, initializing their respective
          two-dimensional subaggregates. If there had been more than six items in any of the lists,
          a diagnostic message would have been issued. The same initialization result could have
          been achieved by:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">short</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span>
<span class="p">};</span>
</pre></div>
</pre><p>or by:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">short</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span>
       <span class="p">{</span> <span class="mi">1</span> <span class="p">},</span>
      <span class="p">},</span>
      <span class="p">{</span>
       <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
      <span class="p">},</span>
      <span class="p">{</span>
       <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">},</span>
       <span class="p">{</span> <span class="mi">6</span> <span class="p">},</span>
      <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</pre><p>in a fully bracketed form.</p><p>Note that the fully bracketed and minimally bracketed forms of initialization are,
          in general, less likely to cause confusion.</p><p>EXAMPLE 7 One form of initialization that completes array types involves typedef
          names. Given the declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[];</span> <span class="c1">// OK - declared with block scope</span>
</pre></div>
</pre><p>the declaration</p><pre class="programlisting">A a = { 1, 2 }, b = { 3, 4, 5 };</pre><p>is identical to:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="n">b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
</pre></div>
</pre><p>due to the rules for incomplete types.</p><p>EXAMPLE 8 The declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
</pre></div>
</pre><p>defines “plain” char array objects <code class="code">s</code> and <code class="code">t</code> whose
          elements are initialized with character string literals.</p><p>This declaration is identical to</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span> <span class="p">},</span>
<span class="n">t</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span> <span class="p">};</span>
</pre></div>
</pre><p>The contents of the arrays are modifiable. On the other hand, the
          declaration</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
</pre></div>
</pre><p>defines p with type “pointer to <code class="code">char</code>” and initializes it to point
          to an object with type “array of <code class="code">char</code>” with length 4 whose elements are
          initialized with a character string literal. If an attempt is made to use p to modify the
          contents of the array, the behavior is undefined.</p><p>EXAMPLE 9 Arrays can be initialized to correspond to the elements of an enumeration
          by using designators:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">enum</span> <span class="p">{</span> <span class="n">member_one</span><span class="p">,</span> <span class="n">member_two</span> <span class="p">};</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nm</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">member_two</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;member two&quot;</span><span class="p">,</span>
  <span class="p">[</span><span class="n">ember_one</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;member one&quot;</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</pre><p>EXAMPLE 10 Structure members can be initialized to nonzero values without depending
          on their order:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">div_t</span> <span class="n">answer</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">quot</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">.</span><span class="n">rem</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
</pre></div>
</pre><p>EXAMPLE 11 Designators can be used to provide explicit initialization when unadorned
          initializer lists might be misunderstood:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span> <span class="n">w</span><span class="p">[]</span> <span class="o">=</span>
         <span class="p">{</span> <span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>
</pre></div>
</pre><p>EXAMPLE 12 Space can be “allocated” from both ends of an array by using a single
          designator:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="p">[</span><span class="n">MAX</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
</pre></div>
</pre><p>In the above, if <code class="code">MAX</code> is greater than ten, there will be some
          zero-valued elements in the middle; if it is less than ten, some of the values provided by
          the first five initializers will be overridden by the second five.</p><p>EXAMPLE 13 Any member of a union can be initialized:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">union</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="n">u</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">any_member</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">};</span>
</pre></div>
</pre><p><span class="bold"><strong>Forward
            references:</strong></span> common definitions <code class="code"><stddef.h></code> (Common
          definitions <stddef.h>).</p></div></div><div class="sect1" title="4.8. Statements and blocks"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp4785536"></a>4.8. Statements and blocks</h2></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A statement specifies an action to be performed. Except as indicated, statements are
        executed in sequence.</p><p>A block allows a set of declarations and statements to be grouped into one syntactic
        unit. The initializers of objects that have automatic storage duration, and the variable
        length array declarators of ordinary identifiers with block scope, are evaluated and the
        values are stored in the objects (including storing an indeterminate value in objects
        without an initializer) each time the declaration is reached in the order of execution, as
        if it were a statement, and within each declaration in the order that declarators
        appear.</p><p>A <span class="italic">full
          expression</span> is an expression that is not part of another expression or of a
        declarator. Each of the following is a full expression: an initializer; the expression in an
        expression statement; the controlling expression of a selection statement
          (<code class="code">if</code> or <code class="code">switch</code>); the controlling expression of a
          <code class="code">while</code> or <code class="code">do</code> statement; each of the (optional)
        expressions of a <code class="code">for</code> statement; the (optional) expression in a
          <code class="code">return</code> statement. The end of a full expression is a sequence
        point.</p><p><span class="bold"><strong>Forward
          references:</strong></span> expression and null statements (Expression and null statements),
        selection statements (Selection statements), iteration statements (Iteration statements),
        the return statement (The return statement).</p><div class="sect2" title="4.8.1. Labeled statements"><div class="titlepage"><div><div><h3 class="title"><a name="idp4794624"></a>4.8.1. Labeled statements</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A <code class="code">case</code> or <code class="code">default</code> label shall appear only in a
            <code class="code">switch</code> statement. Further constraints on such labels are discussed
          under the <code class="code">switch</code> statement.</p><p>Label names shall be unique within a function.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>Any statement may be preceded by a prefix that declares an identifier as a label
          name. Labels in themselves do not alter the flow of control, which continues unimpeded
          across them.</p><p><span class="bold"><strong>Forward
            references:</strong></span> the <code class="code">goto</code> statement (The goto statement), the
            <code class="code">switch</code> statement (The switch statement).</p></div><div class="sect2" title="4.8.2. Compound statement"><div class="titlepage"><div><div><h3 class="title"><a name="idp4803088"></a>4.8.2. Compound statement</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A <span class="italic">compound
            statement</span> is a block.</p></div><div class="sect2" title="4.8.3. Expressions and null statements"><div class="titlepage"><div><div><h3 class="title"><a name="idp4806352"></a>4.8.3. Expressions and null statements</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>The expression in an expression statement is evaluated as a void expression for its
          side effects.<sup>[<a class="footnote" href="#ftn.idp4808560" name="idp4808560">122</a>]</sup></p><p>A <span class="italic">null
            statement</span> (consisting of just a semicolon) performs no operations.</p><p>EXAMPLE 1 If a function call is evaluated as an expression statement for its side
          effects only, the discarding of its value may be made explicit by converting the
          expression to a void expression by means of a cast:</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">p</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="cm">/* ... */</span>
<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</pre><p>EXAMPLE 2 In the program fragment</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
<span class="p">;</span>
</pre></div>
</pre><p>a null statement is used to supply an empty loop body to the iteration
          statement.</p><p>EXAMPLE 3 A null statement may also be used to carry a label just before the closing
            <code class="code">}</code> of a compound statement.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="n">loop1</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">loop2</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">want_out</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">end_loop1</span><span class="p">;</span>
    <span class="cm">/* ... */</span>
  <span class="p">}</span>
  <span class="cm">/* ... */</span>
  <span class="nl">end_loop1:</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p><span class="bold"><strong>Forward
            references:</strong></span> iteration statements (Iteration statements).</p></div><div class="sect2" title="4.8.4. Selection statements"><div class="titlepage"><div><div><h3 class="title"><a name="idp4817168"></a>4.8.4. Selection statements</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A selection statement selects among a set of statements depending on the value of a
          controlling expression.</p><p>A selection statement is a block whose scope is a strict subset of the scope of its
          enclosing block. Each associated substatement is also a block whose scope is a strict
          subset of the scope of the selection statement.</p><div class="sect3" title="4.8.4.1. The if statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4820192"></a>4.8.4.1. The <code class="code">if</code> statement</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The controlling expression of an <code class="code">if</code> statement shall have scalar
            type.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>In both forms, the first substatement is executed if the expression compares
            unequal to 0. In the <code class="code">else</code> form, the second substatement is executed if
            the expression compares equal to 0. If the first substatement is reached via a label,
            the second substatement is not executed.</p><p>An <code class="code">else</code> is associated with the lexically nearest preceding if
            that is allowed by the syntax.</p></div><div class="sect3" title="4.8.4.2. The switch statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4826656"></a>4.8.4.2. The <code class="code">switch</code> statement</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The controlling expression of a switch statement shall have integer type.</p><p>If a <code class="code">switch</code> statement has an associated <code class="code">case</code> or
              <code class="code">default</code> label within the scope of an identifier with a variably
            modified type, the entire switch statement shall be within the scope of that identifier.<sup>[<a class="footnote" href="#ftn.idp4831216" name="idp4831216">123</a>]</sup></p><p>The expression of each <code class="code">case</code> label shall be an integer constant
            expression and no two of the case constant expressions in the same
              <code class="code">switch</code> statement shall have the same value after conversion. There
            may be at most one <code class="code">default</code> label in a switch statement. (Any enclosed
              <code class="code">switch</code> statement may have a <code class="code">default</code> label or
              <code class="code">case</code> constant expressions with values that duplicate
              <code class="code">case</code> constant expressions in the enclosing <code class="code">switch</code>
            statement.)</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A <code class="code">switch</code> statement causes control to jump to, into, or past the
            statement that is the <span class="italic">switch body</span>, depending on the value of a controlling expression, and on
            the presence of a <code class="code">default</code> label and the values of any
              <code class="code">case</code> labels on or in the switch body. A <code class="code">case</code> or
              <code class="code">default</code> label is accessible only within the closest enclosing switch
            statement.</p><p>The integer promotions are performed on the controlling expression. The constant
            expression in each <code class="code">case</code> label is converted to the promoted type of the
            controlling expression. If a converted value matches that of the promoted controlling
            expression, control jumps to the statement following the matched <code class="code">case</code>
            label. Otherwise, if there is a <code class="code">default</code> label, control jumps to the
            labeled statement. If no converted case constant expression matches and there is no
              <code class="code">default</code> label, no part of the switch body is executed.</p><p><span class="bold"><strong>Implementation
              limits</strong></span></p><p>As discussed in Translation limits, the implementation may limit the number of
              <code class="code">case</code> values in a switch statement.</p><p>EXAMPLE In the artificial program fragment</p><pre class="CLexer"><div class="highlight"><pre><span class="k">switch</span> <span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="k">case</span> <span class="mi">0</span>:
    <span class="n">i</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="cm">/* falls through into default code */</span>
  <span class="nl">default:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</pre><p>the object whose identifier is i exists with automatic storage duration (within
            the block) but is never initialized, and thus if the controlling expression has a
            nonzero value, the call to the <code class="code">printf</code> function will access an
            indeterminate value. Similarly, the call to the function f cannot be reached.</p></div></div><div class="sect2" title="4.8.5. Iteration statements"><div class="titlepage"><div><div><h3 class="title"><a name="idp4850288"></a>4.8.5. Iteration statements</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The controlling expression of an iteration statement shall have scalar
          type.</p><p>The declaration part of a for statement shall only declare identifiers for objects
          having storage class <code class="code">auto</code> or <code class="code">register</code>.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>An iteration statement causes a statement called the loop body to be executed
          repeatedly until the controlling expression compares equal to 0.An iteration statement is
          a block whose scope is a strict subset of the scope of its enclosing block. The loop body
          is also a block whose scope is a strict subset of the scope of the iteration
          statement.</p><div class="sect3" title="4.8.5.1. The while statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4855824"></a>4.8.5.1. The <code class="code">while</code> statement</h4></div></div></div><p>The evaluation of the controlling expression takes place before each execution of
            the loop body.</p></div><div class="sect3" title="4.8.5.2. The do statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4857824"></a>4.8.5.2. The <code class="code">do</code> statement</h4></div></div></div><p>The evaluation of the controlling expression takes place after each execution of
            the loop body.</p></div><div class="sect3" title="4.8.5.3. The for statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4859824"></a>4.8.5.3. The <code class="code">for</code> statement</h4></div></div></div><p>The statement</p><pre class="screen">for ( clause-1 ; expression-2 ; expression-3 ) statement</pre><p>behaves as follows: The expression <span class="italic">expression-2</span> is the controlling expression that is evaluated
            before each execution of the loop body. The expression <span class="italic">expression-3</span> is
            evaluated as a void expression after each execution of the loop body. If <span class="italic">clause-1</span> is a
            declaration, the scope of any variables it declares is the remainder of the declaration
            and the entire loop, including the other two expressions; it is reached in the order of
            execution before the first evaluation of the controlling expression. If clause-1 is an
            expression, it is evaluated as a void expression before the first evaluation of the
            controlling expression.<sup>[<a class="footnote" href="#ftn.idp4865456" name="idp4865456">124</a>]</sup></p><p>Both <span class="italic">clause-1</span> and <span class="italic">expression-3</span> can be omitted. An omitted <span class="italic">expression-2</span> is
            replaced by a nonzero constant.</p></div></div><div class="sect2" title="4.8.6. Jump statements"><div class="titlepage"><div><div><h3 class="title"><a name="idp4872544"></a>4.8.6. Jump statements</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>A jump statement causes an unconditional jump to another place.</p><div class="sect3" title="4.8.6.1. The goto statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4874848"></a>4.8.6.1. The <code class="code">goto</code> statement</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The identifier in a <code class="code">goto</code> statement shall name a label located
            somewhere in the enclosing function. A <code class="code">goto</code> statement shall not jump
            from outside the scope of an identifier having a variably modified type to inside the
            scope of that identifier.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A <code class="code">goto</code> statement causes an unconditional jump to the statement
            prefixed by the named label in the enclosing function.</p><p>EXAMPLE 1 It is sometimes convenient to jump into the middle of a complicated set
            of statements. The following outline presents one possible approach to a problem based
            on these three assumptions:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The general initialization code accesses
                objects only visible to the current function.</p></li><li class="listitem"><p>The general initialization code is too
                large to warrant duplication.</p></li><li class="listitem"><p>The code to determine the next operation
                is at the head of the loop. (To allow it to be reached by continue statements, for
                example.)</p></li></ol></div><pre class="CLexer"><div class="highlight"><pre><span class="cm">/* ... */</span>
<span class="k">goto</span> <span class="n">first_time</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
  <span class="c1">// determine next operation</span>
  <span class="cm">/* ... */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">need</span> <span class="n">to</span> <span class="n">reinitialize</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// reinitialize-only code</span>
    <span class="cm">/* ... */</span>
    <span class="nl">first_time:</span>
    <span class="c1">// general initialization code</span>
    <span class="cm">/* ... */</span>
    <span class="k">continue</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// handle other operations</span>
  <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</pre><p>EXAMPLE 2 A <code class="code">goto</code> statement is not allowed to jump past any
            declarations of objects with variably modified types. A jump within the scope, however,
            is permitted.</p><pre class="CLexer"><div class="highlight"><pre><span class="k">goto</span> <span class="n">lab3</span><span class="p">;</span> <span class="c1">// invalid: going INTO scope of VLA.</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
  <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.4</span><span class="p">;</span>
<span class="nl">lab3:</span>
  <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.3</span><span class="p">;</span>
<span class="k">goto</span> <span class="n">lab4</span><span class="p">;</span> <span class="c1">// valid: going WITHIN scope of VLA.</span>
  <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">;</span>
<span class="nl">lab4:</span>
  <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">6.6</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">goto</span> <span class="n">lab4</span><span class="p">;</span> <span class="c1">// invalid: going INTO scope of VLA.</span>
</pre></div>
</pre></div><div class="sect3" title="4.8.6.2. The continue statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4888176"></a>4.8.6.2. The <code class="code">continue</code> statement</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A <code class="code">continue</code> statement shall appear only in or as a loop
            body.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A <span class="bold"><strong>continue</strong></span>
            statement causes a jump to the loop-continuation portion of the smallest enclosing
            iteration statement; that is, to the end of the loop body. More precisely, in each of
            the statements</p><pre class="CLexer"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
  <span class="k">continue</span><span class="p">;</span>
  <span class="cm">/* ... */</span>
  <span class="nl">contin:</span> <span class="p">;</span>
<span class="p">}</span>
<span class="k">do</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
  <span class="k">continue</span><span class="p">;</span>
  <span class="cm">/* ... */</span>
  <span class="nl">contin:</span> <span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
  <span class="k">continue</span><span class="p">;</span>
  <span class="cm">/* ... */</span>
  <span class="nl">contin:</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>unless the continue statement shown is in an enclosed iteration statement (in
            which case it is interpreted within that statement), it is equivalent to <code class="code">goto
              contin;</code><sup>[<a class="footnote" href="#ftn.idp4895472" name="idp4895472">125</a>]</sup></p></div><div class="sect3" title="4.8.6.3. The break statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4896992"></a>4.8.6.3. The <code class="code">break</code> statement</h4></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>A <code class="code">break</code> statement shall appear only in or as a switch body or
            loop body.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A <code class="code">break</code> statement terminates execution of the smallest enclosing
              <code class="code">switch</code> or iteration statement.</p></div><div class="sect3" title="4.8.6.4. The return statement"><div class="titlepage"><div><div><h4 class="title"><a name="idp4902752"></a>4.8.6.4. The <code class="code">return</code> statement</h4></div></div></div><p><span class="bold"><strong>Constaints</strong></span></p><p>A <code class="code">return</code> statement with an expression shall not appear in a
            function whose return type is <code class="code">void</code>. A return statement without an
            expression shall only appear in a function whose return type is
            <code class="code">void</code>.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>A <code class="code">return</code> statement terminates execution of the current function
            and returns control to its caller. A function may have any number of
              <code class="code">return</code> statements.</p><p>If a <code class="code">return</code> statement with an expression is executed, the value
            of the expression is returned to the caller as the value of the function call
            expression. If the expression has a type different from the return type of the function
            in which it appears, the value is converted as if by assignment to an object having the
            return type of the function.<sup>[<a class="footnote" href="#ftn.idp4910528" name="idp4910528">126</a>]</sup></p><p>EXAMPLE In:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">struct</span> <span class="n">s</span> <span class="p">{</span> <span class="kt">double</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span> <span class="n">f</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">union</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">f1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">s</span> <span class="n">f2</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">u1</span><span class="p">;</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">s</span> <span class="n">f3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f4</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">u2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">g</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">s</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">g</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">f2</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* ... */</span>
<span class="n">g</span><span class="p">.</span><span class="n">u2</span><span class="p">.</span><span class="n">f3</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>
</pre></div>
</pre><p>there is no undefined behavior, although there would be if the assignment were
            done directly (without using a function call to fetch the value).</p></div></div></div><div class="sect1" title="4.9. External definitions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp4914448"></a>4.9. External definitions</h2></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The storage-class specifiers <code class="code">auto</code> and <code class="code">register</code> shall
        not appear in the declaration specifiers in an external declaration.</p><p>There shall be no more than one external definition for each identifier declared with
        internal linkage in a translation unit. Moreover, if an identifier declared with internal
        linkage is used in an expression (other than as a part of the operand of a
          <code class="code">sizeof</code> operator whose result is an integer constant), there shall be
        exactly one external definition for the identifier in the translation unit.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>As discussed in Program Structure, the unit of program text after preprocessing is a
        translation unit, which consists of a sequence of external declarations. These are described
        as external because they appear outside any function (and hence have file scope). As
        discussed in Declarations, a declaration that also causes storage to be reserved for an
        object or a function named by the identifier is a definition.</p><p>An <span class="italic">external
          definition</span> is an external declaration that is also a definition of a function
        (other than an inline definition) or an object. If an identifier declared with external
        linkage is used in an expression (other than as part of the operand of a
          <code class="code">sizeof</code> operator whose result is an integer constant), somewhere in the
        entire program there shall be exactly one external definition for the identifier; otherwise,
        there shall be no more than one.<sup>[<a class="footnote" href="#ftn.idp4922816" name="idp4922816">127</a>]</sup></p><div class="sect2" title="4.9.1. Function definitions"><div class="titlepage"><div><div><h3 class="title"><a name="idp4923840"></a>4.9.1. Function definitions</h3></div></div></div><p><span class="bold"><strong>Constraints</strong></span></p><p>The identifier declared in a function definition (which is the name of the function)
          shall have a function type, as specified by the declarator portion of the function
          definition.</p><p>The intent is that the type category in a function definition cannot be inherited
          from a typedef:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="nf">F</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                  <span class="c1">// type F is ‘‘function with no parameters</span>
                                      <span class="c1">// returning int’’</span>
<span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">;</span>                               <span class="c1">// fand g both have type compatible with F</span>
<span class="n">F</span> <span class="n">f</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>                     <span class="c1">// WRONG: syntax/constraint error</span>
<span class="n">F</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>                   <span class="c1">// WRONG: declares that g returns a function</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>             <span class="c1">// RIGHT: f has type compatible with F</span>
<span class="kt">int</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>                 <span class="c1">// RIGHT: g has type compatible with F</span>
<span class="n">F</span> <span class="o">*</span><span class="n">e</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>              <span class="c1">// e returns a pointer to a function</span>
<span class="n">F</span> <span class="o">*</span><span class="p">((</span><span class="n">e</span><span class="p">))(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>          <span class="c1">// same: parentheses irrelevant</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>                      <span class="c1">// fp points to a function that has type F</span>
<span class="n">F</span><span class="o">*</span><span class="n">Fp</span><span class="p">;</span>                                 <span class="c1">//Fp points to a function that has type F</span>
</pre></div>
</pre><p>The return type of a function shall be <code class="code">void</code> or an object type other
          than array type.</p><p>The storage-class specifier, if any, in the declaration specifiers shall be either
            <code class="code">extern</code> or <code class="code">static</code>.</p><p>If the declarator includes a parameter type list, the declaration of each parameter
          shall include an identifier, except for the special case of a parameter list consisting of
          a single parameter of type <code class="code">void</code>, in which case there shall not be an
          identifier. No declaration list shall follow.</p><p>If the declarator includes an identifier list, each declaration in the declaration
          list shall have at least one declarator, those declarators shall declare only identifiers
          from the identifier list, and every identifier in the identifier list shall be declared.
          An identifier declared as a typedef name shall not be redeclared as a parameter. The
          declarations in the declaration list shall contain no storage-class specifier other than
            <code class="code">register</code> and no initializations.</p><p><span class="bold"><strong>Semantics</strong></span></p><p>The declarator in a function definition specifies the name of the function being
          defined and the identifiers of its parameters. If the declarator includes a parameter type
          list, the list also specifies the types of all the parameters; such a declarator also
          serves as a function prototype for later calls to the same function in the same
          translation unit. If the declarator includes an identifier list, the types of the
          parameters shall be declared in a following declaration list. In either case, the type of
          each parameter is adjusted as described in Function declarators (including prototypes) for
          a parameter type list; the resulting type shall be an object type.</p><p>If a function that accepts a variable number of arguments is defined without a
          parameter type list that ends with the ellipsis notation, the behavior is
          undefined.</p><p>Each parameter has automatic storage duration. Its identifier is an lvalue, which is
          in effect declared at the head of the compound statement that constitutes the function
          body (and therefore cannot be redeclared in the function body except in an enclosed
          block). The layout of the storage for parameters is unspecified. 10 On entry to the
          function, the size expressions of each variably modified parameter are evaluated and the
          value of each argument expression is converted to the type of the corresponding parameter
          as if by assignment. (Array expressions and function designators as arguments were
          converted to pointers before the call.)</p><p>After all parameters have been assigned, the compound statement that constitutes the
          body of the function definition is executed.</p><p>If the <code class="code">}</code> that terminates a function is reached, and the value of
          the function call is used by the caller, the behavior is undefined.</p><p>EXAMPLE 1 In the following:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p><code class="code">extern</code> is the storage-class specifier and <code class="code">int</code> is
          the type specifier; <code class="code">max(int a, int b)</code> is the function declarator;
          and</p><pre class="CLexer"><div class="highlight"><pre><span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</pre><p>is the function body. The following similar definition uses the identifier-list form
          for the parameter declarations:</p><pre class="CLexer"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</pre><p>Here <code class="code">int a, b;</code> is the declaration list for the parameters. The
          difference between these two definitions is that the first form acts as a prototype
          declaration that forces conversion of the arguments of subsequent calls to the function,
          whereas the second form does not.</p><p>EXAMPLE 2 To pass one function to another, one might say</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cm">/* ... */</span>
<span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</pre></div>
</pre><p>Then the definition of <code class="code">g</code> might read</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">funcp</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span>
<span class="p">{</span>
  <span class="cm">/* ... */</span>
  <span class="p">(</span><span class="o">*</span><span class="n">funcp</span><span class="p">)()</span> <span class="cm">/* or funcp() ... */</span>
<span class="p">}</span>
</pre></div>
</pre><p>or, equivalently</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">func</span><span class="p">(</span><span class="kt">void</span><span class="p">))</span>
<span class="p">{</span>
  <span class="cm">/* ... */</span>
  <span class="n">func</span><span class="p">()</span> <span class="cm">/* or (*func)() ... */</span>
<span class="p">}</span>
</pre></div>
</pre></div><div class="sect2" title="4.9.2. External object definitions"><div class="titlepage"><div><div><h3 class="title"><a name="idp4949248"></a>4.9.2. External object definitions</h3></div></div></div><p><span class="bold"><strong>Semantics</strong></span></p><p>If the declaration of an identifier for an object has file scope and an initializer,
          the declaration is an external definition for the identifier.</p><p>A declaration of an identifier for an object that has file scope without an
          initializer, and without a storage-class specifier or with the storage-class specifier
            <code class="code">static</code>, constitutes a <span class="italic">tentative definition</span>. If a translation unit contains one or
          more tentative definitions for an identifier, and the translation unit contains no
          external definition for that identifier, then the behavior is exactly as if the
          translation unit contains a file scope declaration of that identifier, with the composite
          type as of the end of the translation unit, with an initializer equal to 0.</p><p>If the declaration of an identifier for an object is a tentative definition and has
          internal linkage, the declared type shall not be an incomplete type.</p><p>EXAMPLE 1</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// definition, external linkage</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// definition, internal linkage</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i3</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// definition, external linkage</span>
<span class="kt">int</span> <span class="n">i4</span><span class="p">;</span>            <span class="c1">// tentative definition, external linkage</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">i5</span><span class="p">;</span>     <span class="c1">// tentative definition, internal linkage</span>
<span class="kt">int</span> <span class="n">i1</span><span class="p">;</span>            <span class="c1">// valid tentative definition, refers to pre vious</span>
<span class="kt">int</span> <span class="n">i2</span><span class="p">;</span>            <span class="c1">// 4.2.2 renders undefined, linkage disagreement</span>
<span class="kt">int</span> <span class="n">i3</span><span class="p">;</span>            <span class="c1">// valid tentative definition, refers to pre vious</span>
<span class="kt">int</span> <span class="n">i4</span><span class="p">;</span>            <span class="c1">// valid tentative definition, refers to pre vious</span>
<span class="kt">int</span> <span class="n">i5</span><span class="p">;</span>            <span class="c1">// 4.2.2 renders undefined, linkage disagreement</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">;</span>     <span class="c1">// refers to pre vious, whose linkage is external</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2</span><span class="p">;</span>     <span class="c1">// refers to pre vious, whose linkage is internal</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i3</span><span class="p">;</span>     <span class="c1">// refers to pre vious, whose linkage is external</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i4</span><span class="p">;</span>     <span class="c1">// refers to pre vious, whose linkage is external</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i5</span><span class="p">;</span>     <span class="c1">// refers to pre vious, whose linkage is internal</span>
</pre></div>
</pre><p>EXAMPLE 2 If at the end of the translation unit containing</p><pre class="CLexer"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span><span class="p">[];</span>
</pre></div>
</pre><p>the array <code class="code">i</code> still has incomplete type, the implicit initializer
          causes it to have one element, which is set to zero on program startup.</p></div></div><div class="sect1" title="4.10. Preprocessing directives"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp4959216"></a>4.10. Preprocessing directives</h2></div></div></div><p>This is dicussed in chapter Preprocessing Directives.</p></div><div class="footnotes"><br/><hr align="left" width="100"/><div class="footnote"><p><sup>[<a class="para" href="#idp1053136" id="ftn.idp1053136">16</a>] </sup>There is no linkage between different identifiers.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp1058512" id="ftn.idp1058512">17</a>] </sup>A function declaration can contain the storage-class specifier static only if it
              is at file scope; see Storage-class specifiers.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp1061728" id="ftn.idp1061728">18</a>] </sup>As specified in Scope of Identifiers, the later declaration might hide the prior
              declaration.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3294720" id="ftn.idp3294720">19</a>] </sup>There is only one name space for tags even though three are possible.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3305952" id="ftn.idp3305952">20</a>] </sup>The term “constant address” means that two pointers to the object constructed at
              possibly different times will compare equal. The address may be different during two
              different executions of the same program.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3307120" id="ftn.idp3307120">21</a>] </sup>In the case of a volatile object, the last store need not be explicit in the
              program.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3321984" id="ftn.idp3321984">22</a>] </sup>Leaving the innermost block containing the declaration, or jumping to a point in
              that block or an embedded block prior to the declaration, leaves the scope of the
              declaration.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3341456" id="ftn.idp3341456">23</a>] </sup>Implementation-defined keywords shall have the form of an identifier reserved
              for any use as described in 7.1.3.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3342544" id="ftn.idp3342544">24</a>] </sup>Therefore, any statement in this Standard about signed integer types also
              applies to the extended signed integer types.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3351312" id="ftn.idp3351312">25</a>] </sup>Therefore, any statement in this Standard about unsigned integer types also
              applies to the extended unsigned integer types.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3355840" id="ftn.idp3355840">26</a>] </sup>The same representation and alignment requirements are meant to imply
              interchangeability as arguments to functions, return values from functions, and
              members of unions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3368960" id="ftn.idp3368960">27</a>] </sup>An implementation may define new keywords that provide alternative ways to
              designate a basic (or any other) type; this does not violate the requirement that all
              basic types be different. Implementation-defined keywords shall have the form of an
              identifier reserved for any use as described in 7.1.3.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3373664" id="ftn.idp3373664">28</a>] </sup><code class="code">CHAR_MIN</code>, defined in <code class="code"><limits.h></code>, will have
              one of the values 0 or <code class="code">SCHAR_MIN</code>, and this can be used to distinguish
              the two options. Irrespective of the choice made, char is a separate type from the
              other two and is not compatible with either.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3389664" id="ftn.idp3389664">29</a>] </sup>Since object types do not include incomplete types, an array of incomplete
                  type cannot be constructed.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3406032" id="ftn.idp3406032">30</a>] </sup>Note that aggregate type does not include union type because an object with
              union type can only contain one member at a time.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3416352" id="ftn.idp3416352">31</a>] </sup>See Type qualifiers regarding qualified array and function types.</p></div><div class="footnote"><p><sup>[<a class="para" href="#a" id="ftn.a">32</a>] </sup>The same representation and alignment requirements are meant to imply
              interchangeability as arguments to functions, return values from functions, and
              members of unions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3438080" id="ftn.idp3438080">33</a>] </sup>A positional representation for integers that uses the binary digits 0 and 1,
                in which the values represented by successive bits are additive, begin with 1, and
                are multiplied by successive integral powers of 2, except perhaps the bit with the
                highest position. (Adapted from the American National Dictionary for Information
                Processing Systems.) A byte contains <code class="code">CHAR_BIT</code> bits, and the values
                of type unsigned char range from 0 to <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:mml="http://www.w3.org/1998/Math/MathML">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>C</mi>
<mi>H</mi>
<mi>A</mi>
<mi>R</mi>
<mi mathvariant="normal">_</mi>
<mi>B</mi>
<mi>I</mi>
<mi>T</mi>
</mrow>
</msup>
<mo>−</mo>
<mn>1</mn>
</math>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3468496" id="ftn.idp3468496">34</a>] </sup>Thus, an automatic variable can be initialized to a trap representation
                without causing undefined behavior, but the value of the variable cannot be used
                until a proper value is stored in it.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3471776" id="ftn.idp3471776">35</a>] </sup>Thus, for example, structure assignment need not copy any padding
                bits.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3477936" id="ftn.idp3477936">36</a>] </sup>It is possible for objects <code class="code">x</code> and <code class="code">y</code> with the
                same effective type <span class="italic">T</span> to have the same value
                when they are accessed as objects of type <span class="italic">T</span>,
                but to have different values in other contexts. In particular, if
                  <code class="code">==</code> is defined for type <span class="italic">T</span>,
                then <code class="code">x == y</code> does not imply that <code class="code">memcmp(&x, &y,
                  sizeof (T)) == 0</code>. Furthermore, <code class="code">x == y</code> does not
                necessarily imply that <code class="code">x</code> and <code class="code">y</code> have the same
                value; other operations on values of type <span class="italic">T</span>
                may distinguish between them.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3498352" id="ftn.idp3498352">37</a>] </sup>Some combinations of padding bits might generate trap representations, for
                example, if one padding bit is a parity bit. Regardless, no arithmetic operation on
                valid values can generate a trap representation other than as part of an exceptional
                condition such as an overflow, and this cannot occur with unsigned types. All other
                combinations of padding bits are alternative object representations of the value
                specified by the value bits.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3519904" id="ftn.idp3519904">38</a>] </sup>Some combinations of padding bits might generate trap representations, for
                example, if one padding bit is a parity bit. Regardless, no arithmetic operation on
                valid values can generate a trap representation other than as part of an exceptional
                condition such as an overflow. All other combinations of padding bits are
                alternative object representations of the value specified by the value
                bits.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3525632" id="ftn.idp3525632">39</a>] </sup>Two types need not be identical to be compatible.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3534160" id="ftn.idp3534160">40</a>] </sup>As specified in Scope of Identifiers, the later declaration might hide the prior
              declaration.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3564288" id="ftn.idp3564288">41</a>] </sup>The integer promotions are applied only: as part of the usual arithmetic
                conversions, to certain argument expressions, to the operands of the unary +, -, and
                ~ operators, and to both operands of the shift operators, as specified by their
                respective subclauses.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3572096" id="ftn.idp3572096">42</a>] </sup>The rules describe arithmetic on the mathematical value, not the value of a
                given type of expression.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3575744" id="ftn.idp3575744">43</a>] </sup>The remaindering operation performed when a value of integer type is converted
                to unsigned type need not be performed when a value of real floating type is
                converted to unsigned type. Thus, the range of portable real floating values is (-1,
                U <span class="italic">type </span>_
                  <code class="code">MAX+1</code> ).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3597200" id="ftn.idp3597200">44</a>] </sup>For example, addition of a <code class="code">double _Complex</code> and a
                      <code class="code">float</code> entails just the conversion of the <code class="code">float</code>
                    operand to <code class="code">double</code> (and yields a <code class="code">double _Complex</code>
                    result).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3608944" id="ftn.idp3608944">45</a>] </sup>The cast and assignment operators are still required to perform their
                specified conversions as described in Real Floating and Integer and Real Floating
                Types.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3613712" id="ftn.idp3613712">46</a>] </sup>The name “lvalue” comes originally from the assignment expression <math xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mrow>
<mtext>E1 </mtext>
<mo>=</mo>
<mtext> E2</mtext>
</mrow>
</math>, in which the left operand <math xmlns:mml="http://www.w3.org/1998/Math/MathML">
<mtext>E1</mtext>
</math> is required to be a (modifiable) lvalue. It is perhaps better
                considered as representing an object “locator value”. What is sometimes called
                “rvalue” is in this International Standard described as the “value of an
                expression”.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3624944" id="ftn.idp3624944">47</a>] </sup>Because this conversion does not occur, the operand of the sizeof operator
                remains a function designator and violates the constraint in 4.5.3.4.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3638592" id="ftn.idp3638592">48</a>] </sup>The macro <code class="code">NULL</code> is defined in <code class="code"><stddef.h></code>
                (and other headers) as a null pointer constant; see 7.17.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3641904" id="ftn.idp3641904">49</a>] </sup>The mapping functions for converting a pointer to an integer or an integer to
                a pointer are intended to be consistent with the addressing structure of the
                execution environment.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3644176" id="ftn.idp3644176">50</a>] </sup>In general, the concept “correctly aligned” is transitive: if a pointer to
                type A is correctly aligned for a pointer to type B, which in turn is correctly
                aligned for a pointer to type C, then a pointer to type A is correctly aligned for a
                pointer to type C.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3653600" id="ftn.idp3653600">51</a>] </sup>An additional category, placemarkers, is used internally in translation phase 4
            (see The ## Operator); it cannot occur in source files.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3665696" id="ftn.idp3665696">52</a>] </sup>One possible specification for imaginary types appears in annex G.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3671232" id="ftn.idp3671232">53</a>] </sup>On systems in which linkers cannot accept extended characters, an encoding of
                the universal character name may be used in forming valid external identifiers. For
                example, some otherwise unused character or sequence of characters may be used to
                encode the \u in a universal character name. Extended characters may produce a long
                external identifier.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3683488" id="ftn.idp3683488">54</a>] </sup>Since the name <code class="code">__func__</code> is reserved for any use by the
                implementation (Macro Replacement), if any other identifier is explicitly declared
                using the name <code class="code">__func__</code>, the behavior is undefined.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3691808" id="ftn.idp3691808">55</a>] </sup>The disallowed characters are the characters in the basic character set and the
              code positions reserved by ISO/IEC 10646 for control characters, the character DELETE,
              and the S-zone (reserved for use by UTF-16).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3695888" id="ftn.idp3695888">56</a>] </sup>Short identifiers for characters were first specified in ISO/IEC
              10646-1/AMD9:1997.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3762928" id="ftn.idp3762928">57</a>] </sup>The specification for the library functions recommends more accurate
                conversion than required for floating constants (see The strtod, strtof and strtold
                functions).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3776608" id="ftn.idp3776608">58</a>] </sup>The semantics of these characters were discussed in Character display
                semantics. If any other character follows a backslash, the result is not a token and
                a diagnostic is required. See “future language directions” (Character escape
                sequences).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3822144" id="ftn.idp3822144">59</a>] </sup>These tokens are sometimes called “digraphs”.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3824752" id="ftn.idp3824752">60</a>] </sup>Thus [ and <: behave differently when “stringized (see The # Operator), but
              can otherwise be freely interchanged.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3830160" id="ftn.idp3830160">61</a>] </sup>Thus, sequences of characters that resemble escape sequences cause undefined
              behavior.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3843648" id="ftn.idp3843648">62</a>] </sup>Thus, /* ... */ comments do not nest.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3849824" id="ftn.idp3849824">63</a>] </sup>This paragraph renders undefined statement expressions such as <code class="code">i = ++i +
              1;</code></p><p><code class="code">a[i++] = i;</code></p><p>while allowing</p><p><code class="code">i = i + 1; a[i] = i;</code></p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3853008" id="ftn.idp3853008">64</a>] </sup>The syntax specifies the precedence of operators in the evaluation of an
            expression, which is the same as the order of the major subclauses of this subclause,
            highest precedence first. Thus, for example, the expressions allowed as the operands of
            the binary + operator (Additive operators) are those expressions defined in Primary
            expressions through Additive operators. The exceptions are cast expressions (Cast
            operators) as operands of unary operators (Unary operators), and an operand contained
            between any of the following pairs of operators: grouping parentheses () (Primary
            expressions), subscripting brackets [] (:ref:`4.5.2.1`), function-call parentheses ``()
            (Function calls), and the conditional operator ?: (Conditional operator).</p><p>Within each major subclause, the operators have the same precedence. Left- or
            right-associativity is indicated in each subclause by the syntax for the expressions
            discussed therein.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3858864" id="ftn.idp3858864">65</a>] </sup>Allocated objects have no declared type.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3861152" id="ftn.idp3861152">66</a>] </sup>The intent of this list is to specify those circumstances in which an object may
            or may not be aliased.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3869904" id="ftn.idp3869904">67</a>] </sup>A contracted expression might also omit the raising of floating-point
            exceptions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3871904" id="ftn.idp3871904">68</a>] </sup>This license is specifically intended to allow implementations to exploit fast
            machine instructions that combine multiple C operators. As contractions potentially
            undermine predictability, and can even decrease accuracy for containing expressions,
            their use needs to be well-defined and clearly documented.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3877040" id="ftn.idp3877040">69</a>] </sup>Thus, an undeclared identifier is a violation of the syntax.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3923760" id="ftn.idp3923760">70</a>] </sup>Most often, this is the result of converting an identifier that is a function
                designator.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3927968" id="ftn.idp3927968">71</a>] </sup>A function may change the values of its parameters, but these changes cannot
                affect the values of the arguments. On the other hand, it is possible to pass a
                pointer to an object, and the function may change the value of the object pointed
                to. A parameter declared to have array or function type is adjusted to have a
                pointer type as described in Function definitions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3950688" id="ftn.idp3950688">72</a>] </sup>If <code class="code">&E</code> is a valid pointer expression (where
                  <code class="code">&</code> is the “address-of” operator, which generates a pointer to
                its operand), the expression <code class="code">(&E)->MOS</code> is the same as
                  <code class="code">E.MOS</code>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3978368" id="ftn.idp3978368">73</a>] </sup>Note that this differs from a cast expression. For example, a cast specifies a
                conversion to scalar types or void only, and the result of a cast expression is not
                an lvalue.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3981456" id="ftn.idp3981456">74</a>] </sup>For example, subobjects without explicit initializers are initialized to
                zero.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp3982816" id="ftn.idp3982816">75</a>] </sup>This allows implementations to share storage for string literals and constant
                compound literals with the same or overlapping representations.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4024768" id="ftn.idp4024768">76</a>] </sup>Thus, <code class="code">&*E</code> is equivalent to <code class="code">E</code> (even if
                  <code class="code">E</code> is a null pointer), and <code class="code">&(E1[E2]) to
                  ((E1)+(E2))</code>. It is always true that if <code class="code">E</code> is a function
                designator or an lvalue that is a valid operand of the unary & operator,
                  <code class="code">*&E</code> is a function designator or an lvalue equal to
                  <code class="code">E</code>. If <code class="code">*P</code> is an lvalue and <code class="code">T</code> is
                the name of an object pointer type, <code class="code">*(T)P</code> is an lvalue that has a
                type compatible with that to which <code class="code">T</code> points. Among the invalid
                values for dereferencing a pointer by the unary <code class="code">*</code> operator are a
                null pointer, an address inappropriately aligned for the type of object pointed to,
                and the address of an object after the end of its lifetime.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4051184" id="ftn.idp4051184">77</a>] </sup>When applied to a parameter declared to have array or function type, the
                sizeof operator yields the size of the adjusted (pointer) type (see Function
                definitions).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4065792" id="ftn.idp4065792">78</a>] </sup>A cast does not yield an lvalue. Thus, a cast to a qualified type has the same
              effect as a cast to the unqualified version of the type.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4066896" id="ftn.idp4066896">79</a>] </sup>If the value of the expression is represented with greater precision or range
              than required by the type named by the cast (Usual Arithmetic Conversions), then the
              cast specifies a conversion even if the type of the expression is the same as the
              named type.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4077184" id="ftn.idp4077184">80</a>] </sup>This is often called “truncation toward zero”.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4108176" id="ftn.idp4108176">81</a>] </sup>Another way to approach pointer arithmetic is first to convert the pointer(s) to
              character pointer(s): In this scheme the integer expression added to or subtracted
              from the converted pointer is first multiplied by the size of the object originally
              pointed to, and the resulting pointer is converted back to the original type. For
              pointer subtraction, the result of the difference between the character pointers is
              similarly divided by the size of the object originally pointed to.</p><p>When viewed in this way, an implementation need only provide one extra byte
              (which may overlap another object in the program) just after the end of the object in
              order to satisfy the “one past the last element” requirements.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4174016" id="ftn.idp4174016">82</a>] </sup>The expression <code class="code">a < b < c</code> is not interpreted as in ordinary
              mathematics. As the syntax indicates, it means <code class="code">(a < b)
	      < c</code>; in
              other words, “if a is less than b, compare 1 to c; otherwise, compare 0 to
              c”.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4184224" id="ftn.idp4184224">83</a>] </sup>Because of the precedences, <code class="code">a < b == c < d</code> is 1 whenever
                <code class="code">a < b</code> and <code class="code">c < d</code> have the same
              truth-value.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4190240" id="ftn.idp4190240">84</a>] </sup>Two objects may be adjacent in memory because they are adjacent elements of a
              larger array or adjacent members of a structure with no padding between them, or
              because the implementation chose to place them so, even though they are unrelated. If
              prior invalid pointer operations (such as accesses outside array bounds) produced
              undefined behavior, subsequent comparisons also produce undefined behavior.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4229392" id="ftn.idp4229392">85</a>] </sup>A conditional expression does not yield an lvalue.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4245120" id="ftn.idp4245120">86</a>] </sup>The asymmetric appearance of these constraints with respect to type qualifiers
                is due to the conversion (specified in Other Operands) that changes lvalues to “the
                value of the expression” and thus removes any type qualifiers that were applied to
                the type category of the expression (for example, it removes <code class="code">const</code>
                but not <code class="code">volatile</code> from the type int volatile * const).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4278576" id="ftn.idp4278576">87</a>] </sup>A comma operator does not yield an lvalue.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4287168" id="ftn.idp4287168">88</a>] </sup>The operand of a <code class="code">sizeof</code> operator is usually not evaluated (The
            sizeof operator).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4291792" id="ftn.idp4291792">89</a>] </sup>An integer constant expression is used to specify the size of a bit-field member
            of a structure, the value of an enumeration constant, the size of an array, or the value
            of a case constant. Further constraints that apply to the integer constant expressions
            used in conditional-inclusion preprocessing directives are discussed in Conditional
            Inclusion.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4307168" id="ftn.idp4307168">90</a>] </sup>Thus, in the following initialization, <code class="code">static int i = 2 || 1 / 0;
            </code>the expression is a valid integer constant expression with value one.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4317232" id="ftn.idp4317232">91</a>] </sup>Function definitions have a different syntax, described in Function
                definitions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4327520" id="ftn.idp4327520">92</a>] </sup>The implementation may treat any <code class="code">register</code> declaration simply as
              an auto declaration. However, whether or not addressable storage is actually used, the
              address of any part of an object declared with storage-class specifier register cannot
              be computed, either explicitly (by use of the unary & operator as discussed in
              Address and indirection operators) or implicitly (by converting an array name to a
              pointer as discussed in :ref:14.3.2.1`). Thus, the only operator that can be applied
              to an array declared with storage-class specifier <code class="code">register</code> is
                <code class="code">sizeof</code>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4367440" id="ftn.idp4367440">93</a>] </sup>Freestanding implementations are not required to provide complex types.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4380272" id="ftn.idp4380272">94</a>] </sup>A structure or union can not contain a member with a variably modified type
                because member names are not ordinary identifiers as defined in Name Spaces of the
                Identifiers.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4382320" id="ftn.idp4382320">95</a>] </sup>The unary <code class="code">&</code> (address-of) operator cannot be applied to a
                bit-field object; thus, there are no pointers to or arrays of bit-field
                objects.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4384368" id="ftn.idp4384368">96</a>] </sup>As specified in Type specifiers above, if the actual type specifier used is
                  <code class="code">int</code> or a typedef-name defined as <code class="code">int</code>, then it is
                implementation-defined whether the bit-field is signed or unsigned.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4388560" id="ftn.idp4388560">97</a>] </sup>An unnamed bit-field structure member is useful for padding to conform to
                externally imposed layouts.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4422800" id="ftn.idp4422800">98</a>] </sup>Thus, the identifiers of enumeration constants declared in the same scope
                shall all be distinct from each other and from other identifiers declared in
                ordinary declarators.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4425088" id="ftn.idp4425088">99</a>] </sup>An implementation may delay the choice of which integer type until all
                enumeration constants have been seen.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4436576" id="ftn.idp4436576">100</a>] </sup>An incomplete type may only by used when the size of an object of that type is
                not needed. It is not needed, for example, when a typedef name is declared to be a
                specifier for a structure or union, or when a pointer to or a function returning a
                structure or union is being declared. (See incomplete types in Types.) The
                specification has to be complete before such a function is called or
                defined.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4443728" id="ftn.idp4443728">101</a>] </sup>If there is no identifier, the type can, within the translation unit, only be
                referred to by the declaration of which it is a part. Of course, when the
                declaration is of a typedef name, subsequent declarations can make use of that
                typedef name to declare objects having the specified structure, union, or enumerated
                type.</p></div><div class="footnote"><p><sup>[<a class="para" href="#b" id="ftn.b">102</a>] </sup>A similar construction with <code class="code">enum</code> does not exist.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4472176" id="ftn.idp4472176">103</a>] </sup>The implementation may place a const object that is not
                <code class="code">volatile</code> in a read-only region of storage. Moreover, the
              implementation need not allocate storage for such an object if its address is never
              used.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4475808" id="ftn.idp4475808">104</a>] </sup>This applies to those objects that behave as if they were defined with qualified
              types, even if they are never actually defined as objects in the program (such as an
              object at a memory-mapped input/output address).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4477744" id="ftn.idp4477744">105</a>] </sup>A <code class="code">volatile</code> declaration may be used to describe an object
              corresponding to a memory-mapped input/output port or an object accessed by an
              asynchronously interrupting function. Actions on objects so declared shall not be
              “optimized out” by an implementation or reordered except as permitted by the rules for
              evaluating expressions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4480304" id="ftn.idp4480304">106</a>] </sup>For example, a statement that assigns a value returned by malloc to a single
              pointer establishes this association between the allocated object and the
              pointer.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4483200" id="ftn.idp4483200">107</a>] </sup>Both of these can occur through the use of typedefs.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4497664" id="ftn.idp4497664">108</a>] </sup>In other words, <code class="code">E</code> depends on the value of <code class="code">P</code>
                itself rather than on the value of an object referenced indirectly through
                  <code class="code">P</code>. For example, if identifier <code class="code">p</code> has type
                  (<code class="code">int **restrict</code>), then the pointer expressions <code class="code">p</code>
                and <code class="code">p+1</code> are based on the restricted pointer object designated by
                  <code class="code">p</code>, but the pointer expressions <code class="code">*p</code> and
                  <code class="code">p[1]</code> are not.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4540464" id="ftn.idp4540464">109</a>] </sup>By using, for example, an alternative to the usual function call mechanism, such
              as “inline substitution”. Inline substitution is not textual substitution, nor does it
              create a new function. Therefore, for example, the expansion of a macro used within
              the body of the function uses the definition it had at the point the function body
              appears, and not where the function is called; and identifiers refer to the
              declarations in scope where the body occurs. Likewise, the function has a single
              address, regardless of the number of inline definitions that occur in addition to the
              external definition.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4542112" id="ftn.idp4542112">110</a>] </sup>For example, an implementation might never perform inline substitution, or might
              only perform inline substitutions to calls in the scope of an inline
              declaration.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4546528" id="ftn.idp4546528">111</a>] </sup>Since an inline definition is distinct from the corresponding external
              definition and from any other corresponding inline definitions in other translation
              units, all corresponding objects with static storage duration are also distinct in
              each of the definitions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4594128" id="ftn.idp4594128">112</a>] </sup>When several “array of” specifications are adjacent, a multidimensional array
                is declared.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4596384" id="ftn.idp4596384">113</a>] </sup>Thus, <code class="code">*</code> can be used only in function declarations that are
                not definitions (see Function declarators (including prototypes)).</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4626080" id="ftn.idp4626080">114</a>] </sup>The macros defined in the <stdarg.h> header (Variable arguments
                <stdarg.h>) may be used to access arguments that correspond to the
                ellipsis.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4632720" id="ftn.idp4632720">115</a>] </sup>If both function types are “old style”, parameter types are not
                compared.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4663072" id="ftn.idp4663072">116</a>] </sup>As indicated by the syntax, empty parentheses in a type name are interpreted as
              “function with no parameter specification”, rather than redundant parentheses around
              the omitted identifier.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4727616" id="ftn.idp4727616">117</a>] </sup>If the initializer list for a subaggregate or contained union does not begin
              with a left brace, its subobjects are initialized as usual, but the subaggregate or
              contained union does not become the current object: current objects are associated
              only with brace-enclosed initializer lists.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4729088" id="ftn.idp4729088">118</a>] </sup>After a union member is initialized, the next object is not the next member of
              the union; instead, it is the next subobject of an object containing the
              union.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4730768" id="ftn.idp4730768">119</a>] </sup>Thus, a designator can only specify a strict subobject of the aggregate or union
              that is associated with the surrounding brace pair. Note, too, that each separate
              designator list is independent.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4732624" id="ftn.idp4732624">120</a>] </sup>Any initializer for the subobject which is overridden and so not used to
              initialize that subobject might not be evaluated at all.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4737008" id="ftn.idp4737008">121</a>] </sup>In particular, the evaluation order need not be the same as the order of
              subobject initialization.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4808560" id="ftn.idp4808560">122</a>] </sup>Such as assignments, and function calls which have side effects.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4831216" id="ftn.idp4831216">123</a>] </sup>That is, the declaration either precedes the <code class="code">switch</code>
                statement, or it follows the last <code class="code">case</code> or <code class="code">default</code>
                label associated with the switch that is in the block containing the
                declaration.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4865456" id="ftn.idp4865456">124</a>] </sup>Thus, <span class="italic">clause-1</span> specifies initialization for the loop, possibly declaring one
                or more variables for use in the loop; the controlling expression, <span class="italic">expression-2</span>,
                specifies an evaluation made before each iteration, such that execution of the loop
                continues until the expression compares equal to 0; and <span class="italic">expression-3</span>
                specifies an operation (such as incrementing) that is performed after each
                iteration.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4895472" id="ftn.idp4895472">125</a>] </sup>Following the <code class="code">contin:</code> label is a null statement.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4910528" id="ftn.idp4910528">126</a>] </sup>The <code class="code">return</code> statement is not an assignment. The overlap
                restriction of subclause 6.5.16.1 does not apply to the case of function
                return.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp4922816" id="ftn.idp4922816">127</a>] </sup>Thus, if an identifier declared with external linkage is not used in an
            expression, there need be no external definition for it.</p></div></div></div><div class="navfooter"><hr/><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="../env/index.html">Prev</a> </td><td align="center" width="20%"> </td><td align="right" width="40%"> <a accesskey="n" href="../basics/index.html">Next</a></td></tr><tr><td align="left" valign="top" width="40%">Chapter 3. Environment </td><td align="center" width="20%"><a accesskey="h" href="../index.html">Home</a></td><td align="right" valign="top" width="40%"> Chapter 5. Basics of C</td></tr></table></div><p style="text-align: center;" xmlns:d="http://docbook.org/ns/docbook" xmlns:exsl="http://exslt.org/common" xmlns:fo="http://www.w3.org/1999/XSL/Format">© 2010, 2013 Shiv S. Dayal. <a href="http://libreprogramming.org">libreprogramming.org</a>.
   GNU FDL license is applicable where not stated.</p></body></html>