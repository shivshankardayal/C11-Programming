<?xml version="1.0" encoding="UTF-8"?>
<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?dbhtml filename="stdio/index.html" ?>
  <d:title>Input/Output &amp;lt;stdio.h></d:title>
  <d:sect1>
    <d:title>Introduction</d:title>
    <d:para>The header <d:code>&amp;lt;stdio.h></d:code> declares three types,
    several macros, and many functions for performing input and
    output.</d:para>
    <d:para>The types declared are <d:code>size_t</d:code> (described in Common
    definitions &amp;lt;stddef.h>);</d:para>
    <d:blockquote><d:para><d:code>FILE</d:code></d:para></d:blockquote>
    <d:para>which is an object type capable of recording all the information
    needed to control a stream, including its file position indicator, a
    pointer to its associated buffer (if any), an error indicator that records
    whether a read/write error has occurred, and an end-of-file indicator that
    records whether the end of the file has been reached; and</d:para>
    <d:blockquote><d:para><d:code>fpos_t</d:code></d:para></d:blockquote>
    <d:para>which is an object type other than an array type capable of
    recording all the information needed to specify uniquely every position
    within a file.</d:para>
    <d:para>The macros are NULL (described in Common definitions
    &amp;lt;stddef.h>);</d:para>
    <d:blockquote>
      <d:para><d:code>_IOFBF</d:code></d:para>
      <d:para><d:code>_IOLBF</d:code></d:para>
      <d:para><d:code>_IONBF</d:code></d:para>
    </d:blockquote>
    <d:para>which expand to integer constant expressions with distinct values,
    suitable for use as the third argument to the <d:code>setvbuf</d:code>
    function;</d:para>
    <d:blockquote><d:para><d:code>BUFSIZ</d:code></d:para></d:blockquote>
    <d:para>which expands to an integer constant expression that is the size of
    the buffer used by the <d:code>setbuf</d:code> function;</d:para>
    <d:blockquote><d:para><d:code>EOF</d:code></d:para></d:blockquote>
    <d:para>which expands to an integer constant expression, with type int and
    a negative value, that is returned by several functions to indicate
    end-of-file, that is, no more input from a stream;</d:para>
    <d:blockquote><d:para><d:code>FOPEN_MAX</d:code></d:para></d:blockquote>
    <d:para>which expands to an integer constant expression that is the minimum 
    number of files that the implementation guarantees can be open
    simultaneously;</d:para>
    <d:blockquote><d:para><d:code>FILENAME_MAX</d:code></d:para></d:blockquote>
    <d:para>which expands to an integer constant expression that is the size
    needed for an array of char large enough to hold the longest file name
    string that the implementation guarantees can be
    opened;<d:footnote><d:para>If the implementation imposes no practical limit
    on the length of file name strings, the value of
    <d:code>FILENAME_MAX</d:code> should instead be the recommended size of an
    array intended to hold a file name string. Of course, file name string
    contents are subject to other system-specific constraints; therefore all
    possible strings of length <d:code>FILENAME_MAX</d:code> cannot be expected
    to be opened successfully.</d:para></d:footnote></d:para>
    <d:blockquote><d:para><d:code>L_tmpnam</d:code></d:para></d:blockquote>
    <d:para>which expands to an integer constant expression that is the size
    needed for an array of char large enough to hold a temporary file name
    string generated by the <d:code>tmpnam</d:code> function;</d:para>
    <d:blockquote>
      <d:para><d:code>stderr</d:code></d:para>
      <d:para><d:code>stdin</d:code></d:para>
      <d:para><d:code>stdout</d:code></d:para>
    </d:blockquote>
    <d:para>which are expressions of type "pointer to <d:code>FILE</d:code>"
    that point to the <d:code>FILE</d:code> objects associated, respectively,
    with the standard error, input, and output streams.</d:para>
    <d:para>The header <d:code>&amp;lt;wchar.h></d:code> declares a number of
    functions useful for wide character input and output. The wide character
    input/output functions described in that subclause provide operations
    analogous to most of those described here, except that the fundamental
    units internal to the program are wide characters. The external
    representation (in the file) is a sequence of "generalized" multibyte
    characters, as described further in Files.</d:para>
    <d:para>The input/output functions are given the following collective
    terms:</d:para>
    <d:itemizedlist>
      <d:listitem>
	<d:para>The <d:emphasis role="italic">wide character input
	functions</d:emphasis> - those functions described in Extended
	multibyte and wide character utilities &amp;lt;wchar.h> that perform
	input into wide characters and wide strings: <d:code>fgetwc, fgetws,
	getwc, getwchar, fwscanf, wscanf, vfwscanf</d:code> and
	<d:code>vwscanf</d:code>.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>The <d:emphasis role="italic">wide character output
	functions</d:emphasis> - those functions described in Extended
	multibyte and wide character utilities &amp;lt;wchar.h> that perform
	output from wide characters and wide strings: <d:code>fputwc, fputws,
	putwc, putwchar, fwprintf, wprintf, vfwprintf</d:code> and
	<d:code>vwprintf</d:code>.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>The <d:emphasis role="italic">wide character input/output
	functions</d:emphasis> the union of the <d:code>ungetwc</d:code>
	function, the wide character input functions, and the wide character
	output functions.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>The <d:emphasis role="italic">byte input/output
	functions</d:emphasis> - those functions described in this subclause
	that perform input/output: <d:code>fgetc, fgets, fprintf, fputc, fputs,
	fread, fscanf, fwrite, getc, getchar, gets, perror, printf, putc,
	putchar, puts, scanf, ungetc, vfprintf, vfscanf, vprintf</d:code> and
	<d:code>vscanf</d:code>.</d:para>
      </d:listitem>
    </d:itemizedlist>
  </d:sect1>
  <d:sect1>
    <d:title>Streams</d:title>
    <d:para>Input and output, whether to or from physical devices such as
    terminals and tape drives, or whether to or from files supported on
    structured storage devices, are mapped into logical data streams, whose
    properties are more uniform than their various inputs and outputs. Two
    forms of mapping are supported, for text streams and for binary
    streams.<d:footnote><d:para>An implementation need not distinguish between
    text streams and binary streams. In such an implementation, there need be
    no new-line characters in a text stream nor any limit to the length of a
    line.</d:para></d:footnote></d:para>
    <d:para>A text stream is an ordered sequence of characters composed into
    lines, each line consisting of zero or more characters plus a terminating
    new-line character. Whether the last line requires a terminating new-line
    character is implementation-defined. Characters may have to be added,
    altered, or deleted on input and output to conform to differing conventions
    for representing text in the host environment. Thus, there need not be a
    oneto- one correspondence between the characters in a stream and those in
    the external representation. Data read in from a text stream will
    necessarily compare equal to the data that were earlier written out to that
    stream only if: the data consist only of printing characters and the
    control characters horizontal tab and new-line; no new-line character is
    immediately preceded by space characters; and the last character is a
    new-line character. Whether space characters that are written out
    immediately before a new-line character appear when read in is
    implementation-defined.</d:para>
    <d:para>A binary stream is an ordered sequence of characters that can
    transparently record internal data. Data read in from a binary stream shall
    compare equal to the data that were earlier written out to that stream,
    under the same implementation. Such a stream may, however, hav e an
    implementation-defined number of null characters appended to the end of the
    stream.</d:para>
    <d:para>Each stream has an orientation. After a stream is associated with
    an external file, but before any operations are performed on it, the stream
    is without orientation. Once a wide character input/output function has
    been applied to a stream without orientation, the stream becomes a
    <d:emphasis role="italic">wide-oriented</d:emphasis> stream. Similarly,
    once a byte input/output function has been applied to a stream without
    orientation, the stream becomes a byte-oriented stream. Only a call to the
    <d:code>freopen</d:code> function or the fwide function can otherwise alter
    the orientation of a stream. (A successful call to <d:code>freopen</d:code>
    removes any orientation.)<d:footnote><d:para>The three predefined streams
    <d:code>stdin, stdout</d:code> and <d:code>stderr</d:code> are unoriented
    at program startup.</d:para></d:footnote></d:para>
    <d:para>Byte input/output functions shall not be applied to a wide-oriented
    stream and wide character input/output functions shall not be applied to a
    byte-oriented stream. The remaining stream operations do not affect, and
    are not affected by, a stream's orientation, except for the following
    additional restrictions:</d:para>
    <d:itemizedlist>
      <d:listitem>
	<d:para>Binary wide-oriented streams have the file-positioning
	restrictions ascribed to both text and binary streams.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>For wide-oriented streams, after a successful call to a
	file-positioning function that leaves the file position indicator prior
	to the end-of-file, a wide character output function can overwrite a
	partial multibyte character; any file contents beyond the byte(s)
	written are henceforth indeterminate.</d:para>
      </d:listitem>
    </d:itemizedlist>
    <d:para>Each wide-oriented stream has an associated
    <d:code>mbstate_t</d:code> object that stores the current parse state of
    the stream. A successful call to fgetpos stores a representation of the
    value of this mbstate_t object as part of the value of the
    <d:code>fpos_t</d:code> object. A later successful call to fsetpos using
    the same stored <d:code>fpos_t</d:code> value restores the value of the
    associated <d:code>mbstate_t</d:code> object as well as the position within
    the controlled stream.</d:para>
    <d:para><d:emphasis role="bold">Environmental limits</d:emphasis></d:para>
    <d:para>An implementation shall support text files with lines containing at
    least 254 characters, including the terminating new-line character. The
    value of the macro <d:code>BUFSIZ</d:code> shall be at least 256.</d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Files</d:title>
    <d:para>A stream is associated with an external file (which may be a
    physical device) by opening a file, which may involve <d:emphasis
    role="italic">creating</d:emphasis> a new file. Creating an existing file
    causes its former contents to be discarded, if necessary. If a file can
    support positioning requests (such as a disk file, as opposed to a
    terminal), then a file position indicator associated with the stream is
    positioned at the start (character number zero) of the file, unless the
    file is opened with append mode in which case it is implementation-defined
    whether the file <d:emphasis role="italic">position</d:emphasis> indicator
    is initially positioned at the beginning or the end of the file. The file
    position indicator is maintained by subsequent reads, writes, and
    positioning requests, to facilitate an orderly progression through the
    file.</d:para>
    <d:para>Binary files are not truncated, except as defined in The fopen
    function. Whether a write on a text stream causes the associated file to be
    truncated beyond that point is implementation-defined.</d:para>
    <d:para>When a stream is <d:emphasis role="italic">unbuffered</d:emphasis>,
    characters are intended to appear from the source or at the destination as
    soon as possible. Otherwise characters may be accumulated and transmitted
    to or from the host environment as a block. When a stream is <d:emphasis
    role="italic">fully buffered</d:emphasis>, characters are intended to be 
    transmitted to or from the host environment as a block when a buffer is 
    filled. When a stream is <d:emphasis role="italic">line
    buffered</d:emphasis>, characters are intended to be transmitted to or from
    the host environment as a block when a new-line character is
    encountered. Furthermore, characters are intended to be transmitted as a
    block to the host environment when a buffer is filled, when input is
    requested on an unbuffered stream, or when input is requested on a line
    buffered stream that requires the transmission of characters from the host
    environment. Support for these characteristics is implementation-defined,
    and may be affected via the setbuf and setvbuf functions.</d:para>
    <d:para>A file may be disassociated from a controlling stream by
    <d:code>closing</d:code> the file. Output streams are flushed (any
    unwritten buffer contents are transmitted to the host environment) before
    the stream is disassociated from the file. The value of a pointer to a
    <d:code>FILE</d:code> object is indeterminate after the associated file is
    closed (including the standard text streams). Whether a file of zero length
    (on which no characters have been written by an output stream) actually
    exists is implementation-defined.</d:para>
    <d:para>The file may be subsequently reopened, by the same or another
    program execution, and its contents reclaimed or modified (if it can be
    repositioned at its start). If the <d:code>main</d:code> function returns
    to its original caller, or if the <d:code>exit</d:code> function is called,
    all open files are closed (hence all output streams are flushed) before
    program termination. Other paths to program termination, such as calling
    the abort function, need not close all files properly.</d:para>
    <d:para>The address of the <d:code>FILE</d:code> object used to control a
    stream may be significant; a copy of a <d:code>FILE</d:code> object need
    not serve in place of the original.</d:para>
    <d:para>At program startup, three text streams are predefined and need not
    be opened explicitly - <d:emphasis role="italic">standard
    input</d:emphasis> (for reading conventional input), <d:emphasis
    role="italic">standard output</d:emphasis> (for writing conventional
    output) and standard error (for writing diagnostic output). As initially
    opened, the <d:emphasis role="italic">y</d:emphasis> stream is not fully
    buffered; the standard input and standard output streams are fully buffered
    if and only if the stream can be determined not to refer to an interactive
    device.</d:para>
    <d:para>Functions that open additional (nontemporary) files require a
    <d:emphasis role="italic">file name</d:emphasis>, which is a string. The
    rules for composing valid file names are implementation-defined. Whether
    the same file can be simultaneously open multiple times is also
    implementation-defined.</d:para>
    <d:para>Although both text and binary wide-oriented streams are
    conceptually sequences of wide characters, the external file associated
    with a wide-oriented stream is a sequence of multibyte characters,
    generalized as follows:</d:para>
    <d:itemizedlist>
      <d:listitem>
	<d:para>Multibyte encodings within files may contain embedded null
	bytes (unlike multibyte encodings valid for use internal to the
	program).</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>A file need not begin nor end in the initial shift
	state.<d:footnote><d:para>Setting the file position indicator to
	end-of-file, as with <d:code>fseek(file, 0, SEEK_END)</d:code>, has
	undefined behavior for a binary stream (because of possible trailing
	null characters) or for any stream with state-dependent encoding that
	does not assuredly end in the initial shift
	state.</d:para></d:footnote></d:para>
      </d:listitem>
    </d:itemizedlist>
    <d:para>Moreover, the encodings used for multibyte characters may differ
    among files. Both the nature and choice of such encodings are
    implementation-defined.</d:para>
    <d:para>The wide character input functions read multibyte characters from
    the stream and convert them to wide characters as if they were read by
    successive calls to the <d:code>fgetwc</d:code> function. Each conversion
    occurs as if by a call to the <d:code>mbrtowc</d:code> function, with the
    conversion state described by the stream's own <d:code>mbstate_t</d:code>
    object. The byte input functions read characters from the stream as if by
    successive calls to the <d:code>fgetc</d:code> function.</d:para>
    <d:para>The wide character output functions convert wide characters to
    multibyte characters and write them to the stream as if they were written
    by successive calls to the <d:code>fputwc</d:code> function. Each
    conversion occurs as if by a call to the wcrtomb function, with the
    conversion state described by the stream's own <d:code>mbstate_t</d:code>
    object. The byte output functions write characters to the stream as if by
    successive calls to the <d:code>fputc</d:code> function.</d:para>
    <d:para>In some cases, some of the byte input/output functions also perform
    conversions between multibyte characters and wide characters. These
    conversions also occur as if by calls to the <d:code>mbrtowc</d:code> and
    <d:code>wcrtomb</d:code> functions.</d:para>
    <d:para>An <d:emphasis role="italic">encoding error</d:emphasis> occurs if
    the character sequence presented to the underlying <d:code>mbrtowc</d:code>
    function does not form a valid (generalized) multibyte character, or if the
    code value passed to the underlying <d:code>wcrtomb</d:code> does not
    correspond to a valid (generalized) multibyte character. The wide character
    input/output functions and the byte input/output functions store the value
    of the macro <d:code>EILSEQ</d:code> in errno if and only if an encoding
    error occurs.</d:para>
    <d:para><d:emphasis role="bold">Enviromental limits</d:emphasis></d:para>
    <d:para>The value of <d:code>FOPEN_MAX</d:code> shall be at least eight,
    including the three standard text streams.</d:para>
    <d:para><d:emphasis role="bold">Forward references:</d:emphasis> the
    <d:code>exit</d:code> function (The exit function), the
    <d:code>fgetc</d:code> function (The fgetc function), the
    <d:code>fopen</d:code> function (The fopen function), the
    <d:code>fputc</d:code> function (The fputc function), the
    <d:code>setbuf</d:code> function (The setbuf function), the
    <d:code>setvbuf</d:code> function (The setvbuf function), the
    <d:code>fgetwc</d:code> function (The fgetwc function), the
    <d:code>fputwc</d:code> function (The fputwc function), conversion state
    (Extended multibyte/wide character conversion utilities), the
    <d:code>mbrtowc</d:code> function (The mbrtowc function), the
    <d:code>wcrtomb</d:code> function (The wcrtomb function)</d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Operations on files</d:title>
    <d:sect2>
      <d:title>The remove function</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;stdio.h>
int remove(const char *filename);</d:programlisting>
      <d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
      <d:para>The <d:code>remove</d:code> function causes the file whose name
      is the string pointed to by filename to be no longer accessible by that
      name. A subsequent attempt to open that file using that name will fail,
      unless it is created anew. If the file is open, the behavior of the
      <d:code>remove</d:code> function is implementation-defined.</d:para>
      <d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
      <d:para>The <d:code>remove</d:code> function returns zero if the
      operation succeeds, nonzero if it fails.</d:para> 
    </d:sect2>
    <d:sect2>
      <d:title>The rename function</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;stdio.h>
int rename(const char *old, const char *new);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>rename</d:code> function causes the file whose name is the
string pointed to by old to be henceforth known by the name given by the string
pointed to by new. The file named old is no longer accessible by that name. If
a file named by the string pointed to by new exists prior to the call to the
<d:code>rename</d:code> function, the behavior is
implementation-defined.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>rename</d:code> function returns zero if the operation
succeeds, nonzero if it fails,<d:footnote><d:para>Among the reasons the
implementation may cause the <d:code>rename</d:code> function to fail are that
the file is open or that it is necessary to copy its contents to effectuate its
renaming.</d:para></d:footnote> in which case if the file existed previously it
is still known by its original name.</d:para>
    </d:sect2>
    <d:sect2>
      <d:title>The tmpfile function</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;stdio.h>
FILE *tmpfile(void);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>tmpfile</d:code> function creates a temporary binary file
that is different from any other existing file and that will automatically be
removed when it is closed or at program termination. If the program terminates
abnormally, whether an open temporary file is removed is
implementation-defined. The file is opened for update with "wb+" mode.</d:para>
<d:para><d:emphasis role="bold">Recommended Practice</d:emphasis></d:para>
<d:para>It should be possible to open at least <d:code>TMP_MAX</d:code>
temporary files during the lifetime of the program (this limit may be shared
with <d:code>tmpnam</d:code>) and there should be no limit on the number
simultaneously open other than this limit and any limit on the number of open
files (<d:code>FOPEN_MAX</d:code>).</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>tmpfile</d:code> function returns a pointer to the stream
of the file that it created. If the file cannot be created, the
<d:code>tmpfile</d:code> function returns a null pointer.</d:para>
<d:para><d:code>Forward references:</d:code> the <d:code>fopen</d:code>
function (The fopen function).</d:para>
    </d:sect2>
    <d:sect2>
      <d:title>The tmpnam function</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;stdio.h>
char *tmpnam(char *s);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>tmpnam</d:code> function generates a string that is a valid
file name and that is not the same as the name of an existing
file.<d:footnote><d:para>Files created using strings generated by the tmpnam
function are temporary only in the sense that their names should not collide
with those generated by conventional naming rules for the implementation. It is
still necessary to use the remove function to remove such files when their use
is ended, and before program termination.</d:para></d:footnote> The function is
potentially capable of generating <d:code>TMP_MAX</d:code> different strings,
but any or all of them may already be in use by existing files and thus not be
suitable return values.</d:para>
<d:para>The <d:code>tmpnam</d:code> function generates a different string each
time it is called.</d:para>
<d:para>The implementation shall behave as if no library function calls the
<d:code>tmpnam</d:code> function.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>If no suitable string can be generated, the <d:code>tmpnam</d:code>
function returns a null pointer. Otherwise, if the argument is a null pointer,
the tmpnam function leaves its result in an internal static object and returns
a pointer to that object (subsequent calls to the tmpnam function may modify
the same object). If the argument is not a null pointer, it is assumed to point
to an array of at least <d:code>L_tmpnam</d:code> chars; the
<d:code>tmpnam</d:code> function writes its result in that array and returns
the argument as its value.</d:para>
<d:para><d:emphasis role="bold">Environemental limits</d:emphasis></d:para>
<d:para>The value of the macro <d:code>TMP_MAX</d:code> shall be at least
25.</d:para>
    </d:sect2>
  </d:sect1>
  <d:sect1>
    <d:title>File acces functions</d:title>
    <d:sect2>
      <d:title>The fclose functions</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;stdio.h>
int fclose(FILE *stream);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>A successful call to the <d:code>fclose</d:code> function causes the
stream pointed to by stream to be flushed and the associated file to be
closed. Any unwritten buffered data for the stream are delivered to the host
environment to be written to the file; any unread buffered data are
discarded. Whether or not the call succeeds, the stream is disassociated from
the file and any buffer set by the <d:code>setbuf</d:code> or
<d:code>setvbuf</d:code> function is disassociated from the stream (and
deallocated if it was automatically allocated).</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>fclose</d:code> function returns zero if the stream was
successfully closed, or <d:code>EOF</d:code> if any errors were
detected.</d:para>
    </d:sect2>
    <d:sect2>
      <d:title>The fflush function</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;stdio.h>
int fflush(FILE *stream);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>If stream points to an output stream or an update stream in which the
most recent operation was not input, the <d:code>fflush</d:code> function
causes any unwritten data for that stream to be delivered to the host
environment to be written to the file; otherwise, the behavior is
undefined.</d:para>
<d:para>If stream is a null pointer, the fflush function performs this flushing
action on all streams for which the behavior is defined above.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>fflush</d:code> function sets the error indicator for the
stream and returns EOF if a write error occurs, otherwise it returns
zero.</d:para>
<d:para><d:code>Forward references:</d:code> the <d:code>fopen</d:code>
function (The fopen function).</d:para>
    </d:sect2>
    <d:sect2>
      <d:title>The fopen function</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;stdio.h>
FILE *fopen(const char * restrict filename, const char * restrict mode);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>fopen</d:code> function opens the file whose name is the
string pointed to by filename, and associates a stream with it.</d:para>
<d:para>The argument mode points to a string. If the string is one of the
following, the file is open in the indicated mode. Otherwise, the behavior is
undefined.<d:footnote><d:para>If the string begins with one of the above
sequences, the implementation might choose to ignore the remaining characters,
or it might use them to select different kinds of a file (some of which might
not conform to the properties in Streams).</d:para></d:footnote></d:para>
<d:literallayout>
  <d:code>r</d:code> open test file for reading
  <d:code>w</d:code> truncate zero length or create text file for writing
  <d:code>a</d:code> append; open or create text file for writing at end-of-file
  <d:code>rb</d:code> open binary file for reading
  <d:code>wb</d:code> truncate to zero length or create binary file for writing
  <d:code>ab</d:code> append; open or create binary file for writing at end-of-file
  <d:code>r+</d:code> open text file for update (reading and writing)
  <d:code>w+</d:code> truncate to zero length or create text file for update
  <d:code>a+</d:code> append; open or create text file for update, writing at end-of-file
  <d:code>r+b</d:code> or <d:code>rb+</d:code> open binary file for update (reading and writing)
  <d:code>w+b</d:code> or <d:code>wb+</d:code> truncate to zero length or create binary file for update
  <d:code>a+b</d:code> or <d:code>ab+</d:code> append; open or create binary file for update, writing at end-of-file
</d:literallayout>
<d:para>Opening a file with read mode ('<d:code>r</d:code>' as the first
character in the mode argument) fails if the file does not exist or cannot be
read.</d:para>
<d:para>Opening a file with append mode ('<d:code>a</d:code>' as the first
character in the mode argument) causes all subsequent writes to the file to be
forced to the then current end-of-file, regardless of intervening calls to the
fseek function. In some implementations, opening a binary file with append mode
('<d:code>b</d:code>' as the second or third character in the above list of
mode argument values) may initially position the file position indicator for
the stream beyond the last data written, because of null character
padding.</d:para>
<d:para>When a file is opened with update mode ('<d:code>+</d:code>' as the
second or third character in the above list of mode argument values), both
input and output may be performed on the associated stream. However, output
shall not be directly followed by input without an intervening call to the
<d:code>fflush</d:code> function or to a file positioning function
(<d:code>fseek, fsetpos</d:code> or <d:code>rewind</d:code>), and input shall
not be directly followed by output without an intervening call to a file
positioning function, unless the input operation encounters
end-of-file. Opening (or creating) a text file with update mode may instead
open (or create) a binary stream in some implementations.</d:para>
<d:para>When opened, a stream is fully buffered if and only if it can be
determined not to refer to an interactive device. The error and end-of-file
indicators for the stream are cleared.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>fopen</d:code> function returns a pointer to the object
controlling the stream. If the open operation fails, fopen returns a null
pointer.</d:para>
<d:para><d:emphasis role="bold">Forward references:</d:emphasis> file
positioning functions (File positioning functions).</d:para>
    </d:sect2>
  </d:sect1>
</d:chapter>
