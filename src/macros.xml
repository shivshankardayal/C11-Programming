<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
  <?dbhtml filename="macros/index.html" ?>
  <d:indexterm>
    <d:primary>preprocessing directives</d:primary>
  </d:indexterm>
  <d:title>Preprocessing Directives</d:title>
  <d:para>The following comes from section &#xa7; iso.6.10 of specification.
  It will terminate when you see code starting. :-)</d:para>
  <d:para>A <d:emphasis role="italic">preprocessing directive</d:emphasis>
  consists of a sequence of preprocessing tokens that begins with a
  <d:code>#</d:code> preprocessing token that (at the start of translation
  phase 4) is either the first character in the source file (optionally after
  white space containing no new-line characters) or that follows white space
  containing at least one new-line character, and is ended by the next
  new-line character.<d:footnote><d:para>Thus, preprocessing directives are
  commonly called “lines”. These “lines” have no other syntactic
  significance, as all white space is equivalent except in certain situations
  during preprocessing (see the # character string literal creation operator
  in 11.3.2, for example).</d:para></d:footnote> A new-line character ends
  the preprocessing directive even if it occurs within what would otherwise
  be an invocation of a function-like macro.</d:para>
  <d:para>A text line shall not begin with a <d:code>#</d:code> preprocessing
  token. A non-directive shall not begin with any of the directive names
  appearing in the syntax.</d:para>
  <d:para>When in a group that is skipped (11.1), the directive syntax is
  relaxed to allow any sequence of preprocessing tokens to occur between the
  directive name and the following new-line character.</d:para>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>The only white-space characters that shall appear between
  preprocessing tokens within a preprocessing directive (from just after the
  introducing # preprocessing token through just before the terminating
  new-line character) are space and horizontal-tab (including spaces that
  have replaced comments or possibly other white-space characters in
  translation phase 3).</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>The implementation can process and skip sections of source files
  conditionally, include other source files, and replace macros. These
  capabilities are called preprocessing, because conceptually they occur
  before translation of the resulting translation unit.</d:para>
  <d:para>The preprocessing tokens within a preprocessing directive are not
  subject to macro expansion unless otherwise stated.</d:para>
  <d:para>EXAMPLE In:</d:para>
  <d:programlisting role="CLexer">#define EMPTY
EMPTY # include &lt;file.h></d:programlisting>
<d:para>the sequence of preprocessing tokens on the second line is not a
preprocessing directive, because it does not begin with a <d:code>#</d:code> at
the start of translation phase 4, even though it will do so after the macro
<d:code>EMPTY</d:code> has been replaced.</d:para>
<d:sect1>
  <d:indexterm>
    <d:primary>conditional inclusion</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#if</d:secondary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#elif</d:secondary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#ifdef</d:secondary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#ifndef</d:secondary>
  </d:indexterm>
  <d:title>Conditional Inclusion</d:title>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>The expression that controls conditional inclusion shall be an
  integer constant expression except that: it shall not contain a cast;
  identifiers (including those lexically identical to keywords) are interpreted
  as described below; <d:footnote><d:para>Because the controlling constant
  expression is evaluated during translation phase 4, all identifiers either
  are or are not macro names - there simply are no keywords, enumeration
  constants, etc.</d:para></d:footnote> and it may contain unary operator
  expressions of the form:</d:para>
  <d:screen>defined identifier</d:screen>
  <d:para>or:</d:para>
  <d:screen>defined (identifier)</d:screen>
  <d:para>which evaluate to 1 if the identifier is currently defined as a macro
  name (that is, if it is predefined or if it has been the subject of a
  <d:code>#define</d:code> preprocessing directive without an intervening
  <d:code>#undef</d:code> directive with the same subject identifier), 0 if it
  is not.</d:para>
  <d:para><d:emphasis role="bold">Sematics</d:emphasis></d:para>
  <d:para>Preprocessing directives of the forms:</d:para>
  <d:programlisting role="CLexer"># if constant-expression new-line group_opt
# elif constant-expression new-line group_opt</d:programlisting>
<d:para>check whether the controlling constant expression evaluates to
nonzero.</d:para>
<d:para>Prior to evaluation, macro invocations in the list of preprocessing
tokens that will become the controlling constant expression are replaced
(except for those macro names modified by the defined unary operator), just as
in normal text. If the token defined is generated as a result of this
replacement process or use of the defined unary operator does not match one of
the two specified forms prior to macro replacement, the behavior is
undefined. After all replacements due to macro expansion and the defined unary
operator have been performed, all remaining identifiers are replaced with the
pp-number 0, and then each preprocessing token is converted into a token. The
resulting tokens compose the controlling constant expression which is evaluated
according to the rules of constant expressions. For the purposes of this token
conversion and evaluation, all signed integer types and all unsigned integer
types act as if they hav e the same representation as, respectively, the types
<d:code>intmax_t</d:code> and <d:code>uintmax_t</d:code> defined in the header
<d:code>&amp;lt;stdint.h></d:code>.<d:footnote><d:para>Thus, on an implementation
where <d:code>INT_MAX</d:code> is <d:code></d:code> and
<d:code>UINT_MAX</d:code> is <d:code>0xFFFF</d:code>, the constant
<d:code>0x8000</d:code> is signed and positive within a <d:code>#if</d:code>
expression even though it would be unsigned in translation phase
7.</d:para></d:footnote> This includes interpreting character constants, which
may involve converting escape sequences into execution character set
members. Whether the numeric value for these character constants matches the
value obtained when an identical character constant occurs in an expression
(other than within a <d:code>#if</d:code> or <d:code>#elif</d:code> directive)
is implementation-defined.<d:footnote><d:para>Thus, the constant expression in
the following <d:code>#if</d:code> directive and if statement is not guaranteed
to evaluate to the same value in these two contexts.
<d:programlisting role="CLexer">#if 'z' - 'a' == 25

if ('z' - 'a' == 25)</d:programlisting></d:para></d:footnote> Also, whether a
single-character character constant may have a negative value is
implementation-defined.</d:para>
<d:para>Preprocessing directives of the forms:</d:para>
<d:programlisting role="CLexer"># ifdef identifier new-line group_opt
# ifndef identifier new-line group_opt</d:programlisting>
<d:para>check whether the identifier is or is not currently defined as a macro
name. Their conditions are equivalent to <d:code>#if</d:code> defined
identifier and <d:code>#if !defined</d:code> identifier respectively.</d:para>
<d:para>Each directive’s condition is checked in order. If it evaluates to
false (zero), the group that it controls is skipped: directives are processed
only through the name that determines the directive in order to keep track of
the level of nested conditionals; the rest of the directives’ preprocessing
tokens are ignored, as are the other preprocessing tokens in the group. Only
the first group whose control condition evaluates to true (nonzero) is
processed. If none of the conditions evaluates to true, and there is a #else
directive, the group controlled by the #else is processed; lacking a #else
directive, all the groups until the #endif are skipped.<d:footnote><d:para>As
indicated by the syntax, a preprocessing token shall not follow a #else or
#endif directive before the terminating new-line character. However, comments
may appear anywhere in a source file, including within a preprocessing
directive.</d:para></d:footnote></d:para>
</d:sect1>
<d:sect1>
  <d:indexterm>
    source file inclusion
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#include</d:secondary>
  </d:indexterm>
  <d:title>Source File Inclusion</d:title>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>A <d:code>#include</d:code> directive shall identify a header or
  source file that can be processed by the implementation.</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># include &lt;h-char-sequence>  new-line</d:programlisting>
  <d:para>searches a sequence of implementation-defined places for a header
  identified uniquely by the specified sequence between the &amp;lt; and >
  delimiters, and causes the replacement of that directive by the entire
  contents of the header. How the places are specified or the header identified
  is implementation-defined.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
<d:programlisting role="CLexer"># include "q-char-sequence" new-line</d:programlisting>
<d:para>causes the replacement of that directive by the entire contents of the
source file identified by the specified sequence between the ” delimiters. The
named source file is searched for in an implementation-defined manner. If this
search is not supported, or if the search fails, the directive is reprocessed
as if it read:</d:para>
<d:programlisting role="CLexer"># include &lt;h-char-sequence> new-line</d:programlisting>
<d:para>with the identical contained sequence (including > characters, if any)
from the original directive.</d:para>
<d:para>A preprocessing directive of the form:</d:para>
<d:programlisting role="CLexer"># include pp-tokens new-line</d:programlisting>
<d:para>(that does not match one of the two previous forms) is permitted. The
preprocessing tokens after include in the directive are processed just as in
normal text. (Each identifier currently defined as a macro name is replaced by
its replacement list of preprocessing tokens.) The directive resulting after
all replacements shall match one of the two previous
forms.<d:footnote><d:para>Note that adjacent string literals are not
concatenated into a single string literal; thus, an expansion that results in
two string literals is an invalid directive.</d:para></d:footnote> The method
by which a sequence of preprocessing tokens between a &amp;lt; and a >
preprocessing token pair or a pair of ” characters is combined into a single
header name preprocessing token is implementation-defined.</d:para> 
<d:para>The implementation shall provide unique mappings for sequences
consisting of one or more letters or digits followed by a period (.) and a
single letter. The first character shall be a letter. The implementation may
ignore the distinctions of alphabetical case and restrict the mapping to eight
significant characters before the period.</d:para>
<d:para>A <d:code>#include</d:code> preprocessing directive may appear in a
source file that has been read because of a <d:code>#include</d:code> directive
in another file, up to an implementation-defined nesting limit.</d:para>
<d:para><d:emphasis role="bold">Forward References</d:emphasis>: <d:xref
linkend="macro_replacement" /></d:para>
</d:sect1>
<d:sect1 id="macro_replacement">
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#define</d:secondary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro replacement</d:primary>
  </d:indexterm>
  <d:title>Macro Replacement</d:title>
<d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>Two replacement lists are identical if and only if the preprocessing
  tokens in both have the same number, ordering, spelling, and white-space
  separation, where all white-space separations are considered
  identical.</d:para>
  <d:para>An identifier currently defined as an object-like macro shall not be
  redefined by another #define preprocessing directive unless the second
  definition is an object-like macro definition and the two replacement lists
  are identical. Likewise, an identifier currently defined as a function-like
  macro shall not be redefined by another <d:code>#define</d:code>
  preprocessing directive unless the second definition is a function-like macro
  definition that has the same number and spelling of parameters, and the two
  replacement lists are identical.</d:para>
  <d:para>There shall be white-space between the identifier and the replacement
  list in the definition of an object-like macro.</d:para>
  <d:para>If the identifier-list in the macro definition does not end with an
  ellipsis, the number of arguments (including those arguments consisting of no
  preprocessing tokens) in an invocation of a function-like macro shall equal
  the number of parameters in the macro definition. Otherwise, there shall be
  more arguments in the invocation than there are parameters in the macro
  definition (excluding the ...). There shall exist a ) preprocessing token
  that terminates the invocation.</d:para>
  <d:para>The identifier <d:code>__VA_ARGS__</d:code> shall occur only in the
  replacement-list of a function-like macro that uses the ellipsis notation in
  the parameters.</d:para>
  <d:para>A parameter identifier in a function-like macro shall be uniquely
  declared within its scope.</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>The identifier immediately following the define is called the macro
  name. There is one name space for macro names. Any white-space characters
  preceding or following the replacement list of preprocessing tokens are not
  considered part of the replacement list for either form of macro.</d:para>
  <d:para>If a <d:code>#</d:code> preprocessing token, followed by an
  identifier, occurs lexically at the point at which a preprocessing directive
  could begin, the identifier is not subject to macro replacement.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># define identifier replacement-list new-line</d:programlisting>
  <d:para>defines an object-like macro that causes each subsequent instance of
  the macro name<d:footnote><d:para>Since, by macro-replacement time, all
  character constants and string literals are preprocessing tokens, not
  sequences possibly containing identifier-like subsequences, they are never
  scanned for macro names or parameters.</d:para></d:footnote> to be replaced
  by the replacement list of preprocessing tokens that constitute the remainder
  of the directive.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># define identifier lparen identifier-listopt ) replacement-list new-line
# define identifier lparen ... ) replacement-list new-line
# define identifier lparen identifier-list , ... ) replacement-list new-line</d:programlisting>
<d:para>defines a function-like macro with arguments, similar syntactically to
a function call. The parameters are specified by the optional list of
identifiers, whose scope extends from their declaration in the identifier list
until the new-line character that terminates the <d:para>#define</d:para>
preprocessing directive. Each subsequent instance of the function-like macro
name followed by a ( as the next preprocessing token introduces the sequence of
preprocessing tokens that is replaced by the replacement list in the definition
(an invocation of the macro). The replaced sequence of preprocessing tokens is
terminated by the matching ) preprocessing token, skipping intervening matched
pairs of left and right parenthesis preprocessing tokens. Within the sequence
of preprocessing tokens making up an invocation of a function-like macro,
new-line is considered a normal white-space character.</d:para>
<d:para>The sequence of preprocessing tokens bounded by the outside-most
matching parentheses forms the list of arguments for the function-like
macro. The individual arguments within the list are separated by comma
preprocessing tokens, but comma preprocessing tokens between matching inner
parentheses do not separate arguments. If there are sequences of preprocessing
tokens within the list of arguments that would otherwise act as preprocessing
directives,<d:footnote><d:para>Despite the name, a non-directive is a
preprocessing directive.</d:para></d:footnote> the behavior is
undefined.</d:para>
<d:para>If there is a ... in the identifier-list in the macro definition, then
the trailing arguments, including any separating comma preprocessing tokens,
are merged to form a single item: the variable arguments. The number of
arguments combined is such that, following merger, the number of arguments is
one more than the number of parameters in the macro definition (excluding the
...).</d:para>
<d:sect2>
  <d:indexterm>
    <d:primary>argument substitution</d:primary>
  </d:indexterm>
  <d:title>Argument Substitution</d:title>
  <d:para>After the arguments for the invocation of a function-like macro have
  been identified, argument substitution takes place. A parameter in the
  replacement list, unless preceded by a <d:code>#</d:code> or
  <d:code>##</d:code> preprocessing token or followed by a <d:code>##</d:code>
  preprocessing token (see below), is replaced by the corresponding argument
  after all macros contained therein have been expanded. Before being
  substituted, each argument’s preprocessing tokens are completely macro
  replaced as if they formed the rest of the preprocessing file; no other
  preprocessing tokens are available.</d:para>
  <d:para>An identifier <d:code>__VA_ARGS__</d:code> that occurs in the
  replacement list shall be treated as if it were a parameter, and the variable
  arguments shall form the preprocessing tokens used to replace it.</d:para>
</d:sect2>
<d:sect2>
  <d:indexterm>
    <d:primary>operator</d:primary>
    <d:secondary>#</d:secondary>
  </d:indexterm>
  <d:title>The # Operator</d:title>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>Each <d:code>#</d:code> preprocessing token in the replacement list
  for a function-like macro shall be followed by a parameter as the next
  preprocessing token in the replacement list.</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>If, in the replacement list, a parameter is immediately preceded by a
  <d:code>#</d:code> preprocessing token, both are replaced by a single
  character string literal preprocessing token that contains the spelling of
  the preprocessing token sequence for the corresponding argument. Each
  occurrence of white space between the argument's preprocessing tokens becomes
  a single space character in the character string literal. White space before
  the first preprocessing token and after the last preprocessing token
  composing the argument is deleted. Otherwise, the original spelling of each
  preprocessing token in the argument is retained in the character string
  literal, except for special handling for producing the spelling of string
  literals and character constants: a \ character is inserted before each " and
  \ character of a character constant or string literal (including the
  delimiting " characters), except that it is implementation-defined whether a
  \ character is inserted before the \ character beginning a universal
  character name. If the replacement that results is not a valid character
  string literal, the behavior is undefined. The character string literal
  corresponding to an empty argument is "". The order of evaluation of
  <d:code>#</d:code> and <d:code>##</d:code> operators is unspecified.</d:para>
</d:sect2>
<d:sect2>
  <d:indexterm>
    <d:primary>operator</d:primary>
    <d:secondary>##</d:secondary>
  </d:indexterm>
  <d:title>The ## Operator</d:title>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>A <d:code>##</d:code> preprocessing token shall not occur at the
  beginning or at the end of a replacement list for either form of macro
  definition.</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>If, in the replacement list of a function-like macro, a parameter is
  immediately preceded or followed by a <d:code>##</d:code> preprocessing
  token, the parameter is replaced by the corresponding argument’s
  preprocessing token sequence; however, if an argument consists of no
  preprocessing tokens, the parameter is replaced by a placemarker
  preprocessing token instead.<d:footnote><d:para>Placemarker preprocessing
  tokens do not appear in the syntax because they are temporary entities that
  exist only within translation phase 4.</d:para></d:footnote></d:para>
  <d:para>For both object-like and function-like macro invocations, before the
  replacement list is reexamined for more macro names to replace, each instance
  of a <d:code>##</d:code> preprocessing token in the replacement list (not
  from an argument) is deleted and the preceding preprocessing token is
  concatenated with the following preprocessing token. Placemarker
  preprocessing tokens are handled specially: concatenation of two placemarkers
  results in a single placemarker preprocessing token, and concatenation of a
  placemarker with a non-placemarker preprocessing token results in the
  non-placemarker preprocessing token. If the result is not a valid
  preprocessing token, the behavior is undefined. The resulting token is
  available for further macro replacement. The order of evaluation of
  <d:code>##</d:code> operators is unspecified.</d:para>
</d:sect2>
<d:sect2>
  <d:title>Rescanning and Further Replacement</d:title>
  <d:para>After all parameters in the replacement list have been substituted
  and <d:code>#</d:code> and <d:code>##</d:code> processing has taken place,
  all placemarker preprocessing tokens are removed. Then, the resulting
  preprocessing token sequence is rescanned, along with all subsequent
  preprocessing tokens of the source file, for more macro names to
  replace.</d:para>
  <d:para>If the name of the macro being replaced is found during this scan of
  the replacement list (not including the rest of the source file’s
  preprocessing tokens), it is not replaced. Furthermore, if any nested
  replacements encounter the name of the macro being replaced, it is not
  replaced. These nonreplaced macro name preprocessing tokens are no longer
  available for further replacement even if they are later (re)examined in
  contexts in which that macro name preprocessing token would otherwise have
  been replaced.</d:para>
  <d:para>The resulting completely macro-replaced preprocessing token sequence
  is not processed as a preprocessing directive even if it resembles one, but
  all pragma unary operator expressions within it are then processed as
  specified in 11.9 below.</d:para>
</d:sect2>
<d:sect2>
  <d:indexterm>
    <d:primary>scope of macro definitions</d:primary>
  </d:indexterm>
  <d:title>Scope of Macro Definitions</d:title>
  <d:para>A macro definition lasts (independent of block structure) until a
  corresponding <d:code>#undef</d:code> directive is encountered or (if none is
  encountered) until the end of the preprocessing translation unit. Macro
  definitions have no significance after translation phase 4.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># undef identifier new-line</d:programlisting>
  <d:para>causes the specified identifier no longer to be defined as a macro
  name. It is ignored if the specified identifier is not currently defined as a
  macro name.</d:para>
</d:sect2>
</d:sect1>
<d:sect1>
  <d:indexterm>
    <d:primary>line control</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#line</d:secondary>
  </d:indexterm>
  <d:title>Line Control</d:title>
  <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
  <d:para>The string literal of a <d:code>#line</d:code> directive, if present,
  shall be a character string literal.</d:para>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>The line number of the current source line is one greater than the
  number of new-line characters read or introduced in translation phase 1 while
  processing the source file to the current token.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># line digit-sequence new-line</d:programlisting>
  <d:para>causes the implementation to behave as if the following sequence of
  source lines begins with a source line that has a line number as specified by
  the digit sequence (interpreted as a decimal integer). The digit sequence
  shall not specify zero, nor a number greater than 2147483647.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># line digit-sequence "s-char-sequenceopt" new-line</d:programlisting>
  <d:para>sets the presumed line number similarly and changes the presumed name
  of the source file to be the contents of the character string
  literal.</d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># line pp-tokens new-line</d:programlisting>
  <d:para>(that does not match one of the two previous forms) is permitted. The
  preprocessing tokens after line on the directive are processed just as in
  normal text (each identifier currently defined as a macro name is replaced by
  its replacement list of preprocessing tokens). The directive resulting after
  all replacements shall match one of the two previous forms and is then
  processed as appropriate.</d:para>
</d:sect1>
<d:sect1>
  <d:indexterm>
    <d:primary>error directive</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#error</d:secondary>
  </d:indexterm>
  <d:title>Error Directive</d:title>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>A preprocessing directive of the form <d:code># error
  pp-tokensopt new-line</d:code> causes the implementation to produce a
  diagnostic message that includes the specified sequence of preprocessing
  tokens.</d:para>
</d:sect1>
<d:sect1>
  <d:indexterm>
    <d:primary>pragma directive</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>macro</d:primary>
    <d:secondary>#pragma</d:secondary>
  </d:indexterm>
  <d:title>Pragma Directive</d:title>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># pragma pp-tokensopt new-line</d:programlisting>
  <d:para>where the preprocessing token STDC does not immediately follow pragma
  in the directive (prior to any macro replacement)<d:footnote><d:para>An
  implementation is not required to perform macro replacement in pragmas, but
  it is permitted except for in standard pragmas (where <d:code>STDC</d:code>
  immediately follows pragma). If the result of macro replacement in a
  non-standard pragma has the same form as a standard pragma, the behavior is
  still implementation-defined; an implementation is permitted to behave as if
  it were the standard pragma, but is not required to.</d:para></d:footnote>
  causes the implementation to behave in an implementation-defined manner. The
  behavior might cause translation to fail or cause the translator or the
  resulting program to behave in a non-conforming manner. Any such pragma that
  is not recognized by the implementation is ignored.</d:para>
  <d:para>If the preprocessing token STDC does immediately follow pragma in the
  directive (prior to any macro replacement), then no macro replacement is
  performed on the directive, and the directive shall have one of the following
  forms whose meanings are described elsewhere:</d:para> 
<d:programlisting role="CLexer">#pragma STDC FP_CONTRACT on-off-switch
#pragma STDC FENV_ACCESS on-off-switch
#pragma STDC CX_LIMITED_RANGE on-off-switch</d:programlisting>
<d:para><d:emphasis role="italic">on-off-switch: </d:emphasis> on of</d:para>
<d:para>ON OFF DEFAULT</d:para>
<d:para><d:emphasis role="bold">Forward references:</d:emphasis> <d:xref
linkend="fp_contract" />, <d:xref linkend="fenv_access" />, <d:xref
linkend="cx_limited_range" />.</d:para>
</d:sect1>
<d:sect1>
  <d:indexterm>
    <d:primary>null directive</d:primary>
  </d:indexterm>
  <d:title>Null Directive</d:title>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>A preprocessing directive of the form:</d:para>
  <d:programlisting role="CLexer"># new-line</d:programlisting>
  <d:para>has no effect.</d:para>
</d:sect1>
<d:sect1>
  <d:indexterm>
    <d:primary>predefined macros</d:primary>
  </d:indexterm>
  <d:title>Predefined Macro Names</d:title>
  <d:para>The following macro names shall be defined by the
  implementation:</d:para>
  <d:indexterm>
    <d:primary>__DATE__</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>__FILE__</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>__LINE__</d:primary>
  </d:indexterm>    
  <d:indexterm>
    <d:primary>__TIME__</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>__STDC__</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>__STDC_VERSION__</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>__STDC_IEC_559_COMPLEX__</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>__STDC_ISO_10646__</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>__STDC_HOSTED__</d:primary>
  </d:indexterm>
  <d:indexterm>
    <d:primary>__STDC_IEC_559__</d:primary>
  </d:indexterm>
  <d:para><d:code>__DATE__</d:code> The date of translation of the
  preprocessing translation unit: a character string literal of the form "Mmm
  dd yyyy", where the names of the months are the same as those generated by
  the asctime function, and the first character of dd is a space character if
  the value is less than 10. If the date of translation is not available, an
  implementation-defined valid date shall be supplied.</d:para>
  <d:para><d:code>__FILE__</d:code> The presumed name of the current source
  file (a character string literal)<d:footnote><d:para>The presumed source file
  name and line number can be changed by the <d:code>#line</d:code>
  directive.</d:para></d:footnote></d:para>
  <d:para><d:code>__LINE__</d:code> The presumed line number (within the
  current source file) of the current source line (an integer
  constant).<d:footnote xml:id="line"><d:para>This macro was not specified in
  ISO/IEC 9899:1990 and was specified as 199409L in ISO/IEC 9899/AMD1:1995. The
  intention is that this will remain an integer constant of type long int that
  is increased with each revision of International
  Standard.</d:para></d:footnote></d:para>
  <d:para><d:code>__STDC__</d:code> The integer constant 1, intended to
  indicate a conforming implementation. <d:code>__STDC_HOSTED__</d:code> The
  integer constant 1 if the implementation is a hosted implementation or the
  integer constant 0 if it is not.</d:para>
  <d:para><d:code>__STDC_VERSION__</d:code> The integer constant
  199901L.<d:footnoteref linkend="line" /></d:para>
  <d:para><d:code>__TIME__</d:code> The time of translation of the
  preprocessing translation unit: a character string literal of the form
  "hh:mm:ss" as in the time generated by the asctime function. If the time of
  translation is not available, an implementation-defined valid time shall be
  supplied.</d:para>
  <d:para>The following macro names are conditionally defined by the
  implementation: <d:code>__STDC_IEC_559__</d:code> The integer constant 1,
  intended to indicate conformance to the specifications in annex F (IEC 60559
  floating-point arithmetic).</d:para>
  <d:para><d:code>__STDC_IEC_559_COMPLEX__</d:code> The integer constant 1,
  intended to indicate adherence to the specifications in informative annex G
  (IEC 60559 compatible complex arithmetic).</d:para>
  <d:para><d:para>__STDC_ISO_10646__</d:para> An integer constant of the form
  yyyymmL (for example, 199712L). If this symbol is defined, then every
  character in the Unicode required set, when stored in an object of type
  <d:code>wchar_t</d:code>, has the same value as the short identifier of that
  character. The Unicode required set consists of all the characters that are
  defined by ISO/IEC 10646, along with all amendments and technical corrigenda,
  as of the specified year and month.</d:para>
  <d:para>The values of the predefined macros (except for
  <d:code>__FILE__</d:code> and <d:code>__LINE__</d:code>) remain constant
  throughout the translation unit.</d:para>
  <d:para>None of these macro names, nor the identifier defined, shall be the
  subject of a <d:code>#define</d:code> or a <d:code>#undef</d:code>
  preprocessing directive. Any other predefined macro names shall begin with a
  leading underscore followed by an uppercase letter or a second
  underscore.</d:para>
  <d:para>The implementation shall not predefine the macro
  <d:code>__cplusplus</d:code>, nor shall it define it in any standard
  header.</d:para>
  <d:para><d:emphasis role="bold">Forward references:</d:emphasis> the asctime
  function, standard headers.</d:para>
</d:sect1>
<d:sect1>
  <d:title>Pragma Operator</d:title>
  <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
  <d:para>A unary operator expression of the form:</d:para>
  <d:programlisting role="CLexer">_Pragma ( string-literal )</d:programlisting>
  <d:para>is processed as follows: The string literal is destringized by
  deleting the L prefix, if present, deleting the leading and trailing
  double-quotes, replacing each escape sequence \" by a double-quote, and
  replacing each escape sequence \\ by a single backslash. The resulting
  sequence of characters is processed through translation phase 3 to produce
  preprocessing tokens that are executed as if they were the pp-tokens in a
  pragma directive. The original four preprocessing tokens in the unary
  operator expression are removed.</d:para>
  <d:para>At this point specification material ends here and now we will see
  usage of above discussed macros.</d:para>
</d:sect1>
<d:sect1>
  <d:title>Usage</d:title>
  <d:para>Note that for this part the compilation command should be
  <d:code>clang -E filename.c</d:code>. Let us create two files
  <d:code>test.c</d:code> and <d:code>test1.c</d:code> and their contents are
  given below respectively.</d:para>
  <d:sect2>
    <d:indexterm>
      <d:primary>macro</d:primary>
      <d:secondary>#include</d:secondary>
    </d:indexterm>
    <d:title>#include</d:title>
    <d:programlisting role="CLexer">#include "test1.c"
I am test.</d:programlisting>
<d:programlisting role="CLexer">#include "test.c"
I am test1.</d:programlisting>
<d:para>Keep both the files in same directory and execute <d:code>clang -E
test.c</d:code> you will see following:</d:para>
<d:programlisting role="CLexer"># 1 "test.c"
# 1 "test.c" 1
# 1 "&lt;built-in>" 1
# 1 "&lt;built-in>" 3
# 143 "&lt;built-in>" 3
# 1 "&lt;command line>" 1
# 1 "&lt;built-in>" 2
# 1 "test.c" 2
# 1 "./test1.c" 1
...
In file included from test.c:1:
In file included from ./test1.c:1:
In file included from test.c:1:
In file included from ./test1.c:1:
In file included from test.c:1:
In file included from ./test1.c:1:
...
In file included from test.c:1:
./test1.c:1:10: error: #include nested too deeply
#include "test.c"

I am test1.
# 2 "test.c" 2
I am test
# 2 "./test1.c" 2
I am test1.
# 2 "test.c" 2
I am test
# 2 "./test1.c" 2
I am test1.
# 2 "test.c" 2</d:programlisting>
<d:para>As you can see <d:code>test.c</d:code> includes
<d:code>test1.c</d:code> and <d:code>test1.c</d:code> includes
<d:code>test.c</d:code>. So they are including each other which is causing
nested includes. After processesing for some time preprocessor’s head starts
spinning as if it has drunk a full bottle of rum and it bails out. As you know
headers are included in all meaningful C programs and headers include each
other as well. This inclusion of each other can easily lead to nested inclusion
so how do header authors circumvent this problem. Well, a technique has been
devised known popularly as header guard. The lines which have the form
<d:code>#</d:code> number text is actually <d:code># line</d:code>
directive.</d:para>
<d:para>Consider following code:</d:para>
<d:programlisting role="CLexer">#ifndef ANYTHING
#define ANYTHING

#include "test1.c"

I am test.

#endif</d:programlisting>
<d:programlisting role="CLexer">#ifndef ANYTHING_ELSE
#define ANYTHING_ELSE

#include "test.c"

I am test1.

#endif</d:programlisting>
<d:para>Now what will happen that when <d:code>test.c</d:code> is included
<d:code>ANYTHING</d:code> is defined and when <d:code>test1.c</d:code> is
included via it <d:code>ANYTHING_ELSE</d:code> will be defined. After first
round of inclusion no more inclusion can happen as governed by the
directives. Please see headers of standard library to see the conventions for
<d:code>ANYTHING</d:code>.</d:para>
  </d:sect2>
  <d:sect2>
    <d:title>Why we need headers?</d:title>
    <d:para>Now that we have seen the <d:code>#include</d:code> directive I
    would like to tell that why we even need header files. Header files contain
    several elements of libraries which come with C. For example, function
    prototypes, structure/type, declarations, macros, global variable
    declaration etc. Actual code resides inside <d:code>*.a</d:code> or
    <d:code>*.so</d:code> library files on GNU/Linux or UNIX OSes. Now let us
    consider a case that we want to access a C function of standard
    library. The compilation phase requires that prototype of function should
    be known at compilation time. If we do not have headers we have no way to
    provide this function prototype at compile time. Same stands true for
    global variables. The declaration of these must be known at compilation
    time. You take any language there has to be a mechanism to include code
    from other files. Be it use directive of Perl or import of Python or any
    other mechanism of any other language.</d:para>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>macro</d:primary>
      <d:secondary>#define</d:secondary>
    </d:indexterm>
    <d:title>#define</d:title>
    <d:para><d:code>#define</d:code> and <d:code>#include</d:code> are probably
    the most encountered macro in all C files. There are many usage of it. We
    will first see the text replacement and function like usage which can be
    avoided and should be replaced by global constants and inline
    functions. First let us see what text replacement functionality we get
    using <d:code>#define</d:code>. Consider the following code
    fragment:</d:para>
    <d:programlisting role="CLexer">#define MAX 5

MAX

I am MAX</d:programlisting>
<d:para>Now run it though <d:code>clang -E filename.c</d:code> and you will get
following output:</d:para>
<d:screen># 1 "test.c"
# 1 "&lt;built-in>"
# 1 "&lt;command-line>"
# 1 "test.c"


5

I am 5</d:screen>
<d:para>So as you see both the occurrences are replaced by the text 5. This is
the simplest form of text replacement which people use to handle many
things. Most common are array sizes and symbolic constants. Another form is the
form like functions which has been shown in 10.4.</d:para>
<d:para>The bad part of these two is that both do not enter symbol table and
make code hard to debug. The former can be replaced by const variables and
latter by inline functions.</d:para>
<d:para>The other usage of it is to define names. For example, we revisit our
old example headers. Header guards usually declare something like
this:</d:para>
<d:programlisting role="CLexer">#ifndef SOMETHING
#define SOMETHING

/* header code */
#endif</d:programlisting>
<d:para>As you can see <d:code>#define</d:code> is used to define
<d:code>SOMETHING</d:code> so second time the conditional inclusion
<d:code>#ifndef</d:code> will fail. It can also be tested by defiend like
<d:code>if(defined(SOMETHING)</d:code>. Now if <d:code>SOMETHING</d:code> has
been defined if test will pass successfully. Similarly <d:code>#ifdef</d:code>
can be used to test it as a shortcut i.e. <d:code>#ifdef
SOMETHING</d:code>. The normal if-else statements are replaced in preprocessing
directives using <d:code>#if, #elif</d:code> and
<d:code>#endif</d:code>.</d:para>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>macro</d:primary>
      <d:secondary>#undef</d:secondary>
    </d:indexterm>
    <d:title>#undef</d:title>
    <d:para>Anything defined by <d:code>#define</d:code> can be undefined by
    <d:code>#undef</d:code>. For example consider the following code:</d:para>
    <d:programlisting role="CLexer">#define test
#ifdef test

//do something

#undef test
#ifdef test

//do something else
#endif
#endif</d:programlisting>
<d:para>If you do this then first something else will be executed while the
second will not be.</d:para>
  </d:sect2>
  <d:sect2>
    <d:title># and ##</d:title>
    <d:para>You can use following two examples and description given above to
    understand both of these:</d:para>
    <d:programlisting role="CLexer">#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)

char p[] = join(x, y); //char p[]="x ## y"

#define FIRST a # b
#define SECOND a ## b

char first[] = FIRST;
char second[] = SECOND;</d:programlisting>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>macro</d:primary>
      <d:secondary>#error</d:secondary>
    </d:indexterm>
    <d:title>#error</d:title>
    <d:programlisting role="CLexer">#include &lt;stdio.h>

int main()
{
  # error MAX

  return 0;
}</d:programlisting>
<d:para>If you try to compile this like <d:code>clang filename.c</d:code> then
you will get following:</d:para>
<d:screen>clang test.c
test.c:5:5: error: #error MAX
  # error MAX
  ^
1 error generated.</d:screen>
<d:para>You can combine <d:code># error</d:code> with <d:code>#if</d:code> but
I have yet to see purposeful code written that way. Non-preprocessing
constructs are better for handling such situations. Only if you want to test a
preprocessing token then it should be used.</d:para>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>macro</d:primary>
      <d:secondary>#pragma</d:secondary>
    </d:indexterm>
    <d:title>#pragma</d:title>
    <d:para><d:code>#pragma</d:code> is dependent on what follows it. You
    should consult compiler documentation as it is mostly
    implementation-defined. It is a way to tell compiler to do things which are
    not governed by specification.</d:para>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>__DATE__</d:primary>
    </d:indexterm>
    <d:indexterm>
      <d:primary>__FILE__</d:primary>
    </d:indexterm>
    <d:indexterm>
      <d:primary>__LINE__</d:primary>
    </d:indexterm>    
    <d:indexterm>
      <d:primary>__TIME__</d:primary>
    </d:indexterm>
    <d:title>Miscellaneous</d:title>
    <d:para>Usage of <d:code>__LINE__, __FILE__, __DATE__</d:code> and
    <d:code>__TIME__</d:code> is simple and shown in following
    example:</d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>

int main()
{
  printf("%s:%d:%s:%s", __FILE__, __LINE__, __DATE__, __TIME__);

  return 0;
}</d:programlisting>
and the output is:
<d:screen>test.c:5:Jun 24 2012:11:24:57</d:screen>
<d:para>This concluded our discussion on macros. Rest of the book will describe
the standard library.</d:para>
  </d:sect2>
</d:sect1>
</d:chapter>
