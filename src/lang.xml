<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
    <?dbhtml filename="lang/index.html" ?>
    <d:title>Language</d:title>
    <d:para>This is going to be meat of the book. This chapter is mapped with chapter 6 of
      specification. This will almost cover entire language. If you are already proficient in any
      programming language you must read it. However for it might be too involving without much
      introduction to language. I would recommend to skip and come back later. I could have put this
      later but then the flow of specification would have been broken.</d:para>
    <d:sect1>
      <d:title>Notation</d:title>
      <d:para>In the syntax notation used in this clause, syntactic categories (nonterminals) are
        indicated by italic type, and literal words and character set members (terminals) by
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">bold</emphasis> type. A colon
        (:) following a nonterminal introduces its definition. Alternative definitions are listed on
        separate lines, except when prefaced by the words “one of”. An optional symbol is indicated
        by the subscript “opt”, so that<d:screen><d:inlineequation>
        <mml:math
              xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>e</mml:mi>
              <mml:mi>x</mml:mi>
              <mml:mi>p</mml:mi>
              <mml:mi>r</mml:mi>
              <mml:mi>e</mml:mi>
              <mml:mi>s</mml:mi>
              <mml:mi>s</mml:mi>
              <mml:mi>i</mml:mi>
              <mml:mi>o</mml:mi>
              <mml:msub>
                <mml:mi>n</mml:mi>
                <mml:mrow class="MJX-TeXAtom-ORD">
                  <mml:mi>o</mml:mi>
                  <mml:mi>p</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:msub>
            </mml:math></d:inlineequation></d:screen></d:para>
      <d:para>indicates an optional expression enclosed in braces.</d:para>
      <d:para>When syntactic categories are referred to in the main text, they are not italicized
        and words are separated by spaces instead of hyphens.</d:para>
      <d:para>A summary of the language syntax is given in annex A.</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Conceptes</title>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Scope of Identifiers</title>
        <d:para>An identifier can denote an object; a function; a tag or a member of a structure,
          union, or enumeration; a typedef name; a label name; a macro name; or a macro parameter.
          The same identifier can denote different entities at different points in the program. A
          member of an enumeration is called an <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">enumeration constant</emphasis>. Macro names and macro parameters are not
          considered further here, because prior to the semantic phase of program translation any
          occurrences of macro names in the source file are replaced by the preprocessing token
          sequences that constitute their macro definitions.</d:para>
        <d:para>The interesting part is “The same identifier can denote different entities at
          different points in the program.”. This can happen if the identifer is in different
          scopes.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  int f=0;
}

int main()
{
  f();

  return 0;
}</d:programlisting>
        <d:para>For each different entity that an identifier designates, the identifier is visible
          (i.e., can be used) only within a region of program text called its scope. Different
          entities designated by the same identifier either have different scopes, or are in
          different name spaces. There are four kinds of scopes: function, file, block, and function
          prototype. (A function prototype is a declaration of a function that declares the types of
          its parameters.)</d:para>
        <d:para>For example; consider following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int i = 25;

void f(int );

void f(int i)
{
  printf("%d\n",i); //uses file scope

  i = 24;

  printf("%d\n",i); //uses function scope

  {
    i = 27;

    printf("%d\n",i); //uses block scope
  }
}

int main()
{
  f(i);

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>25
24
27</d:screen>
        <d:para>A label name is the only kind of identifier that has function scope. It can be used
          (in a goto statement) anywhere in the function in which it appears, and is declared
          implicitly by its syntactic appearance (followed by a : and a statement).</d:para>
        <d:para>For example, consider following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  int i=1;

  ONE:  if(i==2)
          goto TWO;
        else {
          i=2;
          goto ONE;
        }
  TWO: ;
  //TWO: goto MAIN; //will cause error
}

int main()
{
  f();
  //goto MAIN; //will cause error
  //MAIN: ; //will cause error

  return 0;
}</d:programlisting>
        <d:para>Every other identifier has scope determined by the placement of its declaration (in
          a declarator or type specifier). If the declarator or type specifier that declares the
          identifier appears outside of any block or list of parameters, the identifier has
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">file scope</emphasis>,
          which terminates at the end of the translation unit. If the declarator or type specifier
          that declares the identifier appears inside a block or within the list of parameter
          declarations in a function definition, the identifier has <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">block scope</emphasis>, which
          terminates at the end of the associated block. If the declarator or type specifier that
          declares the identifier appears within the list of parameter declarations in a function
          prototype (not part of a function definition), the identifier has function <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">prototype scope</emphasis>, which
          terminates at the end of the function declarator. If an identifier designates two
          different entities in the same name space, the scopes might overlap. If so, the scope of
          one entity (the <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">inner
            scope</emphasis>) will be a strict subset of the scope of the other entity (the
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">outer scope</emphasis>).
          Within the inner scope, the identifier designates the entity declared in the inner scope;
          the entity declared in the outer scope is <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">hidden</emphasis> (and not visible) within the inner scope. For example,
          consider the following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f(int j);

void f(int i)
{
  //identifier j not available in this function
  {
    int i=5;
    printf("%d\n",i);
  }
  //printf("%d", i); not available outside inner scope will cause error
}

int main()
{
  f(7);

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>5</d:screen>
        <d:para>Unless explicitly stated otherwise, where International Standard uses the term
          “identifier” to refer to some entity (as opposed to the syntactic construct), it refers to
          the entity in the relevant name space whose declaration is visible at the point the
          identifier occurs.</d:para>
        <d:para>Two identifiers have the same scope if and only if their scopes terminate at the
          same point.</d:para>
        <d:para>Structure, union, and enumeration tags have scope that begins just after the
          appearance of the tag in a type specifier that declares the tag. Each enumeration constant
          has scope that begins just after the appearance of its defining enumerator in an
          enumerator list. Any other identifier has scope that begins just after the completion of
          its declarator.</d:para>
        <d:para>For example, consider the following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

typedef struct STRUCT {
  struct STRUCT *s1; //just a pointer so can be delared
  struct STRUCT s2;  //object therefore incomplete type error
}S;

int main()
{
  return 0;
}</d:programlisting>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

typedef struct {
  int i;
}S; //type S is has file scope

int main()
{
  S s; //s has function scope

  return 0;
}</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> declarations (Declarations), function calls (Function calls),
          function definitions (Function definitions), identifiers (Identifiers), name spaces of
          identifiers (Name Spaces of the Identifiers), macro replacement (Macro Replacement),
          source file inclusion (Source File Inclusion), statements (Statements and
          blocks).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Linkage of identifiers</title>
        <d:para>An identifier declared in different scopes or in the same scope more than once can
          be made to refer to the same object or function by a process called linkage.<d:footnote>
            <d:para>There is no linkage between different identifiers.</d:para>
          </d:footnote>There are three kinds of linkage: external, internal, and none.</d:para>
        <d:para>In the set of translation units and libraries that constitutes an entire program,
          each declaration of a particular identifier with <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">external linkage</emphasis> denotes
          the same object or function. Within one translation unit, each declaration of an
          identifier with internal linkage denotes the same object or function. Each declaration of
          an identifier with no linkage denotes a unique entity.</d:para>
        <d:para>For example, consider the following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int i; //external scope

void f()
{
  // int i=0; same problem
  int j=0; //can declare j as j has internal scope
}

int main()
{
  // int i=0; will give redeclaration error
  int j;

  f();

  return 0;
}</d:programlisting>
        <d:para>If the declaration of a file scope identifier for an object or a function contains
          the storage-class specifier static, the identifier has <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">internal linkage</emphasis>.<d:footnote>
            <d:para>A function declaration can contain the storage-class specifier static only if it
              is at file scope; see Storage-class specifiers.</d:para>
          </d:footnote></d:para>
        <d:para>For example, consider the following program:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

static int i; //internal scope not visible outside file

void f()
{
  // int i=0; same problem
  int j=0; //can declare j as j has internal scope
}

int main()
{
  // int i=0; will give redeclaration error
  int j;

  f();

  return 0;
}</d:programlisting>
        <d:para>For an identifier declared with the storage-class specifier <d:code>extern</d:code>
          in a scope in which a prior declaration of that identifier is visible,<d:footnote>
            <d:para>As specified in Scope of Identifiers, the later declaration might hide the prior
              declaration.</d:para>
          </d:footnote>if the prior declaration specifies internal or external linkage, the linkage
          of the identifier at the later declaration is the same as the linkage specified at the
          prior declaration. If no prior declaration is visible, or if the prior declaration
          specifies no linkage, then the identifier has external linkage.</d:para>
        <d:para>For example, consider the following programs:</d:para>
        <d:programlisting role="CLexer">//test.c
#include &lt;stdio.h>

int i; //external scope not visible outside file

int main()
{
  printf("%d\n", i);
  f();

  return 0;
}</d:programlisting>
        <d:programlisting role="CLexer">//test1.c
#include &lt;stdio.h>

extern int i;

void f()
{
  printf("%d\n", i);
}</d:programlisting>
        <d:para>compile them like <d:code>gcc test.c test1.c -o out</d:code>.</d:para>
        <d:para>The output is:<d:screen>0
0</d:screen></d:para>
        <d:para>If the declaration of an identifier for a function has no storage-class specifier,
          its linkage is determined exactly as if it were declared with the storage-class specifier
            <d:code>extern</d:code>. If the declaration of an identifier for an object has file
          scope and no storage-class specifier, its linkage is external.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int i;   //external linkage can be called from other files
void f() //external linkage can be called from other files
{
  //do something here
}

int main()
{
  f();

  return 0;
}</d:programlisting>
        <d:para>The following identifiers have no linkage: an identifier declared to be anything
          other than an object or a function; an identifier declared to be a function parameter; a
          block scope identifier for an object declared without the storage-class specifier
          extern.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f(int i) //i has no linkage
{
}

int main()
{
  {
    int i;//no linkage
    f(i);
  }
  return 0;
}</d:programlisting>
        <d:para>If, within a translation unit, the same identifier appears with both internal and
          external linkage, the behavior is undefined.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> declarations (Declarations), expressions (Expressions), external
          definitions (External definitions), statements (Statements and blocks).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Name Spaces of the Identifiers</title>
        <d:para>If more than one declaration of a particular identifier is visible at any point in a
          translation unit, the syntactic context disambiguates uses that refer to different
          entities. Thus, there are separate <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">name spaces</emphasis> for various categories of identifiers, as
          follows:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><emphasis role="italic">label
                names</emphasis> (disambiguated by the syntax of the label declaration and
              use);</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">the tags of structures, unions, and
              enumerations (disambiguated by following any<footnote>
                <para>There is only one name space for tags even though three are possible.</para>
              </footnote>of the keywords <code>struct, union</code> or <code>enum</code>);</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">all other identifiers, called <code>ordinary
                identifiers</code> (declared in ordinary declarators or as enumeration
              constants).</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>For example, consider the following</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

struct S{
  int i;
};

union U {
  int i;
};

int main()
{
  int i = 0;
  int END = 0;
  int S = 0;
  int U = 0;
  struct S s;
  union U u;

  s.i = 7;
  u.i = 9;

  goto END;
  END: ;

  return 0;
}</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> enumeration specifiers (Enumeration specifiers), labeled
          statements (Labeled statements), structure and union specifiers (Structure and union
          specifiers), structure and union members (Structure and union members), tags (Tags), the
          goto statement (The goto statement).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Storage duration of objects</title>
        <d:para>An object has a <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >storage duration</emphasis> that determines its lifetime. There are three storage
          durations: static, automatic, and allocated. Allocated storage is described in <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">Memory management
            functions</emphasis>.</d:para>
        <d:para>The <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >lifetime</emphasis> of an object is the portion of program execution during which
          storage is guaranteed to be reserved for it. An object exists, has a constant address,<d:footnote>
            <d:para>The term “constant address” means that two pointers to the object constructed at
              possibly different times will compare equal. The address may be different during two
              different executions of the same program.</d:para>
          </d:footnote> and retains its last-stored value throughout its lifetime.<d:footnote>
            <d:para>In the case of a volatile object, the last store need not be explicit in the
              program.</d:para>
          </d:footnote> If an object is referred to outside of its lifetime, the behavior is
          undefined. The value of a pointer becomes indeterminate when the object it points to
          reaches the end of its lifetime.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  int *p;
  {
    int i=4;

    p=&amp;i;

    printf("%d %d\n", i, *p);
  }

  //printf("%d\n", i) //will cause error
  printf("%d\n", *p); //dangerous because i is dead

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>4 4
4</d:screen>
        <d:para>Note that even though 4 has been printed for <d:code>*p</d:code> that is because
          stack has not been touched. Make some function calls between brace and printf and most
          probably 4 will be overwritten.</d:para>
        <d:para>An object whose identifier is declared with external or internal linkage, or with
          the storage-class specifier <d:code>static</d:code> has <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">static storage duration</emphasis>.
          Its lifetime is the entire execution of the program and its stored value is initialized
          only once, prior to program startup.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  static int i=0;

  printf("%d\n", i++);
}

int main()
{
  f();
  f();
  f();

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>0
1
2</d:screen>
        <d:para>An object whose identifier is declared with no linkage and without the storage-class
          specifier <d:code>static</d:code> has <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">automatic storage duration</emphasis>.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  {
    int i=0;

    printf("%d\n", i++);
  }
}

int main()
{
  f();
  f();
  f();

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>0
0
0</d:screen>
        <d:para>For such an object that does not have a variable length array type, its lifetime
          extends from entry into the block with which it is associated until execution of that
          block ends in any way. (Entering an enclosed block or calling a function suspends, but
          does not end, execution of the current block.) If the block is entered recursively, a new
          instance of the object is created each time. The initial value of the object is
          indeterminate. If an initialization is specified for the object, it is performed each time
          the declaration is reached in the execution of the block; otherwise, the value becomes
          indeterminate each time the declaration is reached.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  int i=0;
  static int n=0;

  if(n&lt;4)
    printf("%d\n", i++);
  n++;
  f();
}

int main()
{
  f();

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>0
0
0
0</d:screen>
        <d:para>For such an object that does have a variable length array type, its lifetime extends
          from the declaration of the object until execution of the program leaves the scope of the declaration.<d:footnote>
            <d:para>Leaving the innermost block containing the declaration, or jumping to a point in
              that block or an embedded block prior to the declaration, leaves the scope of the
              declaration.</d:para>
          </d:footnote> If the scope is entered recursively, a new instance of the object is created
          each time. The initial value of the object is indeterminate.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> statements (Statements and blocks), function calls (Function
          calls), declarators (Declarators), array declarators (Array declarators), initialization
          (Initialization).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Types</title>
        <d:para>The meaning of a value stored in an object or returned by a function is determined
          by the <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">type</emphasis> of
          the expression used to access it. (An identifier declared to be an object is the simplest
          such expression; the type is specified in the declaration of the identifier.) Types are
          partitioned into <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">object
            types</emphasis> (types that fully describe objects), <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">function types</emphasis> (types
          that describe functions), and <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">incomplete types</emphasis> (types that describe objects but lack
          information needed to determine their sizes).</d:para>
        <d:para>An object declared as type <d:code>_Bool</d:code> is large enough to store the
          values 0 and 1.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int main()
{
  _Bool b=23;

  printf("%d %d\n", b, sizeof(_Bool));

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>1 1</d:screen>
        <d:para>Note that size of 1 byte which means whatever nonzero value we assign will be
          converted to 1 implicitly.</d:para>
        <d:para>An object declared as type char is large enough to store any member of the basic
          execution character set. If a member of the basic execution character set is stored in a
            <d:code>char</d:code> object, its value is guaranteed to be nonnegative. If any other
          character is stored in a char object, the resulting value is implementation-defined but
          shall be within the range of values that can be represented in that type.</d:para>
        <d:para>First let us see how big is <d:code>char</d:code>:</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

int main()
{
  printf("%d\n", sizeof(char));

  return 0;
}</d:programlisting>
        <d:para>and the output is 1. Now let us see what we can store in it.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;conio.h>

int main()
{
  for(register int i=0;  i&lt;256; i++)
    printf("%c\t", i);

  return 0;
}</d:programlisting>
        <d:para>It will show lots of non-printable characters as well. Run it as
            <d:command>./a.out|od -c</d:command> and maximum possible characters will be
          shown.</d:para>
        <d:para>There are five standard <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">signed integer types</emphasis>, designated as <d:code>signed char, short
            int, int, long int</d:code> and <d:code>long long int</d:code>. (These and other types
          may be designated in several additional ways, as described in Type specifiers.) There may
          also be implementation-defined <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">extended signed integer types</emphasis>.<d:footnote>
            <d:para>Implementation-defined keywords shall have the form of an identifier reserved
              for any use as described in 7.1.3.</d:para>
          </d:footnote> The standard and extended signed integer types are collectively called
          signed integer types.<d:footnote>
            <d:para>Therefore, any statement in this Standard about signed integer types also
              applies to the extended signed integer types.</d:para>
          </d:footnote></d:para>
        <d:para>An object declared as type signed char occupies the same amount of storage as a
          “plain” char object. A “plain” int object has the natural size suggested by the
          architecture of the execution environment (large enough to contain any value in the range
            <d:code>INT_MIN</d:code> to <d:code>INT_MAX</d:code> as defined in the header
            <d:code>&lt;limits.h></d:code>).</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;limits.h>

int main()
{
  printf("%d %d", INT_MIN, INT_MAX);

  return 0;
}</d:programlisting>
        <d:para>and the output is:</d:para>
        <d:screen>-2147483648 2147483647</d:screen>
        <d:para>which is much much greater than -127 and 128 possible for our 1 byte
          character.</d:para>
        <d:para>For each of the signed integer types, there is a corresponding (but different)
          unsigned integer type (designated with the keyword <d:code>unsigned</d:code>) that uses
          the same amount of storage (including sign information) and has the same alignment
          requirements. The type <d:code>_Bool</d:code> and the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">unsigned integer types</emphasis>
          that correspond to the standard signed integer types are the standard unsigned integer
          types. The unsigned integer types that correspond to the extended signed integer types are
          the extended unsigned integer types. The standard and extended unsigned integer types are
          collectively called <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">unsigned
            integer types</emphasis>.<d:footnote>
            <d:para>Therefore, any statement in this Standard about unsigned integer types also
              applies to the extended unsigned integer types.</d:para>
          </d:footnote></d:para>
        <d:para>The standard signed integer types and standard unsigned integer types are
          collectively called the <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >standard integer types</emphasis>, the extended signed integer types and extended
          unsigned integer types are collectively called the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">extended integer
          types</emphasis>.</d:para>
        <d:para>For any two integer types with the same signedness and different integer conversion
          rank (see Booleans, Characters and Integers), the range of values of the type with smaller
          integer conversion rank is a subrange of the values of the other type.</d:para>
        <d:para>The range of nonnegative values of a signed integer type is a subrange of the
          corresponding unsigned integer type, and the representation of the same value in each type
          is the same.<d:footnote>
            <d:para>The same representation and alignment requirements are meant to imply
              interchangeability as arguments to functions, return values from functions, and
              members of unions.</d:para>
          </d:footnote> A computation involving unsigned operands can never overflow, because a
          result that cannot be represented by the resulting unsigned integer type is reduced modulo
          the number that is one greater than the largest value that can be represented by the
          resulting type.</d:para>
        <d:para>There are three real <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >floating types</emphasis>, designated as <d:code>float, double</d:code> and
            <d:code>long double</d:code>. The set of values of the type <d:code>float</d:code> is a
          subset of the set of values of the type <d:code>double</d:code>; the set of values of the
          type <d:code>double</d:code> is a subset of the set of values of the type <d:code>long
            double</d:code>.</d:para>
        <d:para>There are three <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >complex types</emphasis>, designated as <d:code>float _Complex, double
            _Complex,</d:code> and <d:code>long double _Complex</d:code>. The real floating and
          complex types are collectively called the <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">floating types</emphasis>.</d:para>
        <d:para>For each floating type there is a <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">corresponding real type</emphasis>, which is always a real floating type.
          For real floating types, it is the same type. For complex types, it is the type given by
          deleting the keyword <d:code>_Complex</d:code> from the type name.</d:para>
        <d:para>Each complex type has the same representation and alignment requirements as an array
          type containing exactly two elements of the corresponding real type; the first element is
          equal to the real part, and the second element to the imaginary part, of the complex
          number.</d:para>
        <d:para>The type <d:code>char</d:code>, the signed and unsigned integer types, and the
          floating types are collectively called the <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">basic types</emphasis>. Even if the implementation defines two or more
          basic types to have the same representation, they are nevertheless different types.<d:footnote>
            <d:para>An implementation may define new keywords that provide alternative ways to
              designate a basic (or any other) type; this does not violate the requirement that all
              basic types be different. Implementation-defined keywords shall have the form of an
              identifier reserved for any use as described in 7.1.3.</d:para>
          </d:footnote></d:para>
        <d:para>The three types <d:code>char, signed char</d:code> and <d:code>unsigned
            char</d:code> are collectively called the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">character types</emphasis>. The
          implementation shall define <d:code>char</d:code> to have the same range, representation,
          and behavior as either <d:code>signed char</d:code> or <d:code>unsigned char</d:code>.<d:footnote>
            <d:para><d:code>CHAR_MIN</d:code>, defined in <d:code>&lt;limits.h></d:code>, will have
              one of the values 0 or <d:code>SCHAR_MIN</d:code>, and this can be used to distinguish
              the two options. Irrespective of the choice made, char is a separate type from the
              other two and is not compatible with either.</d:para>
          </d:footnote></d:para>
        <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >enumeration</emphasis> comprises a set of named integer constant values. Each distinct
          enumeration constitutes a different <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">enumerated type</emphasis>.</d:para>
        <d:para>The type <d:code>char</d:code>, the signed and unsigned integer types, and the
          enumerated types are collectively called <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">integer types</emphasis>. The integer and real floating types are
          collectively called <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">real
            types</emphasis>.</d:para>
        <d:para>Integer and floating types are collectively called <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">arithmetic types</emphasis>. Each
          arithmetic type belongs to one <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">type domain</emphasis>: the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">real type domain</emphasis>
          comprises the real types, the <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">complex type domain</emphasis> comprises the complex types.</d:para>
        <d:para>The <d:code>void</d:code> type comprises an empty set of values; it is an incomplete
          type that cannot be completed.</d:para>
        <d:para>Any number of <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">derived
            types</emphasis> can be constructed from the object, function, and incomplete types, as
          follows:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">An <emphasis role="italic">array
                type</emphasis> describes a contiguously allocated nonempty set of objects with a
              particular member object type, called the <emphasis role="italic">element
                type</emphasis>.<footnote>
                <para>Since object types do not include incomplete types, an array of incomplete
                  type cannot be constructed.</para>
              </footnote>Array types are characterized by their element type and by the number of
              elements in the array. An array type is said to be derived from its element type, and
              if its element type is <emphasis role="italic">T</emphasis>, the array type is
              sometimes called “array of <emphasis role="italic">T</emphasis>”. The construction of
              an array type from an element type is called “array type derivation”.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A <emphasis role="italic">structure
                type</emphasis> describes a sequentially allocated nonempty set of member objects
              (and, in certain circumstances, an incomplete array), each of which has an optionally
              specified name and possibly distinct type.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A <emphasis role="italic">union
                type</emphasis> describes an overlapping nonempty set of member objects, each of
              which has an optionally specified name and possibly distinct type.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A <emphasis role="italic">function
                type</emphasis> describes a function with specified return type. A function type is
              characterized by its return type and the number and types of its parameters. A
              function type is said to be derived from its return type, and if its return type is
                <emphasis role="italic">T</emphasis>, the function type is sometimes called
              “function returning <emphasis role="italic">T</emphasis>”. The construction of a
              function type from a return type is called “function type derivation”.</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">A pointer type may be derived from a
              function type, an object type, or an incomplete type, called the referenced type. A
              pointer type describes an object whose value provides a reference to an entity of the
              referenced type. A pointer type derived from the referenced type <emphasis
                role="italic">T</emphasis> is sometimes called “pointer to <emphasis role="italic"
                >T</emphasis>”. The construction of a pointer type from a referenced type is called
              “pointer type derivation”.</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>These methods of constructing derived types can be applied recursively. What this
          mean is you can have structures of structrues of structures and so on. Similarly, you can
          have array of array of array and so on. And you can have array of array of array of such
          structures of structures of structures ... .</d:para>
        <d:para>Arithmetic types and pointer types are collectively called <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">scalar types</emphasis>. Array and
          structure types are collectively called <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">aggregate types</emphasis>.<d:footnote>
            <d:para>Note that aggregate type does not include union type because an object with
              union type can only contain one member at a time.</d:para>
          </d:footnote></d:para>
        <d:para>An array type of unknown size is an incomplete type. It is completed, for an
          identifier of that type, by specifying the size in a later declaration (with internal or
          external linkage). A structure or union type of unknown content (as described in Tags) is
          an incomplete type. It is completed, for all declarations of that type, by declaring the
          same structure or union tag with its defining content later in the same scope.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

S s[10]; //incomplete type at this moment

typedef struct {
  int i;
}S; //type completed here

int main()
{
  return 0;
}</d:programlisting>
        <d:para>Array, function, and pointer types are collectively called <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">derived declarator types</emphasis>.
          A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">declarator type
            derivation</emphasis> from a type <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">T</emphasis> is the construction of a derived declarator type from
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">T</emphasis> by the
          application of an array-type, a function-type, or a pointer-type derivation to <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">T</emphasis>.</d:para>
        <d:programlisting role="CLexer">#include &lt;stdio.h>

S s[10];

S f()
{
  S s1;

  return s1;
}

S (*g)()
{
  S s2;

  return s2;
}

typedef struct {
  int i;
}S;

int main()
{
  return 0;
}</d:programlisting>
        <d:para>A type is characterized by its <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">type category</emphasis>, which is either the outermost derivation of a
          derived type (as noted above in the construction of derived type), or the type itself if
          the type consists of no derived types.</d:para>
        <d:para>Any type so far mentioned is an unqualified type. Each unqualified type has several
          qualified versions of its type,<d:footnote>
            <d:para>See Type qualifiers regarding qualified array and function types.</d:para>
          </d:footnote> corresponding to the combinations of one, two, or all three of the
            <d:code>const, volatile</d:code> and <d:code>restrict</d:code> qualifiers. The qualified
          or unqualified versions of a type are distinct types that belong to the same type category
          and have the same representation and alignment requirements.<d:footnote xml:id="a">
            <d:para>The same representation and alignment requirements are meant to imply
              interchangeability as arguments to functions, return values from functions, and
              members of unions.</d:para>
          </d:footnote> A derived type is not qualified by the qualifiers (if any) of the type from
          which it is derived.</d:para>
        <d:para>A pointer to void shall have the same representation and alignment requirements as a
          pointer to a character type.<d:footnoteref linkend="a"/> Similarly, pointers to qualified
          or unqualified versions of compatible types shall have the same representation and
          alignment requirements. All pointers to structure types shall have the same representation
          and alignment requirements as each other. All pointers to union types shall have the same
          representation and alignment requirements as each other. Pointers to other types need not
          have the same representation or alignment requirements.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Representation of Types</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">General</title>
          <d:para>The representations of all types are unspecified except as stated in this
            subclause.</d:para>
          <d:para>Except for bit-fields, objects are composed of contiguous sequences of one or more
            bytes, the number, order, and encoding of which are either explicitly specified or
            implementation-defined.</d:para>
          <d:para>Values stored in unsigned bit-fields and objects of type <d:code>unsigned
              char</d:code> shall be represented using a pure binary notation.<d:footnote>
              <d:para>A positional representation for integers that uses the binary digits 0 and 1,
                in which the values represented by successive bits are additive, begin with 1, and
                are multiplied by successive integral powers of 2, except perhaps the bit with the
                highest position. (Adapted from the American National Dictionary for Information
                Processing Systems.) A byte contains <d:code>CHAR_BIT</d:code> bits, and the values
                of type unsigned char range from 0 to <d:inlineequation>
                  <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mml:msup>
                      <mml:mn>2</mml:mn>
                      <mml:mrow class="MJX-TeXAtom-ORD">
                        <mml:mi>C</mml:mi>
                        <mml:mi>H</mml:mi>
                        <mml:mi>A</mml:mi>
                        <mml:mi>R</mml:mi>
                        <mml:mi mathvariant="normal">&#x005F;<!-- _ --></mml:mi>
                        <mml:mi>B</mml:mi>
                        <mml:mi>I</mml:mi>
                        <mml:mi>T</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:math>
                </d:inlineequation>.</d:para>
            </d:footnote></d:para>
          <d:para>Values stored in non-bit-field objects of any other object type consist of
              <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">n x</emphasis>
            <d:code>CHAR_BIT</d:code> bits, where n is the size of an object of that type, in bytes.
            The value may be copied into an object of type unsigned char <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">[n]</emphasis> (e.g., by memcpy);
            the resulting set of bytes is called the object representation of the value. Values
            stored in bit-fields consist of <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">m</emphasis> bits, where m is the size specified for the bit-field. The
            object representation is the set of <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">m</emphasis> bits the bit-field comprises in the addressable storage
            unit holding it. Two values (other than NaNs) with the same object representation
            compare equal, but values that compare equal may have different object
            representations.</d:para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>

typedef struct {
  char   c:7;
  int    i:3;
}S;

int main()
{
  S s;

  s.c = '0';
  s.i = 5;

  printf("%c %d\n", s.c, s.i);

  return 0;
}</d:programlisting>
          <d:para>and the output is:</d:para>
          <d:screen>0 -3</d:screen>
          <d:para>Consider the following program:</d:para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>

typedef struct {
  int    i:1;
}S;

int main()
{
  S s;

  s.i = 1;

  printf("%d\n", s.i);

  return 0;
}</d:programlisting>
          <d:para>what do you think the output will be? 0 to 1 that is what my gut feeling tells me
            but I am wrong. With <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >N</emphasis> bits the range of integer is <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:mo>&#x2212;<!-- − --></mml:mo>
                <mml:msup>
                  <mml:mn>2</mml:mn>
                  <mml:mi>N</mml:mi>
                </mml:msup>
                <mml:mo>&#x2212;<!-- − --></mml:mo>
                <mml:mn>1</mml:mn>
              </mml:math>
            </d:inlineequation> to <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:msup>
                  <mml:mn>2</mml:mn>
                  <mml:mrow class="MJX-TeXAtom-ORD">
                    <mml:mi>N</mml:mi>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>&#x2212;<!-- − --></mml:mo>
                <mml:mo>&#x2212;<!-- − --></mml:mo>
                <mml:mn>1</mml:mn>
              </mml:math>
            </d:inlineequation>. This evaluates to -1 to 0. So any even no. stored in 1 bits field
            is 0 and any odd no. is -1. Useful for finding odd and even numbers eh?</d:para>
          <d:para>The output is:<d:screen>-1</d:screen></d:para>
          <d:para>Certain object representations need not represent a value of the object type. If
            the stored value of an object has such a representation and is read by an lvalue
            expression that does not have character type, the behavior is undefined. If such a
            representation is produced by a side effect that modifies all or any part of the object
            by an lvalue expression that does not have character type, the behavior is undefined.<d:footnote>
              <d:para>Thus, an automatic variable can be initialized to a trap representation
                without causing undefined behavior, but the value of the variable cannot be used
                until a proper value is stored in it.</d:para>
            </d:footnote> Such a representation is called a <d:emphasis role="italic">trap
              representation</d:emphasis>.</d:para>
          <d:para>There are two places where trap representation has been talked about in the
            specification. First is parity bits on numeric types which are visible to software. This
            is given in footnote 44 of n1124.pdf at page no. 38. Second is negative zeros in
            non-twos-complement architecture, given on page 39.</d:para>
          <d:para>When a value is stored in an object of structure or union type, including in a
            member object, the bytes of the object representation that correspond to any padding
            bytes take unspecified values.<d:footnote>
              <d:para>Thus, for example, structure assignment need not copy any padding
                bits.</d:para>
            </d:footnote> The value of a structure or union object is never a trap representation,
            even though the value of a member of the structure or union object may be a trap
            representation.</d:para>
          <d:para>When a value is stored in a member of an object of union type, the bytes of the
            object representation that do not correspond to that member but do correspond to other
            members take unspecified values. What this means is that say you have two members where
            one is of <d:emphasis role="italic">m</d:emphasis> bytes and another of <d:emphasis
              role="italic">n</d:emphasis> bytes and <d:emphasis role="italic">m>n</d:emphasis>.
            Then if you assign value to one having <d:emphasis role="italic">n</d:emphasis> bytes
            then <d:emphasis role="italic">m - n</d:emphasis> bytes will have unspecified
            value.</d:para>
          <d:para>Where an operator is applied to a value that has more than one object
            representation, which object representation is used shall not affect the value of the result.<d:footnote>
              <d:para>It is possible for objects <d:code>x</d:code> and <d:code>y</d:code> with the
                same effective type <d:emphasis role="italic">T</d:emphasis> to have the same value
                when they are accessed as objects of type <d:emphasis role="italic">T</d:emphasis>,
                but to have different values in other contexts. In particular, if
                  <d:code>==</d:code> is defined for type <d:emphasis role="italic">T</d:emphasis>,
                then <d:code>x == y</d:code> does not imply that <d:code>memcmp(&amp;x, &amp;y,
                  sizeof (T)) == 0</d:code>. Furthermore, <d:code>x == y</d:code> does not
                necessarily imply that <d:code>x</d:code> and <d:code>y</d:code> have the same
                value; other operations on values of type <d:emphasis role="italic">T</d:emphasis>
                may distinguish between them.</d:para>
            </d:footnote> Where a value is stored in an object using a type that has more than one
            object representation for that value, it is unspecified which representation is used,
            but a trap representation shall not be generated.</d:para>
          <d:para>For example, char is integral type. Therefore all operations of integers can be
            done on characters.</d:para>
          <d:para><d:emphasis role="bold">Forward references:</d:emphasis> declarations
            (Declarations), expressions (Expressions), lvalues, arrays, and function designators
            (Other Operands).</d:para>
        </d:sect3>
        <d:sect3>
          <d:title>Integer Types</d:title>
          <d:para>For unsigned integer types other than unsigned char, the bits of the object
            representation shall be divided into two groups: value bits and padding bits (there need
            not be any of the latter). If there are <d:emphasis role="italic">N</d:emphasis> value
            bits, each bit shall represent a different power of 2 between 1 and <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:msup>
                  <mml:mn>2</mml:mn>
                  <mml:mrow class="MJX-TeXAtom-ORD">
                    <mml:mi>N</mml:mi>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
              </mml:math>
            </d:inlineequation>, so that objects of that type shall be capable of representing
            values from 0 to <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:msup>
                  <mml:mn>2</mml:mn>
                  <mml:mrow class="MJX-TeXAtom-ORD">
                    <mml:mi>N</mml:mi>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
              </mml:math>
            </d:inlineequation> using a pure binary representation; this shall be known as the value
            representation. The values of any padding bits are unspecified. <d:footnote>
              <d:para>Some combinations of padding bits might generate trap representations, for
                example, if one padding bit is a parity bit. Regardless, no arithmetic operation on
                valid values can generate a trap representation other than as part of an exceptional
                condition such as an overflow, and this cannot occur with unsigned types. All other
                combinations of padding bits are alternative object representations of the value
                specified by the value bits.</d:para>
            </d:footnote></d:para>
          <d:para>For signed integer types, the bits of the object representation shall be divided
            into three groups: value bits, padding bits, and the sign bit. There need not be any
            padding bits; there shall be exactly one sign bit. Each bit that is a value bit shall
            have the same value as the same bit in the object representation of the corresponding
            unsigned type (if there are <d:emphasis role="italic">M</d:emphasis> value bits in the
            signed type and <d:emphasis role="italic">N</d:emphasis> in the unsigned type, then
              <d:emphasis role="italic">M &lt;= N</d:emphasis>). If the sign bit is zero, it shall
            not affect the resulting value. If the sign bit is one, the value shall be modified in
            one of the following ways:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <d:para>the corresponding value with sign bit 0 is negated <d:emphasis role="italic"
                  >(sign and magnitude);</d:emphasis></d:para>
            </d:listitem>
            <d:listitem>
              <d:para>the sign bit has the value <d:inlineequation>
                  <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mml:msup>
                      <mml:mn>2</mml:mn>
                      <mml:mi>N</mml:mi>
                    </mml:msup>
                  </mml:math>
                </d:inlineequation>
                <d:emphasis role="italic">(two's complement);</d:emphasis></d:para>
            </d:listitem>
            <d:listitem>
              <d:para>the sign bit has the value <d:inlineequation>
                  <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mml:msup>
                      <mml:mn>2</mml:mn>
                      <mml:mi>N</mml:mi>
                    </mml:msup>
                    <mml:mo>&#x2212;<!-- − --></mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:math>
                </d:inlineequation>
                <d:emphasis role="italic">(ones' complement).</d:emphasis></d:para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>Which of these applies is implementation-defined, as is whether the value with
            sign bit 1 and all value bits zero (for the first two), or with sign bit and all value
            bits 1 (for one’s complement), is a trap representation or a normal value. In the case
            of sign and magnitude and one's complement, if this representation is a normal value it
            is called a negative zero.</d:para>
          <d:para>If the implementation supports negative zeros, they shall be generated only
            by:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <d:para>the &amp;, |, ^, ~, &lt;&lt;, and >> operators with arguments that produce
                such a value;</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>the +, -, *, /, and % operators where one argument is a negative zero and the
                result is zero;</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>compound assignment operators based on the above cases.</d:para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>It is unspecified whether these cases actually generate a negative zero or a
            normal zero, and whether a negative zero becomes a normal zero when stored in an
            object.</d:para>
          <d:para>If the implementation does not support negative zeros, the behavior of the &amp;,
            |, ^, ~, &lt;&lt;, and >> operators with arguments that would produce such a value is
            undefined.</d:para>
          <d:para>The values of any padding bits are unspecified.<d:footnote>
              <d:para>Some combinations of padding bits might generate trap representations, for
                example, if one padding bit is a parity bit. Regardless, no arithmetic operation on
                valid values can generate a trap representation other than as part of an exceptional
                condition such as an overflow. All other combinations of padding bits are
                alternative object representations of the value specified by the value
                bits.</d:para>
            </d:footnote> A valid (non-trap) object representation of a signed integer type where
            the sign bit is zero is a valid object representation of the corresponding unsigned
            type, and shall represent the same value. For any integer type, the object
            representation where all the bits are zero shall be a representation of the value zero
            in that type.</d:para>
          <d:para>The <d:emphasis role="italic">precision</d:emphasis> of an integer type is the
            number of bits it uses to represent values, excluding any sign and padding bits. The
              <d:emphasis role="italic">width</d:emphasis> of an integer type is the same but
            including any sign bit; thus for unsigned integer types the two values are the same,
            while for signed integer types the width is one greater than the precision.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <d:title>Compatible and Composite Types</d:title>
        <d:para>Two types have compatible type if their types are the same. Additional rules for
          determining whether two types are compatible are described in Type specifiers for type
          specifiers, in Type qualifiers for type qualifiers, and in Declarators for declarators.<d:footnote>
            <d:para>Two types need not be identical to be compatible.</d:para>
          </d:footnote> Moreover, two structure, union, or enumerated types declared in separate
          translation units are compatible if their tags and members satisfy the following
          requirements: If one is declared with a tag, the other shall be declared with the same
          tag. If both are complete types, then the following additional requirements apply: there
          shall be a one-to-one correspondence between their members such that each pair of
          corresponding members are declared with compatible types, and such that if one member of a
          corresponding pair is declared with a name, the other member is declared with the same
          name. For two structures, corresponding members shall be declared in the same order. For
          two structures or unions, corresponding bit-fields shall have the same widths. For two
          enumerations, corresponding members shall have the same values.</d:para>
        <d:para>All declarations that refer to the same object or function shall have compatible
          type; otherwise, the behavior is undefined.</d:para>
        <d:para>A <d:emphasis role="italic">composite type</d:emphasis> can be constructed from two
          types that are compatible; it is a type that is compatible with both of the two types and
          satisfies the following conditions:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <d:para>If one type is an array of known constant size, the composite type is an array
              of that size; otherwise, if one type is a variable length array, the composite type is
              that type.</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>If only one type is a function type with a parameter type list (a function
              prototype), the composite type is a function prototype with the parameter type
              list.</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>If both types are function types with parameter type lists, the type of each
              parameter in the composite parameter type list is the composite type of the
              corresponding parameters.</d:para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>These rules apply recursively to the types from which the two types are
          derived.</d:para>
        <d:para>For an identifier with internal or external linkage declared in a scope in which a
          prior declaration of that identifier is visible,<d:footnote>
            <d:para>As specified in Scope of Identifiers, the later declaration might hide the prior
              declaration.</d:para>
          </d:footnote> if the prior declaration specifies internal or external linkage, the type of
          the identifier at the later declaration becomes the composite type.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Conversion</d:title>
      <d:para>Several operators convert operand values from one type to another automatically. This
        subclause specifies the result required from such an implicit conversion, as well as those
        that result from a cast operation (an explicit conversion). The list in 4.3.1.8 summarizes
        the conversions performed by most ordinary operators; it is supplemented as required by the
        discussion of each operator in 4.5.</d:para>
      <d:para>Conversion of an operand value to a compatible type causes no change to the value or
        the representation.</d:para>
      <d:para><d:emphasis role="bold">Forward references:</d:emphasis> cast operators (Cast
        operators).</d:para>
      <d:sect2>
        <d:title>Arithmetics Operands</d:title>
        <d:sect3>
          <d:title>Booleans, Characters and Integers</d:title>
          <d:para>Every integer type has an <d:emphasis role="italic">integer conversion
              rank</d:emphasis> defined as follows:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <d:para>No two signed integer types shall have the same rank, even if they have the
                same representation.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of a signed integer type shall be greater than the rank of any signed
                integer type with less precision.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of <d:code>long long int</d:code> shall be greater than the rank of
                  <d:code>long int</d:code>, which shall be greater than the rank of
                  <d:code>int</d:code>, which shall be greater than the rank of <d:code>short
                  int</d:code>, which shall be greater than the rank of <d:code>signed
                char</d:code>.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of any unsigned integer type shall equal the rank of the
                corresponding signed integer type, if any.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of any standard integer type shall be greater than the rank of any
                extended integer type with the same width. The rank of <d:code>char</d:code> shall
                equal the rank of <d:code>signed char</d:code> and <d:code>unsigned
                char</d:code>.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of <d:code>_Bool</d:code> shall be less than the rank of all other
                standard integer types.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of any enumerated type shall equal the rank of the compatible integer
                type (see Enumeration specifiers).</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>The rank of any extended signed integer type relative to another extended
                signed integer type with the same precision is implementation-defined, but still
                subject to the other rules for determining the integer conversion rank.</d:para>
            </d:listitem>
            <d:listitem>
              <d:para>For all integer types <d:code>T1, T2,</d:code> and <d:code>T3</d:code>, if
                  <d:code>T1</d:code> has greater rank than <d:code>T2</d:code> and
                  <d:code>T2</d:code> has greater rank than <d:code>T3</d:code>, then
                  <d:code>T1</d:code> has greater rank than <d:code>T3</d:code>.</d:para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>The following may be used in an expression wherever an int or unsigned int may be
            used:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">An object or expression with an integer
                type whose integer conversion rank is less than or equal to the rank of
                  <code>int</code> and <code>unsigned int</code>.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">A bit-field of type <code>_Bool, int,
                  signed int,</code> or <code>unsigned int</code>.</para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>If an int can represent all values of the original type, the value is converted to
            an int; otherwise, it is converted to an unsigned int. These are called the integer promotions.<d:footnote>
              <d:para>The integer promotions are applied only: as part of the usual arithmetic
                conversions, to certain argument expressions, to the operands of the unary +, -, and
                ~ operators, and to both operands of the shift operators, as specified by their
                respective subclauses.</d:para>
            </d:footnote> All other types are unchanged by the integer promotions.</d:para>
          <d:para>The integer promotions preserve value including sign. As discussed earlier,
            whether a “plain” char is treated as signed is implementation-defined.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> enumeration specifiers (Enumeration specifiers), structure and
            union specifiers (Structure and union specifiers).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Boolean Type</title>
          <d:para>When any scalar value is converted to <d:code>_Bool</d:code>, the result is 0 if
            the value compares equal to 0; otherwise, the result is 1.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Signed and Unsigned Integers</title>
          <d:para>When a value with integer type is converted to another integer type other than
              <d:code>_Bool</d:code>, if the value can be represented by the new type, it is
            unchanged.</d:para>
          <d:para>Otherwise, if the new type is unsigned, the value is converted by repeatedly
            adding or subtracting one more than the maximum value that can be represented in the new
            type until the value is in the range of the new type.<d:footnote>
              <d:para>The rules describe arithmetic on the mathematical value, not the value of a
                given type of expression.</d:para>
            </d:footnote></d:para>
          <d:para>Otherwise, the new type is signed and the value cannot be represented in it;
            either the result is implementation-defined or an implementation-defined signal is
            raised.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Real Floating and Integer</title>
          <d:para>When a finite value of real floating type is converted to an integer type other
            than <d:code>_Bool</d:code>, the fractional part is discarded (i.e., the value is
            truncated toward zero). If the value of the integral part cannot be represented by the
            integer type, the behavior is undefined.<d:footnote>
              <d:para>The remaindering operation performed when a value of integer type is converted
                to unsigned type need not be performed when a value of real floating type is
                converted to unsigned type. Thus, the range of portable real floating values is (-1,
                U <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">type </emphasis>_
                  <d:code>MAX+1</d:code> ).</d:para>
            </d:footnote></d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Real Floating Types</title>
          <d:para>When a <d:code>float</d:code> is promoted to <d:code>double</d:code> or
              <d:code>long double</d:code>, or a <d:code>double</d:code> is promoted to <d:code>long
              double</d:code>, its value is unchanged. When a <d:code>double</d:code> is demoted to
              <d:code>float</d:code>, a l<d:code>ong double</d:code> is demoted to
              <d:code>double</d:code> or <d:code>float</d:code>, or a value being represented in
            greater precision and range than required by its semantic type (see Usual Arithmetic
            Conversions) is explicitly converted to its semantic type, if the value being converted
            can be represented exactly in the new type, it is unchanged. If the value being
            converted is in the range of values that can be represented but cannot be represented
            exactly, the result is either the nearest higher or nearest lower representable value,
            chosen in an implementation-defined manner. If the value being converted is outside the
            range of values that can be represented, the behavior is undefined.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Complex Types</title>
          <d:para>When a value of complex type is converted to another complex type, both the real
            and imaginary parts follow the conversion rules for the corresponding real
            types.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Real and Complex</title>
          <d:para>When a value of real type is converted to a complex type, the real part of the
            complex result value is determined by the rules of conversion to the corresponding real
            type and the imaginary part of the complex result value is a positive zero or an
            unsigned zero. When a value of complex type is converted to a real type, the imaginary
            part of the complex value is discarded and the value of the real part is converted
            according to the conversion rules for the corresponding real type.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Usual Arithmetic Conversion</title>
          <d:para>Many operators that expect operands of arithmetic type cause conversions and yield
            result types in a similar way. The purpose is to determine a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">common real typ</emphasis>e for
            the operands and result. For the specified operands, each operand is converted, without
            change of type domain, to a type whose corresponding real type is the common real type.
            Unless explicitly stated otherwise, the common real type is also the corresponding real
            type of the result, whose type domain is the type domain of the operands if they are the
            same, and complex otherwise. This pattern is called the <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">usual arithmetic
              conversions</emphasis>:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">First, if the corresponding real type of
                either operand is long double, the other operand is converted, without change of
                type domain, to a type whose corresponding real type is <code>long
                double</code>.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Otherwise, if the corresponding real type
                of either operand is double, the other operand is converted, without change of type
                domain, to a type whose corresponding real type is <code>double</code>.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Otherwise, if the corresponding real type
                of either operand is float, the other operand is converted, without change of type
                domain, to a type whose corresponding real type is <code>float</code>.<footnote>
                  <para>For example, addition of a <code>double _Complex</code> and a
                      <code>float</code> entails just the conversion of the <code>float</code>
                    operand to <code>double</code> (and yields a <code>double _Complex</code>
                    result).</para>
                </footnote></para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">Otherwise, the integer promotions are
                performed on both operands. Then the following rules are applied to the promoted
                operands:</para>
              <d:itemizedlist>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">If both operands have the same type,
                    then no further conversion is needed.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">Otherwise, if both operands have
                    signed integer types or both have unsigned integer types, the operand with the
                    type of lesser integer conversion rank is converted to the type of the operand
                    with greater rank.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">Otherwise, if the operand that has
                    unsigned integer type has rank greater or equal to the rank of the type of the
                    other operand, then the operand with signed integer type is converted to the
                    type of the operand with unsigned integer type.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">Otherwise, if the type of the operand
                    with signed integer type can represent all of the values of the type of the
                    operand with unsigned integer type, then the operand with unsigned integer type
                    is converted to the type of the operand with signed integer type.</para>
                </d:listitem>
                <d:listitem>
                  <para xmlns="http://docbook.org/ns/docbook">Otherwise, both operands are converted
                    to the unsigned integer type corresponding to the type of the operand with
                    signed integer type.</para>
                </d:listitem>
              </d:itemizedlist>
            </d:listitem>
          </d:itemizedlist>
          <d:para>The values of floating operands and of the results of floating expressions may be
            represented in greater precision and range than that required by the type; the types are
            not changed thereby.<d:footnote>
              <d:para>The cast and assignment operators are still required to perform their
                specified conversions as described in Real Floating and Integer and Real Floating
                Types.</d:para>
            </d:footnote></d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Other Operands</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Lvalues, Arrays and Function
            Designators</title>
          <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">lvalue</emphasis>
            is an expression with an object type or an incomplete type other than
              <d:code>void</d:code>;<d:footnote>
              <d:para>The name “lvalue” comes originally from the assignment expression <d:inlineequation>
                  <mml:math>
                    <mml:mrow>
                      <mml:mtext>E1 </mml:mtext>
                      <mml:mo>=</mml:mo>
                      <mml:mtext> E2</mml:mtext>
                    </mml:mrow>
                  </mml:math>
                </d:inlineequation>, in which the left operand <d:inlineequation>
                  <mml:math>
                    <mml:mtext>E1</mml:mtext>
                  </mml:math>
                </d:inlineequation> is required to be a (modifiable) lvalue. It is perhaps better
                considered as representing an object “locator value”. What is sometimes called
                “rvalue” is in this International Standard described as the “value of an
                expression”.</d:para>
            </d:footnote> if an lvalue does not designate an object when it is evaluated, the
            behavior is undefined. When an object is said to have a particular type, the type is
            specified by the lvalue used to designate the object. A <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">modifiable lvalue</emphasis> is an
            lvalue that does not have array type, does not have an incomplete type, does not have a
            const-qualified type, and if it is a structure or union, does not have any member
            (including, recursively, any member or element of all contained aggregates or unions)
            with a const-qualified type.</d:para>
          <d:para>Except when it is the operand of the <d:code>sizeof</d:code> operator, the unary
            &amp; operator, the ++ operator, the – operator, or the left operand of the . operator
            or an assignment operator, an lvalue that does not have array type is converted to the
            value stored in the designated object (and is no longer an lvalue). If the lvalue has
            qualified type, the value has the unqualified version of the type of the lvalue;
            otherwise, the value has the type of the lvalue. If the lvalue has an incomplete type
            and does not have array type, the behavior is undefined.</d:para>
          <d:para>Except when it is the operand of the <d:code>sizeof</d:code> operator or the unary
            &amp; operator, or is a string literal used to initialize an array, an expression that
            has type “array of type” is converted to an expression with type “pointer to type” that
            points to the initial element of the array object and is not an lvalue. If the array
            object has register storage class, the behavior is undefined.</d:para>
          <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">function
              designator</emphasis> is an expression that has function type. Except when it is the
            operand of the <d:code>sizeof</d:code> operator<d:footnote>
              <d:para>Because this conversion does not occur, the operand of the sizeof operator
                remains a function designator and violates the constraint in 4.5.3.4.</d:para>
            </d:footnote> or the unary &amp; operator, a function designator with type “function
            returning type” is converted to an expression that has type “pointer to function
            returning type”.</d:para>
          <d:para>For example, consider following:</d:para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>

void f()
{
  printf("Hello\n");
}

int main()
{
  f();
  (*f)();
  (&amp;f)();
  (**f)();
  (***f)();

  return 0;
}</d:programlisting>
          <d:para>and the output is:</d:para>
          <d:screen>Hello
Hello
Hello
Hello
Hello</d:screen>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> address and indirection operators (Address and indirection
            operators), assignment operators (Assignment operators), common definitions
              <d:code>&lt;stddef.h></d:code> (Common definitions <d:code>&lt;stddef.h></d:code>),
            initialization (Initialization), postfix increment and decrement operators (Postfix
            increment and decrement operators), prefix increment and decrement operators (Prefix
            increment and decrement operators), the sizeof operator (The sizeof operator), structure
            and union members (Structure and union members).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">void</title>
          <d:para>The (nonexistent) value of a <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">void expression</emphasis> (an expression that has type void) shall not
            be used in any way, and implicit or explicit conversions (except to
              <d:code>void</d:code>) shall not be applied to such an expression. If an expression of
            any other type is evaluated as a void expression, its value or designator is discarded.
            (A void expression is evaluated for its side effects.)</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Pointers</title>
          <d:para>A pointer to void may be converted to or from a pointer to any incomplete or
            object type. A pointer to any incomplete or object type may be converted to a pointer to
              <d:code>void</d:code> and back again; the result shall compare equal to the original
            pointer.</d:para>
          <d:para>For any qualifier q, a pointer to a non-q-qualified type may be converted to a
            pointer to the q-qualified version of the type; the values stored in the original and
            converted pointers shall compare equal.</d:para>
          <d:para>An integer constant expression with the value 0, or such an expression cast to
            type <d:code>void *</d:code>, is called a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">null pointer constant</emphasis>.<d:footnote>
              <d:para>The macro <d:code>NULL</d:code> is defined in <d:code>&lt;stddef.h></d:code>
                (and other headers) as a null pointer constant; see 7.17.</d:para>
            </d:footnote> If a null pointer constant is converted to a pointer type, the resulting
            pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any
            object or function.</d:para>
          <d:para>Conversion of a null pointer to another pointer type yields a null pointer of that
            type. Any two null pointers shall compare equal.</d:para>
          <d:para>An integer may be converted to any pointer type. Except as previously specified,
            the result is implementation-defined, might not be correctly aligned, might not point to
            an entity of the referenced type, and might be a trap representation.<d:footnote>
              <d:para>The mapping functions for converting a pointer to an integer or an integer to
                a pointer are intended to be consistent with the addressing structure of the
                execution environment.</d:para>
            </d:footnote></d:para>
          <d:para>Any pointer type may be converted to an integer type. Except as previously
            specified, the result is implementation-defined. If the result cannot be represented in
            the integer type, the behavior is undefined. The result need not be in the range of
            values of any integer type.</d:para>
          <d:para>A pointer to an object or incomplete type may be converted to a pointer to a
            different object or incomplete type. If the resulting pointer is not correctly aligned<d:footnote>
              <d:para>In general, the concept “correctly aligned” is transitive: if a pointer to
                type A is correctly aligned for a pointer to type B, which in turn is correctly
                aligned for a pointer to type C, then a pointer to type A is correctly aligned for a
                pointer to type C.</d:para>
            </d:footnote> for the pointed-to type, the behavior is undefined. Otherwise, when
            converted back again, the result shall compare equal to the original pointer. When a
            pointer to an object is converted to a pointer to a character type, the result points to
            the lowest addressed byte of the object. Successive increments of the result, up to the
            size of the object, yield pointers to the remaining bytes of the object.</d:para>
          <d:para>A pointer to a function of one type may be converted to a pointer to a function of
            another type and back again; the result shall compare equal to the original pointer. If
            a converted pointer is used to call a function whose type is not compatible with the
            pointed-to type, the behavior is undefined.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> cast operators (Cast operators), equality operators (Equality
            operators), integer types capable of holding object pointers (Integer types capable of
            holding object pointers), simple assignment (Simple assignment).</d:para>
        </d:sect3>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Lexical Elements</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Constraint</emphasis></d:para>
      <d:para>Each preprocessing token that is converted to a token shall have the lexical form of a
        keyword, an identifier, a constant, a string literal, or a punctuator.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">token</emphasis> is
        the minimal lexical element of the language in translation phases 7 and 8. The categories of
        tokens are: keywords, identifiers, constants, string literals, and punctuators. A
        preprocessing token is the minimal lexical element of the language in translation phases 3
        through 6. The categories of preprocessing tokens are: header names, identifiers,
        preprocessing numbers, character constants, string literals, punctuators, and single
        non-white-space characters that do not lexically match the other preprocessing token categories.<d:footnote>
          <d:para>An additional category, placemarkers, is used internally in translation phase 4
            (see The ## Operator); it cannot occur in source files.</d:para>
        </d:footnote> If a ‘ or a ” character matches the last category, the behavior is undefined.
        Preprocessing tokens can be separated by white space; this consists of comments (described
        later), or white-space characters (space, horizontal tab, new-line, vertical tab, and
        form-feed), or both. As described in Preprocessing Directives, in certain circumstances
        during translation phase 4, white space (or the absence thereof) serves as more than
        preprocessing token separation. White space may appear within a preprocessing token only as
        part of a header name or between the quotation characters in a character constant or string
        literal.</d:para>
      <d:para>If the input stream has been parsed into preprocessing tokens up to a given character,
        the next preprocessing token is the longest sequence of characters that could constitute a
        preprocessing token. There is one exception to this rule: a header name preprocessing token
        is only recognized within a <d:code>#include</d:code> preprocessing directive, and within
        such a directive, a sequence of characters that could be either a header name or a string
        literal is recognized as the former.</d:para>
      <d:para>EXAMPLE 1 The program fragment <d:code>1Ex</d:code> is parsed as a preprocessing
        number token (one that is not a valid floating or integer constant token), even though a
        parse as the pair of preprocessing tokens 1 and <d:code>Ex</d:code> might produce a valid
        expression (for example, if <d:code>Ex</d:code> were a macro defined as +1). Similarly, the
        program fragment <d:code>1E1</d:code> is parsed as a preprocessing number (one that is a
        valid floating constant token), whether or not <d:code>E</d:code> is a macro name.</d:para>
      <d:para>EXAMPLE 2 The program fragment <d:code>x+++++y</d:code> is parsed as <d:code>x ++ ++ +
          y</d:code>, which violates a constraint on increment operators, even though the parse
          <d:code>x ++ + ++ y</d:code> might yield a correct expression.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> character constants (Character constants), comments (Comments),
        expressions (Expressions), floating constants (Floating Constants), header names (Header
        names), macro replacement (Macro Replacement), postfix increment and decrement operators
        (Postfix increment and decrement operators), prefix increment and decrement operators
        (Prefix increment and decrement operators), preprocessing directives (Preprocessing
        Directives), preprocessing numbers (Preprocessing numbers), string literals (String
        literals).</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Keywords</title>
        <d:para>List of keywords are given in Environmental considerations</d:para>
        <d:para>The keywords token (case sensitive) are reserved (in translation phases 7 and 8) for
          use as keywords, and shall not be used otherwise. The keyword <d:code>_Imaginary</d:code>
          is reserved for specifying imaginary types.<d:footnote>
            <d:para>One possible specification for imaginary types appears in annex G.</d:para>
          </d:footnote></d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Identifiers</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">General</title>
          <d:para>The characterset for ideantifiers is given in The C Character Set.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>An identifier is a sequence of nondigit characters (including the underscore _,
            the lowercase and uppercase Latin letters, and other characters) and digits, which
            designates one or more entities as described in Scope of Identifiers. Lowercase and
            uppercase letters are distinct. There is no specific limit on the maximum length of an
            identifier.</d:para>
          <d:para>Each universal character name in an identifier shall designate a character whose
            encoding in ISO/IEC 10646 falls into one of the ranges specified in annex D.<d:footnote>
              <d:para>On systems in which linkers cannot accept extended characters, an encoding of
                the universal character name may be used in forming valid external identifiers. For
                example, some otherwise unused character or sequence of characters may be used to
                encode the \u in a universal character name. Extended characters may produce a long
                external identifier.</d:para>
            </d:footnote> The initial character shall not be a universal character name designating
            a digit. An implementation may allow multibyte characters that are not part of the basic
            source character set to appear in identifiers; which characters and their correspondence
            to universal character names is implementation-defined.</d:para>
          <d:para>When preprocessing tokens are converted to tokens during translation phase 7, if a
            preprocessing token could be converted to either a keyword or an identifier, it is
            converted to a keyword.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Implementation
              Limits</emphasis></d:para>
          <d:para>As discussed in Translation limits, an implementation may limit the number of
            significant initial characters in an identifier; the limit for an <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">external name</emphasis> (an
            identifier that has external linkage) may be more restrictive than that for an <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">internal name</emphasis> (a macro
            name or an identifier that does not have external linkage). The number of significant
            characters in an identifier is implementation-defined.</d:para>
          <d:para>Any identifiers that differ in a significant character are different identifiers.
            If two identifiers differ only in nonsignificant characters, the behavior is
            undefined.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> universal character names (Universal character names), macro
            replacement (Macro Replacement).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Predefined Identifiers</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The identifier “__func__” shall be implicitly declared by the translator as if,
            immediately following the opening brace of each function definition, the
            declaration</d:para>
          <d:programlisting role="CLexer">static const char __func__[] = "function-name";</d:programlisting>
          <d:para>appeared, where <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >function-name</emphasis> is the name of the lexically-enclosing function.<d:footnote>
              <d:para>Since the name <d:code>__func__</d:code> is reserved for any use by the
                implementation (Macro Replacement), if any other identifier is explicitly declared
                using the name <d:code>__func__</d:code>, the behavior is undefined.</d:para>
            </d:footnote> This name is encoded as if the implicit declaration had been written in
            the source character set and then translated into the execution character set as
            indicated in translation phase 5.</d:para>
          <d:para>EXAMPLE Consider the code fragment:</d:para>
          <d:programlisting role="CLexer">#include &lt;stdio.h>
void myfunc(void)
{
  printf("%s\n", __func__);
  /* ... */
}</d:programlisting>
          <d:para>Each time the function is called, it will print to the standard output
            stream:</d:para>
          <d:screen>myfunc</d:screen>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> function definitions (Function definitions).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Universal Character Names</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>A universal character name shall not specify a character whose short identifier is
          less than 00A0 other than 0024 ($), 0040 (@), or 0060 (‘), nor one in the range D800
          through DFFF inclusive.<d:footnote>
            <d:para>The disallowed characters are the characters in the basic character set and the
              code positions reserved by ISO/IEC 10646 for control characters, the character DELETE,
              and the S-zone (reserved for use by UTF-16).</d:para>
          </d:footnote></d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Description</emphasis></d:para>
        <d:para>Universal character names may be used in identifiers, character constants, and
          string literals to designate characters that are not in the basic character set.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The universal character name \Unnnnnnnn designates the character whose eight-digit
          short identifier (as specified by ISO/IEC 10646) is nnnnnnnn.<d:footnote>
            <d:para>Short identifiers for characters were first specified in ISO/IEC
              10646-1/AMD9:1997.</d:para>
          </d:footnote> Similarly, the universal character name \unnnn designates the character
          whose four-digit short identifier is nnnn (and whose eight-digit short identifier is
          0000nnnn).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Constants</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The value of a constant shall be in the range of representable values for its
          type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>Each constant has a type, determined by its form and value, as detailed
          later.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Integer Constants</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Description</emphasis></d:para>
          <d:para>An integer constant begins with a digit, but has no period or exponent part. It
            may have a prefix that specifies its base and a suffix that specifies its type.</d:para>
          <d:para>A decimal constant begins with a nonzero digit and consists of a sequence of
            decimal digits. An octal constant consists of the prefix 0 optionally followed by a
            sequence of the digits 0 through 7 only. A hexadecimal constant consists of the prefix
            0x or 0X followed by a sequence of the decimal digits and the letters a (or A) through f
            (or F) with values 10 through 15 respectively.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The value of a decimal constant is computed base 10; that of an octal constant,
            base 8; that of a hexadecimal constant, base 16. The lexically first digit is the most
            significant.</d:para>
          <d:para>The type of an integer constant is the first of the corresponding list in which
            its value can be represented.<table xmlns="http://docbook.org/ns/docbook"
              frame="void" class="dynamic" border="1">
	    <colgroup width="100px" />
	    <colgroup width="200px" />
	    <colgroup width="200px" />
              <thead>
                <tr bgcolor="#aaa">
                  <th>Suffix</th>
                  <th>Decimal Constant</th>
                  <th>Octal or Hexadecimal Constant</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>none</td>
                  <td>
                    <para><code>int</code></para>
                    <para><code>long int</code></para>
                    <para><code>long long int</code></para>
                  </td>
                  <td>
                    <para><code>int</code></para>
                    <para><code>unsigned int</code></para>
                    <para><code>long int</code></para>
                    <para><code>unsigned long int</code></para>
                    <para><code>long long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td><code>u</code> or <code>U</code></td>
                  <td>
                    <para><code>unsigned int</code></para>
                    <para><code>unsigned long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                  <td>
                    <para><code>unsigned int</code></para>
                    <para><code>unsigned long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td><code>l</code> or <code>L</code></td>
                  <td>
                    <para><code>long int</code></para>
                    <para><code>long long int</code></para>
                  </td>
                  <td>
                    <para><code>long int</code></para>
                    <para><code>unsigned long int</code></para>
                    <para><code>long long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td>
                    <para>Both <code>u</code> or <code>U</code></para>
                    <para>and <code>l</code> or <code>L</code></para>
                  </td>
                  <td>
                    <para><code>unsigned long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                  <td>
                    <para><code>unsigned long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td><code>ll</code> or <code>LL</code></td>
                  <td><code>long long int</code></td>
                  <td>
                    <para><code>long long int</code></para>
                    <para><code>unsigned long long int</code></para>
                  </td>
                </tr>
                <tr>
                  <td>
                    <para>Both <code>u</code> or <code>U</code></para>
                    <para>and <code>ll</code> or <code>L</code>
                    </para>
                  </td>
                  <td><code>unsigned long long int</code></td>
                  <td><code>unsigned long long int</code></td>
                </tr>
              </tbody>
            </table></d:para>
          <d:para>If an integer constant cannot be represented by any type in its list, it may have
            an extended integer type, if the extended integer type can represent its value. If all
            of the types in the list for the constant are signed, the extended integer type shall be
            signed. If all of the types in the list for the constant are unsigned, the extended
            integer type shall be unsigned. If the list contains both signed and unsigned types, the
            extended integer type may be signed or unsigned.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Floating Constants</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Description</emphasis></d:para>
          <d:para>A floating constant has a <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">significand</emphasis> part that may be followed by an <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">exponent</emphasis> part and a
              <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">suffix</emphasis> that
            specifies its type. The components of the significand part may include a digit sequence
            representing the whole-number part, followed by a period (.), followed by a digit
            sequence representing the fraction part. The components of the exponent part are an
              <d:code>e, E, p</d:code> or <d:code>P</d:code> followed by an exponent consisting of
            an optionally signed digit sequence. Either the whole-number part or the fraction part
            has to be present; for decimal floating constants, either the period or the exponent
            part has to be present.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The significand part is interpreted as a (decimal or hexadecimal) rational number;
            the digit sequence in the exponent part is interpreted as a decimal integer. For decimal
            floating constants, the exponent indicates the power of 10 by which the significand part
            is to be scaled. For hexadecimal floating constants, the exponent indicates the power of
            2 by which the significand part is to be scaled. For decimal floating constants, and
            also for hexadecimal floating constants when <d:code>FLT_RADIX</d:code> is not a power
            of 2, the result is either the nearest representable value, or the larger or smaller
            representable value immediately adjacent to the nearest representable value, chosen in
            an implementation-defined manner. For hexadecimal floating constants when
              <d:code>FLT_RADIX</d:code> is a power of 2, the result is correctly rounded.</d:para>
          <d:para>An unsuffixed floating constant has type <d:code>double</d:code>. If suffixed by
            the letter <d:code>f</d:code> or <d:code>F</d:code>, it has type <d:code>float</d:code>.
            If suffixed by the letter <d:code>l</d:code> or <d:code>L</d:code>, it has type
              <d:code>long double</d:code>. </d:para>
          <d:para>Floating constants are converted to internal format as if at translation-time. The
            conversion of a floating constant shall not raise an exceptional condition or a
            floating- point exception at execution time.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Recommended
              Practice</emphasis></d:para>
          <d:para>The implementation should produce a diagnostic message if a hexadecimal constant
            cannot be represented exactly in its evaluation format; the implementation should then
            proceed with the translation of the program.</d:para>
          <d:para>The translation-time conversion of floating constants should match the
            execution-time conversion of character strings by library functions, such as strtod,
            given matching inputs suitable for both conversions, the same result format, and default
            execution-time rounding.<d:footnote>
              <d:para>The specification for the library functions recommends more accurate
                conversion than required for floating constants (see The strtod, strtof and strtold
                functions).</d:para>
            </d:footnote></d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Enumeration Constants</title>
          <d:para>An identifier declared as an enumeration constant has type
            <d:code>int</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> enumeration specifiers (Enumeration specifiers).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Character Constants</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Description</emphasis></d:para>
          <d:para>An integer character constant is a sequence of one or more multibyte characters
            enclosed in single-quotes, as in <d:code>'x'</d:code>. A wide character constant is the
            same, except prefixed by the letter <d:code>L</d:code>. With a few exceptions detailed
            later, the elements of the sequence are any members of the source character set; they
            are mapped in an implementation-defined manner to members of the execution character
            set.</d:para>
          <d:para>The single-quote ‘, the double-quote ”, the question-mark ?, the backslash \, and
            arbitrary integer values are representable according to the following table of escape
            sequences:</d:para>
          <d:screen>    single quote                     '       \\'
    double quote                    "      \\"
    question mark                  ?      \\?
    backslash                         \\      \\\\
    octal character                  \\o    octal digits
    hexadecimal character       \\x    hexadecimal digits</d:screen>
          <d:para>The double-quote ” and question-mark ? are representable either by themselves or
            by the escape sequences \” and \?, respectively, but the single-quote ‘ and the
            backslash \ shall be represented, respectively, by the escape sequences \’ and
            \\.</d:para>
          <d:para>The octal digits that follow the backslash in an octal escape sequence are taken
            to be part of the construction of a single character for an integer character constant
            or of a single wide character for a wide character constant. The numerical value of the
            octal integer so formed specifies the value of the desired character or wide
            character.</d:para>
          <d:para>The hexadecimal digits that follow the backslash and the letter x in a hexadecimal
            escape sequence are taken to be part of the construction of a single character for an
            integer character constant or of a single wide character for a wide character constant.
            The numerical value of the hexadecimal integer so formed specifies the value of the
            desired character or wide character.</d:para>
          <d:para>Each octal or hexadecimal escape sequence is the longest sequence of characters
            that can constitute the escape sequence.</d:para>
          <d:para>In addition, characters not in the basic character set are representable by
            universal character names and certain nongraphic characters are representable by escape
            sequences consisting of the backslash \ followed by a lowercase letter: <d:code>\a, \b,
              \f, \n, \r, \t,</d:code> and <d:code>\v</d:code>.<d:footnote>
              <d:para>The semantics of these characters were discussed in Character display
                semantics. If any other character follows a backslash, the result is not a token and
                a diagnostic is required. See “future language directions” (Character escape
                sequences).</d:para>
            </d:footnote></d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The value of an octal or hexadecimal escape sequence shall be in the range of
            representable values for the type <d:code>unsigned char</d:code> for an integer
            character constant, or the unsigned type corresponding to <d:code>wchar_t</d:code> for a
            wide character constant.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>An integer character constant has type <d:code>int</d:code>. The value of an
            integer character constant containing a single character that maps to a single-byte
            execution character is the numerical value of the representation of the mapped character
            interpreted as an integer. The value of an integer character constant containing more
            than one character (e.g., '<d:code>ab</d:code>'), or containing a character or escape
            sequence that does not map to a single-byte execution character, is
            implementation-defined. If an integer character constant contains a single character or
            escape sequence, its value is the one that results when an object with type
              <d:code>char</d:code> whose value is that of the single character or escape sequence
            is converted to type <d:code>int</d:code>.</d:para>
          <d:para>A wide character constant has type <d:code>wchar_t</d:code>, an integer type
            defined in the <d:code>&lt;stddef.h></d:code> header. The value of a wide character
            constant containing a single multibyte character that maps to a member of the extended
            execution character set is the wide character corresponding to that multibyte character,
            as defined by the <d:code>mbtowc</d:code> function, with an implementation-defined
            current locale. The value of a wide character constant containing more than one
            multibyte character, or containing a multibyte character or escape sequence not
            represented in the extended execution character set, is implementation-defined.</d:para>
          <d:para>EXAMPLE 1 The construction '<d:code>\0</d:code>' is commonly used to represent the
            null character.</d:para>
          <d:para>EXAMPLE 2 Consider implementations that use two’s-complement representation for
            integers and eight bits for objects that have type <d:code>char</d:code>. In an
            implementation in which type <d:code>char</d:code> has the same range of values as
              <d:code>signed char</d:code>, the integer character constant '<d:code>\xFF</d:code>'
            has the value <d:code>-1</d:code>; if type <d:code>char</d:code> has the same range of
            values as <d:code>unsigned char</d:code>, the character constant '<d:code>\xFF</d:code>'
            has the value <d:code>+255</d:code>.</d:para>
          <d:para>EXAMPLE 3 Even if eight bits are used for objects that have type char, the
            construction '<d:code>\x123</d:code>' specifies an integer character constant containing
            only one character, since a hexadecimal escape sequence is terminated only by a
            non-hexadecimal character. To specify an integer character constant containing the two
            characters whose values are '<d:code>\x12</d:code>' and '<d:code>3</d:code>', the
            construction '<d:code>\0223</d:code>' may be used, since an octal escape sequence is
            terminated after three octal digits. (The value of this two-character integer character
            constant is implementation-defined.)</d:para>
          <d:para>EXAMPLE 4 Even if <d:code>12</d:code> or more bits are used for objects that have
            type <d:code>wchar_t</d:code>, the construction <d:code>L'\1234'</d:code> specifies the
            implementation-defined value that results from the combination of the values
              <d:code>0123</d:code> and '<d:code>4</d:code>'.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> common definitions <d:code>&lt;stddef.h></d:code> (Common
            definitions <d:code>&lt;stddef.h></d:code>), the <d:code>mbtowc</d:code> function (The
              <d:code>mbtowc</d:code> function).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">String Literals</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Description</emphasis></d:para>
        <d:para>A character <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">string
            literal</emphasis> is a sequence of zero or more multibyte characters enclosed in
          double-quotes, as in “<d:code>xyz</d:code>”. A <d:code>wide string literal</d:code> is the
          same, except prefixed by the letter <d:code>L</d:code>. The same considerations apply to
          each element of the sequence in a character string literal or a wide string literal as if
          it were in an integer character constant or a wide character constant, except that the
          single-quote ' is representable either by itself or by the escape sequence
            <d:code>\'</d:code>, but the double-quote <d:code>"</d:code> shall be represented by the
          escape sequence <d:code>\"</d:code>.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>In translation phase 6, the multibyte character sequences specified by any sequence
          of adjacent character and wide string literal tokens are concatenated into a single
          multibyte character sequence. If any of the tokens are wide string literal tokens, the
          resulting multibyte character sequence is treated as a wide string literal; otherwise, it
          is treated as a character string literal.</d:para>
        <d:para>In translation phase 7, a byte or code of value zero is appended to each multibyte
          character sequence that results from a string literal or literals.66) The multibyte
          character sequence is then used to initialize an array of static storage duration and
          length just sufficient to contain the sequence. For character string literals, the array
          elements have type <d:code>char</d:code>, and are initialized with the individual bytes of
          the multibyte character sequence; for wide string literals, the array elements have type
            <d:code>wchar_t</d:code>, and are initialized with the sequence of wide characters
          corresponding to the multibyte character sequence, as defined by the
            <d:code>mbstowcs</d:code> function with an implementation-defined current locale. The
          value of a string literal containing a multibyte character or escape sequence not
          represented in the execution character set is implementation-defined.</d:para>
        <d:para>It is unspecified whether these arrays are distinct provided their elements have the
          appropriate values. If the program attempts to modify such an array, the behavior is
          undefined.</d:para>
        <d:para>EXAMPLE This pair of adjacent character string literals:</d:para>
        <d:screen>"\x12" "3"</d:screen>
        <d:para>produces a single character string literal containing the two characters whose
          values are '<d:code>\x12</d:code>' and '<d:code>3</d:code>', because escape sequences are
          converted into single members of the execution character set just prior to adjacent string
          literal concatenation.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> common definitions <d:code>&lt;stddef.h></d:code> (Common
          definitions <d:code>&lt;stddef.h></d:code>), the <d:code>mbstowcs</d:code> function (The
            <d:code>mbstowcs</d:code> function).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Punctuators</title>
        <d:para>These are one of:</d:para>
        <d:screen>[ ] ( ) { } . -> ++ -- &amp; * + - ~ ! / % &lt;&lt; >> &lt; > &lt;= > ? : ; ... = *= /=
%= += -= &lt;&lt;= , # ## &lt;: :> &lt;% %> %: %:%: == >>= != &amp;= ^ | ^= &amp;&amp;  || |=</d:screen>
        <d:para>A punctuator is a symbol that has independent syntactic and semantic significance.
          Depending on context, it may specify an operation to be performed (which in turn may yield
          a value or a function designator, produce a side effect, or some combination thereof) in
          which case it is known as an <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >operator</emphasis> (other forms of operator also exist in some contexts). An operand
          is an entity on which an operator acts.</d:para>
        <d:para>In all aspects of the language, the six tokens<d:footnote>
            <d:para>These tokens are sometimes called “digraphs”.</d:para>
          </d:footnote></d:para>
        <d:screen>&lt;: :> &lt;% %> %: %:%:</d:screen>
        <d:para>behave, respectively, the same as the six tokens:</d:para>
        <d:screen>[ ] { } # ##</d:screen>
        <d:para>except for their spelling.<d:footnote>
            <d:para>Thus [ and &lt;: behave differently when “stringized (see The # Operator), but
              can otherwise be freely interchanged.</d:para>
          </d:footnote></d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> expressions (Expressions), declarations (Declarations),
          preprocessing directives (Preprocessing Directives), statements (Statements and
          blocks).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Header Names</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The sequences in both forms of header names are mapped in an implementation-defined
          manner to headers or external source file names as specified in Source File
          Inclusion.</d:para>
        <d:para>If the characters ', \, ", // or /* occur in the sequence between the &lt; and >
          delimiters, the behavior is undefined. Similarly, if the characters ', \, // or /* occur
          in the sequence between the " delimiters, the behavior is undefined.<d:footnote>
            <d:para>Thus, sequences of characters that resemble escape sequences cause undefined
              behavior.</d:para>
          </d:footnote> A header name preprocessing token is recognized only within a
            <d:code>#include</d:code> preprocessing directive.</d:para>
        <d:para>EXAMPLE The following sequence of characters:</d:para>
        <d:programlisting role="CLexer">0x3&lt;1/a.h>1e2
#include &lt;1/a.h>
#define const.member@$</d:programlisting>
        <d:para>forms the following sequence of preprocessing tokens (with each individual
          preprocessing token delimited by a { on the left and a } on the right).</d:para>
        <d:programlisting role="CLexer">{0x3}{&lt;}{1}{/}{a}{.}{h}{>}{1e2}
{#}{include} {&lt;1/a.h>}
{#}{define} {const}{.}{member}{@}{$}</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> source file inclusion (Source File Inclusion).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Preprocessing Numbers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A preprocessing number begins with a digit optionally preceded by a period (.) and
          may be followed by valid identifier characters and the character sequences <d:code>e+, e-,
            E+, E-, p+, p-, P</d:code>+ or <d:code>P-</d:code>.</d:para>
        <d:para>Preprocessing number tokens lexically include all floating and integer constant
          tokens.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A preprocessing number does not have type or a value; it acquires both after a
          successful conversion (as part of translation phase 7) to a floating constant token or an
          integer constant token.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Comments</title>
        <d:para>Except within a character constant, a string literal, or a comment, the characters
            <d:code>/*</d:code> introduce a comment. The contents of such a comment are examined
          only to identify multibyte characters and to find the characters <d:code>*/</d:code> that
          terminate it.<d:footnote>
            <d:para>Thus, /* ... */ comments do not nest.</d:para>
          </d:footnote></d:para>
        <d:para>Except within a character constant, a string literal, or a comment, the characters
            <d:code>//</d:code> ntroduce a comment that includes all multibyte characters up to, but
          not including, the next new-line character. The contents of such a comment are examined
          only to identify multibyte characters and to find the terminating new-line
          character.</d:para>
        <d:para>EXAMPLE</d:para>
        <d:programlisting role="CLexer">"a//b"                      // four-character string literal
#include "//e"              // undefined behavior
// */                       // comment, not syntax error
f = g/**//h;                // equivalent to f = g / h;
//\
i();                        // part of a two-line comment
/\
/ j();                      // part of a two-line comment
#define glue(x,y) x##y
glue(/,/) k();              // syntax error, not comment
/*//*/ l();                 // equivalent to l();
m = n//**/o
+ p;                        // equivalent to m = n + p;</d:programlisting>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Expressions</title>
      <d:para>An expression is a sequence of operators and operands that specifies computation of a
        value, or that designates an object or a function, or that generates side effects, or that
        performs a combination thereof.</d:para>
      <d:para>Between the previous and next sequence point an object shall have its stored value
        modified at most once by the evaluation of an expression. Furthermore, the prior value shall
        be read only to determine the value to be stored.<d:footnote>
          <d:para>This paragraph renders undefined statement expressions such as <d:code>i = ++i +
              1;</d:code></d:para>
          <d:para><d:code>a[i++] = i;</d:code></d:para>
          <d:para>while allowing</d:para>
          <d:para><d:code>i = i + 1; a[i] = i;</d:code></d:para>
        </d:footnote></d:para>
      <d:para>The grouping of operators and operands is indicated by the syntax.<d:footnote>
          <d:para>The syntax specifies the precedence of operators in the evaluation of an
            expression, which is the same as the order of the major subclauses of this subclause,
            highest precedence first. Thus, for example, the expressions allowed as the operands of
            the binary + operator (Additive operators) are those expressions defined in Primary
            expressions through Additive operators. The exceptions are cast expressions (Cast
            operators) as operands of unary operators (Unary operators), and an operand contained
            between any of the following pairs of operators: grouping parentheses () (Primary
            expressions), subscripting brackets [] (:ref:`4.5.2.1`), function-call parentheses ``()
            (Function calls), and the conditional operator ?: (Conditional operator).</d:para>
          <d:para>Within each major subclause, the operators have the same precedence. Left- or
            right-associativity is indicated in each subclause by the syntax for the expressions
            discussed therein.</d:para>
        </d:footnote> Except as specified later (for the function-call <d:code>(), &amp;&amp;, ||,
          ?:</d:code> and comma operators), the order of evaluation of subexpressions and the order
        in which side effects take place are both unspecified.</d:para>
      <d:para>Some operators (the unary operator <d:code>~</d:code>, and the binary operators
          <d:code>&lt;&lt;, >>, &amp;, ^</d:code> and <d:code>|</d:code>, collectively described as
        bitwise operators) are required to have operands that have integer type. These operators
        yield values that depend on the internal representations of integers, and have
        implementation-defined and undefined aspects for signed types. If an exceptional condition
        occurs during the evaluation of an expression (that is, if the result is not mathematically
        defined or not in the range of representable values for its type), the behavior is
        undefined.</d:para>
      <d:para>The effective type of an object for an access to its stored value is the declared type
        of the object, if any.<d:footnote>
          <d:para>Allocated objects have no declared type.</d:para>
        </d:footnote> If a value is stored into an object having no declared type through an lvalue
        having a type that is not a character type, then the type of the lvalue becomes the
        effective type of the object for that access and for subsequent accesses that do not modify
        the stored value. If a value is copied into an object having no declared type using memcpy
        or memmove or is copied as an array of character type, then the effective type of the
        modified object for that access and for subsequent accesses that do not modify the value is
        the effective type of the object from which the value is copied, if it has one. For all
        other accesses to an object having no declared type, the effective type of the object is
        simply the type of the lvalue used for the access.</d:para>
      <d:para>An object shall have its stored value accessed only by an lvalue expression that has
        one of the following types:<d:footnote>
          <d:para>The intent of this list is to specify those circumstances in which an object may
            or may not be aliased.</d:para>
        </d:footnote><d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a type compatible with the effective type of
              the object,</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a qualified version of a type compatible
              with the effective type of the object,</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a type that is the signed or unsigned type
              corresponding to the effective type of the object,</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a type that is the signed or unsigned type
              corresponding to a qualified version of the effective type of the object,</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">an aggregate or union type that includes one
              of the aforementioned types among its members (including, recursively, a member of a
              subaggregate or contained union), or</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">a character type.</para>
          </d:listitem>
        </d:itemizedlist></d:para>
      <d:para>A floating expression may be <d:code>contracted</d:code>, that is, evaluated as though
        it were an atomic operation, thereby omitting rounding errors implied by the source code and
        the expression evaluation method.<d:footnote>
          <d:para>A contracted expression might also omit the raising of floating-point
            exceptions.</d:para>
        </d:footnote> The <d:code>FP_CONTRACT</d:code> pragma in <d:code>&lt;math.h></d:code>
        provides a way to disallow contracted expressions. Otherwise, whether and how expressions
        are contracted is implementation-defined.<d:footnote>
          <d:para>This license is specifically intended to allow implementations to exploit fast
            machine instructions that combine multiple C operators. As contractions potentially
            undermine predictability, and can even decrease accuracy for containing expressions,
            their use needs to be well-defined and clearly documented.</d:para>
        </d:footnote></d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> the <d:code>FP_CONTRACT</d:code> pragma (The FP_CONTRACT pragma),
        copying functions (Copying functions).</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Primary Expressions</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>An identifier is a primary expression, provided it has been declared as designating
          an object (in which case it is an lvalue) or a function (in which case it is a function designator).<d:footnote>
            <d:para>Thus, an undeclared identifier is a violation of the syntax.</d:para>
          </d:footnote></d:para>
        <d:para>A constant is a primary expression. Its type depends on its form and value, as
          detailed in Constants.</d:para>
        <d:para>A string literal is a primary expression. It is an lvalue with type as detailed in
          String literals.</d:para>
        <d:para>A parenthesized expression is a primary expression. Its type and value are identical
          to those of the unparenthesized expression. It is an lvalue, a function designator, or a
          void expression if the unparenthesized expression is, respectively, an lvalue, a function
          designator, or a void expression.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> declarations (Declarations).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Postfix Operators</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Array Subscripting</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>One of the expressions shall have type “pointer to object type”, the other
            expression shall have integer type, and the result has type “type”.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A postfix expression followed by an expression in square brackets
              <d:code>[]</d:code> is a subscripted designation of an element of an array object. The
            definition of the subscript operator <d:code>[]</d:code> is that <d:code>E1[E2]</d:code>
            is identical to <d:code>(*((E1)+(E2)))</d:code>. Because of the conversion rules that
            apply to the binary + operator, if <d:code>E1</d:code> is an array object (equivalently,
            a pointer to the initial element of an array object) and <d:code>E2</d:code> is an
            integer, <d:code>E1[E2]</d:code> designates the <d:code>E2</d:code>-th element of
              <d:code>E1</d:code> (counting from zero).</d:para>
          <d:para>Successive subscript operators designate an element of a multidimensional array
            object. If E is an <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >n</emphasis>-dimensional array <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:mi>(n</mml:mi>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2265;<!-- ≥ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mn>2)</mml:mn>
              </mml:math>
            </d:inlineequation> with dimensions <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:mi>i</mml:mi>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mi>j</mml:mi>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mi>k</mml:mi>
              </mml:math>
            </d:inlineequation>, then <d:code>E</d:code> (used as other than an lvalue) is converted
            to a pointer to an <d:code>(n - 1)</d:code>-dimensional array with dimensions <d:inlineequation>
              <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
                <mml:mi>j</mml:mi>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>.</mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
                <mml:mtext>&#xA0;</mml:mtext>
                <mml:mi>k</mml:mi>
              </mml:math>
            </d:inlineequation>. If the unary <d:code>*</d:code> operator is applied to this pointer
            explicitly, or implicitly as a result of subscripting, the result is the pointed-to
              <d:code>(n - 1)</d:code>-dimensional array, which itself is converted into a pointer
            if used as other than an lvalue. It follows from this that arrays are stored in
            row-major order (last subscript varies fastest).</d:para>
          <d:para>EXAMPLE Consider the array object defined by the declaration</d:para>
          <d:programlisting role="CLexer">int x[3][5];</d:programlisting>
          <d:para>Here <d:code>x</d:code> is a <d:code>3 ∗ 5</d:code> array of ints; more precisely,
              <d:code>x</d:code> is an array of three element objects, each of which is an array of
            five ints. In the expression <d:code>x[i]</d:code> which is equivalent to
              <d:code>(*((x)+(i))), x</d:code> is first converted to a pointer to the initial array
            of five ints. Then i is adjusted according to the type of <d:code>x</d:code>, which
            conceptually entails multiplying <d:code>i</d:code> by the size of the object to which
            the pointer points, namely an array of five int objects. The results are added and
            indirection is applied to yield an array of five ints. When used in the expression
              <d:code>x[i][j]</d:code> that array is in turn converted to a pointer to the first of
            the ints, so <d:code>x[i][j]</d:code> yields an <d:code>int</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> additive operators (Additive operators), address and
            indirection operators (Address and indirection operators), array declarators (Array
            declarators).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Function Calls</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The expression that denotes the called function<d:footnote>
              <d:para>Most often, this is the result of converting an identifier that is a function
                designator.</d:para>
            </d:footnote> shall have type pointer to function returning void or returning an object
            type other than an array type.</d:para>
          <d:para>If the expression that denotes the called function has a type that includes a
            prototype, the number of arguments shall agree with the number of parameters. Each
            argument shall have a type such that its value may be assigned to an object with the
            unqualified version of the type of its corresponding parameter.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A postfix expression followed by parentheses () containing a possibly empty,
            comma- separated list of expressions is a function call. The postfix expression denotes
            the called function. The list of expressions specifies the arguments to the
            function.</d:para>
          <d:para>An argument may be an expression of any object type. In preparing for the call to
            a function, the arguments are evaluated, and each parameter is assigned the value of the
            corresponding argument.<d:footnote>
              <d:para>A function may change the values of its parameters, but these changes cannot
                affect the values of the arguments. On the other hand, it is possible to pass a
                pointer to an object, and the function may change the value of the object pointed
                to. A parameter declared to have array or function type is adjusted to have a
                pointer type as described in Function definitions.</d:para>
            </d:footnote></d:para>
          <d:para>If the expression that denotes the called function has type pointer to function
            returning an object type, the function call expression has the same type as that object
            type, and has the value determined as specified in The return statement. Otherwise, the
            function call has type void. If an attempt is made to modify the result of a function
            call or to access it after the next sequence point, the behavior is undefined.</d:para>
          <d:para>If the expression that denotes the called function has a type that does not
            include a prototype, the integer promotions are performed on each argument, and
            arguments that have type float are promoted to double. These are called the default
              <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">argument
              promotions</emphasis>. If the number of arguments does not equal the number of
            parameters, the behavior is undefined. If the function is defined with a type that
            includes a prototype, and either the prototype ends with an ellipsis (, ...) or the
            types of the arguments after promotion are not compatible with the types of the
            parameters, the behavior is undefined. If the function is defined with a type that does
            not include a prototype, and the types of the arguments after promotion are not
            compatible with those of the parameters after promotion, the behavior is undefined,
            except for the following cases:</d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">one promoted type is a signed integer
                type, the other promoted type is the corresponding unsigned integer type, and the
                value is representable in both types;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">both types are pointers to qualified or
                unqualified versions of a character type or <code>void</code>.</para>
            </d:listitem>
          </d:itemizedlist>
          <d:para>converted, as if by assignment, to the types of the corresponding parameters,
            taking the type of each parameter to be the unqualified version of its declared type.
            The ellipsis notation in a function prototype declarator causes argument type conversion
            to stop after the last declared parameter. The default argument promotions are performed
            on trailing arguments.</d:para>
          <d:para>No other conversions are performed implicitly; in particular, the number and types
            of arguments are not compared with those of the parameters in a function definition that
            does not include a function prototype declarator.</d:para>
          <d:para>If the function is defined with a type that is not compatible with the type (of
            the expression) pointed to by the expression that denotes the called function, the
            behavior is undefined.</d:para>
          <d:para>The order of evaluation of the function designator, the actual arguments, and
            subexpressions within the actual arguments is unspecified, but there is a sequence point
            before the actual call.</d:para>
          <d:para>Recursive function calls shall be permitted, both directly and indirectly through
            any chain of other functions.</d:para>
          <d:para>EXAMPLE In the function call</d:para>
          <d:programlisting role="CLexer">(*pf[f1()]) (f2(), f3() + f4())</d:programlisting>
          <d:para>the functions <d:code>f1, f2, f3</d:code> and <d:code>f4</d:code> may be called in
            any order. All side effects have to be completed before the function pointed to by
              <d:code>pf[f1()]</d:code> is called.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> function declarators (including prototypes) (Function
            declarators (including prototypes)), function definitions (Function definitions), the
            return statement (The return statement), simple assignment (Simple assignment).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Structures and union members</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The first operand of the <d:code>.</d:code> operator shall have a qualified or
            unqualified structure or union type, and the second operand shall name a member of that
            type.</d:para>
          <d:para>The first operand of the <d:code>-></d:code> operator shall have type “pointer to
            qualified or unqualified structure” or “pointer to qualified or unqualified union”, and
            the second operand shall name a member of the type pointed to.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A postfix expression followed by the <d:code>.</d:code> operator and an identifier
            designates a member of a structure or union object. The value is that of the named
            member, and is an lvalue if the first expression is an lvalue. If the first expression
            has qualified type, the result has the so-qualified version of the type of the
            designated member. \</d:para>
          <d:para>A postfix expression followed by the <d:code>-></d:code> operator and an
            identifier designates a member of a structure or union object. The value is that of the
            named member of the object to which the first expression points, and is an lvalue.<d:footnote>
              <d:para>If <d:code>&amp;E</d:code> is a valid pointer expression (where
                  <d:code>&amp;</d:code> is the “address-of” operator, which generates a pointer to
                its operand), the expression <d:code>(&amp;E)->MOS</d:code> is the same as
                  <d:code>E.MOS</d:code>.</d:para>
            </d:footnote> If the first expression is a pointer to a qualified type, the result has
            the so-qualified version of the type of the designated member.</d:para>
          <d:para>One special guarantee is made in order to simplify the use of unions: if a union
            contains several structures that share a common initial sequence (see below), and if the
            union object currently contains one of these structures, it is permitted to inspect the
            common initial part of any of them anywhere that a declaration of the complete type of
            the union is visible. Two structures share a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">common initial sequence</emphasis>
            if corresponding members have compatible types (and, for bit-fields, the same widths)
            for a sequence of one or more initial members.</d:para>
          <d:para>EXAMPLE 1 If <d:code>f</d:code> is a function returning a structure or union, and
              <d:code>x</d:code> is a member of that structure or union, <d:code>f().x</d:code> is a
            valid postfix expression but is not an lvalue.</d:para>
          <d:para>EXAMPLE 2 In:</d:para>
          <d:programlisting role="CLexer">struct s { int i; const int ci; };
struct s s;
const struct s cs;
volatile struct s vs;</d:programlisting>
          <d:para>the various members have the types:</d:para>
          <d:programlisting role="CLexer">s.i   int
s.ci  const int
cs.i  const int
cs.ci const int
vs.i  volatile int
vs.ci volatile const int</d:programlisting>
          <d:para>EXAMPLE 3 The following is a valid fragment:</d:para>
          <d:programlisting role="CLexer">union {
  struct {
    int alltypes;
  } n;
  struct {
    int type;
    int intnode;
  } ni;
  struct {
  int type;
  double doublenode;
  } nf;
} u;
u.nf.type = 1;
u.nf.doublenode = 3.14;
/* ... */
if (u.n.alltypes == 1)
if (sin(u.nf.doublenode) == 0.0)
/* ... */</d:programlisting>
          <d:para>The following is not a valid fragment (because the union type is not visible
            within function <d:code>f</d:code>):</d:para>
          <d:programlisting role="CLexer">struct t1 { int m; };
struct t2 { int m; };
int f(struct t1 *p1, struct t2 *p2)
{
  if (p1->m &lt; 0)
    p2->m = -p2->m;
  return p1->m;
}
int g()
{
  union {
    struct t1 s1;
    struct t2 s2;
  } u;
  /* ... */
  return f(&amp;u.s1, &amp;u.s2);
}</d:programlisting>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> address and indirection operators (Address and indirection
            operators), structure and union specifiers (Structure and union specifiers).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Postfix increment and decrement
            operators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The operand of the postfix increment or decrement operator shall have qualified or
            unqualified real or pointer type and shall be a modifiable lvalue.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The result of the postfix <d:code>++</d:code> operator is the value of the
            operand. After the result is obtained, the value of the operand is incremented. (That
            is, the value 1 of the appropriate type is added to it.) See the discussions of additive
            operators and compound assignment for information on constraints, types, and conversions
            and the effects of operations on pointers. The side effect of updating the stored value
            of the operand shall occur between the previous and the next sequence point.</d:para>
          <d:para>The postfix <d:code>--</d:code> operator is analogous to the postfix
              <d:code>++</d:code> operator, except that the value of the operand is decremented
            (that is, the value 1 of the appropriate type is subtracted from it).</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> additive operators (Additive operators), compound assignment
            (Compound assignment).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Compound literals</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The type name shall specify an object type or an array of unknown size, but not a
            variable length array type.</d:para>
          <d:para>No initializer shall attempt to provide a value for an object not contained within
            the entire unnamed object specified by the compound literal.</d:para>
          <d:para>If the compound literal occurs outside the body of a function, the initializer
            list shall consist of constant expressions.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A postfix expression that consists of a parenthesized type name followed by a
            brace- enclosed list of initializers is a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">compound literal</emphasis>. It
            provides an unnamed object whose value is given by the initializer list.<d:footnote>
              <d:para>Note that this differs from a cast expression. For example, a cast specifies a
                conversion to scalar types or void only, and the result of a cast expression is not
                an lvalue.</d:para>
            </d:footnote></d:para>
          <d:para>If the type name specifies an array of unknown size, the size is determined by the
            initializer list as specified in Initialization, and the type of the compound literal is
            that of the completed array type. Otherwise (when the type name specifies an object
            type), the type of the compound literal is that specified by the type name. In either
            case, the result is an lvalue.</d:para>
          <d:para>The value of the compound literal is that of an unnamed object initialized by the
            initializer list. If the compound literal occurs outside the body of a function, the
            object has static storage duration; otherwise, it has automatic storage duration
            associated with the enclosing block.</d:para>
          <d:para>All the semantic rules and constraints for initializer lists in Initialization are
            applicable to compound literals.<d:footnote>
              <d:para>For example, subobjects without explicit initializers are initialized to
                zero.</d:para>
            </d:footnote></d:para>
          <d:para>String literals, and compound literals with const-qualified types, need not
            designate distinct objects.<d:footnote>
              <d:para>This allows implementations to share storage for string literals and constant
                compound literals with the same or overlapping representations.</d:para>
            </d:footnote></d:para>
          <d:para>EXAMPLE 1 The file scope definition</d:para>
          <d:programlisting role="CLexer">int *p = (int []){2, 4};</d:programlisting>
          <d:para>initializes p to point to the first element of an array of two ints, the first
            having the value two and the second, four. The expressions in this compound literal are
            required to be constant. The unnamed object has static storage duration.</d:para>
          <d:para>EXAMPLE 2 In contrast, in</d:para>
          <d:programlisting role="CLexer">void f(void)
{
  int *p;
  /*...*/
  p = (int [2]){*p};
  /*...*/
}</d:programlisting>
          <d:para><d:code>p</d:code> is assigned the address of the first element of an array of two
            ints, the first having the value previously pointed to by <d:code>p</d:code> and the
            second, zero. The expressions in this compound literal need not be constant. The unnamed
            object has automatic storage duration.</d:para>
          <d:para>EXAMPLE 3 Initializers with designations can be combined with compound literals.
            Structure objects created using compound literals can be passed to functions without
            depending on member order:</d:para>
          <d:programlisting role="CLexer">drawline((struct point){.x=1, .y=1},
(struct point){.x=3, .y=4});</d:programlisting>
          <d:para>Or, if drawline instead expected pointers to struct point:</d:para>
          <d:programlisting role="CLexer">drawline(&amp;(struct point){.x=1, .y=1},
&amp;(struct point){.x=3, .y=4});</d:programlisting>
          <d:para>EXAMPLE 4 A read-only compound literal can be specified through constructions
            like:</d:para>
          <d:programlisting role="CLexer">(const float []){1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6}</d:programlisting>
          <d:para>EXAMPLE 5 The following three expressions have different meanings:</d:para>
          <d:programlisting role="CLexer">"/tmp/fileXXXXXX"
(char []){"/tmp/fileXXXXXX"}
(const char []){"/tmp/fileXXXXXX"}</d:programlisting>
          <d:para>The first always has static storage duration and has type array of char, but need
            not be modifiable; the last two have automatic storage duration when they occur within
            the body of a function, and the first of these two is modifiable.</d:para>
          <d:para>EXAMPLE 6 Like string literals, const-qualified compound literals can be placed
            into read-only memory and can even be shared. For example,</d:para>
          <d:programlisting role="CLexer">(const char []){"abc"} == "abc"</d:programlisting>
          <d:para>might yield 1 if the literals’ storage is shared.</d:para>
          <d:para>EXAMPLE 7 Since compound literals are unnamed, a single compound literal cannot
            specify a circularly linked object. For example, there is no way to write a
            self-referential compound literal that could be used as the function argument in place
            of the named object endless_zeros below:</d:para>
          <d:programlisting role="CLexer">struct int_list { int car; struct int_list *cdr; };
struct int_list endless_zeros = {0, &amp;endless_zeros};
eval(endless_zeros);</d:programlisting>
          <d:para>EXAMPLE 8 Each compound literal creates only a single object in a given
            scope:</d:para>
          <d:programlisting role="CLexer">struct s { int i; };
int f (void)
{
  struct s *p = 0, *q;
  int j = 0;
again:
  q = p, p = &amp;((struct s){ j++ });
  if (j &lt; 2) goto again;
  return p == q &amp;&amp; q->i == 1;
}</d:programlisting>
          <d:para>The function <d:code>f()</d:code> always returns the value 1.</d:para>
          <d:para>Note that if an iteration statement were used instead of an explicit goto and a
            labeled statement, the lifetime of the unnamed object would be the body of the loop
            only, and on entry next time around <d:code>p</d:code> would have an indeterminate
            value, which would result in undefined behavior.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> type names (Type names), initialization
            (Initialization).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Unary Operators</title>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Prefix increment and decrement
            operators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The operand of the prefix increment or decrement operator shall have qualified or
            unqualified real or pointer type and shall be a modifiable lvalue.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The value of the operand of the prefix <d:code>++</d:code> operator is
            incremented. The result is the new value of the operand after incrementation. The
            expression <d:code>++E</d:code> is equivalent to <d:code>(E+=1)</d:code>. See the
            discussions of additive operators and compound assignment for information on onstraints,
            types, side effects, and conversions and the effects of operations on pointers.</d:para>
          <d:para>The prefix <d:code>--</d:code> operator is analogous to the prefix
              <d:code>++</d:code> operator, except that the value of the operand is
            decremented.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> additive operators (Additive operators), compound assignment
            (Compound assignment).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Address and indirection operators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The operand of the unary <d:code>&amp;</d:code> operator shall be either a
            function designator, the result of a <d:code>[]</d:code> or unary <d:code>*</d:code>
            operator, or an lvalue that designates an object that is not a bit-field and is not
            declared with the register storage-class specifier.</d:para>
          <d:para>The operand of the unary <d:code>*</d:code> operator shall have pointer
            type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The unary <d:code>&amp;</d:code> operator yields the address of its operand. If
            the operand has type “type”, the result has type “pointer to type”. If the operand is
            the result of a unary <d:code>*</d:code> operator, neither that operator nor the
              <d:code>&amp;</d:code> operator is evaluated and the result is as if both were
            omitted, except that the constraints on the operators still apply and the result is not
            an lvalue. Similarly, if the operand is the result of a <d:code>[]</d:code> operator,
            neither the <d:code>&amp;</d:code> operator nor he unary <d:code>*</d:code> that is
            implied by the <d:code>[]</d:code> is evaluated and the result is as if the
              <d:code>&amp;</d:code> operator were removed and the <d:code>[]</d:code> operator were
            changed to a <d:code>+</d:code> operator. Otherwise, the result is a pointer to the
            object or function designated by its operand.</d:para>
          <d:para>The unary <d:code>*</d:code> operator denotes indirection. If the operand points
            to a function, the result is a function designator; if it points to an object, the
            result is an lvalue designating the object. If the operand has type “pointer to type”,
            the result has type “type”. If an invalid value has been assigned to the pointer, the
            behavior of the unary <d:code>*</d:code> operator is undefined.<d:footnote>
              <d:para>Thus, <d:code>&amp;*E</d:code> is equivalent to <d:code>E</d:code> (even if
                  <d:code>E</d:code> is a null pointer), and <d:code>&amp;(E1[E2]) to
                  ((E1)+(E2))</d:code>. It is always true that if <d:code>E</d:code> is a function
                designator or an lvalue that is a valid operand of the unary &amp; operator,
                  <d:code>*&amp;E</d:code> is a function designator or an lvalue equal to
                  <d:code>E</d:code>. If <d:code>*P</d:code> is an lvalue and <d:code>T</d:code> is
                the name of an object pointer type, <d:code>*(T)P</d:code> is an lvalue that has a
                type compatible with that to which <d:code>T</d:code> points. Among the invalid
                values for dereferencing a pointer by the unary <d:code>*</d:code> operator are a
                null pointer, an address inappropriately aligned for the type of object pointed to,
                and the address of an object after the end of its lifetime.</d:para>
            </d:footnote></d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> storage-class specifiers (Storage-class specifiers), structure
            and union specifiers (Structure and union specifiers).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Unary arithmetic operators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The operand of the unary <d:code>+</d:code> or <d:code>-</d:code> operator shall
            have arithmetic type; of the <d:code>-</d:code> operator, integer type; of the
              <d:code>!</d:code> operator, scalar type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The result of the unary <d:code>+</d:code> operator is the value of its (promoted)
            operand. The integer promotions are performed on the operand, and the result has the
            promoted type.</d:para>
          <d:para>The result of the unary <d:code>-</d:code> operator is the negative of its
            (promoted) operand. The integer promotions are performed on the operand, and the result
            has the promoted type.</d:para>
          <d:para>The result of the <d:code>~</d:code> operator is the bitwise complement of its
            (promoted) operand (that is, each bit in the result is set if and only if the
            corresponding bit in the converted operand is not set). The integer promotions are
            performed on the operand, and the result has the promoted type. If the promoted type is
            an unsigned type, the expression <d:code>~E</d:code> is equivalent to the maximum value
            representable in that type minus <d:code>E</d:code>.</d:para>
          <d:para>The result of the logical negation operator <d:code>!</d:code> is 0 if the value
            of its operand compares unequal to 0, 1 if the value of its operand compares equal to 0.
            The result has type int. The expression <d:code>!E</d:code> is equivalent to
              <d:code>(0==E)</d:code>.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The sizeof operator</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The <d:code>sizeof</d:code> operator shall not be applied to an expression that
            has function type or an incomplete type, to the parenthesized name of such a type, or to
            an expression that designates a bit-field member.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The <d:code>sizeof</d:code> operator yields the size (in bytes) of its operand,
            which may be an expression or the parenthesized name of a type. The size is determined
            from the type of the operand. The result is an integer. If the type of the operand is a
            variable length array type, the operand is evaluated; otherwise, the operand is not
            evaluated and the result is an integer constant.</d:para>
          <d:para>When applied to an operand that has type <d:code>char, unsigned char</d:code> or
              <d:code>signed char</d:code>, (or a qualified version thereof) the result is 1. When
            applied to an operand that has array type, the result is the total number of bytes in
            the array.<d:footnote>
              <d:para>When applied to a parameter declared to have array or function type, the
                sizeof operator yields the size of the adjusted (pointer) type (see Function
                definitions).</d:para>
            </d:footnote> When applied to an operand that has structure or union type, the result is
            the total number of bytes in such an object, including internal and trailing
            padding.</d:para>
          <d:para>The value of the result is implementation-defined, and its type (an unsigned
            integer type) is <d:code>size_t</d:code>, defined in <d:code>&lt;stddef.h></d:code> (and
            other headers).</d:para>
          <d:para>EXAMPLE 1 A principal use of the sizeof operator is in communication with routines
            such as storage allocators and I/O systems. A storage-allocation function might accept a
            size (in bytes) of an object to allocate and return a pointer to void. For
            example:</d:para>
          <d:programlisting role="CLexer">extern void *alloc(size_t);
double *dp = alloc(sizeof *dp);</d:programlisting>
          <d:para>The implementation of the alloc function should ensure that its return value is
            aligned suitably for conversion to a pointer to double.</d:para>
          <d:para>EXAMPLE 2 Another use of the <d:code>sizeof</d:code> operator is to compute the
            number of elements in an array:</d:para>
          <d:programlisting role="CLexer">sizeof array / sizeof array[0]</d:programlisting>
          <d:para>In this example, the size of a variable length array is computed and returned from
            a function:</d:para>
          <d:programlisting role="CLexer">#include &lt;stddef.h>
size_t fsize3(int n)
{
  char b[n+3];     // variable length array
  return sizeof b; // execution time sizeof
}
int main()
{
  size_t size;
  size = fsize3(10); // fsize3 returns 13
  return 0;
}</d:programlisting>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> common definitions &lt;stddef.h> (Common definitions
            &lt;stddef.h>), declarations (Declarations), structure and union specifiers (Structure
            and union specifiers), type names (Type names), array declarators (Array
            declarators).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Cast operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Unless the type name specifies a <d:code>void</d:code> type, the type name shall
          specify qualified or unqualified scalar type and the operand shall have scalar
          type.</d:para>
        <d:para>Conversions that involve pointers, other than where permitted by the constraints of
          Simple assignment, shall be specified by means of an explicit cast.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>Preceding an expression by a parenthesized type name converts the value of the
          expression to the named type. This construction is called a cast.<d:footnote>
            <d:para>A cast does not yield an lvalue. Thus, a cast to a qualified type has the same
              effect as a cast to the unqualified version of the type.</d:para>
          </d:footnote> A cast that specifies no conversion has no effect on the type or value of an expression.<d:footnote>
            <d:para>If the value of the expression is represented with greater precision or range
              than required by the type named by the cast (Usual Arithmetic Conversions), then the
              cast specifies a conversion even if the type of the expression is the same as the
              named type.</d:para>
          </d:footnote></d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> equality operators (Equality operators), function declarators
          (including prototypes) (Function declarators (including prototypes)), simple assignment
          (Simple assignment), type names (Type names).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Multiplicative operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have arithmetic type. The operands of the
            <d:code>%</d:code> operator shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The usual arithmetic conversions are performed on the operands.</d:para>
        <d:para>The result of the binary <d:code>*</d:code> operator is the product of the
          operands.</d:para>
        <d:para>The result of the <d:code>/</d:code> operator is the quotient from the division of
          the first operand by the second; the result of the <d:code>%</d:code> operator is the
          remainder. In both operations, if the value of the second operand is zero, the behavior is
          undefined.</d:para>
        <d:para>When integers are divided, the result of the <d:code>/</d:code> operator is the
          algebraic quotient with any fractional part discarded.<d:footnote>
            <d:para>This is often called “truncation toward zero”.</d:para>
          </d:footnote> If the quotient <d:code>a/b</d:code> is representable, the expression
            <d:code>(a/b)*b + a%b</d:code> shall equal <d:code>a</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Additive operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>For addition, either both operands shall have arithmetic type, or one operand shall
          be a pointer to an object type and the other shall have integer type. (Incrementing is
          equivalent to adding 1.)</d:para>
        <d:para>For subtraction, one of the following shall hold:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands have arithmetic type;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands are pointers to qualified or
              unqualified versions of compatible object types; or</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">the left operand is a pointer to an object
              type and the right operand has integer type.</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>(Decrementing is equivalent to subtracting 1.)</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>If both operands have arithmetic type, the usual arithmetic conversions are
          performed on them.</d:para>
        <d:para>The result of the binary <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >+</emphasis> operator is the sum of the operands.</d:para>
        <d:para>The result of the binary <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >-</emphasis> operator is the difference resulting from the subtraction of the second
          operand from the first.</d:para>
        <d:para>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the stype of the object as its element type.</d:para>
        <d:para>When an expression that has integer type is added to or subtracted from a pointer,
          the result has the type of the pointer operand. If the pointer operand points to an
          element of an array object, and the array is large enough, the result points to an element
          offset from the original element such that the difference of the subscripts of the
          resulting and original array elements equals the integer expression. In other words, if
          the expression <d:code>P</d:code> points to the <d:code>i</d:code>-th element of an array
          object, the expressions <d:code>(P)+N</d:code> (equivalently, <d:code>N+(P))</d:code> and
            <d:code>(P)-N</d:code> (where <d:code>N</d:code> has the value <d:code>n</d:code>) point
          to, respectively, the <d:code>i+n</d:code>-th and <d:code>i-n</d:code>-th elements of the
          array object, provided they exist. Moreover, if the expression <d:code>P</d:code> points
          to the last element of an array object, the expression <d:code>(P)+1</d:code> points one
          past the last element of the array object, and if the expression <d:code>Q</d:code> points
          one past the last element of an array object, the expression <d:code>(Q)-1</d:code> points
          to the last element of the array object. If both the pointer operand and the result point
          to elements of the same array object, or one past the last element of the array object,
          the evaluation shall not produce an overflow; otherwise, the behavior is undefined. If the
          result points one past the last element of the array object, it shall not be used as the
          operand of a unary <d:code>*</d:code> operator that is evaluated.</d:para>
        <d:para>When two pointers are subtracted, both shall point to elements of the same array
          object, or one past the last element of the array object; the result is the difference of
          the subscripts of the two array elements. The size of the result is
          implementation-defined, and its type (a signed integer type) is <d:code>ptrdiff_t</d:code>
          defined in the <d:code>&lt;stddef.h></d:code> header. If the result is not representable
          in an object of that type, the behavior is undefined. In other words, if the expressions
            <d:code>P</d:code> and <d:code>Q</d:code> point to, respectively, the
          <d:code>i</d:code>-th and <d:code>j</d:code>-th elements of an array object, the
          expression <d:code>(P)-(Q)</d:code> has the value <d:code>i-j</d:code> provided the value
          fits in an object of type <d:code>ptrdiff_t</d:code>. Moreover, if the expression
            <d:code>P</d:code> points either to an element of an array object or one past the last
          element of an array object, and the expression <d:code>Q</d:code> points to the last
          element of the same array object, the expression <d:code>((Q)+1)-(P)</d:code> has the same
          value as <d:code>((Q)-(P))+1</d:code> and as <d:code>-((P)-((Q)+1))</d:code>, and has the
          value zero if the expression <d:code>P</d:code> points one past the last element of the
          array object, even though the expression <d:code>(Q)+1</d:code> does not point to an
          element of the array object.<d:footnote>
            <d:para>Another way to approach pointer arithmetic is first to convert the pointer(s) to
              character pointer(s): In this scheme the integer expression added to or subtracted
              from the converted pointer is first multiplied by the size of the object originally
              pointed to, and the resulting pointer is converted back to the original type. For
              pointer subtraction, the result of the difference between the character pointers is
              similarly divided by the size of the object originally pointed to.</d:para>
            <d:para>When viewed in this way, an implementation need only provide one extra byte
              (which may overlap another object in the program) just after the end of the object in
              order to satisfy the “one past the last element” requirements.</d:para>
          </d:footnote></d:para>
        <d:para>EXAMPLE Pointer arithmetic is well defined with pointers to variable length array
          types.</d:para>
        <d:programlisting role="CLexer">{
  int n = 4, m = 3;
  int a[n][m];
  int (*p)[m] = a; // p == &amp;a[0]
  p += 1;          // p == &amp;a[1]
  (*p)[2] = 99;    // a[1][2] == 99
  n = p - a;       // n == 1
}</d:programlisting>
        <d:para>If array a in the above example were declared to be an array of known constant size,
          and pointer <d:code>p</d:code> were declared to be a pointer to an array of the same known
          constant size (pointing to <d:code>a</d:code>), the results would be the same.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> array declarators (Array declarators), common definitions
          &lt;stddef.h> (Common definitions &lt;stddef.h>).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Bitwise shift operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraint</emphasis></d:para>
        <d:para>Each of the operands shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The integer promotions are performed on each of the operands. The type of the result
          is that of the promoted left operand. If the value of the right operand is negative or is
          greater than or equal to the width of the promoted left operand, the behavior is
          undefined.</d:para>
        <d:para>The result of <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mo>&lt;&lt;</mml:mo>
              <mml:mi>E</mml:mi>
              <mml:mn>2</mml:mn>
            </mml:math>
          </d:inlineequation>is <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> left-shifted <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>2</mml:mn>
            </mml:math>
          </d:inlineequation> bit positions; vacated bits are filled with zeros. If <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has an unsigned type, the value of the result is <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mtext>&#xA0;</mml:mtext>
              <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
              <mml:mtext>&#xA0;</mml:mtext>
              <mml:msup>
                <mml:mn>2</mml:mn>
                <mml:mrow class="MJX-TeXAtom-ORD">
                  <mml:mi>E</mml:mi>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msup>
            </mml:math>
          </d:inlineequation>, reduced modulo one more than the maximum value representable in the
          result type. If <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has a signed type and nonnegative value, and <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mtext>&#xA0;</mml:mtext>
              <mml:mo>&#x2217;<!-- ∗ --></mml:mo>
              <mml:mtext>&#xA0;</mml:mtext>
              <mml:msup>
                <mml:mn>2</mml:mn>
                <mml:mrow class="MJX-TeXAtom-ORD">
                  <mml:mi>E</mml:mi>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msup>
            </mml:math>
          </d:inlineequation> is representable in the result type, then that is the resulting value;
          otherwise, the behavior is undefined.</d:para>
        <d:para>The result of <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mo>&gt;&gt;</mml:mo>
              <mml:mi>E</mml:mi>
              <mml:mn>2</mml:mn>
            </mml:math>
          </d:inlineequation> is <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> right-shifted <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>2</mml:mn>
            </mml:math>
          </d:inlineequation> bit positions. If <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has an unsigned type or if <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has a signed type and a nonnegative value, the value of the result is
          the integral part of the quotient of <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
              <mml:mrow class="MJX-TeXAtom-ORD">
                <mml:mo>/</mml:mo>
              </mml:mrow>
              <mml:msup>
                <mml:mn>2</mml:mn>
                <mml:mrow class="MJX-TeXAtom-ORD">
                  <mml:mi>E</mml:mi>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msup>
            </mml:math>
          </d:inlineequation>. If <d:inlineequation>
            <mml:math xmlns="http://www.w3.org/1998/Math/MathML">
              <mml:mi>E</mml:mi>
              <mml:mn>1</mml:mn>
            </mml:math>
          </d:inlineequation> has a signed type and a negative value, the resulting value is
          implementation-defined.</d:para>
      </d:sect2>
      <d:sect2>
        <d:title>Relational operators</d:title>
        <d:para><d:emphasis role="bold">Constraints</d:emphasis></d:para>
        <d:para>One of the following shall hold:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <d:para>both operands have real type;</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>both operands are pointers to qualified or unqualified versions of compatible
              object types; or</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>both operands are pointers to qualified or unqualified versions of compatible
              incomplete types.</d:para>
          </d:listitem>
        </d:itemizedlist>
        <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
        <d:para>If both of the operands have arithmetic type, the usual arithmetic conversions are
          performed.</d:para>
        <d:para>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the type of the object as its element type.</d:para>
        <d:para>When two pointers are compared, the result depends on the relative locations in the
          address space of the objects pointed to. If two pointers to object or incomplete types
          both point to the same object, or both point one past the last element of the same array
          object, they compare equal. If the objects pointed to are members of the same aggregate
          object, pointers to structure members declared later compare greater than pointers to
          members declared earlier in the structure, and pointers to array elements with larger
          subscript values compare greater than pointers to elements of the same array with lower
          subscript values. All pointers to members of the same union object compare equal. If the
          expression <d:code>P</d:code> points to an element of an array object and the expression
            <d:code>Q</d:code> points to the last element of the same array object, the pointer
          expression <d:code>Q+1</d:code> compares greater than <d:code>P</d:code>. In all other
          cases, the behavior is undefined.</d:para>
        <d:para>Each of the operators <d:code>&lt;</d:code> (less than), <d:code>></d:code> (greater
          than), <d:code>&lt;=</d:code> (less than or equal to), and <d:code>>=</d:code> (greater
          than or equal to) shall yield 1 if the specified relation is true and 0 if it is false.<d:footnote>
            <d:para>The expression <d:code>a &lt; b &lt; c</d:code> is not interpreted as in ordinary
              mathematics. As the syntax indicates, it means <d:code>(a &lt; b)
	      &lt; c</d:code>; in
              other words, “if a is less than b, compare 1 to c; otherwise, compare 0 to
              c”.</d:para>
          </d:footnote></d:para>
      </d:sect2>
      <d:sect2>
        <d:title>Equality operators</d:title>
        <d:para>Constraints</d:para>
        <d:para>One of the following shall hold:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <d:para>both operands have arithmetic type;</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>both operands are pointers to qualified or unqualified versions of compatible
              types;</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>one operand is a pointer to an object or incomplete type and the other is a
              pointer to a qualified or unqualified version of void; or</d:para>
          </d:listitem>
          <d:listitem>
            <d:para>one operand is a pointer and the other is a null pointer constant.</d:para>
          </d:listitem>
        </d:itemizedlist>
        <d:para><d:emphasis role="bold">Semantics</d:emphasis></d:para>
        <d:para>The <d:code>==</d:code> (equal to) and <d:code>!=</d:code> (not equal to) operators
          are analogous to the relational operators except for their lower precedence. <d:footnote>
            <d:para>Because of the precedences, <d:code>a &lt; b == c &lt; d</d:code> is 1 whenever
                <d:code>a &lt; b</d:code> and <d:code>c &lt; d</d:code> have the same
              truth-value.</d:para>
          </d:footnote> Each of the operators yields 1 if the specified relation is true and 0 if it
          is false. The result has type <d:code>int</d:code>. For any pair of operands, exactly one
          of the relations is true.</d:para>
        <d:para>If both of the operands have arithmetic type, the usual arithmetic conversions are
          performed. Values of complex types are equal if and only if both their real parts are
          equal and also their imaginary parts are equal. Any two values of arithmetic types from
          different type domains are equal if and only if the results of their conversions to the
          (complex) result type determined by the usual arithmetic conversions are equal.</d:para>
        <d:para>Otherwise, at least one operand is a pointer. If one operand is a pointer and the
          other is a null pointer constant, the null pointer constant is converted to the type of
          the pointer. If one operand is a pointer to an object or incomplete type and the other is
          a pointer to a qualified or unqualified version of <d:code>void</d:code>, the former is
          converted to the type of the latter.</d:para>
        <d:para>Two pointers compare equal if and only if both are null pointers, both are pointers
          to the same object (including a pointer to an object and a subobject at its beginning) or
          function, both are pointers to one past the last element of the same array object, or one
          is a pointer to one past the end of one array object and the other is a pointer to the
          start of a different array object that happens to immediately follow the first array
          object in the address space.<d:footnote>
            <d:para>Two objects may be adjacent in memory because they are adjacent elements of a
              larger array or adjacent members of a structure with no padding between them, or
              because the implementation chose to place them so, even though they are unrelated. If
              prior invalid pointer operations (such as accesses outside array bounds) produced
              undefined behavior, subsequent comparisons also produce undefined behavior.</d:para>
          </d:footnote></d:para>
        <d:para>For the purposes of these operators, a pointer to an object that is not an element
          of an array behaves the same as a pointer to the first element of an array of length one
          with the type of the object as its element type.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Bitwise AND operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The usual arithmetic conversions are performed on the operands. The result of the
          binary <d:code>&amp;</d:code> operator is the bitwise AND of the operands (that is, each
          bit in the result is set if and only if each of the corresponding bits in the converted
          operands is set).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Bitwise exlusive OR operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The usual arithmetic conversions are performed on the operands. The result of the
            <d:code>^</d:code> operator is the bitwise exclusive OR of the operands (that is, each
          bit in the result is set if and only if exactly one of the corresponding bits in the
          converted operands is set).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Bitwise inclusive OR operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have integer type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The usual arithmetic conversions are performed on the operands. The result of the
            <d:code>|</d:code> operator is the bitwise inclusive OR of the operands (that is, each
          bit in the result is set if and only if at least one of the corresponding bits in the
          converted operands is set).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Logical AND operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have scalar type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The <d:code>&amp;&amp;</d:code> operator shall yield 1 if both of its operands
          compare unequal to 0; otherwise, it yields 0. The result has type
          <d:code>int</d:code>.</d:para>
        <d:para>Unlike the bitwise binary <d:code>&amp;</d:code> operator, the
            <d:code>&amp;&amp;</d:code> operator guarantees left-to-right evaluation; there is a
          sequence point after the evaluation of the first operand. If the first operand compares
          equal to 0, the second operand is not evaluated.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Logical OR operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each of the operands shall have scalar type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The <d:code>||</d:code> operator shall yield 1 if either of its operands compare
          unequal to 0; otherwise, it yields 0. The result has type <d:code>int</d:code>. Unlike the
          bitwise <d:code>|</d:code> operator, the <d:code>||</d:code> operator guarantees
          left-to-right evaluation; there is a sequence point after the evaluation of the first
          operand. If the first operand compares unequal to 0, the second operand is not
          evaluated.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Conditional operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The first operand shall have scalar type. One of the following shall hold for the
          second and third operands:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands have arithmetic type;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands have the same structure or
              union type;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands have void type;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">both operands are pointers to qualified or
              unqualified versions of compatible types;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">one operand is a pointer and the other is a
              null pointer constant; or</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">one operand is a pointer to an object or
              incomplete type and the other is a pointer to a qualified or unqualified version of
              void.</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para> The first operand is evaluated; there is a sequence point after its evaluation. The
          second operand is evaluated only if the first compares unequal to 0; the third operand is
          evaluated only if the first compares equal to 0; the result is the value of the second or
          third operand (whichever is evaluated), converted to the type described below.<d:footnote>
            <d:para>A conditional expression does not yield an lvalue.</d:para>
          </d:footnote> If an attempt is made to modify the result of a conditional operator or to
          access it after the next sequence point, the behavior is undefined.</d:para>
        <d:para>If both the second and third operands have arithmetic type, the result type that
          would be determined by the usual arithmetic conversions, were they applied to those two
          operands, is the type of the result. If both the operands have structure or union type,
          the result has that type. If both operands have void type, the result has <code
            xmlns="http://docbook.org/ns/docbook">void</code> type.</d:para>
        <d:para>If both the second and third operands are pointers or one is a null pointer constant
          and the other is a pointer, the result type is a pointer to a type qualified with all the
          type qualifiers of the types pointed-to by both operands. Furthermore, if both operands
          are pointers to compatible types or to differently qualified versions of compatible types,
          the result type is a pointer to an appropriately qualified version of the composite type;
          if one operand is a null pointer constant, the result has the type of the other operand;
          otherwise, one operand is a pointer to <d:code>void</d:code> or a qualified version of
            <d:code>void</d:code>, in which case the result type is a pointer to an appropriately
          qualified version of <d:code>void</d:code>.</d:para>
        <d:para>EXAMPLE The common type that results when the second and third operands are pointers
          is determined in two independent stages. The appropriate qualifiers, for example, do not
          depend on whether the two pointers have compatible types.</d:para>
        <d:para>Given the declarations</d:para>
        <d:programlisting role="CLexer">const void *c_vp;
void *vp;
const int *c_ip;
volatile int *v_ip;
int *ip;
const char *c_cp;</d:programlisting>
        <d:para>the third column in the following table is the common type that is the result of a
          conditional expression in which the first two columns are the second and third operands
          (in either order):</d:para>
        <d:programlisting role="CLexer">c_vp c_ip const void *
v_ip 0    volatile int *
c_ip v_ip const volatile int *
vp   c_cp const void *
ip   c_ip const int *
vp   ip   void *</d:programlisting>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Assignment operators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Contraints</emphasis></d:para>
        <d:para>An assignment operator shall have a modifiable lvalue as its left operand.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>An assignment operator stores a value in the object designated by the left operand.
          An assignment expression has the value of the left operand after the assignment, but is
          not an lvalue. The type of an assignment expression is the type of the left operand unless
          the left operand has qualified type, in which case it is the unqualified version of the
          type of the left operand. The side effect of updating the stored value of the left operand
          shall occur between the previous and the next sequence point.</d:para>
        <d:para>The order of evaluation of the operands is unspecified. If an attempt is made to
          modify the result of an assignment operator or to access it after the next sequence point,
          the behavior is undefined.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Simple Assignment</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>One of the following shall hold:<d:footnote>
              <d:para>The asymmetric appearance of these constraints with respect to type qualifiers
                is due to the conversion (specified in Other Operands) that changes lvalues to “the
                value of the expression” and thus removes any type qualifiers that were applied to
                the type category of the expression (for example, it removes <d:code>const</d:code>
                but not <d:code>volatile</d:code> from the type int volatile * const).</d:para>
            </d:footnote></d:para>
          <d:itemizedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">the left operand has qualified or
                unqualified arithmetic type and the right has arithmetic type;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">the left operand has a qualified or
                unqualified version of a structure or union type compatible with the type of the
                right;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">both operands are pointers to qualified or
                unqualified versions of compatible types, and the type pointed to by the left has
                all the qualifiers of the type pointed to by the right;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">one operand is a pointer to an object or
                incomplete type and the other is a pointer to a qualified or unqualified version of
                void, and the type pointed to by the left has all the qualifiers of the type pointed
                to by the right;</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">the left operand is a pointer and the
                right is a null pointer constant; or</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">the left operand has type
                  <code>_Bool</code> and the right is a pointer.</para>
            </d:listitem>
          </d:itemizedlist>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>In simple assignment (=), the value of the right operand is converted to the type
            of the assignment expression and replaces the value stored in the object designated by
            the left operand.</d:para>
          <d:para>If the value being stored in an object is read from another object that overlaps
            in any way the storage of the first object, then the overlap shall be exact and the two
            objects shall have qualified or unqualified versions of a compatible type; otherwise,
            the behavior is undefined.</d:para>
          <d:para>EXAMPLE 1 In the program fragment</d:para>
          <d:programlisting role="CLexer">int f(void);
char c;
/* ... */
if ((c = f()) == -1)
/* ... */</d:programlisting>
          <d:para>the int value returned by the function may be truncated when stored in the
              <d:code>char</d:code>, and then converted back to <d:code>int</d:code> width prior to
            the comparison. In an implementation in which “plain” <d:code>char</d:code> has the same
            range of values as <d:code>unsigned char</d:code> (and <d:code>char</d:code> is narrower
            than <d:code>int</d:code>), the result of the conversion cannot be negative, so the
            operands of the comparison can never compare equal. Therefore, for full portability, the
            variable c should be declared as <d:code>int</d:code>.</d:para>
          <d:para>EXAMPLE 2 In the fragment:</d:para>
          <d:programlisting role="CLexer">char c;
int i;
long l;
l = (c = i);</d:programlisting>
          <d:para>the value of <d:code>i</d:code> is converted to the type of the assignment
            expression <d:code>c = i</d:code>, that is, <d:code>char</d:code> type. The value of the
            expression enclosed in parentheses is then converted to the type of the outer assignment
            expression, that is, <d:code>long int</d:code> type.</d:para>
          <d:para>EXAMPLE 3 Consider the fragment:</d:para>
          <d:programlisting role="CLexer">const char **cpp;
char *p;
const char c = 'A';
cpp = &amp;p;   // constraint violation
*cpp = &amp;c;  // valid
*p = 0;     // valid</d:programlisting>
          <d:para>The first assignment is unsafe because it would allow the following valid code to
            attempt to change the value of the <d:code>const</d:code> object
            <d:code>c</d:code>.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Compound assignments</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>For the operators <d:code>+=</d:code> and <d:code>-=</d:code> only, either the
            left operand shall be a pointer to an object type and the right shall have integer type,
            or the left operand shall have qualified or unqualified arithmetic type and the right
            shall have arithmetic type.</d:para>
          <d:para>For the other operators, each operand shall have arithmetic type consistent with
            those allowed by the corresponding binary operator.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A compound assignment of the form <d:code>E1 op = E2</d:code> differs from the
            simple assignment expression <d:code>E1 = E1 op (E2)</d:code> only in that the lvalue
              <d:code>E1</d:code> is evaluated only once.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Comma operator</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The left operand of a comma operator is evaluated as a void expression; there is a
          sequence point after its evaluation. Then the right operand is evaluated; the result has
          its type and value.<d:footnote>
            <d:para>A comma operator does not yield an lvalue.</d:para>
          </d:footnote> If an attempt is made to modify the result of a comma operator or to access
          it after the next sequence point, the behavior is undefined.</d:para>
        <d:para>EXAMPLE As indicated by the syntax, the comma operator (as described in this
          subclause) cannot appear in contexts where a comma is used to separate items in a list
          (such as arguments to functions or lists of initializers). On the other hand, it can be
          used within a parenthesized expression or within the second expression of a conditional
          operator in such contexts. In the function call:</d:para>
        <d:programlisting roel="CLexer">f(a, (t=3, t+2), c)</d:programlisting>
        <d:para>the function has three arguments, the second of which has the value 5.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> initialization (Initialization).</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Constant expressions</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Description</emphasis></d:para>
      <d:para>A constant expression can be evaluated during translation rather than runtime, and
        accordingly may be used in any place that a constant may be.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Constraints</emphasis></d:para>
      <d:para>Constant expressions shall not contain assignment, increment, decrement,
        function-call, or comma operators, except when they are contained within a subexpression
        that is not evaluated.<d:footnote>
          <d:para>The operand of a <d:code>sizeof</d:code> operator is usually not evaluated (The
            sizeof operator).</d:para>
        </d:footnote></d:para>
      <d:para>Each constant expression shall evaluate to a constant that is in the range of
        representable values for its type.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>An expression that evaluates to a constant is required in several contexts. If a
        floating expression is evaluated in the translation environment, the arithmetic precision
        and range shall be at least as great as if the expression were being evaluated in the
        execution environment.</d:para>
      <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">integer constant
          expression</emphasis><d:footnote>
          <d:para>An integer constant expression is used to specify the size of a bit-field member
            of a structure, the value of an enumeration constant, the size of an array, or the value
            of a case constant. Further constraints that apply to the integer constant expressions
            used in conditional-inclusion preprocessing directives are discussed in Conditional
            Inclusion.</d:para>
        </d:footnote> shall have integer type and shall only have operands that are integer
        constants, enumeration constants, character constants, <d:code>sizeof</d:code> expressions
        whose results are integer constants, and floating constants that are the immediate operands
        of casts. Cast operators in an integer constant expression shall only convert arithmetic
        types to integer types, except as part of an operand to the <d:code>sizeof</d:code>
        operator.</d:para>
      <d:para>More latitude is permitted for constant expressions in initializers. Such a constant
        expression shall be, or evaluate to, one of the following:</d:para>
      <d:itemizedlist>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">an arithmetic constant expression,</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">a null pointer constant,</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">an address constant, or</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">an address constant for an object type plus or
            minus an integer constant expression.</para>
        </d:listitem>
      </d:itemizedlist>
      <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">arithmetic constant
          expression</emphasis> shall have arithmetic type and shall only have operands that are
        integer constants, floating constants, enumeration constants, character constants, and
        sizeof expressions. Cast operators in an arithmetic constant expression shall only convert
        arithmetic types to arithmetic types, except as part of an operand to a
          <d:code>sizeof</d:code> operator whose result is an integer constant.</d:para>
      <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">address
          constant</emphasis> is a null pointer, a pointer to an lvalue designating an object of
        static storage duration, or a pointer to a function designator; it shall be created
        explicitly using the unary <d:code>&amp;</d:code> operator or an integer constant cast to
        pointer type, or implicitly by the use of an expression of array or function type. The
        array-subscript <d:code>[]</d:code> and member-access <d:code>.</d:code> and
          <d:code>-></d:code> operators, the address <d:code>&amp;</d:code> and indirection
          <d:code>*</d:code> unary operators, and pointer casts may be used in the creation of an
        address constant, but the value of an object shall not be accessed by use of these
        operators.</d:para>
      <d:para>An implementation may accept other forms of constant expressions.</d:para>
      <d:para>The semantic rules for the evaluation of a constant expression are the same as for
        nonconstant expressions.<d:footnote>
          <d:para>Thus, in the following initialization, <d:code>static int i = 2 || 1 / 0;
            </d:code>the expression is a valid integer constant expression with value one.</d:para>
        </d:footnote></d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> array declarators (Array declarators), initialization
        (Initialization).</d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Declarations</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Constraints</emphasis></d:para>
      <d:para>A declaration shall declare at least a declarator (other than the parameters of a
        function or the members of a structure or union), a tag, or the members of an
        enumeration.</d:para>
      <d:para>If an identifier has no linkage, there shall be no more than one declaration of the
        identifier (in a declarator or type specifier) with the same scope and in the same name
        space, except for tags as specified in Tags.</d:para>
      <d:para>All declarations in the same scope that refer to the same object or function shall
        specify compatible types.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>A declaration specifies the interpretation and attributes of a set of identifiers. A
        definition of an identifier is a declaration for that identifier that:</d:para>
      <d:itemizedlist>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">for an object, causes storage to be reserved
            for that object;</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">for a function, includes the function body;<footnote>
              <para>Function definitions have a different syntax, described in Function
                definitions.</para>
            </footnote></para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">for an enumeration constant or typedef name,
            is the (only) declaration of the identifier.</para>
        </d:listitem>
      </d:itemizedlist>
      <d:para>The declaration specifiers consist of a sequence of specifiers that indicate the
        linkage, storage duration, and part of the type of the entities that the declarators denote.
        The init- declarator-list is a comma-separated sequence of declarators, each of which may
        have additional type information, or an initializer, or both. The declarators contain the
        identifiers (if any) being declared.</d:para>
      <d:para>If an identifier for an object is declared with no linkage, the type for the object
        shall be complete by the end of its declarator, or by the end of its init-declarator if it
        has an initializer; in the case of function parameters (including in prototypes), it is the
        adjusted type (see Function declarators (including prototypes)) that is required to be
        complete.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> declarators (Declarators), enumeration specifiers (Enumeration
        specifiers), initialization (Initialization).</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Storage-class specifiers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>At most, one storage-class specifier may be given in the declaration specifiers in a
          declaration.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The typedef specifier is called a “storage-class specifier” for syntactic
          convenience only; it is discussed in Type definitions. The meanings of the various
          linkages and storage durations were discussed in Linkages of identifiers and Storage
          duration of objects.</d:para>
        <d:para>A declaration of an identifier for an object with storage-class specifier
            <d:code>register</d:code> suggests that access to the object be as fast as possible. The
          extent to which such suggestions are effective is implementation-defined.<d:footnote>
            <d:para>The implementation may treat any <d:code>register</d:code> declaration simply as
              an auto declaration. However, whether or not addressable storage is actually used, the
              address of any part of an object declared with storage-class specifier register cannot
              be computed, either explicitly (by use of the unary &amp; operator as discussed in
              Address and indirection operators) or implicitly (by converting an array name to a
              pointer as discussed in :ref:14.3.2.1`). Thus, the only operator that can be applied
              to an array declared with storage-class specifier <d:code>register</d:code> is
                <d:code>sizeof</d:code>.</d:para>
          </d:footnote></d:para>
        <d:para>The declaration of an identifier for a function that has block scope shall have no
          explicit storage-class specifier other than <d:code>extern</d:code>.</d:para>
        <d:para>If an aggregate or union object is declared with a storage-class specifier other
          than <d:code>typedef</d:code>, the properties resulting from the storage-class specifier,
          except with respect to linkage, also apply to the members of the object, and so on
          recursively for any aggregate or union member objects.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> type definitions (Type definitions).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Type specifiers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>At least one type specifier shall be given in the declaration specifiers in each
          declaration, and in the specifier-qualifier list in each struct declaration and type name.
          Each list of type specifiers shall be one of the following sets (delimited by commas, when
          there is more than one set on a line); the type specifiers may occur in any order,
          possibly intermixed with the other declaration specifiers.</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>void</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>char</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>signed char</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned char</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>short, signed short, short int</code>
              or <code>signed short int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned short</code> or
                <code>unsigned short int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>int, signed</code> or <code>signed
                int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned</code> or <code>unsigned
                int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long, signed long, long int</code> or
                <code>signed long int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned long</code> or <code>unsigned
                long int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long long, signed long long, long long
                int</code> or <code>signed long long int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>unsigned long long</code> or
                <code>unsigned long long int</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>float</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>double</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long double</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>_Bool</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>float _Complex</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>double _Complex</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>long double _Complex</code></para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>struct</code> or <code>union</code>
              specifier</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>enum</code> specifier</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook"><code>typedef</code> name </para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>The type specifier <d:code>_Complex</d:code> shall not be used if the implementation
          does not provide complex types.<d:footnote>
            <d:para>Freestanding implementations are not required to provide complex types.</d:para>
          </d:footnote></d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>Specifiers for structures, unions, and enumerations are discussed in Structure and
          union specifiers through Tags. Declarations of typedef names are discussed in Type
          definitions. The characteristics of the other types are discussed in Types.</d:para>
        <d:para>Each of the comma-separated sets designates the same type, except that for
          bit-fields, it is implementation-defined whether the specifier int designates the same
          type as <d:code>signed int</d:code> or the same type as <d:code>unsigned
          int</d:code>.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> enumeration specifiers (Enumeration specifiers), structure and
          union specifiers (Structure and union specifiers), tags (Tags), type definitions (Type
          definitions).</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Structure and union specifiers</title>
          <d:para>A structure or union shall not contain a member with incomplete or function type
            (hence, a structure shall not contain an instance of itself, but may contain a pointer
            to an instance of itself), except that the last member of a structure with more than one
            named member may have incomplete array type; such a structure (and any union containing,
            possibly recursively, a member that is such a structure) shall not be a member of a
            structure or an element of an array.</d:para>
          <d:para>The expression that specifies the width of a bit-field shall be an integer
            constant expression with a nonnegative value that does not exceed the width of an object
            of the type that would be specified were the colon and expression omitted. If the value
            is zero, the declaration shall have no declarator.</d:para>
          <d:para>A bit-field shall have a type that is a qualified or unqualified version of
              <d:code>_Bool, signed int, unsigned int</d:code> or some other implementation-defined
            type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>As discussed in Types, a structure is a type consisting of a sequence of members,
            whose storage is allocated in an ordered sequence, and a union is a type consisting of a
            sequence of members whose storage overlap.</d:para>
          <d:para>Structure and union specifiers have the same form.</d:para>
          <d:para>The presence of a struct-declaration-list in a struct-or-union-specifier declares
            a new type, within a translation unit. The struct-declaration-list is a sequence of
            declarations for the members of the structure or union. If the struct-declaration-list
            contains no named members, the behavior is undefined. The type is incomplete until after
            the <d:code>}</d:code> that terminates the list.</d:para>
          <d:para>A member of a structure or union may have any object type other than a variably
            modified type.<d:footnote>
              <d:para>A structure or union can not contain a member with a variably modified type
                because member names are not ordinary identifiers as defined in Name Spaces of the
                Identifiers.</d:para>
            </d:footnote> In addition, a member may be declared to consist of a specified number of
            bits (including a sign bit, if any). Such a member is called a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">bit-field</emphasis>;<d:footnote>
              <d:para>The unary <d:code>&amp;</d:code> (address-of) operator cannot be applied to a
                bit-field object; thus, there are no pointers to or arrays of bit-field
                objects.</d:para>
            </d:footnote> its width is preceded by a colon.</d:para>
          <d:para>A bit-field is interpreted as a signed or unsigned integer type consisting of the
            specified number of bits.<d:footnote>
              <d:para>As specified in Type specifiers above, if the actual type specifier used is
                  <d:code>int</d:code> or a typedef-name defined as <d:code>int</d:code>, then it is
                implementation-defined whether the bit-field is signed or unsigned.</d:para>
            </d:footnote> If the value 0 or 1 is stored into a nonzero-width bit-field of type
              <d:code>_Bool</d:code>, the value of the bit-field shall compare equal to the value
            stored.</d:para>
          <d:para>An implementation may allocate any addressable storage unit large enough to hold a
            bit- field. If enough space remains, a bit-field that immediately follows another
            bit-field in a structure shall be packed into adjacent bits of the same unit. If
            insufficient space remains, whether a bit-field that does not fit is put into the next
            unit or overlaps adjacent units is implementation-defined. The order of allocation of
            bit-fields within a unit (high-order to low-order or low-order to high-order) is
            implementation-defined. The alignment of the addressable storage unit is
            unspecified.</d:para>
          <d:para>A bit-field declaration with no declarator, but only a colon and a width,
            indicates an unnamed bit-field.<d:footnote>
              <d:para>An unnamed bit-field structure member is useful for padding to conform to
                externally imposed layouts.</d:para>
            </d:footnote>As a special case, a bit-field structure member with a width of 0 indicates
            that no further bit-field is to be packed into the unit in which the previous bit-
            field, if any, was placed.</d:para>
          <d:para>Each non-bit-field member of a structure or union object is aligned in an
            implementation- defined manner appropriate to its type.</d:para>
          <d:para>Within a structure object, the non-bit-field members and the units in which
            bit-fields reside have addresses that increase in the order in which they are declared.
            A pointer to a structure object, suitably converted, points to its initial member (or if
            that member is a bit-field, then to the unit in which it resides), and vice versa. There
            may be unnamed padding within a structure object, but not at its beginning.</d:para>
          <d:para>The size of a union is sufficient to contain the largest of its members. The value
            of at most one of the members can be stored in a union object at any time. A pointer to
            a union object, suitably converted, points to each of its members (or if a member is a
            bit- field, then to the unit in which it resides), and vice versa.</d:para>
          <d:para>There may be unnamed padding at the end of a structure or union.</d:para>
          <d:para>As a special case, the last element of a structure with more than one named member
            may have an incomplete array type; this is called a <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">flexible array member</emphasis>.
            In most situations, the flexible array member is ignored. In particular, the size of the
            structure is as if the flexible array member were omitted except that it may have more
            trailing padding than the omission would imply. However, when a <d:code>.</d:code> (or
              <d:code>-></d:code>) operator has a left operand that is (a pointer to) a structure
            with a flexible array member and the right operand names that member, it behaves as if
            that member were replaced with the longest array (with the same element type) that would
            not make the structure larger than the object being accessed; the offset of the array
            shall remain that of the flexible array member, even if this would differ from that of
            the replacement array. If this array would have no elements, it behaves as if it had one
            element but the behavior is undefined if any attempt is made to access that element or
            to generate a pointer one past it.</d:para>
          <d:para>EXAMPLE After the declaration:</d:para>
          <d:programlisting role="CLexer">struct s { int n; double d[]; };</d:programlisting>
          <d:para>the structure struct s has a flexible array member d. A typical way to use this
            is:</d:para>
          <d:programlisting role="CLexer">int m = /* some value */;
struct s *p = malloc(sizeof (struct s) + sizeof (double [m]));</d:programlisting>
          <d:para>and assuming that the call to malloc succeeds, the object pointed to by p behaves,
            for most purposes, as if p had been declared as:</d:para>
          <d:programlisting role="CLexer">struct { int n; double d[m]; } *p;</d:programlisting>
          <d:para>(there are circumstances in which this equivalence is broken; in particular, the
            offsets of member d might not be the same).</d:para>
          <d:para>Following the above declaration:</d:para>
          <d:programlisting role="CLexer">struct s t1 = { 0 };         // valid
struct s t2 = { 1, { 4.2 }}; // invalid
t1.n = 4;                    // valid
t1.d[0] = 4.2;               // might be undefined behavior</d:programlisting>
          <d:para>The initialization of <d:code>t2</d:code> is invalid (and violates a constraint)
            because <d:code>struct s</d:code> is treated as if it did not contain member
              <d:code>d</d:code>. The assignment to <d:code>t1.d[0]</d:code> is probably undefined
            behavior, but it is possible that</d:para>
          <d:programlisting role="CLexer">sizeof (struct s) >= offsetof(struct s, d) + sizeof (double)</d:programlisting>
          <d:para>in which case the assignment would be legitimate. Nevertheless, it cannot appear
            in strictly conforming code. After the further declaration:</d:para>
          <d:programlisting role="CLexer">struct ss { int n; };
the expressions:
sizeof (struct s) >= sizeof (struct ss)
sizeof (struct s) >= offsetof(struct s, d)</d:programlisting>
          <d:para>are always equal to 1.</d:para>
          <d:para>If <d:code>sizeof (double)</d:code> is 8, then after the following code is
            executed:</d:para>
          <d:programlisting role="CLexer">struct s *s1;
struct s *s2;
s1 = malloc(sizeof (struct s) + 64);
s2 = malloc(sizeof (struct s) + 46);</d:programlisting>
          <d:para>and assuming that the calls to <d:code>malloc</d:code> succeed, the objects
            pointed to by <d:code>s1</d:code> and <d:code>s2</d:code> behave, for most purposes, as
            if the identifiers had been declared as:</d:para>
          <d:programlisting role="CLexer">struct { int n; double d[8]; } *s1;
struct { int n; double d[5]; } *s2;</d:programlisting>
          <d:para>Following the further successful assignments:</d:para>
          <d:programlisting role="CLexer">s1 = malloc(sizeof (struct s) + 10);
s2 = malloc(sizeof (struct s) + 6);</d:programlisting>
          <d:para>they then behave as if the declarations were:</d:para>
          <d:programlisting role="CLexer">struct { int n; double d[1]; } *s1, *s2;</d:programlisting>
          <d:para>and:</d:para>
          <d:programlisting role="CLexer">double *dp;
dp = &amp;(s1->d[0]); // valid
*dp = 42;         // valid
dp = &amp;(s2->d[0]); // valid
*dp = 42;         // undefined behavior</d:programlisting>
          <d:para>The assignment:</d:para>
          <d:programlisting>*s1 = *s2;</d:programlisting>
          <d:para>only copies the member <d:code>n</d:code>; if any of the array elements are within
            the first <d:code>sizeof (struct s)</d:code> bytes of the structure, they might be
            copied or simply overwritten with indeterminate values.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> tags (Tags).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Enumeration specifiers</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The expression that defines the value of an enumeration constant shall be an
            integer constant expression that has a value representable as an
            <d:code>int</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>The identifiers in an enumerator list are declared as constants that have type int
            and may appear wherever such are permitted.<d:footnote>
              <d:para>Thus, the identifiers of enumeration constants declared in the same scope
                shall all be distinct from each other and from other identifiers declared in
                ordinary declarators.</d:para>
            </d:footnote> An enumerator with = defines its enumeration constant as the value of the
            constant expression. If the first enumerator has no =, the value of its enumeration
            constant is 0. Each subsequent enumerator with no = defines its enumeration constant as
            the value of the constant expression obtained by adding 1 to the value of the previous
            enumeration constant. (The use of enumerators with = may produce enumeration constants
            with values that duplicate other values in the same enumeration.) The enumerators of an
            enumeration are also known as its members.</d:para>
          <d:para>Each enumerated type shall be compatible with char, a signed integer type, or an
            unsigned integer type. The choice of type is implementation-defined,<d:footnote>
              <d:para>An implementation may delay the choice of which integer type until all
                enumeration constants have been seen.</d:para>
            </d:footnote> but shall be capable of representing the values of all the members of the
            enumeration. The enumerated type is incomplete until after the } that terminates the
            list of enumerator declarations.</d:para>
          <d:para>The following fragment:</d:para>
          <d:programlisting role="CLexer">enum hue { chartreuse, burgundy, claret=20, winedark };
enum hue col, *cp;
col = claret;
cp = &amp;col;
if (*cp != burgundy)
/* ... */</d:programlisting>
          <d:para>makes <d:code>hue</d:code> the tag of an enumeration, and then declares
              <d:code>col</d:code> as an object that has that type and <d:code>cp</d:code> as a
            pointer to an object that has that type. The enumerated values are in the set <d:code>{
              0, 1, 20, 21 }</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> tags (Tags).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Tags</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>A specific type shall have its content defined at most once.</d:para>
          <d:para>A type specifier of the form:</d:para>
          <d:programlisting>enum *identifier*</d:programlisting>
          <d:para>without an enumerator list shall only appear after the type it specifies is
            complete.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>All declarations of structure, union, or enumerated types that have the same scope
            and use the same tag declare the same type. The type is incomplete<d:footnote>
              <d:para>An incomplete type may only by used when the size of an object of that type is
                not needed. It is not needed, for example, when a typedef name is declared to be a
                specifier for a structure or union, or when a pointer to or a function returning a
                structure or union is being declared. (See incomplete types in Types.) The
                specification has to be complete before such a function is called or
                defined.</d:para>
            </d:footnote> until the closing brace of the list defining the content, and complete
            thereafter.</d:para>
          <d:para>Two declarations of structure, union, or enumerated types which are in different
            scopes or use different tags declare distinct types. Each declaration of a structure,
            union, or enumerated type which does not include a tag declares a distinct
            type.</d:para>
          <d:para>A type specifier of the form:</d:para>
          <d:programlisting>struct-or-union identifier(optional) { struct-declaration-list }</d:programlisting>
          <d:para>or:</d:para>
          <d:programlisting>enum identifier { enumerator-list }</d:programlisting>
          <d:para>or:</d:para>
          <d:programlisting>enum identifier { enumerator-list , }</d:programlisting>
          <d:para>declares a structure, union, or enumerated type. The list defines the <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">structure content, union
              content</emphasis> or <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >enumeration content</emphasis>. If an identifier is provided,<d:footnote>
              <d:para>If there is no identifier, the type can, within the translation unit, only be
                referred to by the declaration of which it is a part. Of course, when the
                declaration is of a typedef name, subsequent declarations can make use of that
                typedef name to declare objects having the specified structure, union, or enumerated
                type.</d:para>
            </d:footnote> the type specifier also declares the identifier to be the tag of that
            type.</d:para>
          <d:para>A declaration of the form:</d:para>
          <d:programlisting>struct-or-union identifier ;</d:programlisting>
          <d:para>specifies a structure or union type and declares the identifier as a tag of that
              type.<d:footnote xml:id="b">
              <d:para>A similar construction with <d:code>enum</d:code> does not exist.</d:para>
            </d:footnote></d:para>
          <d:para>If a type specifier of the form:</d:para>
          <d:programlisting>struct-or-union identifier</d:programlisting>
          <d:para>occurs other than as part of one of the above forms, and no other declaration of
            the identifier as a tag is visible, then it declares an incomplete structure or union
            type, and declares the identifier as the tag of that type.<d:footnoteref linkend="b"
            /></d:para>
          <d:para>If a type specifier of the form:</d:para>
          <d:programlisting>struct-or-union identifier</d:programlisting>
          <d:para>or:</d:para>
          <d:programlisting>enum specifier</d:programlisting>
          <d:para>occurs other than as part of one of the above forms, and a declaration of the
            identifier as a tag is visible, then it specifies the same type as that other
            declaration, and does not redeclare the tag.</d:para>
          <d:para>EXAMPLE 1 This mechanism allows declaration of a self-referential
            structure.</d:para>
          <d:programlisting role="CLexer">struct tnode {
  int count;
  struct tnode *left, *right;
};</d:programlisting>
          <d:para>specifies a structure that contains an integer and two pointers to objects of the
            same type. Once this declaration has been given, the declaration</d:para>
          <d:programlisting role="CLexer">struct tnode s, *sp;</d:programlisting>
          <d:para>declares <d:code>s</d:code> to be an object of the given type and
              <d:code>sp</d:code> to be a pointer to an object of the given type. With these
            declarations, the expression <d:code>sp->left</d:code> refers to the <d:code>left struct
              tnode</d:code> pointer of the object to which sp points; the expression
              <d:code>s.right->count</d:code> designates the count member of the <d:code>right
              struct tnode</d:code> pointed to from <d:code>s</d:code>.</d:para>
          <d:para>The following alternative formulation uses the typedef mechanism:</d:para>
          <d:programlisting role="CLexer">typedef struct tnode TNODE;
struct tnode {
  int count;
  TNODE *left, *right;
};
TNODE s, *sp;</d:programlisting>
          <d:para>EXAMPLE 2 To illustrate the use of prior declaration of a tag to specify a pair of
            mutually referential structures, the declarations</d:para>
          <d:programlisting role="CLexer">struct s1 { struct s2 *s2p; /* ... */ }; // D1
struct s2 { struct s1 *s1p; /* ... */ }; // D2</d:programlisting>
          <d:para>specify a pair of structures that contain pointers to each other. Note, however,
            that if <d:code>s2</d:code> were already declared as a tag in an enclosing scope, the
            declaration <d:code>D1</d:code> would refer to it, not to the tag <d:code>s2</d:code>
            declared in <d:code>D2</d:code>. To eliminate this context sensitivity, the
            declaration</d:para>
          <d:programlisting role="CLexer">struct s2;</d:programlisting>
          <d:para>may be inserted ahead of <d:code>D1</d:code>. This declares a new tag
              <d:code>s2</d:code> in the inner scope; the declaration <d:code>D2</d:code> then
            completes the specification of the new type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> declarators (Declarators), array declarators (Array
            declarators), type definitions (Type definitions).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Type qualifiers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Types other than pointer types derived from object or incomplete types shall not be
          restrict-qualified.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The properties associated with qualified types are meaningful only for expressions
          that are lvalues.<d:footnote>
            <d:para>The implementation may place a const object that is not
                <d:code>volatile</d:code> in a read-only region of storage. Moreover, the
              implementation need not allocate storage for such an object if its address is never
              used.</d:para>
          </d:footnote></d:para>
        <d:para>If the same qualifier appears more than once in the same <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">specifier-qualifier-list</emphasis>,
          either directly or via one or more typedefs, the behavior is the same as if it appeared
          only once. If an attempt is made to modify an object defined with a const-qualified type
          through use of an lvalue with non-const-qualified type, the behavior is
          undefined.</d:para>
        <d:para>If an attempt is made to refer to an object defined with a volatile-qualified type
          through use of an lvalue with non-volatile-qualified type, the behavior is undefined.<d:footnote>
            <d:para>This applies to those objects that behave as if they were defined with qualified
              types, even if they are never actually defined as objects in the program (such as an
              object at a memory-mapped input/output address).</d:para>
          </d:footnote></d:para>
        <d:para>An object that has volatile-qualified type may be modified in ways unknown to the
          implementation or have other unknown side effects. Therefore any expression referring to
          such an object shall be evaluated strictly according to the rules of the abstract machine,
          as described in Program Execution. Furthermore, at every sequence point the value last
          stored in the object shall agree with that prescribed by the abstract machine, except as
          modified by the unknown factors mentioned previously.<d:footnote>
            <d:para>A <d:code>volatile</d:code> declaration may be used to describe an object
              corresponding to a memory-mapped input/output port or an object accessed by an
              asynchronously interrupting function. Actions on objects so declared shall not be
              “optimized out” by an implementation or reordered except as permitted by the rules for
              evaluating expressions.</d:para>
          </d:footnote> What constitutes an access to an object that has volatile-qualified type is
          implementation-defined.</d:para>
        <d:para>An object that is accessed through a restrict-qualified pointer has a special
          association with that pointer. This association, defined in Formal definition of restrict
          below, requires that all accesses to that object use, directly or indirectly, the value of
          that particular pointer.<d:footnote>
            <d:para>For example, a statement that assigns a value returned by malloc to a single
              pointer establishes this association between the allocated object and the
              pointer.</d:para>
          </d:footnote> The intended use of the <d:code>restrict</d:code> qualifier (like the
            <d:code>register</d:code> storage class) is to promote optimization, and deleting all
          instances of the qualifier from all preprocessing translation units composing a conforming
          program does not change its meaning (i.e., observable behavior).</d:para>
        <d:para>If the specification of an array type includes any type qualifiers, the element type
          is so- qualified, not the array type. If the specification of a function type includes any
          type qualifiers, the behavior is undefined.<d:footnote>
            <d:para>Both of these can occur through the use of typedefs.</d:para>
          </d:footnote></d:para>
        <d:para>For two qualified types to be compatible, both shall have the identically qualified
          version of a compatible type; the order of type qualifiers within a list of specifiers or
          qualifiers does not affect the specified type.</d:para>
        <d:para>EXAMPLE 1 An object declared</d:para>
        <d:programlisting role="CLexer">extern const volatile int real_time_clock;</d:programlisting>
        <d:para>may be modifiable by hardware, but cannot be assigned to, incremented, or
          decremented.</d:para>
        <d:para>EXAMPLE 2 The following declarations and expressions illustrate the behavior when
          type qualifiers modify an aggregate type:</d:para>
        <d:programlisting role="CLexer">const struct s { int mem; } cs = { 1 };
struct s ncs; // the object ncs is modifiable
typedef int A[2][3];
const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const int
int *pi;
const int *pci;

ncs = cs;       // valid
cs = ncs;       // violates modifiable lvalue constraint for =
pi = &amp;ncs.mem;  // valid
pi = &amp;cs.mem;   // violates type constraints for =
pci = &amp;cs.mem;  // valid
pi = a[0];      // nvalid: a[0] has type "const int *"</d:programlisting>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Formal definition of restrict</title>
          <d:para>Let <d:code>D</d:code> be a declaration of an ordinary identifier that provides a
            means of designating an object <d:code>P</d:code> as a restrict-qualified pointer to
            type <d:code>T</d:code>.</d:para>
          <d:para>If <d:code>D</d:code> appears inside a block and does not have storage class
              <d:code>extern</d:code>, let <d:code>B</d:code> denote the block. If
              <d:code>D</d:code> appears in the list of parameter declarations of a function
            definition, let <d:code>B</d:code> denote the associated block. Otherwise, let
              <d:code>B</d:code> denote the block of main (or the block of whatever function is
            called at program startup in a freestanding environment).</d:para>
          <d:para>In what follows, a pointer expression <d:code>E</d:code> is said to be based on
            object <d:code>P</d:code> if (at some sequence point in the execution of
              <d:code>B</d:code> prior to the evaluation of <d:code>E</d:code>) modifying
              <d:code>P</d:code> to point to a copy of the array object into which it formerly
            pointed would change the value of <d:code>E</d:code>.<d:footnote>
              <d:para>In other words, <d:code>E</d:code> depends on the value of <d:code>P</d:code>
                itself rather than on the value of an object referenced indirectly through
                  <d:code>P</d:code>. For example, if identifier <d:code>p</d:code> has type
                  (<d:code>int **restrict</d:code>), then the pointer expressions <d:code>p</d:code>
                and <d:code>p+1</d:code> are based on the restricted pointer object designated by
                  <d:code>p</d:code>, but the pointer expressions <d:code>*p</d:code> and
                  <d:code>p[1]</d:code> are not.</d:para>
            </d:footnote> Note that “based” is defined only for expressions with pointer
            types.</d:para>
          <d:para>During each execution of <d:code>B</d:code>, let <d:code>L</d:code> be any lvalue
            that has <d:code>&amp;L</d:code> based on <d:code>P</d:code>. If L is used to access the
            value of the object <d:code>X</d:code> that it designates, and <d:code>X</d:code> is
            also modified (by any means), then the following requirements apply: <d:code>T</d:code>
            shall not be const-qualified. Every other lvalue used to access the value of
              <d:code>X</d:code> shall also have its address based on <d:code>P</d:code>. Every
            access that modifies <d:code>X</d:code> shall be considered also to modify
              <d:code>P</d:code>, for the purposes of this subclause. If <d:code>P</d:code> is
            assigned the value of a pointer expression <d:code>E</d:code> that is based on another
            restricted pointer object <d:code>P2</d:code>, associated with block
            <d:code>B2</d:code>, then either the execution of <d:code>B2</d:code> shall begin before
            the execution of <d:code>B</d:code>, or the execution of <d:code>B2</d:code> shall end
            prior to the assignment. If these requirements are not met, then the behavior is
            undefined.</d:para>
          <d:para>Here an execution of <d:code>B</d:code> means that portion of the execution of the
            program that would correspond to the lifetime of an object with scalar type and
            automatic storage duration ssociated with <d:code>B</d:code>.</d:para>
          <d:para>A translator is free to ignore any or all aliasing implications of uses of
            restrict.</d:para>
          <d:para>EXAMPLE 1 The file scope declarations</d:para>
          <d:programlisting role="CLexer">int * restrict a;
int * restrict b;
extern int c[];</d:programlisting>
          <d:para>assert that if an object is accessed using one of <d:code>a, b</d:code> or
              <d:code>c</d:code>, and that object is modified anywhere in the program, then it is
            never accessed using either of the other two.</d:para>
          <d:para>EXAMPLE 2 The function parameter declarations in the following example</d:para>
          <d:programlisting role="CLexer">void f(int n, int * restrict p, int * restrict q)
{
  while (n-- > 0)
  *p++ = *q++;
}</d:programlisting>
          <d:para>assert that, during each execution of the function, if an object is accessed
            through one of the pointer parameters, then it is not also accessed through the
            other.</d:para>
          <d:para>The benefit of the restrict qualifiers is that they enable a translator to make an
            effective dependence analysis of function <d:code>f</d:code> without examining any of
            the calls of <d:code>f</d:code> in the program. The cost is that the programmer has to
            examine all of those calls to ensure that none give undefined behavior. For example, the
            second call of <d:code>f</d:code> in <d:code>g</d:code> has undefined behavior because
            each of <d:code>d[1]</d:code> through <d:code>d[49]</d:code> is accessed through both
              <d:code>p</d:code> and <d:code>q</d:code>.</d:para>
          <d:programlisting role="CLexer">void g(void)
{
  extern int d[100];
  f(50, d + 50, d); // valid
  f(50, d + 1, d); // undefined behavior
}</d:programlisting>
          <d:para>EXAMPLE 3 The function parameter declarations</d:para>
          <d:programlisting role="CLexer">void h(int n, int * restrict p, int * restrict q, int * restrict r)
{
  int i;
  for (i = 0; i &lt; n; i++)
  p[i] = q[i] + r[i];
}</d:programlisting>
          <d:para>illustrate how an unmodified object can be aliased through two restricted
            pointers. In particular, if <d:code>a</d:code> and <d:code>b</d:code> are disjoint
            arrays, a call of the form <d:code>h(100, a, b, b)</d:code> has defined behavior,
            because array <d:code>b</d:code> is not modified within function
            <d:code>h</d:code>.</d:para>
          <d:para>EXAMPLE 4 The rule limiting assignments between restricted pointers does not
            distinguish between a function call and an equivalent nested block. With one exception,
            only “outer-to-inner” assignments between restricted pointers declared in nested blocks
            have defined behavior.</d:para>
          <d:programlisting role="CLexer">{
  int * restrict p1;
  int * restrict q1;
  p1 = q1; // undefined behavior
  {
    int * restrict p2 = p1; // valid
    int * restrict q2 = q1; // valid
    p1 = q2;                // undefined behavior
    p2 = q2;                // undefined behavior
  }
}</d:programlisting>
          <d:para>The one exception allows the value of a restricted pointer to be carried out of
            the block in which it (or, more precisely, the ordinary identifier used to designate it)
            is declared when that block finishes execution. For example, this permits
              <d:code>new_vector</d:code> to return a <d:code>vector</d:code>.</d:para>
          <d:programlisting role="CLexer">typedef struct { int n; float * restrict v; } vector;
vector new_vector(int n)
{
  vector t;
  t.n = n;
  t.v = malloc(n * sizeof (float));
  return t;
}</d:programlisting>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Function specifiers</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Function specifiers shall be used only in the declaration of an identifier for a
          function.</d:para>
        <d:para>An <d:code>inline</d:code> definition of a function with external linkage shall not
          contain a definition of a modifiable object with static storage duration, and shall not
          contain a reference to an identifier with internal linkage.</d:para>
        <d:para>In a hosted environment, the inline function specifier shall not appear in a
          declaration of <d:code>main</d:code>.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A function declared with an <d:code>inline</d:code> function specifier is an
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">inline
          function</emphasis>. The function specifier may appear more than once; the behavior is the
          same as if it appeared only once. Making a function an inline function suggests that calls
          to the function be as fast as possible.<d:footnote>
            <d:para>By using, for example, an alternative to the usual function call mechanism, such
              as “inline substitution”. Inline substitution is not textual substitution, nor does it
              create a new function. Therefore, for example, the expansion of a macro used within
              the body of the function uses the definition it had at the point the function body
              appears, and not where the function is called; and identifiers refer to the
              declarations in scope where the body occurs. Likewise, the function has a single
              address, regardless of the number of inline definitions that occur in addition to the
              external definition.</d:para>
          </d:footnote> The extent to which such suggestions are effective is implementation-defined.<d:footnote>
            <d:para>For example, an implementation might never perform inline substitution, or might
              only perform inline substitutions to calls in the scope of an inline
              declaration.</d:para>
          </d:footnote></d:para>
        <d:para>Any function with internal linkage can be an inline function. For a function with
          external linkage, the following restrictions apply: If a function is declared with an
            <d:code>inline</d:code> function specifier, then it shall also be defined in the same
          translation unit. If all of the file scope declarations for a function in a translation
          unit include the <d:code>inline</d:code> function specifier without
            <d:code>extern</d:code>, then the definition in that translation unit is an <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">inline definition</emphasis>. An
          inline definition does not provide an external definition for the function, and does not
          forbid an external definition in another translation unit. An inline definition provides
          an alternative to an external definition, which a translator may use to implement any call
          to the function in the same translation unit. It is unspecified whether a call to the
          function uses the inline definition or the external definition.<d:footnote>
            <d:para>Since an inline definition is distinct from the corresponding external
              definition and from any other corresponding inline definitions in other translation
              units, all corresponding objects with static storage duration are also distinct in
              each of the definitions.</d:para>
          </d:footnote></d:para>
        <d:para>EXAMPLE The declaration of an inline function with external linkage can result in
          either an external definition, or a definition available for use only within the
          translation unit. A file scope declaration with extern creates an
            <d:code>external</d:code> definition. The following example shows an entire translation
          unit.</d:para>
        <d:programlisting role="CLexer">inline double fahr(double t)
{
  return (9.0 * t) / 5.0 + 32.0;
}
inline double cels(double t)
{
  return (5.0 * (t - 32.0)) / 9.0;
}
extern double fahr(double);
// creates an external definition
double convert(int is_fahr, double temp)
{
  /* A translator may perform inline substitutions */
  return is_fahr ? cels(temp) : fahr(temp);
}</d:programlisting>
        <d:para>Note that the definition of <d:code>fahr</d:code> is an external definition because
            <d:code>fahr</d:code> is also declared with <d:code>extern</d:code>, but the definition
          of <d:code>cels</d:code> is an inline definition. Because <d:code>cels</d:code> has
          external linkage and is referenced, an external definition has to appear in another
          translation unit (see External definitions); the inline definition and the external
          definition are distinct and either may be used for the call.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> function definitions (Function definitions).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Declarators</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>Each declarator declares one identifier, and asserts that when an operand of the
          same form as the declarator appears in an expression, it designates a function or object
          with the scope, storage duration, and type indicated by the declaration
          specifiers.</d:para>
        <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">full
            declarator</emphasis> is a declarator that is not part of another declarator. The end of
          a full declarator is a sequence point. If the nested sequence of declarators in a full
          declarator contains a variable length array type, the type specified by the full
          declarator is said to be <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >variably modified</emphasis>.</d:para>
        <d:para>In the following subclauses, consider a declaration:</d:para>
        <d:programlisting>T D1</d:programlisting>
        <d:para>where <d:code>T</d:code> contains the declaration specifiers that specify a type
            <d:code>T</d:code> (such as <d:code>int</d:code>) and <d:code>D1</d:code> is a
          declarator that contains an identifier ident. The type specified for the identifier ident
          in the various forms of declarator is described inductively using this notation. If, in
          the declaration "<d:code>T D1</d:code>", <d:code>D1</d:code> has the form:</d:para>
        <d:programlisting>identifier</d:programlisting>
        <d:para>then the type specified for ident is <d:code>T</d:code>. If, in the declaration
            "<d:code>T D1</d:code>", <d:code>D1</d:code> has the form:</d:para>
        <d:programlisting>( D )</d:programlisting>
        <d:para>then ident has the type specified by the declaration “<d:code>T D</d:code>”. Thus, a
          declarator in parentheses is identical to the unparenthesized declarator, but the binding
          of complicated declarators may be altered by parentheses.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Implementation
            limits</emphasis></d:para>
        <d:para>As discussed in Translation limits, an implementation may limit the number of
          pointer, array, and function declarators that modify an arithmetic, structure, union, or
          incomplete type, either directly or via one or more typedefs.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> array declarators (Array declarators), type definitions (Type
          definitions).</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Pointer declarators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>If, in the declaration "<d:code>T D1</d:code>", <d:code>D1</d:code> has the
            form:</d:para>
          <d:programlisting>* type-qualifier-listopt D</d:programlisting>
          <d:para>and the type specified for ident in the declaration "<d:code>T D</d:code>" is
            “derived-declarator-type-list <d:code>T</d:code>”, then the type specified for ident is
            “derived-declarator-type-list type-qualifier-list pointer to <d:code>T</d:code>”. For
            each type qualifier in the list, ident is a so-qualified pointer.</d:para>
          <d:para>For two pointer types to be compatible, both shall be identically qualified and
            both shall be pointers to compatible types.</d:para>
          <d:para>EXAMPLE The following pair of declarations demonstrates the difference between a
            “variable pointer to a constant value” and a “constant pointer to a variable
            value”.</d:para>
          <d:programlisting role="CLexer">const int *ptr_to_constant;
int *const constant_ptr;</d:programlisting>
          <d:para>The contents of any object pointed to by <d:code>ptr_to_constant</d:code> shall
            not be modified through that pointer, but <d:code>ptr_to_constant</d:code> itself may be
            changed to point to another object. Similarly, the contents of the int pointed to by
              <d:code>constant_ptr</d:code> may be modified, but <d:code>constant_ptr</d:code>
            itself shall always point to the same location. The declaration of the constant pointer
              <d:code>constant_ptr</d:code> may be clarified by including a definition for the type
            “pointer to <d:code>int</d:code>”.</d:para>
          <d:programlisting role="CLexer">typedef int *int_ptr;
const int_ptr constant_ptr;</d:programlisting>
          <d:para>declares <d:code>constant_ptr</d:code> as an object that has type “const-qualified
            pointer to <d:code>int</d:code>”.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Array declarators</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>In addition to optional type qualifiers and the keyword <d:code>static</d:code>,
            the <d:code>[</d:code> and <d:code>]</d:code> may delimit an expression or
              <d:code>*</d:code>. If they delimit an expression (which specifies the size of an
            array), the expression shall have an integer type. If the expression is a constant
            expression, it shall have a value greater than zero. The element type shall not be an
            incomplete or function type. The optional type qualifiers and the keyword
              <d:code>static</d:code> shall appear only in a declaration of a function parameter
            with an array type, and then only in the outermost array type derivation.</d:para>
          <d:para>Only an ordinary identifier (as defined in 6.2.3) with both block scope or
            function prototype scope and no linkage shall have a variably modified type. If an
            identifier is declared to be an object with static storage duration, it shall not have a
            variable length array type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>If, in the declaration "<d:code>T D1</d:code>", <d:code>D1</d:code> has one of the
            forms:</d:para>
          <d:programlisting>D[ type-qualifier-listopt assignment-expressionopt ]
D[ static type-qualifier-list(opt) assignment-expression ]
D[ type-qualifier-list static assignment-expression ]
D[ type-qualifier-listopt * ]</d:programlisting>
          <d:para>and the type specified for ident in the declaration "<d:code>T D</d:code>" is
            “derived-declarator-type-list <d:code>T</d:code>”, then the type specified for ident is
            “derived-declarator-type-list array of <d:code>T</d:code>”.<d:footnote>
              <d:para>When several “array of” specifications are adjacent, a multidimensional array
                is declared.</d:para>
            </d:footnote> (See Function declarators (including prototypes) for the meaning of the
            optional type qualifiers and the keyword <d:code>static</d:code>.)</d:para>
          <d:para>If the size is not present, the array type is an incomplete type. If the size is *
            instead of being an expression, the array type is a variable length array type of
            unspecified size, which can only be used in declarations with function prototype scope;<d:footnote>
              <d:para>Thus, <d:code>*</d:code> can be used only in function declarations that are
                not definitions (see Function declarators (including prototypes)).</d:para>
            </d:footnote> such arrays are nonetheless complete types. If the size is an integer
            constant expression and the element type has a known constant size, the array type is
            not a variable length array type; otherwise, the array type is a variable length array
            type.</d:para>
          <d:para>If the size is an expression that is not an integer constant expression: if it
            occurs in a declaration at function prototype scope, it is treated as if it were
            replaced by *; otherwise, each time it is evaluated it shall have a value greater than
            zero. The size of each instance of a variable length array type does not change during
            its lifetime. Where a size expression is part of the operand of a
              <d:code>sizeof</d:code> operator and changing the value of the size expression would
            not affect the result of the operator, it is unspecified whether or not the size
            expression is evaluated.</d:para>
          <d:para>For two array types to be compatible, both shall have compatible element types,
            and if both size specifiers are present, and are integer constant expressions, then both
            size specifiers shall have the same constant value. If the two array types are used in a
            context which requires them to be compatible, it is undefined behavior if the two size
            specifiers evaluate to unequal values.</d:para>
          <d:para>EXAMPLE 1</d:para>
          <d:programlisting role="CLexer">float fa[11], *afp[17];</d:programlisting>
          <d:para>declares an array of <d:code>float</d:code> numbers and an array of pointers to
              <d:code>float</d:code> numbers.</d:para>
          <d:para>EXAMPLE 2 Note the distinction between the declarations</d:para>
          <d:programlisting role="CLexer">extern int *x;
extern int y[];</d:programlisting>
          <d:para>The first declares <d:code>x</d:code> to be a pointer to <d:code>int</d:code>; the
            second declares <d:code>y</d:code> to be an array of int of unspecified size (an
            incomplete type), the storage for which is defined elsewhere.</d:para>
          <d:para>EXAMPLE 3 The following declarations demonstrate the compatibility rules for
            variably modified types.</d:para>
          <d:programlisting role="CLexer">extern int n;
extern int m;
void fcompat(void)
{
  int a[n][6][m];
  int (*p)[4][n+1];
  int c[n][n][6][m];
  int (*r)[n][n][n+1];
  p = a;               // invalid: not compatible because 4 != 6
  r = c;               // compatible, but defined behavior only if
                       // n == 6 and m == n+1
}</d:programlisting>
          <d:para>EXAMPLE 4 All declarations of variably modified (VM) types have to be at either
            block scope or function prototype scope. Array objects declared with the
              <d:code>static</d:code> or <d:code>extern</d:code> storage-class specifier cannot have
            a variable length array (VLA) type. However, an object declared with the
              <d:code>static</d:code> storage-class specifier can have a VM type (that is, a pointer
            to a VLA type). Finally, all identifiers declared with a VM type have to be ordinary
            identifiers and cannot, therefore, be members of structures or unions.</d:para>
          <d:programlisting role="CLexer">extern int n;                  // invalid: file scope VLA
int A[n];                      // invalid: file scope VM
extern int (*p2)[n];           // valid: file scope but not VM
int B[100];
void fvla(int m, int C[m][m]); // valid: VLA with prototype scope
void fvla(int m, int C[m][m])  // valid: adjusted to auto pointer to VLA
{
  typedef int VLA[m][m];         // valid: block scope typedef VLA

  struct tag {
    int (*y)[n];                   // invalid: y not ordinary identifier
    int z[n];                      // invalid: z not ordinary identifier
  };
  int D[m];                      // valid: auto VLA
  static int E[m];               // invalid: static block scope VLA
  extern int F[m];               // invalid: F has linkage and is VLA
  int (*s)[m];                   // valid: auto pointer to VLA
  extern int (*r)[m];            // invalid: r has linkage and points to VLA
  static int (*q)[m] = &amp;B;       // valid: q is a static block pointer to VLA
}</d:programlisting>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> function declarators (Function declarators (including
            prototypes)), function definitions (Function definitions), initialization
            (Initialization).</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">Function declarators (including
            prototypes)</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>A function declarator shall not specify a return type that is a function type or
            an array type.</d:para>
          <d:para>The only storage-class specifier that shall occur in a parameter declaration is
              <d:code>register</d:code>.</d:para>
          <d:para>An identifier list in a function declarator that is not part of a definition of
            that function shall be empty.</d:para>
          <d:para>After adjustment, the parameters in a parameter type list in a function declarator
            that is part of a definition of that function shall not have incomplete type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>If, in the declaration "<d:code>T D1</d:code>", <d:code>D1</d:code> has the
            form:</d:para>
          <d:programlisting>D( parameter-type-list )</d:programlisting>
          <d:para>or:</d:para>
          <d:programlisting>D( identifier-listopt )</d:programlisting>
          <d:para>and the type specified for ident in the declaration "T D" is
            “derived-declarator-type-list T”, then the type specified for ident is
            “derived-declarator-type-list function returning T”.</d:para>
          <d:para>A parameter type list specifies the types of, and may declare identifiers for, the
            parameters of the function.</d:para>
          <d:para>A declaration of a parameter as “array of type” shall be adjusted to “qualified
            pointer to type”, where the type qualifiers (if any) are those specified within the [
            and ] of the array type derivation. If the keyword <d:code>static</d:code> also appears
            within the <d:code>[</d:code> and <d:code>]</d:code> of the array type derivation, then
            for each call to the function, the value of the corresponding actual argument shall
            provide access to the first element of an array with at least as many elements as
            specified by the size expression.</d:para>
          <d:para>A declaration of a parameter as “function returning type” shall be adjusted to
            “pointer to function returning type”, as in Other Operands.</d:para>
          <d:para>If the list terminates with an ellipsis (, ...), no information about the number
            or types of the parameters after the comma is supplied.<d:footnote>
              <d:para>The macros defined in the &lt;stdarg.h> header (Variable arguments
                &lt;stdarg.h>) may be used to access arguments that correspond to the
                ellipsis.</d:para>
            </d:footnote></d:para>
          <d:para>The special case of an unnamed parameter of type void as the only item in the list
            specifies that the function has no parameters.</d:para>
          <d:para>If, in a parameter declaration, an identifier can be treated either as a typedef
            name or as a parameter name, it shall be taken as a typedef name.</d:para>
          <d:para>If the function declarator is not part of a definition of that function,
            parameters may have incomplete type and may use the <d:code>[*]</d:code> notation in
            their sequences of declarator specifiers to specify variable length array
            types.</d:para>
          <d:para>The storage-class specifier in the declaration specifiers for a parameter
            declaration, if present, is ignored unless the declared parameter is one of the members
            of the parameter type list for a function definition.</d:para>
          <d:para>An identifier list declares only the identifiers of the parameters of the
            function. An empty list in a function declarator that is part of a definition of that
            function specifies that the function has no parameters. The empty list in a function
            declarator that is not part of a definition of that function specifies that no
            information about the number or types of the parameters is supplied.</d:para>
          <d:para>For two function types to be compatible, both shall specify compatible return
            types. Moreover, the parameter type lists, if both are present, shall agree in the
            number of parameters and in use of the ellipsis terminator; corresponding parameters
            shall have compatible types. If one type has a parameter type list and the other type is
            specified by a function declarator that is not part of a function definition and that
            contains an empty identifier list, the parameter list shall not have an ellipsis
            terminator and the type of each parameter shall be compatible with the type that results
            from the application of the default argument promotions. If one type has a parameter
            type list and the other type is specified by a function definition that contains a
            (possibly empty) identifier list, both shall agree in the number of parameters, and the
            type of each prototype parameter shall be compatible with the type that results from the
            application of the default argument promotions to the type of the corresponding
            identifier. (In the determination of type compatibility and of a composite type, each
            parameter declared with function or array type is taken as having the adjusted type and
            each parameter declared with qualified type is taken as having the unqualified version
            of its declared type.)<d:footnote>
              <d:para>If both function types are “old style”, parameter types are not
                compared.</d:para>
            </d:footnote></d:para>
          <d:para>EXAMPLE 1 The declaration</d:para>
          <d:programlisting role="CLexer">int f(void), *fip(), (*pfi)();</d:programlisting>
          <d:para>declares a function <d:code>f</d:code> with no parameters returning an
              <d:code>int</d:code>, a function <d:code>fip</d:code> with no parameter specification
            returning a pointer to an <d:code>int</d:code>, and a pointer <d:code>pfi</d:code> to a
            function with no parameter specification returning an <d:code>int</d:code>. It is
            especially useful to compare the last two. The binding of <d:code>*fip()</d:code> is
              <d:code>*(fip())</d:code>, so that the declaration suggests, and the same construction
            in an expression requires, the calling of a function <d:code>fip</d:code>, and then
            using indirection through the pointer result to yield an <d:code>int</d:code>. In the
            declarator <d:code>(*pfi)()</d:code>, the extra parentheses are necessary to indicate
            that indirection through a pointer to a function yields a function designator, which is
            then used to call the function; it returns an <d:code>int</d:code>. If the declaration
            occurs outside of any function, the identifiers have file scope and external linkage. If
            the declaration occurs inside a function, the identifiers of the functions
              <d:code>f</d:code> and <d:code>fip</d:code> have block scope and either internal or
            external linkage (depending on what file scope declarations for these identifiers are
            visible), and the identifier of the pointer <d:code>pfi</d:code> has block scope and no
            linkage.</d:para>
          <d:para>EXAMPLE 2 The declaration</d:para>
          <d:programlisting role="CLexer">int (*apfi[3])(int *x, int *y);</d:programlisting>
          <d:para>declares an array <d:code>apfi</d:code> of three pointers to functions returning
              <d:code>int</d:code>. Each of these functions has two parameters that are pointers to
              <d:code>int</d:code>. The identifiers <d:code>x</d:code> and <d:code>y</d:code> are
            declared for descriptive purposes only and go out of scope at the end of the declaration
            of <d:code>apfi</d:code>.</d:para>
          <d:para>EXAMPLE 3 The declaration</d:para>
          <d:programlisting role="CLexer">int (*fpfi(int (*)(long), int))(int, ...);</d:programlisting>
          <d:para>declares a function <d:code>fpfi</d:code> that returns a pointer to a function
            returning an <d:code>int</d:code>. The function <d:code>fpfi</d:code> has two
            parameters: a pointer to a function returning an <d:code>int</d:code> (with one
            parameter of type <d:code>long int</d:code>), and an <d:code>int</d:code>. The pointer
            returned by <d:code>fpfi</d:code> points to a function that has one <d:code>int</d:code>
            parameter and accepts zero or more additional arguments of any type.</d:para>
          <d:para>EXAMPEL 4 The following prototype has a variably modified parameter.</d:para>
          <d:programlisting role="CLexer">void addscalar(int n, int m,
double a[n][n*m+300], double x);
int main()
{
  double b[4][308];
  addscalar(4, 2, b, 2.17);
  return 0;
}
void addscalar(int n, int m, double a[n][n*m+300], double x)
{
  for (int i = 0; i &lt; n; i++)
    for (int j = 0, k = n*m+300; j &lt; k; j++)
     // a is a pointer to a VLA with n*m+300 elements
     a[i][j] += x;
}</d:programlisting>
          <d:para>EXAMPLE 5 The following are all compatible function prototype
            declarators.</d:para>
          <d:programlisting role="CLexer">double maximum(int n, int m, double a[n][m]);
double maximum(int n, int m, double a[*][*]);
double maximum(int n, int m, double a[ ][*]);
double maximum(int n, int m, double a[*][m]);</d:programlisting>
          <d:para>as are:</d:para>
          <d:programlisting role="CLexer">void f(double (*restrict a)[5]);
void f(double  a[restrict][5]);
void f(double  a[restrict 3][5]);
void f(double  a[restrict static 3][5]);</d:programlisting>
          <d:para>(Note that the last declaration also specifies that the argument corresponding to
            a in any call to <d:code>f</d:code> must be a non-null pointer to the first of at least
            three arrays of 5 doubles, which the others do not.)</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
              references:</emphasis> function definitions (Function definitions), type names (Type
            names).</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Type names</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>In several contexts, it is necessary to specify a type. This is accomplished using a
            <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">type name</emphasis>,
          which is syntactically a declaration for a function or an object of that type that omits
          the identifier.<d:footnote>
            <d:para>As indicated by the syntax, empty parentheses in a type name are interpreted as
              “function with no parameter specification”, rather than redundant parentheses around
              the omitted identifier.</d:para>
          </d:footnote></d:para>
        <d:para>EXAMPLE The constructions:</d:para>
        <d:programlisting>(a) int
(b) int *
(c) int *[3]
(d) int (*)[3]
(e) int (*)[*]
(f) int *()
(g) int(*)(void)
(h) int (*const [])(unsigned int, ...)</d:programlisting>
        <d:para>name respectively the types (a) <d:code>int</d:code>, (b) pointer to int, (c) array
          of three pointers to <d:code>int</d:code>, (d) pointer to an array of three
            <d:code>int</d:code>s, (e) pointer to a variable length array of an unspecified number
          of <d:code>int</d:code>s, (f) function with no parameter specification returning a pointer
          to <d:code>int</d:code>, (g) pointer to function with no parameters returning an
            <d:code>int</d:code>, and (h) array of an unspecified number of constant pointers to
          functions, each with one parameter that has type <d:code>unsigned int</d:code> and an
          unspecified number of other parameters, returning an <d:code>int</d:code>.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Type definitions</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>If a typedef name specifies a variably modified type then it shall have block
          scope.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>In a declaration whose storage-class specifier is <d:code>typedef</d:code>, each
          declarator defines an identifier to be a typedef name that denotes the type specified for
          the identifier in the way described in Declarators. Any array size expressions associated
          with variable length array declarators are evaluated each time the declaration of the
          typedef name is reached in the order of execution. A <d:code>typedef</d:code> declaration
          does not introduce a new type, only a synonym for the type so specified. That is, in the
          following declarations:</d:para>
        <d:programlisting role="CLexer">typedef T type_ident;
type_ident D;</d:programlisting>
        <d:para><d:code>type_ident</d:code> is defined as a typedef name with the type specified by
          the declaration specifiers in <d:code>T</d:code> (known as <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic">T</emphasis> ), and the identifier
          in <d:code>D</d:code> has the type “<emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">derived-declarator-type-list T</emphasis>” where the <emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic"
            >derived-declarator-type-list</emphasis> is specified by the declarators of
            <d:code>D</d:code>. A typedef name shares the same name space as other identifiers
          declared in ordinary declarators.</d:para>
        <d:para>EXAMPLE 1 After</d:para>
        <d:programlisting role="CLexer">typedef int MILES, KLICKSP();
typedef struct { double hi, lo; } range;</d:programlisting>
        <d:para>the constructions:</d:para>
        <d:programlisting role="CLexer">MILES distance;
extern KLICKSP *metricp;
range x;
range z, *zp;</d:programlisting>
        <d:para>are all valid declarations. The type of <d:code>distance</d:code> is
            <d:code>int</d:code>, that of <d:code>metricp</d:code> is “pointer to function with no
          parameter specification returning <d:code>int</d:code>”, and that of <d:code>x</d:code>
          and <d:code>z</d:code> is the specified structure; <d:code>zp</d:code> is a pointer to
          such a structure. The object distance has a type compatible with any other int
          object.</d:para>
        <d:para>EXAMPLE 2 After the declarations</d:para>
        <d:programlisting role="CLexer">typedef struct s1 { int x; } t1, *tp1;
typedef struct s2 { int x; } t2, *tp2;</d:programlisting>
        <d:para>type <d:code>t1</d:code> and the type pointed to by <d:code>tp1</d:code> are
          compatible. Type <d:code>t1</d:code> is also compatible with type <d:code>struct
            s1</d:code>, but not compatible with the types <d:code>struct s2</d:code>,
            <d:code>t2</d:code> the type pointed to by <d:code>tp2</d:code> or
          <d:code>int</d:code>.</d:para>
        <d:para>The following obscure constructions</d:para>
        <d:programlisting role="CLexer">typedef signed int t;
typedef int plain;
struct tag {
  unsigned t:4;
  const t:5;
  plain r:5;
};</d:programlisting>
        <d:para>declare a typedef name <d:code>t</d:code> with type <d:code>signed int</d:code>, a
          typedef name <d:code>plain</d:code> with type <d:code>int</d:code> and a structure with
          three bit-field members, one named <d:code>t</d:code> that contains values in the range
            <d:code>[0, 15]</d:code>, an unnamed const- qualified bit-field which (if it could be
          accessed) would contain values in either the range <d:code>[-15, +15]</d:code> or
            <d:code>[-16, +15]</d:code>, and one named <d:code>r</d:code> that contains values in
          one of the ranges <d:code>[0, 31], [-15, +15]</d:code> or <d:code>[-16, +15]</d:code>.
          (The choice of range is implementation-defined.) The first two bit-field declarations
          differ in that unsigned is a type specifier (which forces <d:code>t</d:code> to be the
          name of a structure member), while const is a type qualifier (which modifies
            <d:code>t</d:code> which is still visible as a typedef name). If these declarations are
          followed in an inner scope by</d:para>
        <d:programlisting role="CLexer">t f(t (t));
long t;</d:programlisting>
        <d:para>then a function <d:code>f</d:code> is declared with type “function returning signed
          int with one unnamed parameter with type pointer to function returning <d:code>signed
            int</d:code> with one unnamed parameter with type <d:code>signed int</d:code>”, and an
          identifier t with type <d:code>long int</d:code>.</d:para>
        <d:para>EXAMPLE 4 On the other hand, typedef names can be used to improve code readability.
          All three of the following declarations of the <d:code>signal</d:code> function specify
          exactly the same type, the first without making use of any typedef names.</d:para>
        <d:programlisting role="CLexer">typedef void fv(int), (*pfv)(int);
void (*signal(int, void (*)(int)))(int);
fv *signal(int, fv *);
pfv signal(int, pfv);</d:programlisting>
        <d:para>EXAMPLE 5 If a typedef name denotes a variable length array type, the length of the
          array is fixed at the time the typedef name is defined, not each time it is used:</d:para>
        <d:programlisting role="CLexer">void copyt(int n)
{
  typedef int B[n];      // B is n ints, n evaluated now

  n += 1;
  B a;                   // a is n ints, n without += 1
  int b[n];              // a and b are different sizes
  for (int i = 1; i &lt; n;
    a[i-1] = b[i];
}</d:programlisting>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Initialization</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>No initializer shall attempt to provide a value for an object not contained within
          the entity being initialized.</d:para>
        <d:para>The type of the entity to be initialized shall be an array of unknown size or an
          object type that is not a variable length array type.</d:para>
        <d:para>All the expressions in an initializer for an object that has static storage duration
          shall be constant expressions or string literals.</d:para>
        <d:para>If the declaration of an identifier has block scope, and the identifier has external
          or internal linkage, the declaration shall have no initializer for the
          identifier.</d:para>
        <d:para>If a designator has the form <d:code>[</d:code><emphasis
            xmlns="http://docbook.org/ns/docbook" role="italic"
            >constant-expression</emphasis><d:code>]</d:code> then the current object (defined
          below) shall have array type and the expression shall be an integer constant
          expression.</d:para>
        <d:para>If the array is of unknown size, any nonnegative value is valid. If a designator has
          the form <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
            >.identifier</emphasis> then the current object (defined below) shall have structure or
          union type and the identifier shall be the name of a member of that type.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>An initializer specifies the initial value stored in an object.</d:para>
        <d:para>Except where explicitly stated otherwise, for the purposes of this subclause unnamed
          members of objects of structure and union type do not participate in initialization.
          Unnamed members of structure objects have indeterminate value even after
          initialization.</d:para>
        <d:para>If an object that has automatic storage duration is not initialized explicitly, its
          value is indeterminate. If an object that has static storage duration is not initialized
          explicitly, then:</d:para>
        <d:itemizedlist>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">if it has pointer type, it is initialized to
              a null pointer;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">if it has arithmetic type, it is initialized
              to (positive or unsigned) zero;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">if it is an aggregate, every member is
              initialized (recursively) according to these rules;</para>
          </d:listitem>
          <d:listitem>
            <para xmlns="http://docbook.org/ns/docbook">if it is a union, the first named member is
              initialized (recursively) according to these rules.</para>
          </d:listitem>
        </d:itemizedlist>
        <d:para>The initializer for a scalar shall be a single expression, optionally enclosed in
          braces. The initial value of the object is that of the expression (after conversion); the
          same type constraints and conversions as for simple assignment apply, taking the type of
          the scalar to be the unqualified version of its declared type.</d:para>
        <d:para>The rest of this subclause deals with initializers for objects that have aggregate
          or union type.</d:para>
        <d:para>The initializer for a structure or union object that has automatic storage duration
          shall be either an initializer list as described below, or a single expression that has
          compatible structure or union type. In the latter case, the initial value of the object,
          including unnamed members, is that of the expression.</d:para>
        <d:para>An array of character type may be initialized by a character string literal,
          optionally enclosed in braces. Successive characters of the character string literal
          (including the terminating null character if there is room or if the array is of unknown
          size) initialize the elements of the array.</d:para>
        <d:para>An array with element type compatible with <d:code>wchar_t</d:code> may be
          initialized by a wide string literal, optionally enclosed in braces. Successive wide
          characters of the wide string literal (including the terminating null wide character if
          there is room or if the array is of unknown size) initialize the elements of the
          array.</d:para>
        <d:para>Otherwise, the initializer for an object that has aggregate or union type shall be a
          brace-enclosed list of initializers for the elements or named members.</d:para>
        <d:para>Each brace-enclosed initializer list has an associated current object. When no
          designations are present, subobjects of the current object are initialized in order
          according to the type of the current object: array elements in increasing subscript order,
          structure members in declaration order, and the first named member of a union.<d:footnote>
            <d:para>If the initializer list for a subaggregate or contained union does not begin
              with a left brace, its subobjects are initialized as usual, but the subaggregate or
              contained union does not become the current object: current objects are associated
              only with brace-enclosed initializer lists.</d:para>
          </d:footnote> In contrast, a designation causes the following initializer to begin
          initialization of the subobject described by the designator. Initialization then continues
          forward in order, beginning with the next subobject after that described by the designator.<d:footnote>
            <d:para>After a union member is initialized, the next object is not the next member of
              the union; instead, it is the next subobject of an object containing the
              union.</d:para>
          </d:footnote></d:para>
        <d:para>Each designator list begins its description with the current object associated with
          the closest surrounding brace pair. Each item in the designator list (in order) specifies
          a particular member of its current object and changes the current object for the next
          designator (if any) to be that member.<d:footnote>
            <d:para>Thus, a designator can only specify a strict subobject of the aggregate or union
              that is associated with the surrounding brace pair. Note, too, that each separate
              designator list is independent.</d:para>
          </d:footnote> The current object that results at the end of the designator list is the
          subobject to be initialized by the following initializer.</d:para>
        <d:para>The initialization shall occur in initializer list order, each initializer provided
          for a particular subobject overriding any previously listed initializer for the same subobject;<d:footnote>
            <d:para>Any initializer for the subobject which is overridden and so not used to
              initialize that subobject might not be evaluated at all.</d:para>
          </d:footnote> all subobjects that are not initialized explicitly shall be initialized
          implicitly the same as objects that have static storage duration.</d:para>
        <d:para>If the aggregate or union contains elements or members that are aggregates or
          unions, these rules apply recursively to the subaggregates or contained unions. If the
          initializer of a subaggregate or contained union begins with a left brace, the
          initializers enclosed by that brace and its matching right brace initialize the elements
          or members of the subaggregate or the contained union. Otherwise, only enough initializers
          from the list are taken to account for the elements or members of the subaggregate or the
          first member of the contained union; any remaining initializers are left to initialize the
          next element or member of the aggregate of which the current subaggregate or contained
          union is a part.</d:para>
        <d:para>If there are fewer initializers in a brace-enclosed list than there are elements or
          members of an aggregate, or fewer characters in a string literal used to initialize an
          array of known size than there are elements in the array, the remainder of the aggregate
          shall be initialized implicitly the same as objects that have static storage
          duration.</d:para>
        <d:para>If an array of unknown size is initialized, its size is determined by the largest
          indexed element with an explicit initializer. At the end of its initializer list, the
          array no longer has incomplete type.</d:para>
        <d:para>The order in which any side effects occur among the initialization list expressions
          is unspecified.<d:footnote>
            <d:para>In particular, the evaluation order need not be the same as the order of
              subobject initialization.</d:para>
          </d:footnote></d:para>
        <d:para>EXAMPLE 1 Provided that &lt;complex.h> has been #included, the declarations</d:para>
        <d:programlisting role="CLexer">int i = 3.5;
double complex c = 5 + 3 * I;</d:programlisting>
        <d:para>define and initialize <d:code>i</d:code> with the value 3 and <d:code>c</d:code>
          with the value 5. 0 + i3. 0.</d:para>
        <d:para>EXAMPLE 2 The declaration</d:para>
        <d:programlisting role="CLexer">int x[] = { 1, 3, 5 };</d:programlisting>
        <d:para>defines and initializes <d:code>x</d:code> as a one-dimensional array object that
          has three elements, as no size was specified and there are three initializers.</d:para>
        <d:para>EXAMPLE 3 The declaration</d:para>
        <d:programlisting role="CLexer">int y[4][3] = {
      { 1, 3, 5 },
      { 2, 4, 6 },
      { 3, 5, 7 },
};</d:programlisting>
        <d:para>is a definition with a fully bracketed initialization: <d:code>1, 3,</d:code> and
            <d:code>5</d:code> initialize the first row of <d:code>y</d:code> (the array object
            <d:code>y[0]</d:code>), namely <d:code>y[0][0], y[0][1]</d:code> and
            <d:code>y[0][2]</d:code>. Likewise the next two lines initialize <d:code>y[1]</d:code>
          and <d:code>y[2]</d:code>. The initializer ends early, so <d:code>y[3]</d:code> is
          initialized with zeros. Precisely the same effect could have been achieved by</d:para>
        <d:programlisting role="CLexer">int y[4][3] = {
      1, 3, 5, 2, 4, 6, 3, 5, 7
};</d:programlisting>
        <d:para>The initializer for <d:code>y[0]</d:code> does not begin with a left brace, so three
          items from the list are used. Likewise the next three are taken successively for
            <d:code>y[1]</d:code> and <d:code>y[2]</d:code>.</d:para>
        <d:para>EXAMPLE 4 The declaration</d:para>
        <d:programlisting role="CLexer">int z[4][3] = {
      { 1 }, { 2 }, { 3 }, { 4 }
};</d:programlisting>
        <d:para>initializes the first column of <d:code>z</d:code> as specified and initializes the
          rest with zeros.</d:para>
        <d:para>EXAMPLE 5 The declaration</d:para>
        <d:programlisting role="CLexer">struct { int a[3], b; } w[] = { { 1 }, 2 };</d:programlisting>
        <d:para>is a definition with an inconsistently bracketed initialization. It defines an array
          with two element structures: <d:code>w[0].a[0]</d:code> is 1 and
            <d:code>w[1].a[0]</d:code> is 2; all the other elements are zero.</d:para>
        <d:para>EXAMPLE 6 The declaration</d:para>
        <d:programlisting role="CLexer">short q[4][3][2] = {
        { 1 },
        { 2, 3 },
        { 4, 5, 6 }
};</d:programlisting>
        <d:para>contains an incompletely but consistently bracketed initialization. It defines a
          three-dimensional array object: <d:code>q[0][0][0]</d:code> is 1,
            <d:code>q[1][0][0]</d:code> is 2, <d:code>q[1][0][1]</d:code> is 3, and 4, 5, and 6
          initialize <d:code>q[2][0][0], q[2][0][1]</d:code> and <d:code>q[2][1][0]</d:code>,
          respectively; all the rest are zero. The initializer for <d:code>q[0][0]</d:code> does not
          begin with a left brace, so up to six items from the current list may be used. There is
          only one, so the values for the remaining five elements are initialized with zero.
          Likewise, the initializers for <d:code>q[1][0]</d:code> and <d:code>q[2][0]</d:code> do
          not begin with a left brace, so each uses up to six items, initializing their respective
          two-dimensional subaggregates. If there had been more than six items in any of the lists,
          a diagnostic message would have been issued. The same initialization result could have
          been achieved by:</d:para>
        <d:programlisting role="CLexer">short q[4][3][2] = {
        1, 0, 0, 0, 0, 0,
        2, 3, 0, 0, 0, 0,
        4, 5, 6
};</d:programlisting>
        <d:para>or by:</d:para>
        <d:programlisting role="CLexer">short q[4][3][2] = {
      {
       { 1 },
      },
      {
       { 2, 3 },
      },
      {
       { 4, 5 },
       { 6 },
      }
};</d:programlisting>
        <d:para>in a fully bracketed form.</d:para>
        <d:para>Note that the fully bracketed and minimally bracketed forms of initialization are,
          in general, less likely to cause confusion.</d:para>
        <d:para>EXAMPLE 7 One form of initialization that completes array types involves typedef
          names. Given the declaration</d:para>
        <d:programlisting role="CLexer">typedef int A[]; // OK - declared with block scope</d:programlisting>
        <d:para>the declaration</d:para>
        <d:programlisting>A a = { 1, 2 }, b = { 3, 4, 5 };</d:programlisting>
        <d:para>is identical to:</d:para>
        <d:programlisting role="CLexer">int a[] = { 1, 2 }, b[] = { 3, 4, 5 };</d:programlisting>
        <d:para>due to the rules for incomplete types.</d:para>
        <d:para>EXAMPLE 8 The declaration</d:para>
        <d:programlisting role="CLexer">char s[] = "abc", t[3] = "abc";</d:programlisting>
        <d:para>defines “plain” char array objects <d:code>s</d:code> and <d:code>t</d:code> whose
          elements are initialized with character string literals.</d:para>
        <d:para>This declaration is identical to</d:para>
        <d:programlisting role="CLexer">char s[] = { 'a', 'b', 'c', '\0' },
t[] = { 'a', 'b', 'c' };</d:programlisting>
        <d:para>The contents of the arrays are modifiable. On the other hand, the
          declaration</d:para>
        <d:programlisting role="CLexer">char *p = "abc";</d:programlisting>
        <d:para>defines p with type “pointer to <d:code>char</d:code>” and initializes it to point
          to an object with type “array of <d:code>char</d:code>” with length 4 whose elements are
          initialized with a character string literal. If an attempt is made to use p to modify the
          contents of the array, the behavior is undefined.</d:para>
        <d:para>EXAMPLE 9 Arrays can be initialized to correspond to the elements of an enumeration
          by using designators:</d:para>
        <d:programlisting role="CLexer">enum { member_one, member_two };
const char *nm[] = {
  [member_two] = "member two",
  [ember_one] = "member one",
};</d:programlisting>
        <d:para>EXAMPLE 10 Structure members can be initialized to nonzero values without depending
          on their order:</d:para>
        <d:programlisting role="CLexer">div_t answer = { .quot = 2, .rem = -1 };</d:programlisting>
        <d:para>EXAMPLE 11 Designators can be used to provide explicit initialization when unadorned
          initializer lists might be misunderstood:</d:para>
        <d:programlisting role="CLexer">struct { int a[3], b; } w[] =
         { [0].a = {1}, [1].a[0] = 2 };</d:programlisting>
        <d:para>EXAMPLE 12 Space can be “allocated” from both ends of an array by using a single
          designator:</d:para>
        <d:programlisting role="CLexer">int a[MAX] = {
      1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0
};</d:programlisting>
        <d:para>In the above, if <d:code>MAX</d:code> is greater than ten, there will be some
          zero-valued elements in the middle; if it is less than ten, some of the values provided by
          the first five initializers will be overridden by the second five.</d:para>
        <d:para>EXAMPLE 13 Any member of a union can be initialized:</d:para>
        <d:programlisting role="CLexer">union { /* ... */ } u = { .any_member = 42 };</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> common definitions <d:code>&lt;stddef.h></d:code> (Common
          definitions &lt;stddef.h>).</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Statements and blocks</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>A statement specifies an action to be performed. Except as indicated, statements are
        executed in sequence.</d:para>
      <d:para>A block allows a set of declarations and statements to be grouped into one syntactic
        unit. The initializers of objects that have automatic storage duration, and the variable
        length array declarators of ordinary identifiers with block scope, are evaluated and the
        values are stored in the objects (including storing an indeterminate value in objects
        without an initializer) each time the declaration is reached in the order of execution, as
        if it were a statement, and within each declaration in the order that declarators
        appear.</d:para>
      <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">full
          expression</emphasis> is an expression that is not part of another expression or of a
        declarator. Each of the following is a full expression: an initializer; the expression in an
        expression statement; the controlling expression of a selection statement
          (<d:code>if</d:code> or <d:code>switch</d:code>); the controlling expression of a
          <d:code>while</d:code> or <d:code>do</d:code> statement; each of the (optional)
        expressions of a <d:code>for</d:code> statement; the (optional) expression in a
          <d:code>return</d:code> statement. The end of a full expression is a sequence
        point.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
          references:</emphasis> expression and null statements (Expression and null statements),
        selection statements (Selection statements), iteration statements (Iteration statements),
        the return statement (The return statement).</d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Labeled statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>A <d:code>case</d:code> or <d:code>default</d:code> label shall appear only in a
            <d:code>switch</d:code> statement. Further constraints on such labels are discussed
          under the <d:code>switch</d:code> statement.</d:para>
        <d:para>Label names shall be unique within a function.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>Any statement may be preceded by a prefix that declares an identifier as a label
          name. Labels in themselves do not alter the flow of control, which continues unimpeded
          across them.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> the <d:code>goto</d:code> statement (The goto statement), the
            <d:code>switch</d:code> statement (The switch statement).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Compound statement</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">compound
            statement</emphasis> is a block.</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Expressions and null statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The expression in an expression statement is evaluated as a void expression for its
          side effects.<d:footnote>
            <d:para>Such as assignments, and function calls which have side effects.</d:para>
          </d:footnote></d:para>
        <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">null
            statement</emphasis> (consisting of just a semicolon) performs no operations.</d:para>
        <d:para>EXAMPLE 1 If a function call is evaluated as an expression statement for its side
          effects only, the discarding of its value may be made explicit by converting the
          expression to a void expression by means of a cast:</d:para>
        <d:programlisting role="CLexer">int p(int);
/* ... */
(void)p(0);</d:programlisting>
        <d:para>EXAMPLE 2 In the program fragment</d:para>
        <d:programlisting role="CLexer">char *s;
/* ... */
while (*s++ != '\0')
;</d:programlisting>
        <d:para>a null statement is used to supply an empty loop body to the iteration
          statement.</d:para>
        <d:para>EXAMPLE 3 A null statement may also be used to carry a label just before the closing
            <d:code>}</d:code> of a compound statement.</d:para>
        <d:programlisting role="CLexer">while (loop1) {
  /* ... */
  while (loop2) {
    /* ... */
    if (want_out)
    goto end_loop1;
    /* ... */
  }
  /* ... */
  end_loop1: ;
}</d:programlisting>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Forward
            references:</emphasis> iteration statements (Iteration statements).</d:para>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Selection statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A selection statement selects among a set of statements depending on the value of a
          controlling expression.</d:para>
        <d:para>A selection statement is a block whose scope is a strict subset of the scope of its
          enclosing block. Each associated substatement is also a block whose scope is a strict
          subset of the scope of the selection statement.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>if</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The controlling expression of an <d:code>if</d:code> statement shall have scalar
            type.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>In both forms, the first substatement is executed if the expression compares
            unequal to 0. In the <d:code>else</d:code> form, the second substatement is executed if
            the expression compares equal to 0. If the first substatement is reached via a label,
            the second substatement is not executed.</d:para>
          <d:para>An <d:code>else</d:code> is associated with the lexically nearest preceding if
            that is allowed by the syntax.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>switch</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The controlling expression of a switch statement shall have integer type.</d:para>
          <d:para>If a <d:code>switch</d:code> statement has an associated <d:code>case</d:code> or
              <d:code>default</d:code> label within the scope of an identifier with a variably
            modified type, the entire switch statement shall be within the scope of that identifier.<d:footnote>
              <d:para>That is, the declaration either precedes the <d:code>switch</d:code>
                statement, or it follows the last <d:code>case</d:code> or <d:code>default</d:code>
                label associated with the switch that is in the block containing the
                declaration.</d:para>
            </d:footnote></d:para>
          <d:para>The expression of each <d:code>case</d:code> label shall be an integer constant
            expression and no two of the case constant expressions in the same
              <d:code>switch</d:code> statement shall have the same value after conversion. There
            may be at most one <d:code>default</d:code> label in a switch statement. (Any enclosed
              <d:code>switch</d:code> statement may have a <d:code>default</d:code> label or
              <d:code>case</d:code> constant expressions with values that duplicate
              <d:code>case</d:code> constant expressions in the enclosing <d:code>switch</d:code>
            statement.)</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <d:code>switch</d:code> statement causes control to jump to, into, or past the
            statement that is the <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >switch body</emphasis>, depending on the value of a controlling expression, and on
            the presence of a <d:code>default</d:code> label and the values of any
              <d:code>case</d:code> labels on or in the switch body. A <d:code>case</d:code> or
              <d:code>default</d:code> label is accessible only within the closest enclosing switch
            statement.</d:para>
          <d:para>The integer promotions are performed on the controlling expression. The constant
            expression in each <d:code>case</d:code> label is converted to the promoted type of the
            controlling expression. If a converted value matches that of the promoted controlling
            expression, control jumps to the statement following the matched <d:code>case</d:code>
            label. Otherwise, if there is a <d:code>default</d:code> label, control jumps to the
            labeled statement. If no converted case constant expression matches and there is no
              <d:code>default</d:code> label, no part of the switch body is executed.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">Implementation
              limits</emphasis></d:para>
          <d:para>As discussed in Translation limits, the implementation may limit the number of
              <d:code>case</d:code> values in a switch statement.</d:para>
          <d:para>EXAMPLE In the artificial program fragment</d:para>
          <d:programlisting role="CLexer">switch (expr)
{
  int i = 4;
    f(i);
  case 0:
    i = 17;
    /* falls through into default code */
  default:
    printf("%d\n", i);
}</d:programlisting>
          <d:para>the object whose identifier is i exists with automatic storage duration (within
            the block) but is never initialized, and thus if the controlling expression has a
            nonzero value, the call to the <d:code>printf</d:code> function will access an
            indeterminate value. Similarly, the call to the function f cannot be reached.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Iteration statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The controlling expression of an iteration statement shall have scalar
          type.</d:para>
        <d:para>The declaration part of a for statement shall only declare identifiers for objects
          having storage class <d:code>auto</d:code> or <d:code>register</d:code>.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>An iteration statement causes a statement called the loop body to be executed
          repeatedly until the controlling expression compares equal to 0.An iteration statement is
          a block whose scope is a strict subset of the scope of its enclosing block. The loop body
          is also a block whose scope is a strict subset of the scope of the iteration
          statement.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>while</code> statement</title>
          <d:para>The evaluation of the controlling expression takes place before each execution of
            the loop body.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>do</code> statement</title>
          <d:para>The evaluation of the controlling expression takes place after each execution of
            the loop body.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>for</code> statement</title>
          <d:para>The statement</d:para>
          <d:screen>for ( clause-1 ; expression-2 ; expression-3 ) statement</d:screen>
          <d:para>behaves as follows: The expression <emphasis xmlns="http://docbook.org/ns/docbook"
              role="italic">expression-2</emphasis> is the controlling expression that is evaluated
            before each execution of the loop body. The expression <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">expression-3</emphasis> is
            evaluated as a void expression after each execution of the loop body. If <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">clause-1</emphasis> is a
            declaration, the scope of any variables it declares is the remainder of the declaration
            and the entire loop, including the other two expressions; it is reached in the order of
            execution before the first evaluation of the controlling expression. If clause-1 is an
            expression, it is evaluated as a void expression before the first evaluation of the
            controlling expression.<d:footnote>
              <d:para>Thus, <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
                  >clause-1</emphasis> specifies initialization for the loop, possibly declaring one
                or more variables for use in the loop; the controlling expression, <emphasis
                  xmlns="http://docbook.org/ns/docbook" role="italic">expression-2</emphasis>,
                specifies an evaluation made before each iteration, such that execution of the loop
                continues until the expression compares equal to 0; and <emphasis
                  xmlns="http://docbook.org/ns/docbook" role="italic">expression-3</emphasis>
                specifies an operation (such as incrementing) that is performed after each
                iteration.</d:para>
            </d:footnote></d:para>
          <d:para>Both <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >clause-1</emphasis> and <emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
              >expression-3</emphasis> can be omitted. An omitted <emphasis
              xmlns="http://docbook.org/ns/docbook" role="italic">expression-2</emphasis> is
            replaced by a nonzero constant.</d:para>
        </d:sect3>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Jump statements</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>A jump statement causes an unconditional jump to another place.</d:para>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>goto</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>The identifier in a <d:code>goto</d:code> statement shall name a label located
            somewhere in the enclosing function. A <d:code>goto</d:code> statement shall not jump
            from outside the scope of an identifier having a variably modified type to inside the
            scope of that identifier.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <d:code>goto</d:code> statement causes an unconditional jump to the statement
            prefixed by the named label in the enclosing function.</d:para>
          <d:para>EXAMPLE 1 It is sometimes convenient to jump into the middle of a complicated set
            of statements. The following outline presents one possible approach to a problem based
            on these three assumptions:</d:para>
          <d:orderedlist>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">The general initialization code accesses
                objects only visible to the current function.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">The general initialization code is too
                large to warrant duplication.</para>
            </d:listitem>
            <d:listitem>
              <para xmlns="http://docbook.org/ns/docbook">The code to determine the next operation
                is at the head of the loop. (To allow it to be reached by continue statements, for
                example.)</para>
            </d:listitem>
          </d:orderedlist>
          <d:programlisting role="CLexer">/* ... */
goto first_time;
for (;;) {
  // determine next operation
  /* ... */
  if (need to reinitialize) {
    // reinitialize-only code
    /* ... */
    first_time:
    // general initialization code
    /* ... */
    continue;
  }
  // handle other operations
  /* ... */
}</d:programlisting>
          <d:para>EXAMPLE 2 A <d:code>goto</d:code> statement is not allowed to jump past any
            declarations of objects with variably modified types. A jump within the scope, however,
            is permitted.</d:para>
          <d:programlisting role="CLexer">goto lab3; // invalid: going INTO scope of VLA.
{
  double a[n];
  a[j] = 4.4;
lab3:
  a[j] = 3.3;
goto lab4; // valid: going WITHIN scope of VLA.
  a[j] = 5.5;
lab4:
  a[j] = 6.6;
}
goto lab4; // invalid: going INTO scope of VLA.</d:programlisting>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>continue</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>A <d:code>continue</d:code> statement shall appear only in or as a loop
            body.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">continue</emphasis>
            statement causes a jump to the loop-continuation portion of the smallest enclosing
            iteration statement; that is, to the end of the loop body. More precisely, in each of
            the statements</d:para>
          <d:programlisting role="CLexer">while (/* ... */) {
  /* ... */
  continue;
  /* ... */
  contin: ;
}
do {
  /* ... */
  continue;
  /* ... */
  contin: ;
} while (/* ... */);
for (/* ... */) {
  /* ... */
  continue;
  /* ... */
  contin: ;
}</d:programlisting>
          <d:para>unless the continue statement shown is in an enclosed iteration statement (in
            which case it is interpreted within that statement), it is equivalent to <d:code>goto
              contin;</d:code><d:footnote>
              <d:para>Following the <d:code>contin:</d:code> label is a null statement.</d:para>
            </d:footnote></d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>break</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constraints</emphasis></d:para>
          <d:para>A <d:code>break</d:code> statement shall appear only in or as a switch body or
            loop body.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <d:code>break</d:code> statement terminates execution of the smallest enclosing
              <d:code>switch</d:code> or iteration statement.</d:para>
        </d:sect3>
        <d:sect3>
          <title xmlns="http://docbook.org/ns/docbook">The <code>return</code> statement</title>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Constaints</emphasis></d:para>
          <d:para>A <d:code>return</d:code> statement with an expression shall not appear in a
            function whose return type is <d:code>void</d:code>. A return statement without an
            expression shall only appear in a function whose return type is
            <d:code>void</d:code>.</d:para>
          <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
            >Semantics</emphasis></d:para>
          <d:para>A <d:code>return</d:code> statement terminates execution of the current function
            and returns control to its caller. A function may have any number of
              <d:code>return</d:code> statements.</d:para>
          <d:para>If a <d:code>return</d:code> statement with an expression is executed, the value
            of the expression is returned to the caller as the value of the function call
            expression. If the expression has a type different from the return type of the function
            in which it appears, the value is converted as if by assignment to an object having the
            return type of the function.<d:footnote>
              <d:para>The <d:code>return</d:code> statement is not an assignment. The overlap
                restriction of subclause 6.5.16.1 does not apply to the case of function
                return.</d:para>
            </d:footnote></d:para>
          <d:para>EXAMPLE In:</d:para>
          <d:programlisting role="CLexer">struct s { double i; } f(void);
union {
  struct {
    int f1;
    struct s f2;
  } u1;
  struct {
    struct s f3;
    int f4;
  } u2;
} g;
struct s f(void)
{
  return g.u1.f2;
}
/* ... */
g.u2.f3 = f();</d:programlisting>
          <d:para>there is no undefined behavior, although there would be if the assignment were
            done directly (without using a function call to fetch the value).</d:para>
        </d:sect3>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">External definitions</title>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Constraints</emphasis></d:para>
      <d:para>The storage-class specifiers <d:code>auto</d:code> and <d:code>register</d:code> shall
        not appear in the declaration specifiers in an external declaration.</d:para>
      <d:para>There shall be no more than one external definition for each identifier declared with
        internal linkage in a translation unit. Moreover, if an identifier declared with internal
        linkage is used in an expression (other than as a part of the operand of a
          <d:code>sizeof</d:code> operator whose result is an integer constant), there shall be
        exactly one external definition for the identifier in the translation unit.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
        >Semantics</emphasis></d:para>
      <d:para>As discussed in Program Structure, the unit of program text after preprocessing is a
        translation unit, which consists of a sequence of external declarations. These are described
        as external because they appear outside any function (and hence have file scope). As
        discussed in Declarations, a declaration that also causes storage to be reserved for an
        object or a function named by the identifier is a definition.</d:para>
      <d:para>An <emphasis xmlns="http://docbook.org/ns/docbook" role="italic">external
          definition</emphasis> is an external declaration that is also a definition of a function
        (other than an inline definition) or an object. If an identifier declared with external
        linkage is used in an expression (other than as part of the operand of a
          <d:code>sizeof</d:code> operator whose result is an integer constant), somewhere in the
        entire program there shall be exactly one external definition for the identifier; otherwise,
        there shall be no more than one.<d:footnote>
          <d:para>Thus, if an identifier declared with external linkage is not used in an
            expression, there need be no external definition for it.</d:para>
        </d:footnote></d:para>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">Function definitions</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Constraints</emphasis></d:para>
        <d:para>The identifier declared in a function definition (which is the name of the function)
          shall have a function type, as specified by the declarator portion of the function
          definition.</d:para>
        <d:para>The intent is that the type category in a function definition cannot be inherited
          from a typedef:</d:para>
        <d:programlisting role="CLexer">typedef int F(void);                  // type F is ‘‘function with no parameters
                                      // returning int’’
F f, g;                               // fand g both have type compatible with F
F f { /* ... */ }                     // WRONG: syntax/constraint error
F g() { /* ... */ }                   // WRONG: declares that g returns a function
int f(void) { /* ... */ }             // RIGHT: f has type compatible with F
int g() { /* ... */ }                 // RIGHT: g has type compatible with F
F *e(void) { /* ... */ }              // e returns a pointer to a function
F *((e))(void) { /* ... */ }          // same: parentheses irrelevant
int (*fp)(void);                      // fp points to a function that has type F
F*Fp;                                 //Fp points to a function that has type F</d:programlisting>
        <d:para>The return type of a function shall be <d:code>void</d:code> or an object type other
          than array type.</d:para>
        <d:para>The storage-class specifier, if any, in the declaration specifiers shall be either
            <d:code>extern</d:code> or <d:code>static</d:code>.</d:para>
        <d:para>If the declarator includes a parameter type list, the declaration of each parameter
          shall include an identifier, except for the special case of a parameter list consisting of
          a single parameter of type <d:code>void</d:code>, in which case there shall not be an
          identifier. No declaration list shall follow.</d:para>
        <d:para>If the declarator includes an identifier list, each declaration in the declaration
          list shall have at least one declarator, those declarators shall declare only identifiers
          from the identifier list, and every identifier in the identifier list shall be declared.
          An identifier declared as a typedef name shall not be redeclared as a parameter. The
          declarations in the declaration list shall contain no storage-class specifier other than
            <d:code>register</d:code> and no initializations.</d:para>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>The declarator in a function definition specifies the name of the function being
          defined and the identifiers of its parameters. If the declarator includes a parameter type
          list, the list also specifies the types of all the parameters; such a declarator also
          serves as a function prototype for later calls to the same function in the same
          translation unit. If the declarator includes an identifier list, the types of the
          parameters shall be declared in a following declaration list. In either case, the type of
          each parameter is adjusted as described in Function declarators (including prototypes) for
          a parameter type list; the resulting type shall be an object type.</d:para>
        <d:para>If a function that accepts a variable number of arguments is defined without a
          parameter type list that ends with the ellipsis notation, the behavior is
          undefined.</d:para>
        <d:para>Each parameter has automatic storage duration. Its identifier is an lvalue, which is
          in effect declared at the head of the compound statement that constitutes the function
          body (and therefore cannot be redeclared in the function body except in an enclosed
          block). The layout of the storage for parameters is unspecified. 10 On entry to the
          function, the size expressions of each variably modified parameter are evaluated and the
          value of each argument expression is converted to the type of the corresponding parameter
          as if by assignment. (Array expressions and function designators as arguments were
          converted to pointers before the call.)</d:para>
        <d:para>After all parameters have been assigned, the compound statement that constitutes the
          body of the function definition is executed.</d:para>
        <d:para>If the <d:code>}</d:code> that terminates a function is reached, and the value of
          the function call is used by the caller, the behavior is undefined.</d:para>
        <d:para>EXAMPLE 1 In the following:</d:para>
        <d:programlisting role="CLexer">extern int max(int a, int b)
{
  return a > b ? a : b;
}</d:programlisting>
        <d:para><d:code>extern</d:code> is the storage-class specifier and <d:code>int</d:code> is
          the type specifier; <d:code>max(int a, int b)</d:code> is the function declarator;
          and</d:para>
        <d:programlisting role="CLexer">{ return a > b ? a : b; }</d:programlisting>
        <d:para>is the function body. The following similar definition uses the identifier-list form
          for the parameter declarations:</d:para>
        <d:programlisting role="CLexer">extern int max(a, b)
int a, b;
{
  return a > b ? a : b;
}</d:programlisting>
        <d:para>Here <d:code>int a, b;</d:code> is the declaration list for the parameters. The
          difference between these two definitions is that the first form acts as a prototype
          declaration that forces conversion of the arguments of subsequent calls to the function,
          whereas the second form does not.</d:para>
        <d:para>EXAMPLE 2 To pass one function to another, one might say</d:para>
        <d:programlisting role="CLexer">int f(void);
/* ... */
g(f);</d:programlisting>
        <d:para>Then the definition of <d:code>g</d:code> might read</d:para>
        <d:programlisting role="CLexer">void g(int (*funcp)(void))
{
  /* ... */
  (*funcp)() /* or funcp() ... */
}</d:programlisting>
        <d:para>or, equivalently</d:para>
        <d:programlisting role="CLexer">void g(int func(void))
{
  /* ... */
  func() /* or (*func)() ... */
}</d:programlisting>
      </d:sect2>
      <d:sect2>
        <title xmlns="http://docbook.org/ns/docbook">External object definitions</title>
        <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >Semantics</emphasis></d:para>
        <d:para>If the declaration of an identifier for an object has file scope and an initializer,
          the declaration is an external definition for the identifier.</d:para>
        <d:para>A declaration of an identifier for an object that has file scope without an
          initializer, and without a storage-class specifier or with the storage-class specifier
            <d:code>static</d:code>, constitutes a <emphasis xmlns="http://docbook.org/ns/docbook"
            role="italic">tentative definition</emphasis>. If a translation unit contains one or
          more tentative definitions for an identifier, and the translation unit contains no
          external definition for that identifier, then the behavior is exactly as if the
          translation unit contains a file scope declaration of that identifier, with the composite
          type as of the end of the translation unit, with an initializer equal to 0.</d:para>
        <d:para>If the declaration of an identifier for an object is a tentative definition and has
          internal linkage, the declared type shall not be an incomplete type.</d:para>
        <d:para>EXAMPLE 1</d:para>
        <d:programlisting role="CLexer">int i1 = 1;        // definition, external linkage
static int i2 = 2; // definition, internal linkage
extern int i3 = 3; // definition, external linkage
int i4;            // tentative definition, external linkage
static int i5;     // tentative definition, internal linkage
int i1;            // valid tentative definition, refers to pre vious
int i2;            // 4.2.2 renders undefined, linkage disagreement
int i3;            // valid tentative definition, refers to pre vious
int i4;            // valid tentative definition, refers to pre vious
int i5;            // 4.2.2 renders undefined, linkage disagreement
extern int i1;     // refers to pre vious, whose linkage is external
extern int i2;     // refers to pre vious, whose linkage is internal
extern int i3;     // refers to pre vious, whose linkage is external
extern int i4;     // refers to pre vious, whose linkage is external
extern int i5;     // refers to pre vious, whose linkage is internal</d:programlisting>
        <d:para>EXAMPLE 2 If at the end of the translation unit containing</d:para>
        <d:programlisting role="CLexer">int i[];</d:programlisting>
        <d:para>the array <d:code>i</d:code> still has incomplete type, the implicit initializer
          causes it to have one element, which is set to zero on program startup.</d:para>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Preprocessing directives</title>
      <d:para>This is dicussed in chapter Preprocessing Directives.</d:para>
    </d:sect1>
</d:chapter>
