<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
    <?dbhtml filename="complex/index.html" ?>
    <d:title>Complex arithmetic &lt;complex.h&gt;</d:title>
    <d:sect1>
      <d:indexterm>
        <d:primary>_Complex</d:primary>
      </d:indexterm>
      <d:indexterm>
        <d:primary>_Complex_I</d:primary>
      </d:indexterm>
      <d:title>Introduction</d:title>
      <d:para>The header <d:code>&lt;complex.h&gt;</d:code> defines macros and
      declares functions that support complex
      arithmetic.<d:footnote><d:para>See <d:quote>future library
      directions</d:quote> (&#xa7; iso.7.31.1).</d:para></d:footnote>
      </d:para>
      <d:para>
        mplementations that define the macro
        <d:code>__STDC_NO_COMPLEX__</d:code> need not provide this header nor
        support any of its facilities.
      </d:para>
      <d:para>
      Each synopsis
      specifies a family of functions consisting of a principal function with
      one or more <d:code>double complex</d:code> parameters and a
      <d:code>double complex</d:code> or <d:code>double</d:code> 
      return value; and other functions with the same name but with f and l
      suffixes which are corresponding functions with <d:code>float</d:code>
      and <d:code>long double</d:code> parameters and return values.</d:para>
      <d:para>The macro
      <d:blockquote>
        <d:para><d:code>complex</d:code></d:para>
      </d:blockquote>
      expands to <d:code>_Complex</d:code>; the macro
      <d:blockquote>
        <d:para><d:code>_Complex_I</d:code></d:para>
      </d:blockquote>
      expands to a constant expression of type
      <d:code>const float _Complex</d:code>, with the value of the imaginary
      unit.<d:footnote><d:para>The imaginary unit is a number
      <d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>i</mml:mi>
</mml:math></d:inlineequation> such that <d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:msup>
    <mml:mi>i</mml:mi>
    <mml:mn>2</mml:mn>
  </mml:msup>
  <mml:mo>=</mml:mo>
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mn>1</mml:mn>
      </mml:math></d:inlineequation></d:para></d:footnote>.</d:para>
      <d:para>
        The macros
        <d:blockquote>
          <d:para><d:code>imaginary</d:code></d:para>
        </d:blockquote>
        and
        <d:blockquote>
          <d:para><d:code>_Imaginary_I</d:code></d:para>
        </d:blockquote>
        are defined if and only if the implementation supports imaginary
        types;<d:footnote><d:para>A specification for imaginary types is in
        informative &#xa7; iso.annex G.</d:para></d:footnote> f defined, they
        expand to <d:code>_Imaginary</d:code> and a constant expression of type
        <d:code>const float _Imaginary</d:code> with the value of the imaginary
        unit.
      </d:para>
      <d:para>
        The macro
        <d:blockquote>
          <d:para><d:code>I</d:code></d:para>
        </d:blockquote>
        expands to either <d:code>_Imaginary_I</d:code> or
        <d:code>_Complex_I</d:code>. If <d:code>_Imaginary_I</d:code> s not
        defined, <d:code>I</d:code> shall expand to
        <d:code>_Complex_I</d:code>.
      </d:para>
<d:para>Notwithstanding the provisions of reserved identifiers, a program may
undefine and perhaps then redefine the macros <d:code>complex,
imaginary</d:code> and
<d:code>I</d:code>.</d:para>
<d:para>
  <d:emphasis role="bold">Forward references:</d:emphasis> IEC 60559-compatible
  complex arithmetic (annex G).
</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>Conventions</d:title>
      <d:para>Values are interpreted as radians, not degrees. An implementation
      may set errno but is not required to.</d:para>
    </d:sect1>
    <d:sect1>
      <d:indexterm>
        <d:primary>branch cuts</d:primary>
      </d:indexterm>
      <d:title>Branch Cuts</d:title>
      <d:para>Some of the functions below have branch cuts, across which the
      function is discontinuous. For implementations with a signed zero
      (including all IEC 60559 implementations) that follow the specifications
      of annex G, the sign of zero distinguishes one side of a cut from another
      so the function is continuous (except for format limitations) as the cut
      is approached from either side. For example, for the square root
      function, which has a branch cut along the negative real axis, the top of
      the cut, with imaginary part +0, maps to the positive imaginary axis, and
      the bottom of the cut, with imaginary part -0, maps to the negative
      imaginary axis.</d:para>
      <d:para>Implementations that do not support a signed zero (see annex F)
      cannot distinguish the sides of branch cuts. These implementations shall
      map a cut so the function is continuous as the cut is approached coming
      around the finite endpoint of the cut in a counter clockwise
      direction. (Branch cuts for the functions specified here have just one
      finite endpoint.) For example, for the square root function, coming
      counter clockwise around the finite endpoint of the cut along the
      negative real axis approaches the cut from above, so the cut maps to the
      positive imaginary axis.</d:para>
    </d:sect1>
    <d:sect1 id="cx_limited_range">
      <d:indexterm>
        <d:primary>CX_LIMITED_RANGE Pragma</d:primary>
      </d:indexterm>
      <d:title>The CX_LIMITED_RANGE Pragma</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;complex.h>
#pragma STDC CX_LIMITED_RANGE on-off-switch</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The usual mathematical formulas for complex multiply, divide, and
absolute value are problematic because of their treatment of infinities and
because of undue overflow and underflow. The <d:code>CX_LIMITED_RANGE</d:code>
pragma can be used to inform the implementation that (where the state is “on”)
the usual mathematical formulas are acceptable.<d:footnote><d:para>The purpose
of the pragma is to allow the implementation to use the
formulas.</d:para>
<d:para>
  <d:inlineequation><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi><mo>)</mo><mo>&#215;</mo><mo>(</mo><mi>u</mi><mo>+</mo><mi>i</mi><mi>v</mi><mo>)</mo><mo>=</mo><mo>(</mo><mi>x</mi><mi>u</mi><mo>-</mo><mi>y</mi><mi>v</mi><mo>)</mo><mo>+</mo><mi>i</mi><mo>(</mo><mi>x</mi><mi>v</mi><mo>+</mo><mi>y</mi><mi>u</mi><mo>)</mo></math></d:inlineequation>
</d:para>
<d:para>
  <d:inlineequation><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi><mo>)</mo><mo>/</mo><mo>(</mo><mi>u</mi><mo>+</mo><mi>i</mi><mi>v</mi><mo>)</mo><mo>=</mo><mo>[</mo><mo>(</mo><mi>x</mi><mi>u</mi><mo>+</mo><mi>y</mi><mi>v</mi><mo>)</mo><mo>+</mo><mi>i</mi><mo>(</mo><mi>x</mi><mi>v</mi><mo>-</mo><mi>y</mi><mi>u</mi><mo>)</mo><mo>]</mo><mo>/</mo><mo>(</mo><msup><mi>u</mi><mn>2</mn></msup><mo>+</mo><msup><mi>v</mi><mn>2</mn></msup><mo>)</mo></math></d:inlineequation>
</d:para>
<d:para>
  <d:inlineequation><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>|</mo><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi><mo>|</mo><mo>=</mo><msqrt><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></msqrt></math></d:inlineequation>
</d:para>
<d:para>
  where the programmer can determine they are safe.
</d:para>
</d:footnote> The pragma can occur either outside external
declarations or preceding all explicit declarations and statements inside a
compound statement. When outside external declarations, the pragma takes effect
from its occurrence until another <d:code>CX_LIMITED_RANGE</d:code> pragma is
encountered, or until the end of the translation unit. When inside a compound
statement, the pragma takes effect from its occurrence until another
<d:code>CX_LIMITED_RANGE</d:code> pragma is encountered (including within a
nested compound statement), or until the end of the compound statement; at the
end of a compound statement the state for the pragma is restored to its
condition just before the compound statement. If this pragma is used in any
other context, the behavior is undefined. The default state for the pragma is
“off”.</d:para>
</d:sect1>
<d:sect1>
  <d:indexterm>
    <d:primary>complex trigonometric functions</d:primary>
  </d:indexterm>
  <d:title>Trigonometric functions</d:title>
  <d:sect2>
    <d:indexterm>
      <d:primary>cacos function</d:primary>
    </d:indexterm>
    <d:title>The cacos functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Descriptiotn</d:emphasis></d:para>
<d:para>The <d:code>cacos</d:code> functions compute the complex arc cosine of
<d:code>z</d:code>, with branch cuts outside the interval <d:code>[-1,
+1]</d:code> along the real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cacos</d:code> functions return the complex arc cosine value, in the range
of a strip mathematically unbounded along the imaginary axis and in the
interval [0, <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacos(z)]=%lf and Im[cacos(z)]=%lf\n", creal(cacos(z)), cimag(cacos(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like <d:code>clang filename.c -lm</d:code>. Execution gives
following output:</d:para>
<d:screen>Re[cacos(z)]=0.936812 and Im[cacos(z)]=-2.305509</d:screen>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>casin functions</d:primary>
    </d:indexterm>
    <d:title>The casin functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>casin</d:code> functions compute the complex arc sine of
<d:code>z</d:code>, with branch cuts outside the interval [-1, +1] along the
real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions return the complex arc sine value, in
the range of a strip mathematically unbounded along the imaginary axis and in
the interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacsin(z)]=%lf and Im[cacsin(z)]=%lf\n", creal(casin(z)), cimag(casin(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like <d:code>clang filename.c -lm</d:code>. Execution gives
following output:</d:para>
<d:screen>Re[cacsin(z)]=0.633984 and Im[cacsin(z)]=2.305509</d:screen>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>catan functions</d:primary>
    </d:indexterm>
    <d:title>The catan functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>catan</d:code> functions compute the complex arc tangent of
<d:code>z</d:code>, with branch cuts outside the interval [-i, +i] along the
imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>catan</d:code> functions return the complex arc tangent
value, in the range 
of a strip mathematically unbounded along the imaginary axis and in the
interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML"> 
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cactan(z)]=%lf and Im[cactan(z)]=%lf\n", creal(catan(z)), cimag(catan(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like . Execution<d:code>clang filename.c -lm</d:code> gives
following output:</d:para>
<d:screen>Re[cactan(z)]=1.448307 and Im[cactan(z)]=0.158997</d:screen>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>ccos functions</d:primary>
    </d:indexterm>
    <d:title>The ccos functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ccos</d:code> functions compute the complex cosine of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ccos</d:code> functions return the complex cosine
value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ccos(z)]=%lf and Im[ccos(z)]=%lf\n", creal(ccos(z)), cimag(ccos(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ccos(z)]=-27.034946 and Im[ccos(z)]=-3.851153</d:screen>
  </d:sect2>
  <d:sect2>
    <d:indexterm>
      <d:primary>csin functions</d:primary>
    </d:indexterm>
    <d:title>The csin functions</d:title>
    <d:para>Synopsis</d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions compute the complex sine of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Desciption</d:emphasis></d:para>
<d:para>The <d:code>csin</d:code> functions return the complex sine
value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[csin(z)]=%lf and Im[csin(z)]=%lf\n", creal(csin(z)), cimag(csin(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[csin(z)]=3.853738 and Im[csin(z)]=-27.01681</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The ctan functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ctan</d:code> functions compute the complex tangent of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ctan</d:code> functions return the complex tangent
value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ctann(z)]=%lf and Im[ctan(z)]=%lf\n", creal(ctan(z)), cimag(ctan(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ctann(z)]=-0.000187 and Im[ctan(z)]=0.999356</d:screen>
  </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:indexterm>
        <d:primary>complex hyperbolic functions</d:primary>
      </d:indexterm>
      <d:title>Hyperbolic functions</d:title>
      <d:sect2>
        <d:indexterm>
          <d:primary>cacosh functions</d:primary>
        </d:indexterm>
	<d:title>The cacosh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cacosh</d:code> functions compute the complex arc
hyperbolic cosine of <d:code>z</d:code>, with a branch cut at values less than
1 along the real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cacosh</d:code> functions return the complex arc hyperbolic
cosine value, in the range of a half-strip of non-negative values along the
real axis and in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacosh(z)]=%lf and Im[cacosh(z)]=%lf\n", creal(cacosh(z)), cimag(cacosh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cacosh(z)]=2.305509 and Im[cacosh(z)]=0.93681</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>casinh functions</d:primary>
        </d:indexterm>
	<d:title>The casinh function</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>casinh</d:code> functions compute the complex arc
hyperbolic sine of <d:code></d:code>, with branch cuts outside the interval
[-i, +i] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>casinh</d:code> functions return the complex arc hyperbolic
sine value, in the range of a strip mathematically unbounded along the real
axis and in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[casinh(z)]=%lf and Im[casinh(z)]=%lf\n", creal(casinh(z)), cimag(casinh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[casinh(z)]=2.299914 and Im[casinh(z)]=0.917617</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>catanh functions</d:primary>
        </d:indexterm>
	<d:title>The catanh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex catanh(double complex z);
float complex catanhf(float complex z);
long double complex catanhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>catanh</d:code> functions compute the complex arc
hyperbolic tangent of <d:code>z</d:code>, with branch cuts outside the interval
[-1, +1] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Rerurns</d:emphasis></d:para>
<d:para>The <d:code>catanh</d:code> functions return the complex arc hyperbolic
tangent value, in the range of a strip mathematically unbounded along the real
axis and in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>]</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[catanh(z)]=%lf and Im[catanh(z)]=%lf\n", creal(catanh(z)), cimag(catanh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[catanh(z)]=0.117501 and Im[catanh(z)]=1.409921</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>ccosh functions</d:primary>
        </d:indexterm>
	<d:title>The ccosh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ccosh</d:code> functions compute the complex hyperbolic
cosine of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ccosh</d:code> functions return the complex hyperbolic
cosine value.</d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ccosh(z)]=%lf and Im[ccosh(z)]=%lf\n", creal(ccosh(z)), cimag(ccosh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ccosh(z)]=-6.580663 and Im[ccosh(z)]=-7.581553</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>csinh functions</d:primary>
        </d:indexterm>
	<d:title>The csinh functions</d:title>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex csinh(double complex z);
float complex csinhf(float complex z);
long double complex csinhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>csinh</d:code> functions compute the complex hyperbolic
sine of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>csinh</d:code> functions return the complex hyperbolic sine
value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[csinh(z)]=%lf and Im[csinh(z)]=%lf\n", creal(csinh(z)), cimag(csinh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[csinh(z)]=-6.548120 and Im[csinh(z)]=-7.619232</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>ctanh functions</d:primary>
        </d:indexterm>
	<d:title>The ctanh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ctanh(double complex z);
float complex ctanhf(float complex z);
long double complex ctanhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ctanh</d:code> functions compute the complex hyperbolic
tangent of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ctanh</d:code> functions return the complex hyperbolic
tangent value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ctanh(z)]=%lf and Im[ctanh(z)]=%lf\n", creal(ctanh(z)), cimag(ctanh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ctanh(z)]=1.000710 and Im[ctanh(z)]=0.004908</d:screen>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:indexterm>
        <d:primary>complex exponential functions</d:primary>
      </d:indexterm>
      <d:indexterm>
        <d:primary>complex logarithmic functions</d:primary>
      </d:indexterm>
      <d:title>Exponential and logarithmic functions</d:title>
      <d:sect2>
        <d:indexterm>
          <d:primary>cexp functions</d:primary>
        </d:indexterm>
	<d:title>The cexp functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cexp(double complex z);
float complex cexpf(float complex z);
long double complex cexpl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cexp</d:code> functions compute the complex base-e
exponential of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cexp</d:code> functions return the complex base-e
exponential value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cexp(z)]=%lf and Im[cexp(z)]=%lf\n", creal(cexp(z)), cimag(cexp(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cexp(z)]=-13.128783 and Im[cexp(z)]=-15.200784</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>clog functions</d:primary>
        </d:indexterm>
	<d:title>The clog functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex clog(double complex z);
float complex clogf(float complex z);
long double complex clogl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>clog</d:code> functions compute the complex natural
(base-e) logarithm of <d:code>z</d:code>, with a branch cut along the negative
real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The clog functions return the complex natural logarithm value, in the
range of a strip mathematically unbounded along the real axis and in the
interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation> ] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:para><d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[clog(z)]=%lf and Im[clog(z)]=%lf\n", creal(clog(z)), cimag(clog(z)));

  return 0;
}</d:programlisting></d:para>
and the output is:
<d:screen>Re[clog(z)]=1.609438 and Im[clog(z)]=0.927295</d:screen>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:indexterm>
        <d:primary>complex power functions</d:primary>
      </d:indexterm>
      <d:indexterm>
        <d:primary>complex absolute-value functions</d:primary>
      </d:indexterm>
      <d:title>Power and absolute-value functions</d:title>
      <d:sect2>
        <d:indexterm>
          <d:primary>cabs functions</d:primary>
        </d:indexterm>
	<d:title>The cabs functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double cabs(double complex z);
float cabsf(float complex z);
long double cabsl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cabs</d:code> functions compute the complex absolute value
(also called norm, modulus, or magnitude) of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">The <d:code>cabs</d:code> functions return the
complex absolute value.</d:emphasis></d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cabs(z)]=%lf and Im[cabs(z)]=%lf\n", creal(cabs(z)), cimag(cabs(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cabs(z)]=5.000000 and Im[cabs(z)]=0.000000</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>cpow functions</d:primary>
        </d:indexterm>
	<d:title>The cpow functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cpow(double complex x, double complex y);
float complex cpowf(float complex x, float complex y);
long double complex cpowl(long double complex x, long double complex y);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cpow</d:code> functions compute the complex power function
<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:msup>
    <mml:mi>x</mml:mi>
    <mml:mi>y</mml:mi>
  </mml:msup>
</mml:math></d:inlineequation>, with a branch cut for the first parameter along
the negative real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cpow</d:code> functions return the complex power function
value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cpow(z, z)]=%lf and Im[cpow(z, z)]=%lf\n", creal(cpow(z, z)), cimag(cpow(z, z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cpow(z, z)]=-2.997991 and Im[cpow(z, z)]=0.623785</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>csqrt functions</d:primary>
        </d:indexterm>
	<d:title>The csqrt functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex csqrt(double complex z);
float complex csqrtf(float complex z);
long double complex csqrtl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>csqrt</d:code> functions compute the complex square root of
<d:code>z</d:code>, with a branch cut along the negative real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions return the complex square root value,
in the range of the right halfplane (including the imaginary axis).</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[csqrt(z)]=%lf and Im[csqrt(z)]=%lf\n", creal(csqrt(z)), cimag(csqrt(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[csqrt(z)]=2.000000 and Im[csqrt(z)]=1.000000</d:screen>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:indexterm>
        <d:primary>complex manipulation functions</d:primary>
      </d:indexterm>
      <d:title>Manipulation functions</d:title>
      <d:sect2>
        <d:indexterm>
          <d:primary>carg functions</d:primary>
        </d:indexterm>
	<d:title>The carg functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double carg(double complex z);
float cargf(float complex z);
long double cargl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions compute the argument (also called phase
angle) of <d:code>z</d:code>, with a branch cut along the negative real
axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The carg functions return the value of the argument in the interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation></d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[carg(z)]=%lf and Im[carg(z)]=%lf\n", creal(carg(z)), cimag(carg(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[carg(z)]=0.927295 and Im[carg(z)]=0.000000</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>cimag functions</d:primary>
        </d:indexterm>
	<d:title>The cimag functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double cimag(double complex z);
float cimagf(float complex z);
long double cimagl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cimag</d:code> functions compute the imaginary part of
<d:code>z</d:code>.<d:footnote><d:para>For a variable <d:code>z</d:code> of
complex type, <d:code>z == creal(z) +
cimag(z)*I</d:code>.</d:para></d:footnote></d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cimag</d:code> functions return the imaginary part value
(as a real).</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cimag(z)]=%lf and Im[cimag(z)]=%lf\n", creal(cimag(z)), cimag(cimag(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cimag(z)]=4.000000 and Im[cimag(z)]=0.000000</d:screen>
<d:sect2>
  <d:title>The CMPLX macros</d:title>
  <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
  <d:programlisting role="CLexer"><![CDATA[#include <complex.h>
double complex CMPLX(double x, double y);
float complex CMPLXF(float x, float y);
long double complex CMPLXL(long double x, long double y);]]></d:programlisting>
  <d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
  <d:para>
    The <d:code>CMPLX</d:code> macros expand to an expression of the specified
    complex type, with the real part having the (converted) value of
    <d:code>x</d:code> and the imaginary part having the (converted) value of
    <d:code>y</d:code>. The resulting expression shall be suitable for use as
    an initializer for an object with static or thread storage duration,
    provided both arguments are likewise suitable.
  </d:para>
  <d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
  <d:para>
    The <d:code>CMPLX</d:code> macros return the complex value <d:code>x +
    iy</d:code>.
  </d:para>
  <d:para>
    NOTE These macros act as if the implementation supported imaginary types
    and the definitions were:
  </d:para>
  <d:programlisting role="CLexer"><![CDATA[#define CMPLX(x, y)  ((double complex)((double)(x) + \
                             _Imaginary_I * (double)(y)))
#define CMPLXF(x, y) ((float complex)((float)(x) + \
                             _Imaginary_I * (float)(y)))
#define CMPLXL(x, y) ((long double complex)((long double)(x) + \
                            _Imaginary_I * (long double)(y)))]]></d:programlisting>
</d:sect2>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>conj functions</d:primary>
        </d:indexterm>
	<d:title>The conj functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>conj</d:code> functions compute the complex conjugate of
<d:code>z</d:code>, by reversing the sign of its imaginary part.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>conj</d:code> functions return the complex conjugate
value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[conj(z)]=%lf and Im[conj(z)]=%lf\n", creal(conj(z)), cimag(conj(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[conj(z)]=3.000000 and Im[conj(z)]=-4.000000</d:screen>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>cproj function</d:primary>
        </d:indexterm>
	<d:title>The cproj functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cproj(double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cproj</d:code> functions compute a projection of
<d:code>z</d:code> onto the Riemann sphere: <d:code>z</d:code> projects to
<d:code>z</d:code> except that all complex infinities (even those with one
infinite part and one NaN part) project to positive infinity on the real
axis. If <d:code>z</d:code> has an infinite part, then
<d:code>cproj(z)</d:code> is equivalent to:</d:para>
<d:screen>INFINITY + I * copysign(0.0, cimag(z))</d:screen>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cproj</d:code> functions return the value of the projection
onto the Riemann sphere.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cproj(z)]=%lf and Im[cproj(z)]=%lf\n", creal(cproj(z)), cimag    (cproj(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cproj(z)]=3.000000 and Im[cproj(z)]=4.000000</d:screen>
<d:para>Since our complex number was finite, it projected itself.</d:para>
      </d:sect2>
      <d:sect2>
        <d:indexterm>
          <d:primary>creal functions</d:primary>
        </d:indexterm>
	<d:title>The creal function</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double creal(double complex z);
float crealf(float complex z);
long double creall(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>creal</d:code> functions compute the real part of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>creal</d:code> functions return the real part
value.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[creal(z)]=%lf and Im[creal(z)]=%lf\n", creal(creal(z)), cimag    (creal(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[creal(z)]=3.000000 and Im[creal(z)]=0.000000</d:screen>
      </d:sect2>
    </d:sect1>
</d:chapter>
