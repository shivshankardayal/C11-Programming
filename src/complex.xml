<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
    <?dbhtml filename="complex/index.html" ?>
    <d:title>Complex arithmetic &amp;lt;complex.h></d:title>
    <d:sect1>
      <d:title>Introduction</d:title>
      <d:para>The header <d:code>&amp;lt;complex.h></d:code> defines macros and
      declares functions that support complex arithmetic. Each synopsis
      specifies a family of functions consisting of a principal function with
      one or more <d:code>double complex</d:code> parameters and a
      <d:code>double complex</d:code> or <d:code>double</d:code> 
      return value; and other functions with the same name but with f and l
      suffixes which are corresponding functions with <d:code>float</d:code>
      and <d:code>long double</d:code> parameters and return values.</d:para>
      <d:para>The macro complex expands to <d:code>_Complex</d:code>; the macro
      <d:code>_Complex_I</d:code> expands to a constant expression of type
      <d:code>const float _Complex</d:code>, with the value of the imaginary
      unit.<d:footnote><d:para>The imaginary unit is a number
      <d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>i</mml:mi>
</mml:math></d:inlineequation> such that <d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:msup>
    <mml:mi>i</mml:mi>
    <mml:mn>2</mml:mn>
  </mml:msup>
  <mml:mo>=</mml:mo>
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mn>1</mml:mn>
</mml:math></d:inlineequation></d:para></d:footnote>.</d:para>
<d:para>The macro <d:code>I</d:code> expands to
<d:code>_Complex_I</d:code>.</d:para>
<d:para>Notwithstanding the provisions of reserved identifiers, a program may
undefine and perhaps then redefine the macros <d:code>complex</d:code> and
<d:code>I</d:code>.</d:para>
<d:para><d:emphasis role="bold">Forward references:</d:emphasis> IEC
60559-compatible complex arithmetic (annex G).</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>Conventions</d:title>
      <d:para>Values are interpreted as radians, not degrees. An implementation
      may set errno but is not required to.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>Branch Cuts</d:title>
      <d:para>Some of the functions below have branch cuts, across which the
      function is discontinuous. For implementations with a signed zero
      (including all IEC 60559 implementations) that follow the specifications
      of annex G, the sign of zero distinguishes one side of a cut from another
      so the function is continuous (except for format limitations) as the cut
      is approached from either side. For example, for the square root
      function, which has a branch cut along the negative real axis, the top of
      the cut, with imaginary part +0, maps to the positive imaginary axis, and
      the bottom of the cut, with imaginary part -0, maps to the negative
      imaginary axis.</d:para>
      <d:para>Implementations that do not support a signed zero (see annex F)
      cannot distinguish the sides of branch cuts. These implementations shall
      map a cut so the function is continuous as the cut is approached coming
      around the finite endpoint of the cut in a counter clockwise
      direction. (Branch cuts for the functions specified here have just one
      finite endpoint.) For example, for the square root function, coming
      counter clockwise around the finite endpoint of the cut along the
      negative real axis approaches the cut from above, so the cut maps to the
      positive imaginary axis.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>The CX_LIMITED_RANGE Pragma</d:title>
      <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
      <d:programlisting role="CLexer">#include &lt;complex.h>
#pragma STDC CX_LIMITED_RANGE on-off-switch</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The usual mathematical formulas for complex multiply, divide, and
absolute value are problematic because of their treatment of infinities and
because of undue overflow and underflow. The <d:code>CX_LIMITED_RANGE</d:code>
pragma can be used to inform the implementation that (where the state is “on”)
the usual mathematical formulas are acceptable.<d:footnote><d:para>The purpose
of the pragma is to allow the implementation to use the
formulas.</d:para></d:footnote> The pragma can occur either outside external
declarations or preceding all explicit declarations and statements inside a
compound statement. When outside external declarations, the pragma takes effect
from its occurrence until another <d:code>CX_LIMITED_RANGE</d:code> pragma is
encountered, or until the end of the translation unit. When inside a compound
statement, the pragma takes effect from its occurrence until another
<d:code>CX_LIMITED_RANGE</d:code> pragma is encountered (including within a
nested compound statement), or until the end of the compound statement; at the
end of a compound statement the state for the pragma is restored to its
condition just before the compound statement. If this pragma is used in any
other context, the behavior is undefined. The default state for the pragma is
“off”.</d:para>
</d:sect1>
<d:sect1>
  <d:title>Trigonometric functions</d:title>
  <d:sect2>
    <d:title>The cscos functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Descriptiotn</d:emphasis></d:para>
<d:para>The <d:code>cacos</d:code> functions compute the complex arc cosine of
<d:code>z</d:code>, with branch cuts outside the interval <d:code>[-1,
+1]</d:code> along the real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cacos</d:code> functions return the complex arc cosine value, in the range
of a strip mathematically unbounded along the imaginary axis and in the
interval [0, <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm</d:code>.</d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cacos()</d:code> function calculates the complex arc cosine
of <d:code>z</d:code>. If <d:code>y = cacos(z)</d:code>, then <d:code>z =
ccos(y)</d:code>. The real part of <d:code>y</d:code> is chosen in the interval
[0, <d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>].</d:para>
<d:para>One has:</d:para>
<d:screen>cacos(z) = -i * clog(z + i * csqrt(1 - z * z))</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacos(z)]=%lf and Im[cacos(z)]=%lf\n", creal(cacos(z)), cimag(cacos(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like <d:code>clang filename.c -lm</d:code>. Execution gives
following output:</d:para>
<d:screen>Re[cacos(z)]=0.936812 and Im[cacos(z)]=-2.305509</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The casin functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>casin</d:code> functions compute the complex arc sine of
<d:code>z</d:code>, with branch cuts outside the interval [-1, +1] along the
real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions return the complex arc sine value, in
the range of a strip mathematically unbounded along the imaginary axis and in
the interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:screen>csin(z) = (exp(i * z) - exp(-i * z)) / (2 * i)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacsin(z)]=%lf and Im[cacsin(z)]=%lf\n", creal(casin(z)), cimag(casin(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like <d:code>clang filename.c -lm</d:code>. Execution gives
following output:</d:para>
<d:screen>Re[cacsin(z)]=0.633984 and Im[cacsin(z)]=2.305509</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The cstan functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>catan</d:code> functions compute the complex arc tangent of
<d:code>z</d:code>, with branch cuts outside the interval [-i, +i] along the
imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>catan</d:code> functions return the complex arc tangent
value, in the range 
of a strip mathematically unbounded along the imaginary axis and in the
interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML"> 
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm</d:code>.</d:para>
<d:para>The <d:code>catan()</d:code> function calculates the complex arc tangent of <d:code>z</d:code>. If <d:code>y = catan(z)</d:code>, then <d:code>z = ctan(y)</d:code>. The real part of <d:code>y</d:code> is chosen in the interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>].</d:para>
<d:para>One has:</d:para>
<d:screen>catan(z) = (clog(1 + i * z) - clog(1 - i * z)) / (2 * i)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cactan(z)]=%lf and Im[cactan(z)]=%lf\n", creal(catan(z)), cimag(catan(z)));

  return 0;
}</d:programlisting>
<d:para>Compile like . Execution<d:code>clang filename.c -lm</d:code> gives
following output:</d:para>
<d:screen>Re[cactan(z)]=1.448307 and Im[cactan(z)]=0.158997</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The ccos functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ccos</d:code> functions compute the complex cosine of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ccos</d:code> functions return the complex cosine
value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm</d:code>.</d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The complex cosine function is defined as:</d:para>
<d:screen>ccos(z) = (exp(i * z) + exp(-i * z)) / 2</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ccos(z)]=%lf and Im[ccos(z)]=%lf\n", creal(ccos(z)), cimag(ccos(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ccos(z)]=-27.034946 and Im[ccos(z)]=-3.851153</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The csin functions</d:title>
    <d:para>Synopsis</d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions compute the complex sine of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Desciption</d:emphasis></d:para>
<d:para>The <d:code>csin</d:code> functions return the complex sine
value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm</d:code>.</d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The complex sine function is defined as:</d:para>
<d:screen>csin(z) = (exp(i * z) - exp(-i * z)) / (2 * i)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[csin(z)]=%lf and Im[csin(z)]=%lf\n", creal(csin(z)), cimag(csin(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[csin(z)]=3.853738 and Im[csin(z)]=-27.01681</d:screen>
  </d:sect2>
  <d:sect2>
    <d:title>The ctan functions</d:title>
    <d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
    <d:programlisting role="CLexer">#include &lt;complex.h>
double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ctan</d:code> functions compute the complex tangent of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ctan</d:code> functions return the complex tangent
value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The complex tangent function is defined as:</d:para>
<d:screen>ctan(z) = csin(z) / ccos(z)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ctann(z)]=%lf and Im[ctan(z)]=%lf\n", creal(ctan(z)), cimag(ctan(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ctann(z)]=-0.000187 and Im[ctan(z)]=0.999356</d:screen>
  </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Hyperbolic functions</d:title>
      <d:sect2>
	<d:title>The cscosh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cacosh</d:code> functions compute the complex arc
hyperbolic cosine of <d:code>z</d:code>, with a branch cut at values less than
1 along the real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cacosh</d:code> functions return the complex arc hyperbolic
cosine value, in the range of a half-strip of non-negative values along the
real axis and in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cacosh()</d:code> function calculates the complex arc
hyperpolic cosine of <d:code>z</d:code>. If <d:code>y = cacosh(z)</d:code>,
then <d:code>z = ccosh(y)</d:code>. The imaginary part of <d:code>y</d:code> is
chosen in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>]. The real part of <d:code>y</d:code> is chosen
nonnegative.</d:para>
<d:para>One has:</d:para>
<d:screen>cacosh(z) = 2 * clog(csqrt((z + 1) / 2) + csqrt((z - 1) /
2))</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cacosh(z)]=%lf and Im[cacosh(z)]=%lf\n", creal(cacosh(z)), cimag(cacosh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cacosh(z)]=2.305509 and Im[cacosh(z)]=0.93681</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The casinh function</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>casinh</d:code> functions compute the complex arc
hyperbolic sine of <d:code></d:code>, with branch cuts outside the interval
[-i, +i] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>casinh</d:code> functions return the complex arc hyperbolic
sine value, in the range of a strip mathematically unbounded along the real
axis and in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>casinh()</d:code> function calculates the complex arc
hyperbolic sine of <d:code>z</d:code>. If <d:code></d:code>, then <d:code>z =
csinh(y)</d:code>. The imaginary part of <d:code>y</d:code> is chosen in the
interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>].</d:para>
<d:para>One has:</d:para>
<d:screen>casinh(z) = clog(z + csqrt(z * z + 1))</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[casinh(z)]=%lf and Im[casinh(z)]=%lf\n", creal(casinh(z)), cimag(casinh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[casinh(z)]=2.299914 and Im[casinh(z)]=0.917617</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The catanh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex catanh(double complex z);
float complex catanhf(float complex z);
long double complex catanhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>catanh</d:code> functions compute the complex arc
hyperbolic tangent of <d:code>z</d:code>, with branch cuts outside the interval
[-1, +1] along the real axis.</d:para>
<d:para><d:emphasis role="bold">Rerurns</d:emphasis></d:para>
<d:para>The <d:code>catanh</d:code> functions return the complex arc hyperbolic
tangent value, in the range of a strip mathematically unbounded along the real
axis and in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation></d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex catanh(double complex z);
float complex catanhf(float complex z);
long double complex catanhl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Desacription</d:emphasis></d:para>
<d:para>The <d:code>catanh()</d:code> function calculates the complex arc
hyperbolic tangent of <d:code>z</d:code>. If <d:code>y = catanh(z)</d:code>,
then <d:code>z = ctanh(y)</d:code>. The imaginary part of <d:code>y</d:code> is
chosen in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mrow class="MJX-TeXAtom-ORD">
    <mml:mo>/</mml:mo>
  </mml:mrow>
  <mml:mn>2</mml:mn>
</mml:math></d:inlineequation>].</d:para>
<d:para>One has:</d:para>
<d:screen>catanh(z) = 0.5 * (clog(1 + z) - clog(1 - z))</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[catanh(z)]=%lf and Im[catanh(z)]=%lf\n", creal(catanh(z)), cimag(catanh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[catanh(z)]=0.117501 and Im[catanh(z)]=1.409921</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The ccosh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ccosh</d:code> functions compute the complex hyperbolic
cosine of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ccosh</d:code> functions return the complex hyperbolic
cosine value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>One has:</d:para>
<d:screen>ccosh(z) = (exp(z)+exp(-z))/2</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ccosh(z)]=%lf and Im[ccosh(z)]=%lf\n", creal(ccosh(z)), cimag(ccosh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ccosh(z)]=-6.580663 and Im[ccosh(z)]=-7.581553</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The csinh functions</d:title>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex csinh(double complex z);
float complex csinhf(float complex z);
long double complex csinhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>csinh</d:code> functions compute the complex hyperbolic
sine of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>csinh</d:code> functions return the complex hyperbolic sine
value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex csinh(double complex z);
float complex csinhf(float complex z);
long double complex csinhl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The complex hyperbolic sine function is defined as:</d:para>
<d:screen>csinh(z) = (exp(z)-exp(-z))/2</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[csinh(z)]=%lf and Im[csinh(z)]=%lf\n", creal(csinh(z)), cimag(csinh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[csinh(z)]=-6.548120 and Im[csinh(z)]=-7.619232</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The ctanh functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ctanh(double complex z);
float complex ctanhf(float complex z);
long double complex ctanhl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>ctanh</d:code> functions compute the complex hyperbolic
tangent of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>ctanh</d:code> functions return the complex hyperbolic
tangent value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex ctanh(double complex z);
float complex ctanhf(float complex z);
long double complex ctanhl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The complex hyperbolic tangent function is defined mathematically
as:</d:para>
<d:screen>ctanh(z) = csinh(z) / ccosh(z)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[ctanh(z)]=%lf and Im[ctanh(z)]=%lf\n", creal(ctanh(z)), cimag(ctanh(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[ctanh(z)]=1.000710 and Im[ctanh(z)]=0.004908</d:screen>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Exponential and logrithmic functions</d:title>
      <d:sect2>
	<d:title>The cexp functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cexp(double complex z);
float complex cexpf(float complex z);
long double complex cexpl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cexp</d:code> functions compute the complex base-e
exponential of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cexp</d:code> functions return the complex base-e
exponential value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cexp(double complex z);
float complex cexpf(float complex z);
long double complex cexpl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">The function calculates e (2.71828..., the base
of natural logarithms) raised to the power of
<d:code>z</d:code>.</d:emphasis></d:para>
<d:para>One has:</d:para>
<d:screen>cexp(I * z) = ccos(z) + I * csin(z)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cexp(z)]=%lf and Im[cexp(z)]=%lf\n", creal(cexp(z)), cimag(cexp(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cexp(z)]=-13.128783 and Im[cexp(z)]=-15.200784</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The clog functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex clog(double complex z);
float complex clogf(float complex z);
long double complex clogl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>clog</d:code> functions compute the complex natural
(base-e) logarithm of <d:code>z</d:code>, with a branch cut along the negative
real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The clog functions return the complex natural logarithm value, in the
range of a strip mathematically unbounded along the real axis and in the
interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>i</mml:mi>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation> ] along the imaginary axis.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex clog(double complex z);
float complex clogf(float complex z);
long double complex clogl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The logarithm <d:code>code</d:code> is the inverse function of the
exponential <d:code>cesp()</d:code>. Thus, if <d:code>y = clog(z)</d:code>,
then <d:code>z = cexp(y)</d:code>. The imaginary part of <d:code>y</d:code> is
chosen in the interval [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>].</d:para>
<d:para>One has:</d:para>
<d:screen>clog(z) = log(cabs(z)) + I * carg(z)</d:screen>
<d:para><d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[clog(z)]=%lf and Im[clog(z)]=%lf\n", creal(clog(z)), cimag(clog(z)));

  return 0;
}</d:programlisting></d:para>
and the output is:
<d:screen>Re[clog(z)]=1.609438 and Im[clog(z)]=0.927295</d:screen>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Power and absolute-value functions</d:title>
      <d:sect2>
	<d:title>The cabs functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double cabs(double complex z);
float cabsf(float complex z);
long double cabsl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cabs</d:code> functions compute the complex absolute value
(also called norm, modulus, or magnitude) of <d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">The <d:code>cabs</d:code> functions return the
complex absolute value.</d:emphasis></d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double cabs(double complex z);
float cabsf(float complex z);
long double cabsl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cabs()</d:code> function returns the absolute value of the
complex number <d:code>z</d:code>. The result is a real number.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cabs(z)]=%lf and Im[cabs(z)]=%lf\n", creal(cabs(z)), cimag(cabs(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cabs(z)]=5.000000 and Im[cabs(z)]=0.000000</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The cpow functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cpow(double complex x, double complex y);
float complex cpowf(float complex x, float complex y);
long double complex cpowl(long double complex x, long double complex y);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cpow</d:code> functions compute the complex power function
<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:msup>
    <mml:mi>x</mml:mi>
    <mml:mi>y</mml:mi>
  </mml:msup>
</mml:math></d:inlineequation>, with a branch cut for the first parameter along
the negative real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cpow</d:code> functions return the complex power function
value.</d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cpow(double complex x, double complex y);
float complex cpowf(float complex x, float complex y);
long double complex cpowl(long double complex x, long double complex y);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The function calculates <d:code>x</d:code> raised to the power
<d:code>z</d:code>. (With a branch cut for <d:code>x</d:code> along the
negative real axis.)</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cpow(z, z)]=%lf and Im[cpow(z, z)]=%lf\n", creal(cpow(z, z)), cimag(cpow(z, z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cpow(z, z)]=-2.997991 and Im[cpow(z, z)]=0.623785</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The csqrt functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex csqrt(double complex z);
float complex csqrtf(float complex z);
long double complex csqrtl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>csqrt</d:code> functions compute the complex square root of
<d:code>z</d:code>, with a branch cut along the negative real axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions return the complex square root value,
in the range of the right halfplane (including the imaginary axis).</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex csqrt(double complex z);
float complex csqrtf(float complex z);
long double complex csqrtl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>Calculate the square root of a given complex number, with nonnegative
real part, and with a branch cut along the negative real axis. (That means that
<d:code>csqrt(-1+eps*I)</d:code> will be close to <d:code>I</d:code> while
<d:code>csqrt(-1-eps*I)</d:code> will be close to <d:code>-I</d:code>, if
<d:code>eps</d:code> is a small positive real number.)</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[csqrt(z)]=%lf and Im[csqrt(z)]=%lf\n", creal(csqrt(z)), cimag(csqrt(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[csqrt(z)]=2.000000 and Im[csqrt(z)]=1.000000</d:screen>
      </d:sect2>
    </d:sect1>
    <d:sect1>
      <d:title>Manipulation functions</d:title>
      <d:sect2>
	<d:title>The carg functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double carg(double complex z);
float cargf(float complex z);
long double cargl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code></d:code> functions compute the argument (also called phase
angle) of <d:code>z</d:code>, with a branch cut along the negative real
axis.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The carg functions return the value of the argument in the interval [<d:inlineequation><mml:math xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation></d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double carg(double complex z);
float cargf(float complex z);
long double cargl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>A complex number can be described by two real coordinates. One may use
rectangular coordinates and gets</d:para>
<d:screen>z = x + I * y</d:screen>
<d:para>where <d:code>x = creal(z)</d:code> and <d:code>y =
cimag(z)</d:code>.</d:para>
<d:para>Or one may use polar coordinates and gets:</d:para>
<d:screen>z = r * cexp(I * a)</d:screen>
<d:para>where <d:code>r = cabs(z)</d:code> is the "radius", the "modulus", the
absolute value of <d:code>z</d:code>, and <d:code>a = carg(z)</d:code> is the
"phase angle", the argument of <d:code>z</d:code>.</d:para>
<d:para>One has:</d:para>
<d:screen>tan(carg(z)) = cimag(z) / creal(z)</d:screen>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The return value is the range of [<d:inlineequation><mml:math
xmlns="http://www.w3.org/1998/Math/MathML">
  <mml:mo>&#x2212;<!-- − --></mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
  <mml:mo>,</mml:mo>
  <mml:mo>+</mml:mo>
  <mml:mi>&#x03C0;<!-- π --></mml:mi>
</mml:math></d:inlineequation>].</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[carg(z)]=%lf and Im[carg(z)]=%lf\n", creal(carg(z)), cimag(carg(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[carg(z)]=0.927295 and Im[carg(z)]=0.000000</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The cimag functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double cimag(double complex z);
float cimagf(float complex z);
long double cimagl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cimag</d:code> functions compute the imaginary part of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cimag</d:code> functions return the imaginary part value
(as a real).</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double cimag(double complex z);
float cimagf(float complex z);
long double cimagl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cimag()</d:code> function returns the imaginary part of the
complex number <d:code>z</d:code>.</d:para>
<d:para>One has:</d:para>
<d:screen>z = creal(z) + I * cimag(z)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cimag(z)]=%lf and Im[cimag(z)]=%lf\n", creal(cimag(z)), cimag(cimag(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cimag(z)]=4.000000 and Im[cimag(z)]=0.000000</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The conj functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>conj</d:code> functions compute the complex conjugate of
<d:code>z</d:code>, by reversing the sign of its imaginary part.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>conj</d:code> functions return the complex conjugate
value.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>conj()</d:code> function returns the complex conjugate
value of <d:code>z</d:code>. That is the value obtained by changing the sign of
the imaginary part.</d:para>
<d:para>One has:</d:para>
<d:screen>cabs(z) = csqrt(z * conj(z))</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[conj(z)]=%lf and Im[conj(z)]=%lf\n", creal(conj(z)), cimag(conj(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[conj(z)]=3.000000 and Im[conj(z)]=-4.000000</d:screen>
      </d:sect2>
      <d:sect2>
	<d:title>The cproj functions</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cproj(double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>cproj</d:code> functions compute a projection of
<d:code>z</d:code> onto the Riemann sphere: <d:code>z</d:code> projects to
<d:code>z</d:code> except that all complex infinities (even those with one
infinite part and one NaN part) project to positive infinity on the real
axis. If <d:code>z</d:code> has an infinite part, then
<d:code>cproj(z)</d:code> is equivalent to:</d:para>
<d:screen>INFINITY + I * copysign(0.0, cimag(z))</d:screen>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>cproj</d:code> functions return the value of the projection
onto the Riemann sphere.</d:para>
<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double complex cproj(double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>This function projects a point in the plane onto the surface of a
Riemann Sphere, the one-point compactification of the complex plane. Each
finite point <d:code>z</d:code> projects to <d:code>z</d:code> itself. Every
complex infinite value is projected to a single infinite value, namely to
positive infinity on the real axis.</d:para>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[cproj(z)]=%lf and Im[cproj(z)]=%lf\n", creal(cproj(z)), cimag    (cproj(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[cproj(z)]=3.000000 and Im[cproj(z)]=4.000000</d:screen>
<d:para>Since our complex number was finite, it projected itself.</d:para>
      </d:sect2>
      <d:sect2>
	<d:title>The creal function</d:title>
	<d:para><d:emphasis role="bold">Synopsis</d:emphasis></d:para>
	<d:programlisting role="CLexer">#include &lt;complex.h>
double creal(double complex z);
float crealf(float complex z);
long double creall(long double complex z);</d:programlisting>
<d:para><d:emphasis role="bold">Description</d:emphasis></d:para>
<d:para>The <d:code>creal</d:code> functions compute the real part of
<d:code>z</d:code>.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:para>The <d:code>creal</d:code> functions return the real part
value.</d:para>
<d:para><d:emphasis role="bold">Returns</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;complex.h>
double creal(double complex z);
float crealf(float complex z);
long double creall(long double complex z);</d:programlisting>
<d:para>Link with <d:code>-lm.</d:code></d:para>
<d:para><d:emphasis role="bold">Desciption</d:emphasis></d:para>
<d:para>The <d:code>creal()</d:code> function returns the real part of the
complex number <d:code>z</d:code>.</d:para>
<d:para>One has:</d:para>
<d:screen>z = creal(z) + I * cimag(z)</d:screen>
<d:para><d:emphasis role="bold">Example</d:emphasis></d:para>
<d:programlisting role="CLexer">#include &lt;stdio.h>
#include &lt;complex.h>

int main()
{
  double complex z = 3.0 + 4.0i;

  printf("Re[creal(z)]=%lf and Im[creal(z)]=%lf\n", creal(creal(z)), cimag    (creal(z)));

  return 0;
}</d:programlisting>
and the output is:
<d:screen>Re[creal(z)]=3.000000 and Im[creal(z)]=0.000000</d:screen>
      </d:sect2>
    </d:sect1>
</d:chapter>
