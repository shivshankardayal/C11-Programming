<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
           xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
           xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
  <?dbhtml filename="introduction/index.html" ?>
  <d:title> Introduction </d:title>
  <d:para>C programming language is a relatively low-level programming
  language with an inclination towards system programming. This book
  will try to serve both as a tutorial and reference of C programming
  language. If you have not programmed earlier then you should read in
  linear manner. Even if you have programmed it would be better if you
  read the book in linear fashion because there are certain points which you
  may miss if you skip chapters. Of all popular mainstream 
  languages C, and Lisp are two oldest but we cannot really say that Lisp is
  really popular. It has a niche area(artificial intelligence) and it is there
  for that. So let me redefine my statement. Of all general-purpose and popular
  programming language C is 
  the oldest. FORTRAN is another very old language but it is not
  general purpose programming language. So what makes C so special
  that it is still out there. Well, C and Unix were born almost
  together in early 1970s. Then Unix was ported in C and the notion
  that operating systems can be only written in assembly language,
  because it has to do time critical things, was destroyed. After that
  Unix became very popular. Then when C++ was not yet there Windows
  was written in C and more and more programs were written in C. It
  might have been the case that Microsoft and Apple would have written
  their OS in C++ had it been there. So, essentially what happened
  that there is a lot of code base which is there in C. Also, C++'s
  backward compatibility is one of the reasons why C++ is so
  popular. When C was invented there was no structured programming
  language and code was mostly written in assembly. With C it gave the
  power of assembly and benefits of structured language like code
  reuse, modularity, and portability among others. Because of these
  reasons C became immensely popular and is still popular.</d:para> 
  <d:para>C is simple, small, succinct. It may be dirty but is
  quick. It may have its quirks but it is a success. C is really so
  simple yet so deceptive. It will take one years of programming to
  really thoroughly understand it.</d:para> 
  <d:para>C is currently described by ISO/IEC 9899:2011 which you can
  buy on web or you can get the draft revision <d:link
      xmlns="http://docbook.org/ns/docbook"
      xlink:href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">n1570.pdf</d:link>.
  It is not necessary to buy the specification as draft is very much
  similar. I will refer to specification in the form of (&#167;
  iso.x.x.x.x) to point to sections where exact information is
  discussed. Note that specification is written for accuracy and the
  language is not trivial to understand. At the same time, it does not
  directly address programmers but compiler writers because there are
  certain decisions which specification does not make but rather
  leaves for compiler authors' decision.
  </d:para>
  <d:sect1>
    <d:title>Why C?</d:title>
    <d:para>Because it is the most common denominator. Any language be
    it C++, Java, Perl, Python etc have got bindings in C. Whenever
    you are willing to extend these languages you need to know
    C. Also, if by any chance you are going towards system programming
    you need to C. C is everywhere. There is no escape from learning
    it; it does not matter whether you like it or not.</d:para>
    <d:para>There is one more important point worth noting here is
    that C++ is far more complex compared to C. It is generally
    accepted that one should not try to learn C++ as one's first
    programming language. If you search web then you will find that
    many great computer scientists like Ken Thompson, Richard
    Stallman, Donald Knuth etc. clearly say that they do not like C++
    because it is overly complex. Also, the runtime(virtual functions)
    calculations of C++ make it slightly slower than C. However, C++
    has its own strengths and it excels as well if used properly.
    Wherever there is a memory
    constraint or extreme high performance is needed C is
    preferred. The simple syntax of C means its code is very verbose
    for programmer in the sense that if you read code then you can
    very easily see what instructions the code is going to translate
    into.</d:para>
    <d:para>It is very easy to write interfaces to other languages
    because other languages expose there objects in terms of C
    structures not the other way around. The reason for this is huge
    popularity of C, maturity and large code base.</d:para>
    <d:para>One more important feature is portability. Note that if
    you want your program to have high degree of portability then you
    should not use C99 features but rather ANSI C because ANSI C
    compilers are available on most platforms. Even though Java claims
    to be portable or other interpreted languages they are limited by
    the fact that the interpreters or VMs(JVM in case of Java) is not
    available on all the platforms. Therefore, C is the MOST portable
    language. :-)</d:para>
    <d:para>One of the advantages with C is that since it is very old
    a lot of software has been written using it. GNU/Linux for example
    uses C for its kernel. GNOME which is one of the desktop
    environments of GNU/Linux is also written in C. The fact is that
    since a lot of libraries are available in C thus it makes a lot of
    work very easy to do in C since the infrastructure or ecosystem is
    developed and mature. At the same time, since C is taught in
    many colleges and universities as first course in programming a
    lot of people know C thus if you are writing free(as in freedom)
    software then you have a much higher  chance of getting support if
    you write your code in C.</d:para>
  </d:sect1>
  <d:sect1>
    <d:title>History</d:title>
    <d:para><d:indexterm>
      <d:primary>history</d:primary>
    </d:indexterm>
    <d:indexterm>
      <d:primary>Dennis Ritchie</d:primary>
    </d:indexterm>
      C was formally delivered to this world in 1972
      and started by Dennis MacAlistair Ritchie in 1968. In 1972 C was
      formally announced. C took its features from BCPL a language by
      Martin Richard and B by Ken Thompson. AT&amp;T Bells labs gave
      Unix and a C compiler to many universities at a nominal
      distribution fees because there was a contract between
      government of USA AT&amp;T which forbid them from selling
      software. It grew with leaps and bounds from there and became a
      ubiquitous language along with Unix, which became an immensely
      popular operating system. For many years “The C Programming
      Language”(a book written by Dennis Ritchie and Brian Kernighan
      published in 1978) served as 
      a reference of C. Later it was standardized by ANSI and then by
      ISO standards.
    </d:para> 
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Comparison with
      other Languages</title>
      <d:para>C is a structured, statically typed, somewhat low-level,
      high-performance compiled language. It does not support
      object-oriented programming like most modern programming 
      including C++, Java, Perl, Python, Ruby etc. However, that does
      not mean you cannot do object-oriented programming in C. In
      fact, CFront, written by Bjarne Stroustrup which was first C++
      compiler was actually a translator from C++ to C. It is just
      that C does not have support at the language level and it is
      painful to do so. However, GNOME project has implemented many
      features of object-oriented paradigm in GObject library. C is
      low level because it allows you to handle memory contents
      directly. You have something called <d:code>void</d:code> which
      is raw representation of memory content. C also does not support
      functional or generic programming but again it is possible 
      to do so in a limited manner with painful hacks. One of the
      coveted features is C programs deliver very high performance if
      written correctly as it does not have reunite penalties of
      virtual functions of OOP (object-oriented programming)
      languages.</d:para> 
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">How to Learn
      Programming?</title> 
      <d:para>Programming is exactly like Mathematics. As in
      Mathematics you need to read theory, understand solved problems
      and then solve more and more problems by yourself. If you cannot
      solve ask your teacher. Similarly, in programming you need to
      read about language, try examples given, read code written by
      others and then develop your own code. If you get stuck there
      are umpteen number of tutorials, mailing lists and groups to
      help you. I recommend comp.lang.c user group for C
      programming. Its interface is at <d:link
      xmlns="http://docbook.org/ns/docbook"
      xlink:href="http://groups.google.com/group/comp.lang.c/">http://groups.google.com/group/comp.lang.c/</d:link>.
      You should join it and participate there. <link
      xmlns="http://docbook.org/ns/docbook"
      xlink:href="http://www.stackoverflow.com/">http://www.stackoverflow.com/</link>
      is also a very good forum to ask questions about programming in
      general.</d:para> 
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">What is a Computer
      Program?</title>
      <d:para>As you may know a computer consists of many components
      and one of the most or rather most important part is processor
      often named as CPU (central processing unit). The logic gates in
      CPUs are formed and instructions like ADD (addition), SUB
      (subtraction), MUL(multiplication), DIV(division) etc are
      implemented in hardware of CPU. When we write a program say C
      program the instructions given in our program is translated to a
      format which operating system can understand. In our case that
      is GNU/Linux this executable format is known as ELF (executable
      and linkable format). For the curious you can read <link
      xmlns="http://docbook.org/ns/docbook"
      xlink:href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">http://en.wikipedia.org/wiki/Executable_and_Linkable_Format</link>
      and there are lots of specification for different CPUs. Then
      operating system interprets these files and ask CPU to perform
      action. So a C program does not directly talk to processor but
      it rather talks to operating system or rather kernel of the
      operating system and in turn the operating system or kernel
      provides services to your program.
      </d:para>
    </d:sect1>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">Attributes of a
      Program</title>
      <d:para>You may be wondering so that is very easy. You just
      learn programming in C and start hacking on keyboard to produce
      software. Well, that is partially true but a program has several
      desired attributes which you must consider. Any program cannot
      be considered a good program unless it satisfies following
      requirements or possess following attributes (Note: These are
      generic attributes and not specific to C programming
      language):<orderedlist xmlns="http://docbook.org/ns/docbook">
      <listitem>
        <para><emphasis role="bold">Correctness:</emphasis>
        Correctness means that a program satisfies its requirement
        specification. It means that for a specified input the 
        specified output should be produced. This particular
        attribute is of most significance. It does not matter whether
        other attributes are present or not but this one is a must. If
        a program behavior is not correct then it is of no use.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Efficiency:</emphasis> Efficiency
        is second to correctness only. Say you are developing a text
        editor and you take 5 seconds to load a 10KB text file then by
        no means you can persuade a user to use you text editor. A
        programmable must be as efficient as possible. Sometimes it
        clashes with other attributes and also depend on the problem
        domain that how strict are the requirements.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Security:</emphasis> A very highly
        desirable feature in programs which deal with more than one computer
        and also for desktop applications. It is very bad if someone can take
        advantage of buffer overflow, stack overflow, integer overflow etc. in
        your program and you must guard against these at all times. Note that
        to provide security you must put extra checks which will go against
        efficiency.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Robustness:</emphasis> Sometimes users will
        not give correct inputs. For example they may enter a character when an
        integer is asked for or they can give input beyond range. In such cases
        you must handle the erroneous input. This is just one
        example. Sometimes your memory allocation may fail. The rule is program
        defensively. All such input validations and checks on memory do take a
        toll on our second attribute but that does not mean that we can neglect
        it.</para> 
      </listitem>
      <listitem>
        <para><emphasis role="bold">Maintainability:</emphasis> Even a one line
        program has to be maintained if it is worth it! Typically the life of a
        program far exceeds the development time. In almost all the cases the
        original programmer is not maintainer. Because of these reasons you
        must strive for maintainability. You should follow some coding
        standards like I highly recommend <link
        xlink:href="http://www.gnu.org/prep/standards/">GNU Coding
        Stadards</link>. Clear documentation is one of the prerequisites of
        maintainability.</para> 
      </listitem>
      <listitem>
        <para><emphasis role="bold">Extensibility:</emphasis> Let us take our
        example of text editor and say our editor is complete. Now someone else
        would like to provide a plugin which will enable syntax highlighting
        and project management for this editor. So, in order to do so you can
        choose a plugin-based extensible architecture or you can allow them to
        extend the editor using scripting languages like Guile, Python, Lua
        etc.This features allows user to collaborate and make your program
        better. Remember the rule is the more the merrier here.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Portability:</emphasis> It is an elusive
        and painful goal. Let us say we write our text editor GUI using
        something like Xlib directly then we will have to port the entire GUI
        for other non X-based OSes. So we can choose some cross-platform GUI
        libraries like GTK+, Qt, WxWidgets etc. Even then when system calls
        come in your software you can do not much but either write wrappers and
        do conditional compilation.</para>
      </listitem>
    </orderedlist></d:para>
  </d:sect1>
  <d:sect1>
    <title xmlns="http://docbook.org/ns/docbook">Tools of Trade</title>
    <d:para>At the very least you need a compiler, an editor and a
    linker. Almost all GNU/Linux systems install GCC by default which is the
    compiler we are going to use and it includes linker ld. There are several
    editors you can use  from but I am going to use Emacs along with
    Sr-speedbar and Flymake plugins. Other 
    options include VI, Kate, Gedit, Kwrite etc. A debugger is optional but if
    you want to go far with C programming then you must learn to use a
    debugger. GDB is a very nice editor and we are going to use it for
    debugging in Emacs itself. Emacs has native support for debugging with
    GDB. For dynamic memory checking, heap corruption, cache corruption etc I
    am going to show you how to use valgrind. Again, valgrind is optional but
    it becomes mandatory if you want to work on large projects. For profiling
    gprof and for code coverage gcov. Note that you can use gcc for compiling
    programs. Most of the GNU/Linux systems come with gcc. For compiling
    programs I will use GNU Make though in the beginning I will show you how to
    compile on command line. Again, profiling, code coverage and make are
    optional to learn C but practically they are necessary to develop any
    software worth its value.</d:para>
    <d:para>
    You may choose another editor or IDE but I will recommend against IDEs
    for beginners as they hide much of compilation process from the users. The
    reason of choosing Emacs as an editor is its power. Emacs is hard to learn
    but it is very powerful and I implore you to spend some time and learn
    it. Learning Emacs will pay rich dividends in future to you. Emacs comes
    with its manual which you can read in menu for <d:code>Help</d:code>. For
    using more tools like <d:code>Sr-speedbar</d:code> and
    <d:code>Flymake</d:code> mode you can read more on <d:link
    xlink:href="http://emacswiki.org/">Emacs Wiki</d:link>. A lot of extensions
    are available at <d:link xlink:href="https://marmalade-repo.org/">Marmalade
    Repo</d:link>. In fact it is wrong to say that Emacs is an editor. You can
    read your email, play games, have a shell, read news, do remote editing,
    browse web and many other things. It is so powerful that some people set it
    to run when they login and they never get out of it.
    </d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Bits and Bytes</d:title>
    <d:para>The smallest unit a computer can understand is called a bit. The
    values for a bit is either 0 or 1. Consider a voltage. It can be 0V or 1.5V
    or whatever the core CPU voltage is. CPU does not understand numbers but
    voltages :-). You cannot expect an electronics hardware to understand the
    same semantics of 0 and 1 which we know. 0 and 1 are abstraction of CPUs
    voltages in programming. Four bits form a nibble and eight form a byte. A
    byte is the area of memory which can be addressed by CPU and its content
    manipulated. To address a memory a CPU has say 4 or 8 or up to 256
    pins. For example, in a common 32-bit CPU there are 32 pins whose voltages
    may represent 0 or 1. Consider all pins are low i.e. 0 then the memory
    location pointed to is 00000000000000000000000000000000 i.e. a 8 bit memory
    at location 0 can be accessed. This memory is also called primary memory or
    RAM (Random Access Memory). So computing this way we can see that a 32-bit
    processor can access <d:inlineequation> 
    <mml:math>
      <mml:mrow>
        <mml:msup>
          <mml:mi>2</mml:mi>
          <mml:mn>32</mml:mn>
        </mml:msup>
      </mml:mrow>
    </mml:math>
    </d:inlineequation> bytes or 4,294,967,296 bytes. You can arrive at this
    number by 4*1024*1024*1024. This is equivalent to 4GB of RAM. However,
    modern Intel processors have 36 physical pins to address up to 64GB of
    memory. That does not mean that all 64-bit CPUs have 64 pins for addressing
    memory as 16 Exabytes(approximately <d:inlineequation>
    <mml:math>
      <mml:mrow>
        <mml:mn>16</mml:mn>
        <mml:mo>*</mml:mo>
        <mml:msup>
          <mml:mi>10</mml:mi>
          <mml:mn>18</mml:mn>
        </mml:msup>
      </mml:mrow>
    </mml:math>
    </d:inlineequation>) is really, really huge amount of memory which
    is not needed by any single monolithic system practically 
    and will be very expensive, thus it is not practical Another point
    is that this much memory will require huge area because RAM is not
    as compact as hard disk. There are more important practical
    aspects that if such a computer fails then it will cause massive
    loss in productivity of the system which employs such a
    computer. Thus computers are kept much smaller than this size and
    tasks are divided on those computers and in case one of them fails
    then it does not affect the entire system. But all that is an
    architectural concern the point I am saying is it is impractical as of now
    to have so much RAM in a system but again no one knows future.</d:para>
    <d:para> Since a byte has 8 bits, its value may range from
    0 to 255 as <d:inlineequation>
    <mml:math>
      <mml:mrow>
        <mml:msup>
          <mml:mi>2</mml:mi>
          <mml:mn>8</mml:mn>
        </mml:msup>
      </mml:mrow>
    </mml:math>
    </d:inlineequation> is 256. For unsigned data type this will be the
    range. When all bits are 0 value is zero and when all are high it is
    255. Computers use two's complement form to represent binary number. So if
    these 8-bits represent signed number the range will be from
    <d:inlineequation>
      <mml:math>
        <mml:mrow>
          <mml:mo>-</mml:mo>
          <mml:msup>
            <mml:mn>2</mml:mn>
            <mml:mn>8</mml:mn>
          </mml:msup>
        </mml:mrow>
      </mml:math>
      </d:inlineequation> to <d:inlineequation>
      <mml:math>
        <mml:mrow>
          <mml:mo>-</mml:mo>
          <mml:msup>
            <mml:mn>2</mml:mn>
            <mml:mn>8</mml:mn>
          </mml:msup>
          <mml:mtext> </mml:mtext>
          <mml:mo>-</mml:mo>
          <mml:mtext> 1</mml:mtext>
        </mml:mrow>
      </mml:math>
      </d:inlineequation> that is -128 to 127. As you will see later at lowest
      levels C allows you to access even one bit using something called
      bit-fields. If you read specification it will signify the range
    of one 8-bit byte as -127 to 127 because it also takes in to
    consideration of 1’s complement computers in which positive and
    negative zeroes are different.</d:para>
  </d:sect1>
  <d:sect1>
    <d:indexterm>
      <d:primary>number system</d:primary>
    </d:indexterm>
    <d:title>Notes on Number System</d:title>
    <d:para>A number system is a system which determines the rules and symbols
    for numbers on how we are going to use them. A number system consists of
    symbols for representing numbers and a dot for representing fractional
    numbers. Minus sign is used to represent negative numbers. A number system
    ranges from<d:inlineequation>
    <mml:math><mml:mo>-</mml:mo><mml:mo>&#8734;</mml:mo></mml:math>
    </d:inlineequation> to <d:inlineequation>
    <mml:math><mml:mo>-</mml:mo><mml:mo>&#8734;</mml:mo></mml:math>
    </d:inlineequation>. It is best represented by a straight line given below:
    </d:para>
    <d:para>
      <d:figure>
        <d:title>Number axis.</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="../images/number_system.png" valign="middle"
                         align="center"/>
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
    </d:para>
    <d:para>Each point on this axis represents a number. It may be integer or
    fractional number. An integer is a whole number like -1, -2, 0, 5, 7
    etc. Floating-point numbers have fractional parts like 1.234. The important
    fact to note is that between any two points there exists infinite
    numbers. In other words between any two numbers there exists infinite
    numbers. For example, between 1.2 and 1.3 there are 1.21, 1.22, 1.23...,
    1.29. Moreover between 1.21 and 1.22 there are 1.211, 1.212, 1.213 and so
    on. It enables us to represent a point on this axis. The numbers I have
    written are supposedly in decimal number system. Base of decimal number
    system is 10. Why because it consists of 10 distinct symbols 0 through
    9 or vice-versa. Similarly we can have any other number system. Popular
    number systems in computers are octal and hexadecimal not to
    mention decimal of course. Binary is already mentioned as the native number
    system for computers.</d:para>
    <d:para>A number in a generic number system is given
    below:
    <d:informalequation>
      <math xmlns="http://www.w3.org/1998/Math/MathML"><mtable rowspacing="3pt" columnalign="right left"><mtr><mtd><mo>(</mo><mo>&#8230;</mo><msub><mi>c</mi><mi>m</mi></msub><msup><mi>b</mi><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><msub><mi>c</mi><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><msup><mi>b</mi><mrow><mi>m</mi><mo>-</mo><mn>2</mn></mrow></msup><mo>+</mo><mo>&#8230;</mo><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msup><mi>b</mi><mn>1</mn></msup><mo>+</mo><mi>c</mi><msubsup><mn>1</mn><mi>b</mi><mn>0</mn></msubsup><mo>+</mo><msub><mi>c</mi><mrow><mo>-</mo><mn>1</mn></mrow></msub><msup><mi>b</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>&#8230;</mo><mo>+</mo><msub><mi>c</mi><mrow><mo>-</mo><mi>m</mi></mrow></msub><msup><mi>b</mi><mrow><mo>-</mo><mi>m</mi></mrow></msup><mo>)</mo></mtd></mtr><mtr><mtd><mo>=</mo><mo>(</mo><mo>&#8230;</mo><msub><mi>c</mi><mi>m</mi></msub><msub><mi>c</mi><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>&#8230;</mo><msub><mi>c</mi><mn>2</mn></msub><msub><mi>c</mi><mn>1</mn></msub><mo>.</mo><msub><mi>c</mi><mrow><mo>-</mo><mn>1</mn></mrow></msub><mo>&#8230;</mo><msub><mi>c</mi><mrow><mo>-</mo><mi>m</mi></mrow></msub><msub><mo>)</mo><mi>b</mi></msub></mtd></mtr></mtable></math>
    </d:informalequation>
    </d:para>
    <d:para>All the terms with <d:inlineequation>
    <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi></math>
    </d:inlineequation> are called digits. The leftmost or leading digit is
    called <d:emphasis role="italic">most significant digit</d:emphasis> and
    the rightmost or trailing digit is called <d:emphasis role="italic">least
    significant digit</d:emphasis>. The . is called a point which separates the
    integral part which is towards its left from the fractional part which is
    towards its right. <d:inlineequation><math
    xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math></d:inlineequation>
    is known as radix or base of the number system. Note that all digits will
    be between 0 to <d:inlineequation><math
    xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi><mo>-</mo><mn>1</mn></math></d:inlineequation>. So
    in our decimal system <d:inlineequation><math
    xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math></d:inlineequation>
    is 10 therefore we have digits from 0 to 9. In binary number system it is 2
    therefore digits permitted are 0 and 1.</d:para>
  </d:sect1>
    <d:sect1>
      <d:title>Binary Number System</d:title>
      <d:para>As the name suggests binary number system has base of
      2. Therefore it has only two symbols. 0 and 1. This is the most popular
      system for computers because TTL NAND and NOR gates which are the most
      basic logic gates using which other gates are implemented in processor
      has only two voltage output levels because of their operation in cut-off
      and saturation zones. These terms are better understood with the help of
      a book on electronics which is out of scope of this book. All binary
      numbers consist of 0 and 1. So the count is like 0, 1, 10, 11, 100, 101,
      110, 111, 1000 and so on.</d:para>
      <d:sect2>
        <d:title>Conversion of Unsigned Decimals and Binaries</d:title>
        <d:para>Consider a decimal number. Let us say 53 then how would be
        convert it to binary. The technique is that of division. Please examine
        following carefully:<d:programlisting>2 | 53 | 1
----------
2 | 26 | 0
----------
2 | 13 | 1
----------
2 | 6  | 0
----------
2 | 3  | 1
----------
  | 1  |</d:programlisting></d:para>
        <d:para>So the binary is <d:inlineequation>
        <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msub>
        <mn>110101</mn>
        <mn>2</mn>
        </msub>
        </math></d:inlineequation>. First we divide 53 by 2 and write the
        remainder. Then quotient is 26. We repeat the process for 26 therefore
        remainder is 0 and quotient is 13. This we go on repeating till we have
        1 as quotient. Note that all the remainders will be 0 or 1 because
        divisor is 2. Similarly, final quotient is always 1. Now we take final
        quotient and start writing remainders from top to bottom.</d:para>
        <d:para>To convert binary to decimal let us examine following:
        <d:inlineequation><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <mn>1</mn>
          <mo>&#x2217;<!-- ∗ --></mo>
          <msup>
            <mn>2</mn>
            <mn>5</mn>
          </msup>
          <mo>+</mo>
          <mn>1</mn>
          <mo>&#x2217;<!-- ∗ --></mo>
          <msup>
            <mn>2</mn>
            <mn>4</mn>
          </msup>
          <mo>+</mo>
          <mn>0</mn>
          <mo>&#x2217;<!-- ∗ --></mo>
          <msup>
            <mn>2</mn>
            <mn>3</mn>
          </msup>
          <mo>+</mo>
          <mn>1</mn>
          <mo>&#x2217;<!-- ∗ --></mo>
          <msup>
            <mn>2</mn>
            <mn>2</mn>
          </msup>
          <mo>+</mo>
          <mn>0</mn>
          <mo>&#x2217;<!-- ∗ --></mo>
          <msup>
            <mn>2</mn>
            <mn>1</mn>
          </msup>
          <mo>+</mo>
          <mn>1</mn>
          <mo>&#x2217;<!-- ∗ --></mo>
          <msup>
            <mn>2</mn>
            <mn>0</mn>
          </msup>
          <mo>=</mo>
          <msub>
            <mn>53</mn>
            <mrow class="MJX-TeXAtom-ORD">
              <mn>10</mn>
            </mrow>
          </msub>
        </math></d:inlineequation></d:para>
        <d:para>The power is to 2 because 2 is the base of source. It starts
        from 0 for unit’s position and increases to 1 and 2 for ten’s and
        hundred’s position and so on. 1’s and 0’s are the values of that
        place. If you note carefully powers of 2 grow like 1, 2, 4, 8, 16, 32,
        64, 128 and so on. Any number can be written by using these powers at
        most one time. For example consider 100. I know it is less than 128 so
        I will use 64. Then 36 remains. So I will use 32 and then 4. This means
        100=64+32+4 which means power 6, 5 and 2 have been used. Therefore, I
        can quickly write down number as <d:inlineequation>
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mn>1100100</mn>
            <mn>2</mn>
          </msub>
        </math></d:inlineequation>.</d:para>
        <d:para>Fractional numbers are slightly more complicated. Let us
        consider <d:inlineequation>
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <msub>
            <mn>1.1</mn>
            <mn>2</mn>
          </msub>
        </math>
        </d:inlineequation>. In decimal it will be
        <d:inlineequation>
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mn>1</mn>
            <mo>+</mo>
            <mfrac>
              <mn>1</mn>
              <mn>2</mn>
            </mfrac>
          </math>
        </d:inlineequation>. This is 1.5 in decimal. Note that when you convert
        a fractional part of binary to decimal denominator will always be power
        of 2. For that matter when you convert from any base to decimal
        denominator will be powers of that base. <d:emphasis
        role="bold">Important:</d:emphasis> Therefore, when you
        convert from decimal to some base <d:emphasis
        role="italic">n</d:emphasis> then denominator of that decimal number
        can have only those prime factors which are available in the set of
        prime factors of <d:emphasis role="italic">n</d:emphasis>.
        </d:para>
        <d:para>
          Let us say we have a fractional number in decimal .59 then to
          convert it to decimal we multiply it with 2 which yields 1.018 which is
          greater than 1 so our equivalent binary number is .1. Now we subtract 1
          from 1.18 to get .18 which is less than 1 so we multiply it with 2
          again to get .36. Now since this is less than 1 our equivalent binary
          number is .10. Repeating the process we get .72 and .100 then 1.44 and
          .1001. We put 1 in binary part because decimal part has become greater
          than 1. Now again we subtract 1 from decimal part to get .44 and repeat
          the process. Operations such as addition, subtraction, multiplication
          and division are similar in all number systems.
        </d:para>
      </d:sect2>
      <d:sect2>
        <d:title>2's Complement and 1's Complement
        </d:title>
        <d:para>
          2's complement and 1's complement are used to convert binary
          numbers to decimal values. In 1's complement the number is obtained by
          inverting bits i.e. making 0 bit to 1 bit and 1 bit to 0 bit of the
          binary number in question.
        </d:para>
        <d:para>
          The 2's complement of an
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>
                N
              </mi>
            </math>
          </d:inlineequation>-bit number is defined as the complement
          with respect to
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mn>2</mn>
                <mi>N</mi>
              </msup>
            </math>
          </d:inlineequation>; i.e. it is the result of subtracting the number
          from
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mn>2</mn>
                <mi>N</mi>
              </msup>
            </math>
          </d:inlineequation>, which in binary is one followed by
                    <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>
                N
              </mi>
            </math>
          </d:inlineequation> zeroes. This is also
          equivalent to taking the 1's complement and then adding one, since
          the sum of a number and its 1's complement is all 1 bits.
        </d:para>
        <d:para>
          Consider the following table which contains some numbers for 1's
          complement of some 8-bit numbers.
          <table xmlns="http://docbook.org/ns/docbook" frame="border" class="centered"
                 border="1">
	        <colgroup/>
	        <colgroup/>
	        <colgroup/>
            <caption>Example of 1's complement</caption>
            <thead>
              <tr bgcolor="#aaaaaa">
                <td>Bits</td>
                <td>Unsigned Value</td>
                <td>1's Complement</td>
              </tr>
            </thead>
            <tr>
              <td>0111 1111</td>
              <td>127</td>
              <td>127</td>
            </tr>
            <tr>
              <td>0111 1110</td>
              <td>120</td>
              <td>126</td>
            </tr>
            <tr>
              <td>0000 0010</td>
              <td>2</td>
              <td>2</td>
            </tr>
            <tr>
              <td>0000 0001</td>
              <td>1</td>
              <td>1</td>
            </tr>
            <tr>
              <td>0000 0000</td>
              <td>0</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1111 1111</td>
              <td>255</td>
              <td>-0</td>
            </tr>
            <tr>
              <td>1111 1110</td>
              <td>254</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>1000 0010</td>
              <td>130</td>
              <td>-125</td>
            </tr>
            <tr>
              <td>1000 0001</td>
              <td>129</td>
              <td>-126</td>
            </tr>
            <tr>
              <td>1000 0000</td>
              <td>128</td>
              <td>-127</td>
            </tr>
          </table>
        </d:para>
        <d:para>
          For signed numbers MSB(most significant bit) decides sign in both 1's
          complement as well as 2's complement. 1's complement has two
          zeroes. Positive and negative. As you see in table that 1111 1111 is
          -0 because MSB is 1 so it is a negative number and then if you invert
          all remaining bits then it turns out to be 0. In a 1's complement
          system negative numbers are represented by the arithmetic negative of
          the value. An
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>
                N
              </mi>
            </math>
          </d:inlineequation>-bit 1's complement number system can represent
          integers in the range
          <d:inlineequation>
            <math
                xmlns="http://www.w3.org/1998/Math/MathML"> 
              <mo>&#x2212;<!-- − --></mo>
              <msup>
                <mn>2</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msup>
              <mo>&#x2212;<!-- − --></mo>
              <mn>1</mn>
            </math>
          </d:inlineequation> to 
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mo>&#x2212;<!-- − --></mo>
              <msup>
                <mn>2</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msup>
              <mo>&#x2212;<!-- − --></mo>
              <mn>1</mn>
            </math>
          </d:inlineequation>.
        </d:para>
        <d:para>
          Now it is easy to do addition, subtraction, multiplication, division
          and other arithmetic operations. Subtraction for 1’s complement is a
          bit different. Consider the following:
          <d:programlisting>+ 0000 0110       6
- 0001 0011      19
===========    ====
1 1111 0011     -12    -An end-around borrow is produced, and the sign bit
                        of the intermediate result is 1.
- 0000 0001       1    -Subtract the end-around borrow from the result.
===========    ====
  1111 0010     -13    -The correct result (6 - 19 = -13)
          </d:programlisting>          
        </d:para>
        <d:para>
          Borrows are propagated to the left. If the borrow extends past the
          end then it is said to have "wrapped around", a condition called an
          "end-around borrow". When this occurs, the bit must be subtracted
          from the right-most bit or least significant bit(LSB). This does not
          occur in 2's complement arithmetic.
        </d:para>
        <d:para>
          As you see in table and also you can verify the value becomes
          negative if its 1's complement is computed. However, 2's complement
          is used on most of computers because of two zeroes in 1's complement,
          borrowing being complicated etc.
                    <table xmlns="http://docbook.org/ns/docbook" frame="border" class="centered"
                 border="1">
	        <colgroup/>
	        <colgroup/>
	        <colgroup/>
            <caption>Example of 2's complement</caption>
            <thead>
              <tr bgcolor="#aaaaaa">
                <td>Bits</td>
                <td>Unsigned Value</td>
                <td>2's Complement</td>
              </tr>
            </thead>
            <tr>
              <td>0111 1111</td>
              <td>127</td>
              <td>127</td>
            </tr>
            <tr>
              <td>0111 1110</td>
              <td>120</td>
              <td>126</td>
            </tr>
            <tr>
              <td>0000 0010</td>
              <td>2</td>
              <td>2</td>
            </tr>
            <tr>
              <td>0000 0001</td>
              <td>1</td>
              <td>1</td>
            </tr>
            <tr>
              <td>0000 0000</td>
              <td>0</td>
              <td>0</td>
            </tr>
            <tr>
              <td>1111 1111</td>
              <td>255</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>1111 1110</td>
              <td>254</td>
              <td>-2</td>
            </tr>
            <tr>
              <td>1000 0010</td>
              <td>130</td>
              <td>-126</td>
            </tr>
            <tr>
              <td>1000 0001</td>
              <td>129</td>
              <td>-127</td>
            </tr>
            <tr>
              <td>1000 0000</td>
              <td>128</td>
              <td>-128</td>
            </tr>
          </table>
        </d:para>
        <d:para>
          Clearly, since
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>
                N
              </mi>
            </math>
          </d:inlineequation>-bit 1's complement can represent numbers in range
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mo>&#x2212;<!-- − --></mo>
              <msup>
                <mn>2</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msup>
              <mo>&#x2212;<!-- − --></mo>
              <mn>1</mn>
            </math>
          </d:inlineequation> to
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mn>2</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msup>
              <mo>-</mo>
              <mn>1</mn>
            </math>
          </d:inlineequation> 2's complement of
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>
                N
              </mi>
            </math>
          </d:inlineequation>bit can represent
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mo>&#x2212;<!-- − --></mo>
              <msup>
                <mn>2</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msup>
            </math>
          </d:inlineequation> to
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup>
                <mn>2</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msup>
              <mo>&#x2212;<!-- − --></mo>
              <mn>1</mn>
            </math>
          </d:inlineequation>s it does not have negative 0 i.e. its range is
          more by 1 number.
        </d:para>
        <d:para>
          The 2's complement system has the advantage that operations of
          addition, subtraction, and multiplication are same as unsigned binary
          numbers (as long as the inputs are represented in the same number of
          bits and any overflow beyond those bits is discarded from the
          result). This property makes the system both simpler to implement and
          capable of easily handling higher precision arithmetic. Also, as
          mentioned above zero has only a single representation, avoiding the
          subtleties associated with negative zero, which exists in 1's
          complement systems.
        </d:para>
        <d:para>
          The value
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>v</mi>
            </math>
          </d:inlineequation> of an
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>N</mi>
            </math>
          </d:inlineequation>-bit integer
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>b</mi>
                <mrow>
                  <mi>N</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <msub>
                <mi>b</mi>
                <mrow>
                  <mi>N</mi>
                  <mo>-</mo>
                  <mn>2</mn>
                </mrow>
              </msub>
              <mo>&#8230;</mo>
              <msub>
                <mi>b</mi>
                <mn>0</mn>
              </msub>
            </math>
          </d:inlineequation>  is given by the following formula:
          <d:inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
              <mi>v</mi>
              <mo>=</mo>
              <mo>&#x2212;<!-- − --></mo>
              <msub>
                <mi>b</mi>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msub>
              <msup>
                <mn>2</mn>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>1</mn>
                </mrow>
              </msup>
              <mo>+</mo>
              <munderover>
                <mo>&#x2211;<!-- ∑ --></mo>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>i</mi>
                  <mo>=</mo>
                  <mn>0</mn>
                </mrow>
                <mrow class="MJX-TeXAtom-ORD">
                  <mi>N</mi>
                  <mo>&#x2212;<!-- − --></mo>
                  <mn>2</mn>
                </mrow>
              </munderover>
              <msub>
                <mi>b</mi>
                <mi>i</mi>
              </msub>
              <msup>
                <mn>2</mn>
                <mi>i</mi>
              </msup>
            </math>
          </d:inlineequation>
        </d:para>
        <d:para>
          I will leave it up to you, the reader, to perform basic operations
          like addition, subtraction, multiplication, division etc.
        </d:para>
      </d:sect2>
    </d:sect1>
  <d:sect1>
    <d:title>Compiling and Executing</d:title>
    <d:para>To compile and execute a program create a new file, edit it and
    save it. The extension of file should be <d:code>*.c</d:code>. For example,
    <d:code>myprogram.c</d:code>. After that you can give this command at
    terminal. Here is the first program for 
    you.<programlisting xmlns="http://docbook.org/ns/docbook" role="CLexer">#include &lt;stdio.h&gt;

int main()
{
  return 0;
}</programlisting>
    Execute the following command on your command prompt:</d:para>
    <d:para><d:code>$</d:code><d:command>gcc nothing.c -o nothing</d:command>
      where <d:code>nothing.c</d:code> is the name of the program.</d:para>
      <d:para>Then you will see a file named <d:code>nothing</d:code> is
      created by compiler if no errors were there in your program. In case of
      errors, like we had in one shown to you they have to be resolved
      first. Suppose nothing is produced then you can execute it like</d:para>
      <d:para><d:code>$</d:code><d:command>./nothing</d:command></d:para>
      <d:para>Note that in both the commands $ is not part of command but it is
      prompt. For you it may be <d:code>%</d:code> or <d:code>#</d:code> or
      something fancier (depends on the imagination of your system
      administrator). To execute this command your working directory must be
      same as the directory your program is in. Also, note that on some systems
      TAB auto completes filename so do not do the following by
      accident:</d:para> 
      <d:warning>
        <d:title>DO NOT DO THIS.</d:title>
        <d:para><d:code>$</d:code><d:command>gcc nothing.c -o
        nothing.c</d:command></d:para>
      </d:warning>
      <d:para>This will overwrite your nothing.c by nothing. Let us see how to
      compile this program using a Makefile. Edit your Makefile like
        this:<d:programlisting role="MakefileLexer">#sample Makefile
check-syntax:
    gcc -o nul -Wall -S $(CHK_SOURCES)

nothing:nothing.c
    gcc nothing.c -o nothing</d:programlisting></d:para>
      <d:para>2nd and 3rd lines in the above Makefile is for Flymake to work in
      Emacs. Now from do this from menu of Emacs. From
      <d:guimenu>Tools</d:guimenu> select
      <d:guimenuitem>compile</d:guimenuitem>. As the command issue
      <d:command>make -k nothing</d:command>. Your code will be
      compiled. Makefiles are better than executing commands however you must
      know underlying commands. Alternatively, you can execute
      <d:code>make</d:code> directly from your shell or type 5th line yourself
      on prompt to compiler the program. You can also use something like 
      <d:application>CMake</d:application> or
      <d:application>Scons</d:application> but I think that should be part of a
      book covering build systems.</d:para>
    </d:sect1>
  </d:chapter>
