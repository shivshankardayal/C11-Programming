<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
    <?dbhtml filename="io/index.html" ?>
    <d:title>Console I/O</d:title>
    <d:para>What is I/O? I know you may be wondering what rubbish question? It is input/output.
      Well, yes you are right. However, i/o can be further categorized in several categories. First
      of them is console i/o, which is what we are concerned with. In console i/o your keyboard is
      input device or <d:code>stdin</d:code> file stream and display device or monitor is output
      device or <d:code>stdout</d:code> file stream. There is also also something called
        <d:code>stderr</d:code> which is standard error file stream. For historical reasons these
      are known as <d:code>FILE</d:code>, which, happens to be the data type for handling these
      streams. Then there are more different kind of i/o. In everyday usage you use mouse to handle
      GUI. Standard C99 does not have anything for mouse. For your hard disk i/o that is real files
      like our source code files and executable file same FILE stream is used. Network i/o is also
      there. There is an opengroup which specifies functions for network related functions. Some
      operating system like GNU/Linux are POSIX compatible which defines how network i/o will be
      used. Even a printer is a special output device, a camera input, speakers output, microphone
      input and so on. However, before we go on with i/o I would like to present C’s memory model
      which will be needed by our discussion of i/o related functions. However, if things do not
      make sense even then please go through it and come later to understand more.</d:para>
    <d:sect1>
      <title xmlns="http://docbook.org/ns/docbook">C's Memory Model</title>
      <d:para>C programs use <d:hardware>RAM</d:hardware> as primary memory except when you use
        register keyword to request compiler to store variables in cpu register. C’s memory model is
        split into three area at a higher level. Data, Stack and Code Segment. Date is further split
        in three parts; initialized data segment, uninitialized data segment or BSS which is name
        after an ancient assembler Block Started by Symbol and heap. Initialized data segment
        contains initialized global variables and static variables. Here both global and local
        static variables are counted. For uninitialized data segment it is same as above just that
        the variables are not initialized explicitly but implicitly to zero. Next is heap. Heap is
        the largest area of memory used for dynamic memory allocation. As you will see later that
        you can manage heap using <d:code>malloc(), calloc(), realloc(),</d:code> and
          <d:code>free()</d:code>. Note that compiler does not manage memory allocated for you. You,
        the programmer, are responsible for allocating and freeing up memory in area. If heap gets
        full os will use virtual memory or swap space on hard disk. Objects allocated on heap
        persist across function calls. However, there are some very nasty problems, which, come in
        picture when you use heap. There are several of them. You may forget to allocate memory and
        want to dereference unallocated pointer. You may have initialized it to
          <d:code>NULL</d:code> and try to dereference that. You may allocate and free twice. You
        forgot to set pointer to <d:code>NULL</d:code> after freeing it. And last but not the least
        you loose all pointers to the memory area before you can free. The nature with this
        particular problem is that if your program is going to run for long time then it is going to
        consume more and more memory. Because of its nature it is known as memory leak. It is very
        difficult to detect such problems in code which does not run for long periods of time. Our
        friend valgrind will come to help up with this problem. When a memory leak happens it eats
        up <d:hardware>RAM</d:hardware> slowly and then operating system has to use virtual memory
        as explained above. In a nutshell, I will say that heap means you have to handle
        it.</d:para>
      <d:para>Stack is relatively simple. All non-static and non-register variables go on stack.
        Stack variables do not retain there value across function calls unless they are passed as
        pointers. Also, when they go out of scope, that is the scope in which they were declared
        ends, they will be kind of lost. The way in which stack frame moves the same area will be
        used for new variables. However, stack is very limited (compared to heap) and in deeply
        nested function calls or recursion (you will see these in Functions chapter) stack may get
        full and program may crash. The reason for crashing is that operating system will not use
        virtual memory but will do a segmentation fault in its place. GNU/Linux allow its users to
        modify the stack size by ulimit command. Note that stack and heap are adjacent in memory and
        grow in opposite direction.</d:para>
      <d:para>Code segment or text segment is an area where the executable instructions of program
        reside. It is typically constant and read-only area unless your system allows self-modifying
        code. Following diagram shows the memory layout.</d:para>
      <d:figure>
        <d:title>C's Memory Model</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="images/memmod.png"/>
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
      <d:para>In this chapter we will look at only those functions, which, allow us to do console
        i/o. We will begin with our familiar friends. Can you guess who are they? Yes! They are
          <d:code>printf</d:code> and <d:code>scanf</d:code>.</d:para>
    </d:sect1>
    <d:sect1>
      <d:title>printf</d:title>
      <d:para><d:code>printf</d:code> is a string based output function that is It writes character
        strings to <d:code>stdout</d:code>. The data which has to be written is formatted by format
        string as shown previously. After the format specifier it expects as many arguments as
        specified in format string. The characters which are not like, say <d:code>%d</d:code> for
        example, arecalled ordinary characters. These are simply copied to output stream, which, is
          <d:code>stdout</d:code> for <d:code>printf</d:code>. The <d:code>%d</d:code> like
        conversion charcaters are known as conversion specification or format specifiers. Each
        conversion specification should be augmented with one one argument. The results are
        undefined if there are insufficient arguments for the format. If extra arguments are given
        the excess arguments will be evaluated but are otherwise ignored. However, there is a big
        problem here! There is no type-safety.:-( In general compiler will warn you about it and
        you, the programmer, are responsible for giving correct format string, correct no. of
        correct type of arguments. Consider the following program for
        example:<d:programlisting role="CLexer">// printf demo
// Author: Shiv Shankar Dayal
// Description: printf demo

#include &lt;stdio.h>

int main()
{
  printf("%d %d\n", 3, 8);

  //do not mess it. undefined behavior
  printf("%d %d\n", 5);

  //extra arguments ignored
  printf("%d %d\n", 3, 5, "hello");

  //legal because char is integer type
  printf("%d\n", 's');

  //wrap around of integer as char
  printf("%c\n", 836);

  //do not mess with type-safety
  int i = printf("%d\n", "hello");
  prinf("%d\n", i);

  return 0;
}</d:programlisting>
        now that if you give the command like <d:code>clang printf.c</d:code> then you will be shown
        following warnings:
        <d:screen>printf.c:12:14: warning: more '%' conversions than data arguments [-Wformat]
        printf("%d %d\n", 5);
                 ~^
printf.c:15:26: warning: data argument not used by format string [-Wformat-extra-args]
        printf("%d %d\n", 3, 5, "hello");
             ~~~~~~~~~        ^
printf.c:24:19: warning: conversion specifies type 'int' but the argument has type
'char *' [-Wformat]
      int i = printf("%d\n", "hello");
                      ~^     ~~~~~~~
                      %s
3 warnings generated.</d:screen>
        Clearly this is not a good sign for any program. A program should compile cleanly. In our
        case compiler is generating binary even though there are warnings. You can make compiler
        generate more warnings by issuing a <d:code>-Wall</d:code> flag. You can also treat all
        warnings as errors by passing <d:code>-Werror</d:code> to compiler. These two options will
        ensure that your code has no warnings. Now let us move to output and try to understand it.
        The output on my system is as given below. It may differ on your system:
        <d:screen>3 8
5 8
3 5
115
D
134514119
10</d:screen> First
          <d:code>printf</d:code> is correct as expected. The second line causes undefined behavior.
        You may think it is the previous 8 but rest assured it is not guaranteed that it will always
        the case. Ii is <d:emphasis role="bold">UNDEFINED</d:emphasis>. Third printf is also fine in
        the sense that extra argument is ignored. Fourth and fifth are normal. Sixth is again a big
        problem. You are trying to print a decimal integer while argument is a character string.
        There is no way for compiler to determine that what should be printed which will fit on
        standards. Now we will have to take a look at all possible format specifier and their
        meanings. You have seen most of them so this is more for a reference. I have taken following
        from <d:link xlink:href="http://www3.opengroup.org">http://www3.opengroup.org</d:link> and
        modified to suit the book. In particular, I have omitted facts related to XSI specification. </d:para>
      <d:para>Each conversion specification starts with '<d:code>%</d:code>' character. After this
        following appear in sequence:</d:para>
      <d:itemizedlist>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">Zero or more flags, in any order, which modify
            the meaning of the conversion specification.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional minimum field width. If the
            converted value from argument has fewer characters (bytes) than the field width, it will
            be padded with spaces by default on left; it will be padded on right if the
            left-adjustment flag (‘-‘) is given to the field width. The field width takes the form
            of an asterisk or a decimal integer.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional precision that gives the minimum
            number of digits to appear for the <code>d, i, o, u, x</code> and <code>X</code>
            conversion specifiers; the number of digits to appear for radix character for the
              <code>a, A, e, E, f</code> and <code>F</code> conversion specifiers; the maximum
            number of significant digits for the <code>g</code> and <code>G</code> conversion
            specifiers; or the maximum number of bytes to be printed from a string in the s
            conversion specifiers. The precision takes form of a period (‘.’) followed either by an
            asterisk (‘*’), described below, or an optional decimal digit string, where a null digit
            string is treated as zero. If a precision appears with any other conversion specifier,
            the behavior is undefined.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">An optional length modifier that specifies the
            size of the argument.</para>
        </d:listitem>
        <d:listitem>
          <para xmlns="http://docbook.org/ns/docbook">A conversion specifier character that
            indicates the type of conversion to be applied.</para>
        </d:listitem>
      </d:itemizedlist>
      <d:para>A field width, or precision, or both, may be indicated by an asterisk(‘*’). In this
        case an argument of type int supplies the field width or precision. You, the programmer,
        will have to ensure that arguments specifying field, width or precision, or both appear in
        that order before the argument, if any to be converted. A negative field width is taken as a
        ‘-‘ flag followed a positive field width. A negative precision is taken as if the precision
        were omitted.</d:para>
      <d:para>The flag characters and their meanings are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">-</emphasis> The result of
        the conversion will be left-justified within the field. The conversion is right-justified if
        the flag is not specified.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">+</emphasis> The result of
        a signed conversion will always begin with a sign (‘+’ or ‘-‘). The conversion will begin
        with a sign only when a negative value is converted if this value is not specified.</d:para>
      <d:para>If the first character of a signed conversion is not a sign or if a signed conversion
        results in no characters, a will be prefixed to the result. This means that if the and ‘+’
        flags both appear, the flag will be ignored.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">#</emphasis> Specifies
        that the value is to be converted to an alternative form. For o conversion, it increases the
        precision (if necessary) to force the first digit of the result to be zero. For
          <d:code>x</d:code> or <d:code>X</d:code> conversion specifiers, a non-zero result will
        have <d:code>0x (0X)</d:code> prefixed to it. For <d:code>a, A, e, E, f, F, g</d:code> and
          <d:code>G</d:code> conversion specifiers, the result will always contain a radix
        character, even if no digits follow the radix character. Without this flag, a radix
        character appears in the result of these conversions only if a digit follows it.</d:para>
      <d:para>For 0 and <d:code>G</d:code> conversion specifiers, trailing zeros will not be removed
        from the result as they normally are. For other conversion specifiers the, the behavior is
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">UNDEFINED</emphasis>.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">0</emphasis> For
          <d:code>d, i, o, x, X, a, A, e, E, f, F, g</d:code> and <d:code>G</d:code> conversion
        specifiers, leading zeros (following any indication of sign or base) are used to pad to the
        field width; no space padding is performed. If the ‘0’ and ‘-‘ flags both appear, the ‘0’
        flag is ignored. For <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion
        specifiers, if a precision is specified, the ‘0’ flag is ignored.</d:para>
      <d:para>The length and their meanings are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">hh</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifiers
        applies to a <d:code>signed char</d:code> or <d:code>unsigned char</d:code> argument (the
        argument will have been promoted according to integer promotions, but its value will be
        converted to <d:code>signed char</d:code> or <d:code>unsigned char</d:code> before printing;
        or that a following n conversion specifier applies to a pointer to a <d:code>signed
          char</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">h</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>short</d:code> or <d:code>unsigned short</d:code> argument (the
        argument will have been promoted according to the integer promotions, but its value will be
        converted to <d:code>short</d:code> or <d:code>unsigned short</d:code> before printing); or
        that a following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>short</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">l</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>long</d:code> or <d:code>unsigned long</d:code> argument; that a
        following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>long</d:code> argument; that a following <d:code>c</d:code> conversion specifier
        applies to a <d:code>win_t</d:code> argument; that a following <d:code>s</d:code> conversion
        specifier applies to a <d:code>wchar_t</d:code> argument; or has not effect on a following
          <d:code>a, A, e, R, f, F, g</d:code> or <d:code>G</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">ll</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>long long</d:code> or <d:code>unsigned long long</d:code> argument;
        that a following <d:code>n</d:code> conversion specifier applies to a pointer to a
          <d:code>long long</d:code> argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">j</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to an <d:code>intmax_t</d:code> or <d:code>uintmax_t</d:code> argument; or that a
        following <d:code>n</d:code> conversion specifier applies to an <d:code>intmax_t</d:code>
        argument.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">z</emphasis> Specifies
        that a following <d:code>d, i, o, u, x</d:code> and <d:code>X</d:code> conversion specifier
        applies to a <d:code>size_t</d:code> or the corresponding signed integer type argument; or
        that a following <d:code>n</d:code> conversion specifier applies to a signed integer type
        corresponding to a <d:code>size_t</d:code> argument.</d:para>
      <d:para><d:code>t</d:code> Specifies that a following <d:code>d, i, o, u, x</d:code> and
          <d:code>X</d:code> conversion specifier applies to a <d:code>ptrdiff_t</d:code> or the
        corresponding <d:code>unsigned int</d:code> type argument; or that a following
          <d:code>n</d:code> conversion specifier applies to a unsigned integer type corresponding
        to a <d:code>ptrdiff_t</d:code> argument.</d:para>
      <d:para><d:code>L</d:code> Specifies that a following <d:code>a, A, e, E, f, F, g</d:code> and
          <d:code>G</d:code> conversion specifier applies to a <d:code>long double</d:code>
        argument.</d:para>
      <d:para>If a length modifier appears with any conversion specfier other than as specified
        above, the behavior is <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >UNDEFINED</emphasis>. You may have noted data types like <d:code>intmax_t,
          size_t</d:code> and <d:code>ptrdiff_t</d:code>, which you may not know and I have not told
        you about them. But do not worry in due course of time we will see them.</d:para>
      <d:para>The conversion specifiers and their meaning are:</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">d, i</emphasis> The
          <d:code>int</d:code> argument will be converted to a signed decimal in the style
          “[-]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be converted in fewer digits, it will be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">o</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned octal format in the style
          “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be represented in fewer digits, it will be expanded with leading zeros. The default
        precision is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">u</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned decimal format in the
        style “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”. The
        precision specifies the minimum number of digits to appear; if the value being converted can
        be represented in fewer digits, it will be expanded with leading zeros. The default
        precision is 1. The result of converting zero with an explicit precision of zero will be no
        characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">x</emphasis> The
          <d:code>unsigned</d:code> argument will be converted to unsigned decimal format in the
        style “<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">dddd</emphasis>”; the
        letters “abcdef” are used. The precision specifiers specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer digits, it will be
        expanded with leading zeros. The default precision is 1. The result of converting zero with
        an explicit precision of zero will be no characters.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">X</emphasis> Equivalent to
        the x conversion specifier, except that letters "<d:code>ABCDEF</d:code>" are used instead
        of "<d:code>abcdef</d:code>".</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">f, F</emphasis> The
          <d:code>double</d:code> argument will be converted to decimal notation in the style
          “[-]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic">ddd.ddd</emphasis>”,
        where the number of digits after the radix character is equal to the precision
        specification. If the precision is missing, it will be taken as 6; if the precision is
        explicitly zero and no ‘#’ flag is present, no radix character will appear. If a radix
        character appears, at least one digit appears before it. The low-order digit will be rounded
        in an implementation-defined manner.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity will be converted in one
        of the styles “[-]<d:code>inf</d:code>” or “[-]<d:code>infinity</d:code>” ; which style is
        implementation-defined. A double argument representing a NaN will be converted in one of the
        styles “[-]<d:code>nan</d:code>(<emphasis xmlns="http://docbook.org/ns/docbook"
          role="italic">n-char-sequence</emphasis>)” or “[-]<d:code>nan</d:code>”; which style, and
        the meaning of any n-char-sequence, is implementation-defined. The F conversion specifier
        produces "<d:code>INF</d:code>", "<d:code>INFINITY</d:code>" or "<d:code>NAN</d:code>"
        instead of "<d:code>inf</d:code>", "<d:code>infinity</d:code>" or "<d:code>nan</d:code>",
        respectively.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">e, E</emphasis> The
          <d:code>double</d:code> argument will be converted in the style “[-]<emphasis
          xmlns="http://docbook.org/ns/docbook" role="italic">d.ddde</emphasis>[<d:inlineequation>
          <mml:math>
            <mml:mo>±</mml:mo>
          </mml:math>
        </d:inlineequation>]<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
          >dd</emphasis>”, where there is one digit before the radix character (which is non-zero if
        the argument is non-zero) and the number of digits after it is equal to the precision; if
        the precision is missing, it will be taken as 6; if the precision is zero and no ‘#’ flag is
        present, no radix character will appear. The low-order digit will be rounded in an
        implementation-defined manner. The E conversion specifier will produce a number with ‘E’
        instead of ‘e’ introducing the exponent. The exponent will always contain at least two
        digits. If the value is zero, the exponent will be zero.</d:para>
      <d:para>A double argument representing an infinity or NaN will be converted in the style of an
          <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">g, G</emphasis> The double
        argument will be converted in the style <d:code>f</d:code> or <d:code>e</d:code> (or in the
        style <d:code>F</d:code> or <d:code>E</d:code> in the case of a <d:code>G</d:code>
        conversion specifier), with the precision specifying the number of significant digits. If an
        explicit precision is zero, it will be taken as 1. The style used depends on the value
        converted; style <d:code>e</d:code> (or <d:code>E</d:code> ) will be used only if the
        exponent resulting from such a conversion is less than -4 or greater than or equal to the
        precision. Trailing zeros will be removed from the fractional portion of the result; a radix
        character will appear only if it is followed by a digit or a ‘<d:code>#</d:code>’ flag is
        present.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity or NaN will be converted
        in the style of an <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><d:code>a, A</d:code> A <d:code>double</d:code> argument representing a floating-point
        number will be converted in the style “[-]<emphasis xmlns="http://docbook.org/ns/docbook"
          role="italic">0xh.hhhhp</emphasis>(<d:inlineequation>
          <mml:math>
            <mml:mo>±</mml:mo>
          </mml:math>
        </d:inlineequation>)<emphasis xmlns="http://docbook.org/ns/docbook" role="italic"
          >d</emphasis>”, where there is one hexadecimal digit (which will be non-zero if the
        argument is a normalized floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is equal to the
        precision; if the precision is missing and <d:code>FLT_RADIX</d:code> is a power of 2, then
        the precision will be sufficient for an exact representation of the value; if the precision
        is missing and <d:code>FLT_RADIX</d:code> is not a power of 2, then the precision will be
        sufficient to distinguish values of type <d:code>double</d:code>, except that trailing zeros
        may be omitted; if the precision is zero and the ‘<d:code>#</d:code>’ flag is not specified,
        no decimal-point character will appear. The letters "<d:code>abcdef</d:code>" will be used
        for a conversion and the letters "<d:code>ABCDEF</d:code>" for A conversion. The
          <d:code>A</d:code> conversion specifier produces a number with ‘<d:code>X</d:code>’ and
          ‘<d:code>P</d:code>’ instead of ‘<d:code>x</d:code>’ and ‘<d:code>p</d:code>’. The
        exponent will always contain at least one digit, and only as many more digits as necessary
        to represent the decimal exponent of 2. If the value is zero, the exponent will be
        zero.</d:para>
      <d:para>A <d:code>double</d:code> argument representing an infinity or NaN will be converted
        in the style of an <d:code>f</d:code> or <d:code>F</d:code> conversion specifier.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">c</emphasis> The <emphasis
          xmlns="http://docbook.org/ns/docbook" role="bold">int</emphasis> argument will be
        converted to an <d:code>unsigned char</d:code>, and the resulting byte will be written. If
        an <d:code>l</d:code> qualifier is present, the <d:code>wint_t</d:code> argument will be
        converted as if by an <d:code>ls</d:code> conversion specification with no precision and an
        argument that points to a two-element array of type <d:code>wchar_t</d:code>, the first
        element of which contains the <d:code>wint_t</d:code> argument to the <d:code>ls</d:code>
        conversion specification and the second element contains a null wide character.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">s</emphasis> The argument
        will be a pointer to an array of <emphasis xmlns="http://docbook.org/ns/docbook" role="bold"
          >char</emphasis>. Bytes from the array will be written up to (but not including) any
        terminating null byte. If the precision is specified, no more than that many bytes will be
        written. If the precision is not specified or is greater than the size of the array, the
        programmer will ensure that the array contains a null byte. Note that it is a big problem
        which causes <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">strcpy</emphasis>
        to be insecure. What is the char array does not have this null terminating character? We
        will see a safe implementation of <d:code>strcpy</d:code> later. Also,
          <d:code>strlen</d:code> suffers from this problem. Any function relying on null character
        will suffer from this. If an <d:code>l</d:code> qualifier is present, the argument will be a
        pointer to an array of type <d:code>wchar_t</d:code>. Wide characters from the array will be
        converted to characters (each as if by a call to the <d:code>wcrtomb()</d:code> function,
        with the conversion state described by an <d:code>mbstate_t</d:code> object initialized to
        zero before the first wide character is converted) up to and including a terminating null
        wide character. The resulting characters will be written up to (but not including) the
        terminating null character (byte). If no precision is specified, the programmer will ensure
        that the array contains a null wide character. If a precision is specified, no more than
        that many characters (bytes) will be written (including shift sequences, if any), and the
        array will contain a null wide character if, to equal the character sequence length given by
        the precision, the function would need to access a wide character one past the end of the
        array. In no case will a partial character be written.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">p</emphasis> The argument
        will be a pointer to <d:code>void</d:code>. The value of the pointer is converted to a
        sequence of printable characters, in an implementation-defined manner.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">n</emphasis> The argument
        will be a pointer to an <d:code>int</d:code> into which is written the number of bytes
        written to the output so far by this call to one of the fprintf() functions. No argument is
        converted.</d:para>
      <d:para><emphasis xmlns="http://docbook.org/ns/docbook" role="bold">%</emphasis> Print a
          ‘<d:code>%</d:code>’ character; no argument is converted. The complete conversion
        specification will be <d:code>%%</d:code>.</d:para>
      <d:para>If a conversion specification does not match one of the above forms, the behavior is
          <emphasis xmlns="http://docbook.org/ns/docbook" role="bold">UNDEFINED</emphasis>. If any
        argument is not the correct type for the corresponding conversion specification, the
        behavior is undefined. This is what happened to out string in <d:code>printf.c</d:code>
        shown above. In no case will a nonexistent or small field width cause truncation of a field;
        if the result of a conversion is wider than the field width, the field will be expanded to
        contain the conversion result. Characters generated by <d:code>fprintf()</d:code> and
          <d:code>printf()</d:code> are printed as if <d:code>fputc()</d:code> had been
        called.</d:para>
      <d:para>For the <d:code>a</d:code> and <d:code>A</d:code> conversion specifiers, if
          <d:code>FLT_RADIX</d:code> is a power of 2, the value will be correctly rounded to a
        hexadecimal floating number with the given precision. For <d:code>a</d:code> and
          <d:code>A</d:code> conversions, if <d:code>FLT_RADIX</d:code> is not a power of 2 and the
        result is not exactly representable in the given precision, the result should be one of the
        two adjacent numbers in hexadecimal floating style with the given precision, with the extra
        stipulation that the error should have a correct sign for the current rounding
        direction.</d:para>
      <d:para>For the <d:code>e, E, f, F, g</d:code> and <d:code>G</d:code> conversion specifiers,
        if the number of significant decimal digits is at most <d:code>DECIMAL_DIG</d:code>, then
        the result should be correctly rounded. If the number of significant decimal digits is more
        than <d:code>DECIMAL_DIG</d:code> but the source value is exactly representable with
          <d:code>DECIMAL_DIG</d:code> digits, then the result should be an exact representation
        with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
          <d:code>L &lt; U</d:code>, both having <d:code>DECIMAL_DIG</d:code> significant digits;
        the value of the resultant decimal string <d:code>D</d:code> should satisfy <d:code>L &lt;=
          D &lt;= U</d:code>, with the extra stipulation that the error should have a correct sign
        for the current rounding direction.</d:para>
      <d:para>Some of the capitalized words like <d:code>DECIMAL_DIG, FLT_RADIX</d:code> etc are
        macros defined in <d:code>float.h</d:code>. You should have a look at it. Now we will have
        one example and I will show you output but not explain it. Understanding the output is left
        as an exercise to you, the reader.</d:para>
      <d:programlisting role="CLexer">// Format Specifiers
// Author: Shiv S. Dayal
//Desciption: It is a demo of several format specifiers

#include&lt;stdio.h>

int main()
{
  int i   = 343456;
  float f = 123;
  long double ld = 78939.9347;

  printf("% d\n", i);
  printf("%+d\n", i);
  printf("%#o\n", i);
  printf("%#f\n", f);
  printf("%-08i\n", i);
  printf("%08i\n", i);
  printf("%8i\n", i);
  printf("%hhi\n", i);
  printf("%hi\n", i);
  printf("%li\n", i);
  printf("%lli\n", i);
  printf("%ji\n", i);
  printf("%zi\n", i);
  printf("%ti\n", i);
  printf("%8.8f\n", f);
  printf("%8.8Lf\n", ld);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen> 343456
+343456
01236640
123.000000
343456
00343456
  343456
-96
15776
343456
4638355772471066016
4638355772471066016
343456
343456
123.00000000
78939.93470000</d:screen>
<d:para>I suggest you to read the desciption of conversion specifiers
and experiment with various parameters to get different kind of
output.</d:para>
    </d:sect1>
    <d:sect1><d:title>scanf</d:title>
    <d:para><d:code>scanf()</d:code> is sister of
    <d:code>printf()</d:code>. They work in tandem. As its
    name says scan function it scans <d:code>stdin</d:code> or
    keyboard for input. Its signature is same as that of printf(). It
    raeds bytes from keyboard input, interprets them according to
    format string. It also expects a set of pointer arguments as
    opposed to values for <d:code>printf()</d:code>. The 
    pointers indicate where the interpreted data from the input will
    be stored. The result is <d:emphasis
    role="bold">UNDEFINED</d:emphasis>
    if there are less number of pointer arguments than the number of
    conversion specifers in format string. Excess arguments will be
    evaluated but ignored. The format string can have only white-space
    characters or an ordinary character (neither ‘<d:code>%</d:code>’
    nor a white-space character) or a conversion specification. Each
    conversion specification is introduced by ‘<d:code>%</d:code>’,
    after which the following appear in sequence.</d:para>
    <d:itemizedlist>
      <d:listitem>
	<d:para>An optoinal assignment suppressing character
	‘<d:code>*</d:code>’.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>An optional non-zero decimal integer that specifies
	the maximum field width</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>An option length modifier that specifies the size of
	the receiving object.</d:para>
      </d:listitem>
      <d:listitem>
	<d:para>A conversion specifier character that specifies the
	type of conversion to be applied. The valid conversion
	specifiers are described below.</d:para>
      </d:listitem>
    </d:itemizedlist>
    <d:para>A directive composed of one or more white-space characters
    will be executed by reading input until no more valid input can be
    read, or up to the first byte which is not a white-space character,
    which remains unread.</d:para>
    <d:para>A directive that is an ordinary character will be executed
    as follows: the next byte will be read from the input and compared
    with the byte that comprises the directive; if the comparison
    shows that they are not equivalent, the directive will fail, and
    the differing and subsequent bytes will remain unread. Similarly,
    if end-of-file, an encoding error, or a read error prevents a
    character from being read, the directive will fail.</d:para>
    <d:para>A directive that is a conversion specification defines a set
    of matching input sequences, as described below for each conversion
    character. A conversion specification will be executed in the
    following steps.</d:para>
    <d:para>Input white-space characters (as specified by
    <d:code>isspace()</d:code>) will be skipped, unless the conversion
    specification includes a <d:code>[, c, C</d:code> or
    <d:code>n</d:code> conversion specifier.</d:para>
    <d:para>An item will be read from the input, unless the conversion
    specification includes an n conversion specifier. An input item
    will be defined as the longest sequence of input bytes (up to any
    specified maximum field width, which may be measured in characters
    or bytes dependent on the conversion specifier) which is an
    initial subsequence of a matching sequence. The first byte, if
    any, after the input item will remain unread. If the length of the
    input item is 0, the execution of the conversion specification
    will fail; this condition is a matching failure, unless
    end-of-file, an encoding error, or a read error prevented input
    from the stream, in which case it is an input failure.</d:para>
    <d:para>Except in the case of a <d:code>%n</d:code> conversion
    specifier, the input item (or, in the case of a
    <d:code>%n</d:code> conversion specification, the count 
    of input bytes) will be converted to a type appropriate to the
    conversion character. If the input item is not a matching
    sequence, the execution of the conversion specification fails;
    this condition is a matching failure. Unless assignment
    suppression was indicated by a '<d:code>*</d:code>', the result of
    the conversion will be placed in the object pointed to by the
    first argument following the format argument that has not already
    received a conversion result if the conversion specification is
    introduced by <d:code>%</d:code>. If this object does not have an
    appropriate type, or if the result of the conversion cannot be
    represented in the space provided, the behavior is
    undefined.</d:para>
    <d:para>The length modifiers and their meanings are:</d:para>
    <d:para><d:emphasis role="bold">hh</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>signed char</d:code> or <d:code>unsigned
    char</d:code>.</d:para>
    <d:para><d:emphasis role="bold">h</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>short</d:code> or <d:code>unsigned
    short</d:code>.</d:para>
    <d:para><d:emphasis role="bold">l</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>long</d:code> or <d:code>unsigned long</d:code>; that a
    following <d:code>a, A, e, E, f, F, g</d:code> or
    <d:code>G</d:code> conversion specifier applies to an argument
    with type pointer to <d:code>double</d:code>; or that a following
    <d:code>c, s</d:code> or <d:code>[ conversion</d:code> specifier
    applies to an argument with type pointer to
    <d:code>wchar_t</d:code>.</d:para>
    <d:para><d:emphasis role="bold">j</d:emphasis> Specifies that a
    following <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code>
    conversion specifier applies to an argument with type pointer to
    <d:code>intmax_t</d:code> or <d:code>uintmax_t</d:code>.</d:para>
    <d:para><d:emphasis role="bold">z</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to
    <d:code>size_t</d:code> or the corresponding <d:code>signed int</d:code>
    type.</d:para>
    <d:para><d:emphasis role="bold">t</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to
    <d:code>ptrdiff_t</d:code> or the corresponding <d:code>unsigned
    type</d:code>.</d:para>
    <d:para><d:emphasis role="bold">L</d:emphasis> Specifies that a following
    <d:code>d, i, o, u, x, X</d:code> or <d:code>n</d:code> conversion
    specifier applies to an argument with type pointer to <d:code>long
    double</d:code>.</d:para>
    <d:para>If a length modifier appears with any conversion specifier other
    than as specified above, the bahavior is undefined. The following
    conversion specifiers are valid:</d:para>
    <d:para><d:emphasis role="bold">d</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 10 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">i</d:emphasis> Matches an optionally signed
    integer, whose format is the same as expected for the subject sequence of
    <d:code>strtol() with</d:code> 0 for the base argument. In the absence of a
    size modifier, the programmer will ensure that the corresponding argument
    is a pointer to <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">code</d:emphasis> Matches an optionally
    signed octal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 8 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to unsigned.</d:para>
    <d:para><d:emphasis role="bold">u</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 10 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">x</d:emphasis> Matches an optionally signed
    decimal integer, whose format is the same as expected for the subject
    sequence of <d:code>strtol() with</d:code> the value 16 for the base
    argument. In the absence of a size modifier, the programmer will ensure
    that the corresponding argument is a pointer to
    <d:code>int</d:code>.</d:para>
    <d:para><d:emphasis role="bold">a, e, f, g</d:emphasis> Matches an
    optionally signed floating-point number, infinity, or NaN, whose format is
    the same as expected for the subject sequence of
    <d:code>strtod(). In</d:code> the absence of a size modifier, the
    programmer will ensure that the corresponding argument is a pointer to
    float.</d:para>
    <d:para>If the <d:code>printf() family</d:code> of functions generates
    character string representations for infinity and NaN (a symbolic entity
    encoded in floating-point format) to support IEEE Std 754-1985, the
    <d:code>scanf() family</d:code> of functions will recognize them as
    input.</d:para>
    <d:para><d:emphasis role="bold">s</d:emphasis> Matches a sequence of bytes
    that are not white-space characters. The programmer will ensure that the
    corresponding argument is a pointer to the initial byte of an array (will
    see them later) of <d:code>char, signed char</d:code> or <d:code>unsigned
    char</d:code> large enough to accept the sequence and a terminating null
    character code, which will be added automatically.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character will be converted to a wide character as if by a call to the
    <d:code>mbrtowc() function</d:code>, with the conversion state described by
    an <d:code>mbstate_t</d:code> object initialized to zero 
    before the first character is converted. The programmer will ensure that
    the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the sequence and the
    terminating null wide character, which will be added
    automatically.</d:para>
    <d:para><d:emphasis role="bold">c</d:emphasis> Matches a sequence of bytes
    of the number specified by the field width (1 if no field width is present
    in the conversion specification). The programmer will ensure that the
    corresponding argument is a pointer to the initial byte of an array of
    <d:code>char, signed char</d:code> or <d:code>unsigned char</d:code> large
    enough to accept the sequence. No null byte is added. The normal skip over
    white-space characters will be suppressed in this case.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character will be converted to a wide character as if by a call to the
    <d:code>mbrtowc() function</d:code>, with the conversion state described by
    an <d:code>mbstate_t</d:code> object initialized to zero 
    before the first character is converted. The programmer will ensure that
    the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the resulting sequence of
    wide characters. No null wide character is added.</d:para>
    <d:para><d:emphasis role="bold">p</d:emphasis> Matches an
    implementation-defined set of sequences, which shall be the same as the set
    of sequences that is produced by the %p conversion specification of the
    corresponding <d:code>printf() functions</d:code>. The application shall
    ensure that the corresponding argument is a pointer to a pointer to
    void. The interpretation of the input item is implementation-defined. If
    the input item is a value converted earlier during the same program
    execution, the pointer that results will compare equal to that value;
    otherwise, the behavior of the <d:code>%p</d:code> conversion specification
    is undefined.</d:para>
    <d:para><d:emphasis role="bold">[ </d:emphasis>Matches a non-empty sequence
    of bytes from a set of expected bytes (the scanset). The normal skip over
    white-space characters shall be suppressed in this case. The programmer
    will ensure that the corresponding argument is a pointer to the initial
    byte of an array of <d:code>char, signed char</d:code> or <d:code>unsigned
    char</d:code> large enough to accept the sequence and a terminating null
    byte, which shall be added automatically.</d:para>
    <d:para>If an <d:code>l</d:code> qualifier is present, the input is a
    sequence of characters that begins in the initial shift state. Each
    character in the sequence will be converted to a wide character as if by a
    call to the <d:code>mbrtowc() function</d:code>, 
    with the conversion state described by an <d:code>mbstate_t</d:code> object
    initialized to zero before the first character is converted. The programmer
    will ensure that the corresponding argument is a pointer to an array of
    <d:code>wchar_t</d:code> large enough to accept the sequence and the
    terminating null wide character, which will be added
    automatically.</d:para>
    <d:para>The conversion specification includes all subsequent bytes in the format string up to
        and including the matching right square bracket ( '<d:code>]</d:code>' ). The bytes between
        the square brackets (the scanlist) comprise the scanset, unless the byte after the left
        square bracket is a circumflex ( '<d:code>^</d:code>^ ), in which case the scanset contains
        all bytes that do not appear in the scanlist between the circumflex and the right square
        bracket. If the conversion specification begins with "<d:code>[]</d:code>" or
          <d:code>"[^]"</d:code>, the right square bracket is included in the scanlist and the next
        right square bracket is the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that ends the conversion
        specification. If a '-' is in the scanlist and is not the first character, nor the second
        where the first character is a '<d:code>^</d:code>', nor the last character, the behavior is
        implementation-defined.</d:para>
      <d:para>The conversion specifiers <d:code>A, E, F, G</d:code> and <d:code>X</d:code> are also
        valid and shall be equivalent to <d:code>a, e, f, g</d:code> and <d:code>x</d:code>
        respectively.</d:para>
      <d:para>If end-of-file is encountered during input, conversion shall be terminated. If
        end-of-file occurs before any bytes matching the current conversion specification (except
        for <d:code>%n</d:code>) have been read (other than leading white-space characters, where
        permitted), execution of the current conversion specification will terminate with an input
        failure. Otherwise, unless execution of the current conversion specification is terminated
        with a matching failure, execution of the following conversion specification (if any) will
        be terminated with an input failure.</d:para>
      <d:para>Reaching the end of the string in <d:code>sscanf()</d:code> shall be equivalent to
        encountering end-of-file for <d:code>scanf()</d:code>. If conversion terminates on a
        conflicting input, the offending input is left unread in the input. Any trailing white space
        (including newlines) shall be left unread unless matched by a conversion specification. The
        success of literal matches and suppressed assignments is only directly determinable via the
          <d:code>%n</d:code> conversion specification.</d:para>
      <d:para>Time for some code. You have already seen many examples of <d:code>scanf</d:code> so I
        will just explain some concepts here. Consider the following program:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of string input

#include &lt;stdio.h>

int main()
{
  char str[128] = {0};

  scanf("%s", str);
  printf("You entered:\n%s\n", str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv.
You entered:
Hi!</d:screen>
      <d:para>It is certainly not the corect output. We had expected to see like: “Hi! My name is
        Shiv.”. What happend to input string after “Hi!”. Well, in a form given above for
          <d:code>scanf()</d:code> it will stop taking input after white-space for character
        strings. For numerics it does not matter as it does not match the format. For characters it
        is character-by-character so no confusion either. So what if you want to have the entire
        string including white-spaces. Use <d:code>[^n]</d:code> as given below:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Corrected demo of string input

#include &lt;stdio.h>

int main()
{
  char str[128] = {0};

  scanf("%[^\n]s", str);
  printf("You entered:\n%s\n", str);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv.
You entered:
Hi! My name is Shiv.</d:screen>
      <d:para>What if you want to filter a string based on certain patterns. For example, a
        charcater string does not contain more that a single space, English alphabets, period and
        digits. To scan such a string you can define a pttern as program given below shows:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv. S Dayal
// Description: Demo of []

#include &lt;stdio.h>

int main()
{
  char c[100]={0};

  scanf("%[ A-Za-z0-9!.]", c);
  printf("%s\n", c);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>Hi! My name is Shiv! My phone no. is 1234. %^$&amp;*
Hi! My name is Shiv! My phone no. is 1234.</d:screen>
      <d:para>There is also a major problem associated with input and that comes when you have
        characters involved. Consider the following program:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of scanf() function

#include &lt;stdio.h>

int main()
{
  int   i = 0;
  float f = 0.0;
  char  c1 = '\0';
  char  c2 = '\0';
  char  c3 = '\0';

  printf("Enter an integer, a float and three character one by one:\n");

  scanf("%d", &amp;i);
  scanf("%f", &amp;f);
  scanf("%c", &amp;c1);
  scanf("%c", &amp;c2);
  scanf("%c", &amp;c3);

  printf("You entered\n");
  printf("%d\n", i);
  printf("%f\n", f);
  printf("%c\n", c1);
  printf("%c\n", c2);
  printf("%c\n", c3);

  return 0;
}</d:programlisting>
      <d:para>and the output is:</d:para>
      <d:screen>2
3.4
s
You entered
2
3.400000


s</d:screen>
      <d:para>What is happening here is that newline entered by our <d:code>RET</d:code> key is
        getting assigned to <d:code>c1</d:code> and <d:code>c3</d:code>. That is why the program
        accepted only second character. The enter after <d:code>float f;</d:code> was assigned to
          <d:code>c1</d:code> and the character entered to <d:code>c2</d:code> and then the RET
        newline to <d:code>c3</d:code>. There is a very simple way to recover from this:</d:para>
      <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Demo of scanf() function

#include &lt;stdio.h>

int main()
{
  int   i = 0;
  float f = 0.0;
  char  c1 = '\0';
  char  c2 = '\0';
  char  c3 = '\0';

  printf("Enter an integer, a float and three character one by one:\n");
  scanf("%d", &amp;i);
  scanf("%f", &amp;f);
  scanf(" %c", &amp;c1);
  scanf(" %c", &amp;c2);
  scanf(" %c", &amp;c3);

  printf("%d\n", i);
  printf("%f\n", f);
  printf("%c\n", c1);
  printf("%c\n", c2);
  printf("%c\n", c3);

  return 0;
}</d:programlisting>
      <d:para>The whitespace character shown will eat up all the white-space given after the
        previous input. This concludes our discussion on <d:code>printf()</d:code> and
          <d:code>scanf()</d:code>. Now we will move to another set of i/o functions which take
        character string without filtering and print it to screen without filtering. What I am going
        to discuss are <d:code>gets(), fgets(), puts()</d:code> and
        <d:code>fputs()</d:code>.</d:para> 
  </d:sect1>
  <d:sect1>
    <d:title>Character String I/O Functions</d:title>
    <d:para>These functions are very simple compared to
    <d:code>printf()</d:code> and <d:code>scanf()</d:code>. They take a pointer
    to a character array or a character pointer and fill it with input or print
    it to monitor. Note that <d:code>gets()</d:code> and
    <d:code>puts()</d:code> work only with stdin and stdout respectively while
    <d:code>fgets()</d:code> and <d:code>fputs()</d:code> work with
    <d:code>FILE</d:code> streams. They can read and write to file streams that
    is. Here is a sample program:</d:para>
<d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description : Demo of string i/o
#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
  char cStack[1024] = "";
  char *cHeap = (char*)malloc(sizeof(1024));

  gets(cStack);
  puts(cStack);

  cHeap = fgets(cHeap, 1024, stdin);
  fputs(cHeap, stdout);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>Hi!
Hi!
Hello!
Hello!</d:screen>
<d:para>First <d:code>"Hi!"</d:code> and <d:code>"Hello!"</d:code> are keyboard
inputs. Do not worry about array and pointer syntax at the moment. Just see the
difference between function calls. Their is a problem with
<d:code>gets()</d:code> that it can cause buffer overflow. If input is bigger
than 1024 bytes including the null terminator then buffer overflow will
happen. Note how you can prevent it with fgets() by specifying the number of
characters you want to read. Rest of input will be ignored by
<d:code>fgets()</d:code>. This is a security hole and therefore you should
never ever use <d:code>gets()</d:code>.</d:para>
<d:para>Time for single character input/output.</d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Single Character I/O</d:title>
    <d:para>There are several functions for single character i/o. They are
    <d:code>getc(), putc(), getchar(), putchar(), fgetc()</d:code> and
    <d:code>fputc()</d:code>. Apart from <d:code>getchar()</d:code> and
    <d:code>putchar()</d:code> rest can do any FILE stream-based i/o. Let us
    see them as they are mostly trivial.</d:para>
    <d:programlisting role="CLexer">// Author: Shiv S. Dayal
// Description: Single character funciton demo
#include &lt;stdio.h>

int main()
{
  char c ='';

  c = getchar();
  putchar(c);

  c = getchar();
  putchar(c);

  c = fgetc(stdin);
  fputc(c, stdout);

  c = getchar();
  putchar(c);

  c = getc(stdin);
  putc(c, stdout);

  return 0;
}</d:programlisting>
<d:para>and the output is:</d:para>
<d:screen>4
4
5
5
6
6</d:screen>
<d:para>The first 4, 5 and 6 were keyboard inputs. Note the use of extra
<d:code>getchar()</d:code> and <d:code>putchar()</d:code> to handle the
situation we faced during <d:code>scanf()</d:code>.</d:para>
<d:para>So we have seen many functions and programs for console i/o. File i/o
is still there and will be covered later. This chapter ends here. See you in
the next chapter with operators and expressions.:-)</d:para>
  </d:sect1>
</d:chapter>
